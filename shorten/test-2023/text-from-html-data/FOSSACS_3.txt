 Top    
 Open Access  2023 | Open Access | Book  
 Foundations of Software Science and Computation Structures  
 26th International Conference, FoSSaCS 2023, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2023, Paris, France, April 22–27, 2023, Proceedings  
 Editors: Orna Kupferman, Pawel Sobocinski   
 About this book  
 This open access book constitutes the proceedings of the 26th International Conference on Foundations of Software Science and Computational Structures, FOSSACS 2023, which was held during April 22-27, 2023, in Paris, France, as part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2023.  
 On the Existential Arithmetics with Addition and Bitwise Minimum  
  Abstract   
 This paper presents a similar approach for existential first-order characterizations of the languages recognizable by finite automata, by Parikh automata, and by multi-counter machines over the alphabet \(\left\{ 0,1,...,k-1\right\} ^{n}\)  for some \(k\ge 2\)  . The set of k  -FA-recognizable relations coincides with the set of relations, which are existentially definable in the structure  , where  corresponds to the bitwise minimum of base k  . In order to obtain an existential first-order description of k  -Parikh automata languages, we extend this structure with the predicate \( EqNZB _{k}(x,y)\)  which is true if and only if x  and y  have the same number of non-zero bits in k  -ary encoding. Using essentially the same ideas, we encode computations of k  -multi-counter machines and thus show that every recursively enumerable relation over the natural numbers is existentially definable in the aforementioned structure supplemented with concatenation \(z=x\smallfrown _{k} y\rightleftharpoons z = x + k^{l_{k}(x)}y\)  , where \(l_{k}(x)\)  is the bit-length of x  in base k  . This result gives us another proof of DPR-theorem.   
 Mikhail R. Starchak   
 Coverability in Petri nets finds applications in verification of safety properties of reactive systems. We study coverability in the equivalent model: Vector Addition Systems with States (VASS).   
 A k  -VASS can be seen as k  counters and a finite automaton whose transitions are labelled with k  integers. Counter values are updated by adding the respective transition labels. A configuration in this system consists of a state and k  counter values. Importantly, the counters are never allowed to take negative values. The coverability problem asks whether one can traverse the k  -VASS from the initial configuration to a configuration with at least the counter values of the target.   
 In a well-established line of work on k  -VASS, coverability in 2-VASS is already PSPACE  -hard when the integer updates are encoded in binary. This lower bound limits the practicality of applications, so it is natural to focus on restrictions. In this paper we initiate the study of 2-VASS with one unary counter. Here, one counter receives binary encoded updates and the other receives unary encoded updates. Our main result is that coverability in 2-VASS with one unary counter is in NP  . This improves upon the inherited state-of-the-art PSPACE  upper bound. Our main technical contribution is that one only needs to consider runs in a certain compressed linear form.   
 Filip Mazowiecki, Henry Sinclair-Banks, Karol Węgrzycki   
  Abstract   
 In this paper, we address this question by returning to the definition of probabilistic bisimilarity distances proposed by Desharnais, Gupta, Jagadeesan, and Panangaden more than two decades ago. We use a slight variation of their logic to construct for each pair of states a sequence of formulas that explains the probabilistic bisimilarity distance of the states. Furthermore, we present an algorithm that computes those formulas and we show that each formula can be computed in polynomial time.   
 We also prove that our logic is minimal. That is, if we leave out any operator from the logic, then the resulting logic no longer provides a logical characterization of the probabilistic bisimilarity distances.   
  Abstract   
 In the theory of coalgebras, distributive laws give a general perspective on determinisation and other automata constructions. This perspective has recently been extended to include so-called weak distributive laws, covering several constructions on state-based systems that are not captured by regular distributive laws, such as the construction of a belief-state transformer from a probabilistic automaton, and ultrafilter extensions of Kripke frames.   
 In this paper we first observe that weak distributive laws give rise to the more general notion of what we call an invertible step: a pair of natural transformations that allows to move coalgebras along an adjunction. Our main result is that part of the construction induced by an invertible step preserves and reflects bisimilarity. This covers results that have previously been shown by hand for the instances of ultrafilter extensions and belief-state transformers.   
 Ruben Turkenburg, Clemens Kupke, Jurriaan Rot, Ezra Schoen   
 Compositional Learning for Interleaving Parallel Automata  
  Abstract   
 Active automata learning has been a successful technique to learn the behaviour of state-based systems by interacting with them through queries. In this paper, we develop a compositional algorithm for active automata learning in which systems comprising interleaving parallel components are learned compositionally. Our algorithm automatically learns the structure of systems while learning the behaviour of the components. We prove that our approach is sound and that it learns a maximal set of interleaving parallel components. We empirically evaluate the effectiveness of our approach and show that our approach requires significantly fewer numbers of input symbols and resets while learning systems. Our empirical evaluation is based on a large number of subject systems obtained from a case study in the automotive domain.   
 Faezeh Labbaf, Jan Friso Groote, Hossein Hojjat, Mohammad Reza Mousavi   
  Abstract   
 Pebble transducers are nested two-way transducers which can drop marks (named “pebbles”) on their input word. Such machines can compute functions whose output size is polynomial in the size of their input. They can be seen as simple recursive programs whose recursion height is bounded. A natural problem is, given a pebble transducer, to compute an equivalent pebble transducer with minimal recursion height. This problem has been open since the introduction of the model.   
 In this paper, we study two restrictions of pebble transducers, that cannot see the marks (“blind pebble transducers” introduced by Nguyên et al.), or that can only see the last mark dropped (“last pebble transducers” introduced by Engelfriet et al.). For both models, we provide an effective algorithm for minimizing the recursion height. The key property used in both cases is that a function whose output size is linear (resp. quadratic, cubic, etc.) can always be computed by a machine whose recursion height is 1 (resp. 2, 3, etc.). We finally show that this key property fails as soon as we consider machines that can see more than one mark.   
 Gaëtan Douéneau-Tabot   
 Fixed Points and Noetherian Topologies  
  Abstract   
 Noetherian spaces are a generalisation of well-quasi-orderings to topologies, that can be used to prove termination of programs. They find applications in the verification of transition systems, some of which are better described using topology. The goal of this paper is to allow the systematic description of computations using inductively defined datatypes via Noetherian spaces. This is achieved through a fixed point theorem based on a topological minimal bad sequence argument.   
 Aliaume Lopez   
  Abstract   
 An efficient entailment proof system is essential to compositional verification using separation logic. Unfortunately, existing decision procedures are either inexpressive or inefficient. For example, Smallfoot is an efficient procedure but only works with hardwired lists and trees. Other procedures that can support general inductive predicates run exponentially in time as their proof search requires back-tracking to deal with a disjunction in the consequent.   
 This paper presents a decision procedure to derive cyclic entailment proofs for general inductive predicates in polynomial time. Our procedure is efficient and does not require back-tracking; it uses normalisation rules that help avoid the introduction of disjunction in the consequent. Moreover, our decidable fragment is sufficiently expressive: It is based on compositional predicates and can capture a wide range of data structures, including sorted and nested list segments, skip lists with fast-forward pointers, and binary search trees. We implemented the proposal in a prototype tool, called \(\mathtt {S2S_{Lin}}\)  , and evaluated it over challenging problems from a recent separation logic competition. The experimental results confirm the efficiency of the proposed system.   
 Quang Loc Le, Xuan-Bach D. Le   
  Abstract   
 Given a textual representation of a finite-state concurrent program \(P\)  , one can construct the corresponding Kripke structure \(\mathcal {M}\)  . However, the size of \(\mathcal {M}\)  can be exponentially larger than the textual size of \(P\)  . This state explosion can make model checking properties of \(P\)  via \(\mathcal {M}\)  expensive or even infeasible. The action of a symmetry group \(G\)  on \(\mathcal {M}\)  can be used to produce a smaller Kripke structure \(\overline{\mathcal {M}}\)  . Various authors have exploited the direct correspondence between \(\mathcal {M}\)  and \(\overline{\mathcal {M}}\)  to perform model checking. When the structure \(\mathcal {M}\)  does not satisfy a formula, one can look for a substructure that will satisfy the formula. We call this substructure-repair  : identifying a substructure \(\mathcal {N}\)  of \(\mathcal {M}\)  that satisfies a given temporal logic formula.   
 In this paper we extend previous work by showing that repairs of \(\overline{\mathcal {M}}\)  lift to repairs of \(\mathcal {M}\)  . In other words, we can repair a computer program \(P\)  , which exhibits a high degree of symmetry, by repairing the smaller Kripke structure \(\overline{\mathcal {M}}\)  and then symmetrizing the corresponding program. To do this we arrange the substructures of \(\mathcal {M}\)  and \(\overline{\mathcal {M}}\)  into substructure lattices that are ordered by substructure inclusion. We show that the substructures of \(\mathcal {M}\)  preserved by \(G\)  form a (sub)lattice that maps to the substructure lattice of \(\overline{\mathcal {M}}\)  . When restricted to the lattice of substructures of \(\mathcal {M}\)  that are “maximal” with the action of \(G\)  on \(\mathcal {M}\)  , the above map is a lattice isomorphism.   
 These results enable us to repair \(\overline{\mathcal {M}}\)  and then to lift the repair to \(\mathcal {M}\)  . In cases where a program has a high degree of symmetry, such as in many concurrent programs, we can repair the program by repairing the small Kripke structure \(\overline{\mathcal {M}}\)  .   
  Pawel Sobocinski  
 Copyright Year  2023    
 Publisher  Springer Nature Switzerland     
