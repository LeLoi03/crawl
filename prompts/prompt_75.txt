input:
1. ECOOP_2 conference:
DITAM 
  DNA 
  ECOOP 
  ECRTS 
  ESA 
  Part of: | Series: | Leibniz International Proceedings in Informatics (LIPIcs) | Part of: | Conference: | European Conference on Object-Oriented Programming (ECOOP) 
 Event  
 ECOOP 2023, July 17-21, 2023, Seattle, Washington, United States   
 Editors  
 Karim Ali            
 Publication Details  
 published at: 2023-07-11 
  Publisher: Schloss Dagstuhl – Leibniz-Zentrum für Informatik 
  DBLP: | db/conf/ecoop/ecoop2023 
  Access Numbers  
 Authors:  Jim Bauwens and Elisa Gonzalez Boix  
  Abstract    
 Modern distributed applications increasingly replicate data to guarantee high availability and optimal user experience. Conflict-free Replicated Data Types (CRDTs) are a family of data types specially designed for highly available systems that guarantee some form of eventual consistency. Designing CRDTs is very difficult because it requires devising designs that guarantee convergence in the presence of conflicting operations. Even though design patterns and structured frameworks have emerged to aid developers with this problem, they mostly focus on statically structured data; nesting and dynamically changing the structure of a CRDT remains to be an open issue. This paper explores support for nested CRDTs in a structured and systematic way. To this end, we define an approach for building nested CRDTs based on the work of pure operation-based CRDTs, resulting in nested pure operation-based CRDTs. We add constructs to control the nesting of CRDTs into a pure operation-based CRDT framework and show how several well-known CRDT designs can be defined in our framework. We provide an implementation of nested pure operation-based CRDTs as an extension to the Flec, an existing TypeScript-based framework for pure operation-based CRDTs. We validate our approach, 1) by implementing a portfolio of nested data structures, 2) by implementing and verifying our approach in the VeriFx language, and 3) by implementing a real-world application scenario and comparing its network usage against an implementation in the closest related work, Automerge. We show that the framework is general enough to nest well-known CRDT designs like maps and lists, and its performance in terms of network traffic is comparable to the state of the art.   
  Cite as    
 Authors:  Riccardo Bianchini, Francesco Dagnino, Paola Giannini, and Elena Zucca  
  Abstract    
 Resource-aware type systems statically approximate not only the expected result type of a program, but also the way external resources are used, e.g., how many times the value of a variable is needed. We extend the type system of Featherweight Java to be resource-aware, parametrically on an arbitrary grade algebra modeling a specific usage of resources. We prove that this type system is sound with respect to a resource-aware version of reduction, that is, a well-typed program has a reduction sequence which does not get stuck due to resource consumption. Moreover, we show that the available grades can be heterogeneous, that is, obtained by combining grades of different kinds, via a minimal collection of homomorphisms from one kind to another. Finally, we show how grade algebras and homomorphisms can be specified as Java classes, so that grade annotations in types can be written in the language itself.   
  Cite as    
 Authors:  David Castro-Perez and Nobuko Yoshida  
  Abstract    
 Multiparty Session Types (MPST) are a typing disciplines that guarantee the absence of deadlocks and communication errors in concurrent and distributed systems. However, existing MPST frameworks do not support protocols with dynamic unbounded participants, and cannot express many common programming patterns that require the introduction of new participants into a protocol. This poses a barrier for the adoption of MPST in languages that favour the creation of new participants (processes, lightweight threads, etc) that communicate via message passing, such as Go or Erlang. This paper proposes Dynamically Updatable Multiparty Session Protocols, a new MPST theory (DMst) that supports protocols with an unbounded number of fresh participants, whose communication topologies are dynamically updatable. We prove that DMst guarantees deadlock-freedom and liveness. We implement a toolchain, GoScr (Go-Scribble), which generates Go implementations from DMst, ensuring by construction, that the different participants will only perform I/O actions that comply with a given protocol specification. We evaluate our toolchain by (1) implementing representative parallel and concurrent algorithms from existing benchmarks, textbooks and literature; (2) showing that GoScr does not introduce significant overheads compared to a naive implementation, for computationally expensive benchmarks; and (3) building three realistic protocols (dynamic task delegation, recursive Domain Name System, and a parallel Min-Max strategy) in GoScr that could not be represented with previous theories of session types.   
  Cite as    
 Authors:  Luís Cruz-Filipe, Eva Graversen, Lovro Lugović, Fabrizio Montesi, and Marco Peressotti  
  Abstract    
 Choreographic programming is a paradigm for concurrent and distributed software, whereby descriptions of the intended communications (choreographies) are automatically compiled into distributed code with strong safety and liveness properties (e.g., deadlock-freedom). Recent efforts tried to combine the theories of choreographic programming and higher-order functional programming, in order to integrate the benefits of the former with the modularity of the latter. However, they do not offer a satisfactory theory of compilation compared to the literature, because of important syntactic and semantic shortcomings: compilation is not modular (editing a part might require recompiling everything) and the generated code can perform unexpected global synchronisations. In this paper, we find that these shortcomings are not mere coincidences. Rather, they stem from genuine new challenges posed by the integration of choreographies and functions: knowing which participants are involved in a choreography becomes nontrivial, and divergence in applications requires rethinking how to prove the semantic correctness of compilation. We present a novel theory of compilation for functional choreographies that overcomes these challenges, based on types and a careful design of the semantics of choreographies and distributed code. The result: a modular notion of compilation, which produces code that is deadlock-free and correct (it operationally corresponds to its source choreography).   
  Cite as    
 Authors:  Feiyang Jin, Lechen Yu, Tiago Cogumbreiro, Jun Shirako, and Vivek Sarkar  
  Abstract    
 Much of the past work on dynamic data-race and determinacy-race detection algorithms for task parallelism has focused on structured parallelism with fork-join constructs and, more recently, with future constructs. This paper addresses the problem of dynamic detection of data-races and determinacy-races in task-parallel programs with promises, which are more general than fork-join constructs and futures. The motivation for our work is twofold. First, promises have now become a mainstream synchronization construct, with their inclusion in multiple languages, including C++, JavaScript, and Java. Second, past work on dynamic data-race and determinacy-race detection for task-parallel programs does not apply to programs with promises, thereby identifying a vital need for this work. This paper makes multiple contributions. First, we introduce a featherweight programming language that captures the semantics of task-parallel programs with promises and provides a basis for formally defining determinacy using our semantics. This definition subsumes functional determinacy (same output for same input) and structural determinacy (same computation graph for same input). The main theoretical result shows that the absence of data races is sufficient to guarantee determinacy with both properties. We are unaware of any prior work that established this result for task-parallel programs with promises. Next, we introduce a new Dynamic Race Detector for Promises that we call DRDP. DRDP is the first known race detection algorithm that executes a task-parallel program sequentially without requiring the serial-projection property; this is a critical requirement since programs with promises do not satisfy the serial-projection property in general. Finally, the paper includes experimental results obtained from an implementation of DRDP. The results show that, with some important optimizations introduced in our work, the space and time overheads of DRDP are comparable to those of more restrictive race detection algorithms from past work. To the best of our knowledge, DRDP is the first determinacy race detector for task-parallel programs with promises.   
  Cite as    
 Authors:  Christian Kuessner, Ragnar Mogk, Anna-Katharina Wickert, and Mira Mezini  
  Abstract    
 This paper is about programming support for local-first applications that manage private data locally, but still synchronize data between multiple devices. Typical use cases are synchronizing settings and data, and collaboration between multiple users. Such applications must preserve the privacy and integrity of the user’s data without impeding or interrupting the user’s normal workflow - even when the device is offline or has a flaky network connection. From the programming perspective, availability along with privacy and security concerns pose significant challenges, for which developers have to learn and use specialized solutions such as conflict-free replicated data types (CRDTs) or APIs for centralized data stores. This work relieves developers from this complexity by enabling the direct and automatic use of algebraic data types - which developers already use to express the business logic of the application - for synchronization and collaboration. Moreover, we use this approach to provide end-to-end encryption and authentication between multiple replicas (using a shared secret), that is suitable for a coordination-free setting. Overall, our approach combines all the following advantages: it (1) allows developers to design custom data types, (2) provides data privacy and integrity when using untrusted intermediaries, (3) is coordination free, (4) guarantees eventual consistency by construction (i.e., independent of developer errors), (5) does not cause indefinite growth of metadata, (6) has sufficiently efficient implementations for the local-first setting.   
  Cite as    
 Authors:  Roland Kuhn, Hernán Melgratti, and Emilio Tuosto  
  Abstract    
 Peer-to-peer systems are the most resilient form of distributed computing, but the design of robust protocols for their coordination is difficult. This makes it hard to specify and reason about global behaviour of such systems. This paper presents swarm protocols to specify such systems from a global viewpoint. Swarm protocols are projected to machines, that is local specifications of peers. We take inspiration from behavioural types with a key difference: peers communicate through an event notification mechanism rather than through point-to-point message passing. Our goal is to adhere to the principles of local-first software where network devices collaborate on a common task while retaining full autonomy: every participating device can locally make progress at all times, not encumbered by unavailability of other devices or network connections. This coordination-free approach leads to inconsistencies that may emerge during computations. Our main result shows that under suitable well-formedness conditions for swarm protocols consistency is eventually recovered and the locally observable behaviour of conforming machines will eventually match the global specification. Our model elaborates on the Actyx industrial platform and provides the basis for tool support: we sketch an implemented prototype which proves this work a viable step towards reasoning about local-first and peer-to-peer software systems.   
  Cite as    
 Authors:  Magnus Madsen, Jonathan Lindegaard Starup, and Matthew Lutze  
  Abstract    
 We propose restrictable variants as a simple and practical alternative to extensible variants. Restrictable variants combine nominal and structural typing: a restrictable variant is an algebraic data type indexed by a type-level set formula that captures its set of active labels. We introduce new pattern-matching constructs that allows programmers to write functions that only match on a subset of variants, i.e., pattern-matches may be non-exhaustive. We then present a type system for restrictable variants which ensures that such non-exhaustive matches cannot get stuck at runtime. An essential feature of restrictable variants is that the type system can capture structure-preserving transformations: specifically the introduction and elimination of variants. This property is important for writing reusable functions, yet many row-based extensible variant systems lack it. In this paper, we present a calculus with restrictable variants, two partial pattern-matching constructs, and a type system that ensures progress and preservation. The type system extends Hindley-Milner with restrictable variants and supports type inference with an extension of Algorithm W with Boolean unification. We implement restrictable variants as an extension of the Flix programming language and conduct a few case studies to illustrate their practical usefulness.   
  Cite as    
 Authors:  Ashish Mishra and Suresh Jagannathan  
  Abstract    
 Parser combinators are a well-known mechanism used for the compositional construction of parsers, and have shown to be particularly useful in writing parsers for rich grammars with data-dependencies and global state. Verifying applications written using them, however, has proven to be challenging in large part because of the inherently effectful nature of the parsers being composed and the difficulty in reasoning about the arbitrarily rich data-dependent semantic actions that can be associated with parsing actions. In this paper, we address these challenges by defining a parser combinator framework called Morpheus equipped with abstractions for defining composable effects tailored for parsing and semantic actions, and a rich specification language used to define safety properties over the constituent parsers comprising a program. Even though its abstractions yield many of the same expressivity benefits as other parser combinator systems, Morpheus is carefully engineered to yield a substantially more tractable automated verification pathway. We demonstrate its utility in verifying a number of realistic, challenging parsing applications, including several cases that involve non-trivial data-dependent relations.   
  Cite as    
 Authors:  Luca Olivieri, Luca Negrini, Vincenzo Arceri, Fabio Tagliaferro, Pietro Ferrara, Agostino Cortesi, and Fausto Spoto  
  Abstract    
 A mandatory feature for blockchain software, such as smart contracts and decentralized applications, is determinism. In fact, non-deterministic behaviors do not allow blockchain nodes to reach one common consensual state or a deterministic response, which causes the blockchain to be forked, stopped, or to deny services. While domain-specific languages are deterministic by design, general-purpose languages widely used for the development of smart contracts such as Go, provide many sources of non-determinism. However, not all non-deterministic behaviours are critical. In fact, only those that affect the state or the response of the blockchain can cause problems, as other uses (for example, logging) are only observable by the node that executes the application and not by others. Therefore, some frameworks for blockchains, such as Hyperledger Fabric or Cosmos SDK, do not prohibit the use of non-deterministic constructs but leave the programmer the burden of ensuring that the blockchain application is deterministic. In this paper, we present a flow-based approach to detect non-deterministic vulnerabilities which could compromise the blockchain. The analysis is implemented in GoLiSA, a semantics-based static analyzer for Go applications. Our experimental results show that GoLiSA is able to detect all vulnerabilities related to non-determinism on a significant set of applications, with better results than other open-source analyzers for blockchain software written in Go.   
  Cite as    
 Authors:  David Richter, Timon Böhler, Pascal Weisenburger, and Mira Mezini  
  Abstract    
 Modeling sequential and parallel composition of effectful computations has been investigated in a variety of languages for a long time. In particular, the popular do-notation provides a lightweight effect embedding for any instance of a monad. Idiom bracket notation, on the other hand, provides an embedding for applicatives. First, while monads force effects to be executed sequentially, ignoring potential for parallelism, applicatives do not support sequential effects. Composing sequential with parallel effects remains an open problem. This is even more of an issue as real programs consist of a combination of both sequential and parallel segments. Second, common notations do not support invoking effects in direct-style, instead forcing a rigid structure upon the code. In this paper, we propose a mixed applicative/monadic notation that retains parallelism where possible, but allows sequentiality where necessary. We leverage a direct-style notation where sequentiality or parallelism is derived from the structure of the code. We provide a mechanisation of our effectful language in Coq and prove that our compilation approach retains the parallelism of the source program.   
  Cite as    
 Authors:  Hesam Shahrokhi and Amir Shaikhha  
  Abstract    
 In recent years, the increasing demand for high-performance analytics on big data has led the research on batch hash tables. It is shown that this type of hash table can benefit from the cache locality and multi-threading more than ordinary hash tables. Moreover, the batch design for hash tables is amenable to using advanced features of modern processors such as prefetching and SIMD vectorization. While state-of-the-art research and open-source projects on batch hash tables made efforts to propose improved designs by better usage of mentioned hardware features, their approaches still do not fully exploit the existing opportunities for performance improvements. Furthermore, there is a gap for a high-level batch API of such hash tables for wider adoption of these high-performance data structures. In this paper, we present Vec-HT, a parallel, SIMD-vectorized, and prefetching-enabled hash table for fast batch processing. To allow developers to fully take advantage of its performance, we recommend a high-level batch API design. Our experimental results show the superiority and competitiveness of this approach in comparison with the alternative implementations and state-of-the-art for the data-intensive workloads of relational join processing, set operations, and sparse vector processing.   
  Cite as    
 Authors:  Amir Shaikhha, Mahdi Ghorbani, and Hesam Shahrokhi  
  Abstract    
 This paper introduces hinted dictionaries for expressing efficient ordered sets and maps functionally. As opposed to the traditional ordered dictionaries with logarithmic operations, hinted dictionaries can achieve better performance by using cursor-like objects referred to as hints. Hinted dictionaries unify the interfaces of imperative ordered dictionaries (e.g., C++ maps) and functional ones (e.g., Adams' sets). We show that such dictionaries can use sorted arrays, unbalanced trees, and balanced trees as their underlying representations. Throughout the paper, we use Scala to present the different components of hinted dictionaries. We also provide a C++ implementation to evaluate the effectiveness of hinted dictionaries. Hinted dictionaries provide superior performance for set-set operations in comparison with the standard library of C++. Also, they show a competitive performance in comparison with the SciPy library for sparse vector operations.   
  Cite as    
 Authors:  Lucas Silver, Eddy Westbrook, Matthew Yacavone, and Ryan Scott  
  Abstract    
 This paper presents a specification framework for monadic, recursive, interactive programs that supports auto-active verification, an approach that combines user-provided guidance with automatic verification techniques. This verification tool is designed to have the flexibility of a manual approach to verification along with the usability benefits of automatic approaches. We accomplish this by augmenting Interaction Trees, a Coq datastructure for representing effectful computations, with logical quantifier events. We show that this yields a language of specifications that are easy to understand, automatable, and are powerful enough to handle properties that involve non-termination. Our framework is implemented as a library in Coq. We demonstrate the effectiveness of this framework by verifying real, low-level code.   
  Cite as    
 Authors:  Jonathan Lindegaard Starup, Magnus Madsen, and Ondřej Lhoták  
  Abstract    
 The λ_Dat calculus brings together the power of functional and declarative logic programming in one language. In λ_Dat, Datalog constraints are first-class values that can be constructed, passed around as arguments, returned, composed with other constraints, and solved. A significant part of the expressive power of Datalog comes from the use of negation. Stratified negation is a particularly simple and practical form of negation accessible to ordinary programmers. Stratification requires that Datalog programs must not use recursion through negation. For a Datalog program, this requirement is straightforward to check, but for a λ_Dat program, it is not so simple: A λ_Dat program constructs, composes, and solves Datalog programs at runtime. Hence stratification cannot readily be determined at compile-time. In this paper, we explore the design space of stratification for λ_Dat. We investigate strategies to ensure, at compile-time, that programs constructed at runtime are guaranteed to be stratified, and we argue that previous design choices in the Flix programming language have been suboptimal.   
  Cite as    
 Authors:  Jinhao Tan and Bruno C. d. S. Oliveira  
  Abstract    
 In most programming languages a (runtime) environment stores all the definitions that are available to programmers. Typically, environments are a meta-level notion, used only conceptually or internally in the implementation of programming languages. Only a few programming languages allow environments to be first-class values, which can be manipulated directly in programs. Although there is some research on calculi with first-class environments for statically typed programming languages, these calculi typically have significant restrictions. In this paper we propose a statically typed calculus, called 𝖤_i, with first-class environments. The main novelty of the 𝖤_i calculus is its support for first-class environments, together with an expressive set of operators that manipulate them. Such operators include: reification of the current environment, environment concatenation, environment restriction, and reflection mechanisms for running computations under a given environment. In 𝖤_i any type can act as a context (i.e. an environment type) and contexts are simply types. Furthermore, because 𝖤_i supports subtyping, there is a natural notion of context subtyping. There are two important ideas in 𝖤_i that generalize and are inspired by existing notions in the literature. The 𝖤_i calculus borrows disjoint intersection types and a merge operator, used in 𝖤_i to model contexts and environments, from the λ_i calculus. However, unlike the merges in λ_i, the merges in 𝖤_i can depend on previous components of a merge. From implicit calculi, the 𝖤_i calculus borrows the notion of a query, which allows type-based lookups on environments. In particular, queries are key to the ability of 𝖤_i to reify the current environment, or some parts of it. We prove the determinism and type soundness of 𝖤_i, and show that 𝖤_i can encode all well-typed λ_i programs.   
  Cite as    
 Authors:  Jacob Van Geffen, Xi Wang, Emina Torlak, and James Bornholt  
  Abstract    
 Reliable storage systems must be crash consistent - guaranteed to recover to a consistent state after a crash. Crash consistency is non-trivial as it requires maintaining complex invariants about persistent data structures in the presence of caching, reordering, and system failures. Current programming models offer little support for implementing crash consistency, forcing storage system developers to roll their own consistency mechanisms. Bugs in these mechanisms can lead to severe data loss for applications that rely on persistent storage. This paper presents a new synthesis-aided programming model for building crash-consistent storage systems. In this approach, storage systems can assume an angelic crash-consistency model, where the underlying storage stack promises to resolve crashes in favor of consistency whenever possible. To realize this model, we introduce a new labeled writes interface for developers to identify their writes to disk, and develop a program synthesis tool, DepSynth, that generates dependency rules to enforce crash consistency over these labeled writes. We evaluate our model in a case study on a production storage system at Amazon Web Services. We find that DepSynth can automate crash consistency for this complex storage system, with similar results to existing expert-written code, and can automatically identify and correct consistency and performance issues.   
  Cite as    
  Document   
 Experience Paper   
 Building Code Transpilers for Domain-Specific Languages Using Program Synthesis (Experience Paper)   
 Authors:  Sahil Bhatia, Sumer Kohli, Sanjit A. Seshia, and Alvin Cheung  
  Abstract    
 Domain-specific languages (DSLs) are prevalent across many application domains. Such languages let developers easily express computations using high-level abstractions that result in performant implementations. To leverage DSLs, however, application developers need to master the DSL’s syntax and manually rewrite existing code. Compilers can aid in this effort, but part of building a compiler requires transpiling code from the source code to the target DSL. Such transpilation is typically done via pattern-matching rules on the source code. Sadly, developing such rules is often a painstaking and error-prone process. In this paper, we describe our experience in using program synthesis to build code transpilers. To do so, we developed MetaLift, a new framework for building transpilers that transform general-purpose code into DSLs using program synthesis. To use MetaLift, transpiler developers first define the target DSL’s semantics using MetaLift’s specification language, and specify the search space for each input code fragment to be transpiled using MetaLift’s API. MetaLift then leverages program synthesizers and theorem provers to automatically find transpilations expressed in the target DSL that is provably semantic equivalent to the input code. We have used MetaLift to build three DSL transpilers targeting different programming models and application domains. Our results show that the MetaLift-based compilers can translate many benchmarks used in prior work created by specialized implementations, but can be built using orders-of-magnitude fewer lines of code as compared to prior work.   
  Cite as    
  Document   
 Experience Paper   
 Rust for Morello: Always-On Memory Safety, Even in Unsafe Code (Experience Paper)   
 Authors:  Sarah Harris, Simon Cooksey, Michael Vollmer, and Mark Batty  
  Abstract    
  Document   
 Experience Paper   
 On Using VeriFast, VerCors, Plural, and KeY to Check Object Usage (Experience Paper)   
 Authors:  João Mota, Marco Giunti, and António Ravara  
  Abstract    
 Typestates are a notion of behavioral types that describe protocols for stateful objects, specifying the available methods for each state. Ensuring methods are called in the correct order (protocol compliance), and that, if and when the program terminates, all objects are in the final state (protocol completion) is crucial to write better and safer programs. Objects of this kind are commonly shared among different clients or stored in collections, which may also be shared. However, statically checking protocol compliance and completion when objects are shared is challenging. To evaluate the support given by state of the art verification tools in checking the correct use of shared objects with protocol, we present a survey on four tools for Java: VeriFast, VerCors, Plural, and KeY. We describe the implementation of a file reader, linked-list, and iterator, check for each tool its ability to statically guarantee protocol compliance and completion, even when objects are shared in collections, and evaluate the programmer’s effort in making the code acceptable to these tools. With this study, we motivate the need for lightweight methods to verify the presented kinds of programs.   
  Cite as    
 Authors:  Sung-Shik Jongmans and Francisco Ferreira  
  Abstract    
 Programming distributed systems is difficult. Multiparty session typing (MPST) is a method to automatically prove safety and liveness of protocol implementations relative to protocol specifications. In this paper, we introduce two new techniques to significantly improve the expressiveness of the MPST method: projection is based on implicit local types instead of explicit; type checking is based on the operational semantics of implicit local types instead of on the syntax. That is, the reduction relation on implicit local types is used not only "a posteriori" to prove type soundness (as usual), but also "a priori" to define the typing rules - synthetically. Classes of protocols that can now be specified/implemented/verified for the first time using the MPST method include: recursive protocols in which different roles participate in different branches; protocols in which a receiver chooses the sender of the first communication; protocols in which multiple roles synchronously choose both the sender and the receiver of a next communication, implemented as mixed input/output processes. We present the theory of the new techniques, as well as their future potential, and we demonstrate their present capabilities to effectively support regular expressions as global types (not possible before).   
  Cite as    
 Authors:  Ori Roth  
  Abstract    
 Grigore proved that Java generics are Turing complete by describing a reduction from Turing machines to Java subtyping. Furthermore, he demonstrated that his "subtyping machines" could have metaprogramming applications if not for their extremely high compilation times. The current work reexamines Grigore’s study in the context of another prominent programming language - Python. We show that the undecidable Java fragment used in Grigore’s construction is included in Python’s type system, making it Turing complete. In contrast to Java, Python type hints are checked by third-party static analyzers and run-time type checkers. The new undecidability result means that both kinds of type checkers cannot fully incorporate Python’s type system and guarantee termination. The paper includes a survey of infinite subtyping cycles in various type checkers and type reification in different Python distributions. In addition, we present an alternative reduction in which the Turing machines are simulated in real time, resulting in a significantly faster compilation. Our work is accompanied by a Python implementation of both reductions that compiles Turing machines into Python subtyping machines.   
  Cite as    
  TGDK – Transactions on Graph Data and Knowledge 
 © 2023-2024 Schloss Dagstuhl – LZI GmbH  Imprint  Privacy  Contact
2. ECOOP_3 conference:
ECOOP 2023   Mon 17 - Fri 21 July 2023 Seattle (University of Washington campus), Washington, United States    
 co-located with ECOOP and ISSTA 2023    
 Toggle navigation        
 Attending | Venue: Seattle 
  ECOOP and ISSTA 2023 
  Conduct 
  Covid-19 
  Registration 
  Visas 
  Program | ECOOP Program 
  Your Program 
  Schedule Overview 
   Mon 17 Jul 
  Tue 18 Jul 
  Wed 19 Jul 
  Thu 20 Jul 
  Fri 21 Jul 
  Tracks | ECOOP 2023 
  Awards 
  Keynotes 
  Research Papers 
  Artifacts 
  ECOOP and ISSTA 2023 
  Doctoral Symposium 
  Keynotes 
  ICOOOLPS 
  VORTEX 
  Organization | ECOOP 2023 Committees 
  Organizing Committee 
  Track Committees 
  Extended Review Committee and External Reviewers 
  Artifacts 
  ECOOP and ISSTA 
  Doctoral Symposium 
  Sponsorships 
  Series | Series 
  ECOOP 2024 
  ECOOP 2023 
  ECOOP 2022 
  Sign up 
  ECOOP and ISSTA 2023  ( series  ) /   ECOOP 2023  ( series  ) /  Research Papers ECOOP 2023   
 Program 
   The GMT offsets shown reflect the offsets at the moment of the conference  .     
 Time Band   
 ×    You're viewing the program in a time zone which is different from your device's time zone change time zone     
 Wed 19 Jul   
 Displayed time zone: Pacific Time (US & Canada)  change      
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Keynote | Reflections on the Impact of Calculating Source Line Level Energy Information for Android Applications   ECOOP and ISSTA Keynotes   
 K:  William G.J. Halfond  University of Southern California 
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Lunch | Lunch   ECOOP and ISSTA Catering 
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Thu 20 Jul   
 Displayed time zone: Pacific Time (US & Canada)  change      
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 30m    
 Awards | ECOOP: Dahl-Nygaard Prize Ceremony and Awards   ECOOP and ISSTA Keynotes 
 Keynote | Dahl-Nygaard Senior Prize: Safe Journeys into the Unknown – Object Capabilities   ECOOP and ISSTA Keynotes   
 K:  Sophia Drossopoulou  Imperial College London    
  Media Attached 
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Lunch | Lunch   ECOOP and ISSTA Catering 
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Keynote | Machine Learning for Software Engineering   ECOOP and ISSTA Keynotes   
 K:  Satish Chandra  Meta Platforms 
 15m    
 Day closing | ISSTA'24 Preview   ECOOP and ISSTA Keynotes 
 15m    
 Day closing | ISSTA Closing   ECOOP and ISSTA Keynotes 
 Fri 21 Jul   
 Displayed time zone: Pacific Time (US & Canada)  change      
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 30m    
 Day closing | ECOOP: Outlooks and Farewells   ECOOP and ISSTA Keynotes 
 Keynote | Dahl-Nygaard Junior Prize: My Part of the Scala Story, and Beyond!   ECOOP and ISSTA Keynotes   
 K:  Heather Miller  Carnegie Mellon University and Two Sigma    
  Media Attached 
 30m    
 Coffee break | Break   ECOOP and ISSTA Catering 
 Lunch | Lunch   ECOOP and ISSTA Catering 
 Unscheduled Events  
 Call for Papers  
 ECOOP  is a conference about programming originally focused on object-orientation, but now including all practical and theoretical investigations of programming languages, systems and environments. ECOOP solicits innovative solutions to real problems as well as evaluations of existing solutions.  
 Authors are asked to pick one of the following categories:  
 Research. | The most traditional category for papers that advance the state of the art. 
  Pearls/Brave New Ideas. | Articles that either explain a known idea in an elegant way or unconventional papers introducing ideas that may take some time to substantiate. These papers may be short. 
  Submissions   
 Submission must not have been published, or have major overlap with previous work. In case of doubt, contact the chairs. Proceedings are published in open access by Dagstuhl LIPIcs in the Dagstuhl LIPIcs LaTeX-style  template. To reduce friction when resubmitting, ACM’s PACMPL and TOPLAS formatted papers can be submitted as such (with the understanding that if accepted, they will be reformatted).  
 ECOOP uses double-anonymous reviewing. Authors’ identities are only revealed if a paper is accepted. Papers must omit author names and institutions, and use the third person when referencing the authors’ own work. Nothing should be done in the name of anonymity that weakens the submission; see the FAQ. If in doubt, contact the chairs.  
 There is no page limit on submissions, but authors must understand that reviewers have a fixed time budget for each paper, so the length of the feedback is likely to be unaffected by length. Brevity is a virtue. Authors also have to consider that the camera-ready version must be 25 pages  in LIPIcs format (not including references).  
 Authors will be given a three-day period to read and respond to the reviews of their papers before the program committee meeting. Responses have no length limit.  
 ECOOP will continue to have two deadlines for submissions. Papers submitted in each round can be (a) accepted, (b) rejected, or (c) asked for revisions. Rejected papers that are submitted to the immediate next round may be desk rejected if they are not sufficiently different from the previous submission. Revisions can be submitted at any later round. Papers retain their reviewers during revision.  
 Artifact Evaluation and Intent   
 To support replication of experiments, authors of research papers may submit artifacts to the Artifact Evaluation Committee. They will be asked whether they intend to submit an artifact at submission time. It is understood that some paper do not have artifacts. AEC members will serve on the extended review committee.  
 Journal First and Journal After   
 We have Journal First / After arrangements with ACM’s Transactions on Programming Languages and Systems (TOPLAS), Elsevier’s Science of Computer Programming (SCP) and AITO’s Journal of Object Technology (JOT).  
 Only new research papers are eligible to be Journal First (JF). JF papers will have an extended abstract in the ECOOP proceedings. The deadline is that same as Round 1 of submissions and the notification is aligned with Round 2 notification. TOPLAS JF papers should be submitted according to this announcement. SCP JF papers should follow this call for papers. JF papers are presented at the conference and eligible for awards.  
 Journal After (JA) papers are papers for which the authors request to be considered for post conference journal publication. Once accepted by the ECOOP PC, these papers will be forwarded to the journal editors. Reviews and reviewers will be forwarded and used at the editor’s discretion. JA papers will have an extended abstract (up to 12 pages) in the conference proceedings.  
 Important Dates   AoE (UTC-12h)     
 Fri 12 May 2023  
  Camera-ready R2 
 Fri 28 Apr 2023  
  Author Notification R2 
 Mon 17 - Wed 19 Apr 2023  
  Author Response R2 
 Wed 1 Mar 2023   
  Submission R2 
 Tue 21 Feb 2023  
  Camera-ready R1 
 Mon 6 Feb 2023  
  Author Notification R1 
 Mon 23 - Wed 25 Jan 2023  
  Author Response R1 
 Thu 1 Dec 2022  
  Submission R1 
 Submission Link   
  ECOOP 2023   
  contact form    
  Artifacts   
  ECOOP and ISSTA 2023  
 Doctoral Symposium   
  Keynotes   
  Workshops    
 Workshops  
 COP 2023   
  DEBT 2023   
  FTfJP 2023   
  FUZZING 2023   
  ICOOOLPS 2023   
  VORTEX 2023    
 Attending  
 Venue: Seattle   
  ECOOP/ISSTA Code of Conduct   
  ECOOP/ISSTA Covid-19 Disclosure & Liability Waiver   
  Accommodation   
  ECOOP / ISSTA 2023 Registration Is Open   
  Visas
3. ECRTS_0 conference:
Skip to content    
 Home 
  Author information | Call for papers 
  Submission instructions | Double-blind submission 
  Review Process | Evaluation criteria 
  Artifact evaluation 
  Registration 
  Organizers 
  About ECRTS | General information 
  Subscribe to ecrts-info 
  ECRTS in social media 
  ECRTS archive 
  ECRTS awards 
  Home    RTSOPS 2023    
 RTSOPS 2023  
 12th International Real-Time Scheduling Open Problems Seminar  
 July 11, 2023, Vienna – Austria  
 Home  |  Program  |  Call for papers  |  Submission instructions  |  Organizers   
 Welcome  
 The 12th International Real-Time Scheduling Open Problems Seminar (RTSOPS 2023) provides a venue for the exchange of ideas and the discussion of interesting unsolved problems in real-time systems.  
  To promote a spirit of cooperation and collaboration within the real-time systems community, the seminar is organized around presentation sessions. Each session provides the opportunity to hear about a number of unsolved problems in real-time systems, highlighted via brief presentations/pitches, followed by intensive discussion. The 12th edition of RTSOPS will be co-located with the Euromicro Conference on Real-Time Systems (ECRTS 2023) in Vienna, Austria, from July 11 – 14, 2023.  
  Important dates:   
 Submission deadline: | May 11th | Extended deadline | May 18th 
  Notification: May 30th 
  Camera-ready: tba 
  Early-registration: June 4th 
  Workshop day: July 11th 
 Comments are closed.  
  Deadlines are UTC-12 (Anywhere on Earth)   
 Submission website: tba  
 Early registration deadline: tba   
 Euromicro Privacy Policy   
   Please report issues to webmaster@ecrts.org    
 Powered by Tempera  & WordPress.
4. ECRTS_1 conference:
Skip to content    
 Home 
  Author information | Call for papers 
  Submission instructions | Double-blind submission 
  Review Process | Evaluation criteria 
  Artifact evaluation 
  Registration 
  Organizers 
  About ECRTS | General information 
  Subscribe to ecrts-info 
  ECRTS in social media 
  ECRTS archive 
  ECRTS awards 
        Manneken Pis – Bruxelles – Belgique      (Image credits: Suicasmo, Alina Zienowicz, Zairon, Michielverbeek, Myrabella see Wiki Commons  , Title: JoaquinAranoa)  
  ECRTS is the premier European venue for presenting research into the broad area of real-time systems. Along with RTSS and RTAS, ECRTS ranks as one of the top three international conferences on this topic.  
 ECRTS has been at the forefront of recent innovations in the real-time community such as artifact evaluation  , open access  proceedings, industry challenge  , and real-time pitches  .  
 Tell the community about your interesting research, work in progress, new thoughts, or any other topic you would like to share with the real-time community.  
  If you want to receive important information about ECRTS, please subscribe to the ecrts-info  mailing list.  
 To take part in general discussions about the future of the conference, please subscribe to the ecrts-friends  mailing-list.  
 Comments are closed.  
  Deadlines are UTC-12 (Anywhere on Earth)   
 Submission website: tba  
 Early registration deadline: tba   
 Euromicro Privacy Policy   
   Please report issues to webmaster@ecrts.org    
 Powered by Tempera  & WordPress.
5. ECRTS_2 conference:
Skip to content    
 Home 
  Author information | Call for papers 
  Submission instructions | Double-blind submission 
  Review Process | Evaluation criteria 
  Artifact evaluation 
  Registration 
  Organizers 
  About ECRTS | General information 
  Subscribe to ecrts-info 
  ECRTS in social media 
  ECRTS archive 
  ECRTS awards 
  Home    About ECRTS    
 About ECRTS  
 Real-time systems 
  Organization 
  Real-time systems  
 ECRTS promotes state-of-the-art research for applications with temporal constraints, time-sensitive, real-time systems. Such computing systems have to provide results that are not only correct in value but also delivered at the right time. Instead of average behavior as for standard computing, real-time systems have to allow for guarantees that temporal requirements will be met.  
 Quality  
 ECRTS is the premier European venue for presenting research into the broad area of real-time systems. Along with IEEE RTSS and IEEE RTAS, ECRTS ranks as one of the three top international conferences on this topic. Google Scholar Metrics  lists ECRTS as top conference per h5-index, CAPES (Brasil) as A1  .  
 Innovation  
 ECRTS has been at the forefront of recent innovations in the real-time community such as Work-in-Progress Poster sessions, Call for Actions, Artifact Evaluation, Industrial Challenges, Open-Access proceedings, etc., in the larger real-time computing community.  
 Open access  
 We believe that the conference serves the research community and the public best when results are accessible to the largest audience without restrictions, in particular not behind paywalls.  
 We also believe that the dissemination of results should not be restricted by the financial situation of authors, e.g. when substantial sums are required by for-profit publishers for “open access”.  
 Conference fees cover publication costs, which include the cost of keeping proceedings open access.  
 Organization  
 The Technical Committee is responsible for selecting locations and organizers for ECRTS.  
 Program Chairs  are responsible for the technical program of the main conference. They are selected based on their technical achievements, standing in the community, and organizational abilities. They select Program Committee  members, who review submitted papers and, together with the Program Chair, select papers for the program of the main conference, based on their scientific quality only in a face-to-face meeting. Program chairs serve only once.  
 General Chairs  are responsible for the logistical aspects of holding the conference, such as venue, facilities for communication, networking, and community building, including financial aspects.  
 ECRTS is complemented by a series of satellite workshops, which provide lively forums for discussion and interactions on various technical topics. They complement the main conference by providing short turnaround time for contributions, enabling exchange and discussions of new ideas in their areas, and establishing communities on specific topics.  
 Workshop chairs  are responsible for proposing new or organizing the technical aspects of specific workshops, with an emphasis on novelty and innovative concepts for interaction.  
  Technical committee: Yasmina Abdeddaïm  , Sebastian Altmeyer  , Steve Goddard  , Marcus Völp   
  Deadlines are UTC-12 (Anywhere on Earth)   
 Submission website: tba  
 Early registration deadline: tba   
 Euromicro Privacy Policy   
   Please report issues to webmaster@ecrts.org    
 Powered by Tempera  & WordPress.
6. ECRTS_3 conference:
Skip to content    
 Home 
  Author information | Call for papers 
  Submission instructions | Double-blind submission 
  Review Process | Evaluation criteria 
  Artifact evaluation 
  Registration 
  Organizers 
  About ECRTS | General information 
  Subscribe to ecrts-info 
  ECRTS in social media 
  ECRTS archive 
  ECRTS awards 
  Home    ECRTS awards    
 ECRTS awards  
 Gerhard Fohler receives the ECRTS outstanding achievement award for two decades of leadership and services to the conference and the real-time community in general.  
 It is with deepest gratitude that the real-time community awards the ECRTS outstanding achievement award   to Prof. Dr. Gerhard Fohler in recognition for two decades of leadership and services to the conference and the real-time community in general.  
 Comments are closed.  
  Deadlines are UTC-12 (Anywhere on Earth)   
 Submission website: tba  
 Early registration deadline: tba   
 Euromicro Privacy Policy   
   Please report issues to webmaster@ecrts.org    
 Powered by Tempera  & WordPress.
7. ECSA_0 conference:
ECSA 2023   Mon 18 - Fri 22 September 2023 Istanbul, Turkey    
 Toggle navigation        
  Info | Previous Venues 
  Contact 
  Program | ECSA Program 
  Your Program 
   Mon 18 Sep 
  Tue 19 Sep 
  Wed 20 Sep 
  Thu 21 Sep 
  Fri 22 Sep 
  Tracks | ECSA 2023 
  Research Papers 
  Industry Program 
  Doctoral Symposium 
  Keynotes 
  Organization | ECSA 2023 Committees 
  Organizing Committee 
  Steering Committee 
  Series | Series 
  ECSA 2024 
  ECSA 2023 
  ECSA 2022 
  Sign up 
 17th European Conference on Software Architecture (ECSA)  
 Welcome to the website of the ECSA 2023 conference!   
 The European Conference on Software Architecture (ECSA) is the premier European software architecture conference, providing researchers, practitioners, and educators with a platform to present and discuss the most recent, innovative, and significant findings and experiences in the field of software architecture research and practice. The 17th European Conference on Software Architecture (ECSA 2023) will be held from September 18 to 22, 2023  .  
 ECSA 2023 is planned as an in-person/physical conference, with the events taking place in the beautiful and historic city of Istanbul in Turkiye  .  
  News  
 To download the slides for the keynote presented by Dr. Birgit Penzenstadler, | please click | . 
  To access the conference proceedings published via SpringerLink, please click here  . Note that the free access is available for 4 weeks only for the conference participants and authors.  Keynotes To Attend  
 Wednesday, 20th of September   
  Thursday, 21st of September   
  Friday, 22nd of September   
  ECSA 2023 Tracks   
 Research Papers  | Industry Program  | Journal First  | Tools & Demos  | Workshops/Tutorials  | Diversity, Equity and Inclusion (DE&I)  | Doctoral Symposium  | Keynotes    
   Posts   
 ECSA 2023    
  ECSA 2023   
   Support page
8. ECSA_1 conference:
ECSA    
 ☰  History 
  Steering Committee 
  Awards 
  Call for Letters of Interest 
  ECSA 2024 
 ECSA is the premier European conference on Software Architecture. It targets advances and breakthroughs beyond the state-of-the-art in Software Architecture and covers all aspects of research in the domain of Software Architecture, ranging from theory to technology and their applications.  
 On this web site you can find information about the ECSA conference series as well as useful information for organizing a future ECSA conference  . We also provide information about the history of ECSA and its predecessor event, EWSA, as well as on awards.  
 Tweets by ECSACONF    
 Previous Recent Editions  
 #ECSA   
 Copyright © 2023 ECSA
9. ECSA_2 conference:
ECSA 2024 
  ECSA 2023 
  ECSA 2022 
  Sign up 
 ECSA  
 All Editions   
 Tue 3 - Fri 6 September 2024 Luxembourg, Luxembourg  ECSA 2024   
 Welcome to the website of the ECSA 2024 conference! The European Conference on Software Architecture (ECSA) is the premier European software architecture conference, providing researchers, practitioners, and educators with a platform to present and discuss the most recent, innovative, and significant findings and experiences in the field of software architecture research and practice. The 18th European Conferenc ... 
 Mon 18 - Fri 22 September 2023 Istanbul, Turkey  ECSA 2023   
 Welcome to the website of the ECSA 2023 conference! The European Conference on Software Architecture (ECSA) is the premier European software architecture conference, providing researchers, practitioners, and educators with a platform to present and discuss the most recent, innovative, and significant findings and experiences in the field of software architecture research and practice. The 17th European Conferenc ... 
 Mon 19 - Fri 23 September 2022 Prague, Czech Republic  ECSA 2022   
 Welcome to the website of the ECSA 2022 conference! The European Conference on Software Architecture (ECSA) is the premier European software architecture conference, providing researchers, practitioners, and educators with a platform to present and discuss the most recent, innovative, and significant findings and experiences in the field of software architecture research and practice. The 16th European Conferenc ...
10. ECSCW_0 conference:
The 21 st  European Conference on Computer-Supported Cooperative Work  
 June 5 th  –9 th  , 2023  
  Trondheim, Norway  
 Thanks for your participation at ECSCW 2023!  
 See you next year at ECSCW 2024 in Rimini, Italy   
 ECSCW is a single-track  conference that contributes to developing an interdisciplinary and global community, supported by EUSSET, the European Society for Socially Embedded Technologies  . The conference format facilitates critical discussion across disciplinary and national borders in the field. An overview of earlier ECSCW conferences (and proceedings) is available here  .  
 The conference will be hosted by the Department of Computer Science  , within the Faculty of Information Technology and Electrical Engineering of the Norwegian University of Science and Technology  .  
 Latest ECSCW Tweets ecscw    
  Recent Posts  
    Workshop 3: Collectively Improve the Quality of Life at Work: How and Which Data to Collect and Analyze?    
 April 28, 2023  If you are interested in how data could be collected, analyzed, and discussed to improve the quality of life at work: which data? Which methods for its collection and its analysis? Under which conditions? You should submit a short position paper to this workshop by May 2nd, 2023. The workshop will be organized by Claus Bossen, … Workshop 3: Collectively Improve the Quality of Life at Work: How and Which Data to Collect and Analyze? Read More »  [...]    Read more...    
    Workshop 4: The digital public encounter    
 April 28, 2023  Tuesday, June 6th, Michaela Schmidt (NTNU), Babak A. Farshchian (NTNU), and Sara Hofmann (University of Agder) will organize a workshop on the interaction between citizens and public officials at a time when face-to-face interaction is being replaced by digital platforms, chat-bots, and self-service. Send your position paper by May 1st if you are a … Workshop 4: The digital public encounter Read More »  [...]    Read more...    
    Workshop 2: Spatial tensions in CSCW: The political and ethical challenges of scale    
 April 25, 2023  On Tuesday, June 6th, Airi Lampinen, Chiara Rossitto, Roel Roscam Abbing, Ann Light, Anton Fedosov, and Luigina Ciolfi will organize a full-day workshop on the political and ethical challenges of scale. The workshop is designed for up to 20 participants. If you are interested in participating, submit a short position paper by May 5th, … Workshop 2: Spatial tensions in CSCW: The political and ethical challenges of scale Read More »  [...]    Read more...    
    Workshop 5: From empathy to gamification: Inspecting motivational and sensitive methods for participation of co-researchers in healthcare    
 April 24, 2023  On Monday, June 5th, Tim Weiler (University of Siegen), Liliana Savage Pinto (University of Siegen), David Struzek (University of Siegen), Holger Klapperich (University of Applied Sciences Düsseldorf), Alina Huldtgren (University of Applied Sciences Düsseldorf) and Claudia Müller (University of Siegen) will organize a workshop on the topic of appropriate methods for increasing participants’ motivation with preserving … Workshop 5: From empathy to gamification: Inspecting motivational and sensitive methods for participation of co-researchers in healthcare Read More »  [...]    Read more...    
    Workshop 1: Implementing Electronic Health Records – Cases, Concepts, Questions    
 April 19, 2023  On Tuesday, June 6th, Morten Hertzum (Roskilde University), Rebecca Randell (University of Bradford), Gunnar Ellingsen (UiT Arctic University of Norway), and Miria Grisot (University of Oslo) will organize a half-day workshop on implementing EHRs. If you are interested in participating in the workshop, submit your position paper by April 28th, 2023. For more information … Workshop 1: Implementing Electronic Health Records – Cases, Concepts, Questions Read More »  [...]    Read more...    
    Become a student volunteer!    
 March 28, 2023  You can now apply to become a student volunteer! As an SV, you have the opportunity to attend the conference while having unique access to the backstage view of how the conference is run. In addition, you will receive free access to all the conference sessions, reception and conference dinner, a kick-off dinner during the … Become a student volunteer! Read More »  [...]    Read more...    
    Registration is open    
    You can still participate in ECSCW 2023    
 March 17, 2023  Although some deadlines have passed there are still several opportunities to get involved in ECSCW 20223 and share your late-breaking research, preliminary findings, innovative ideas, and early research and design explorations with conference participants. You can still participate in this year’s conference through three different tracks: 1. Posters & Demos It is still possible to … You can still participate in ECSCW 2023 Read More »  [...]    Read more...    
    Exploratory paper or Note?    
 February 27, 2023  One of the most frequent questions we receive is related to these two types of contributions. Here is a summary of the difference between the two.  [...]    Read more...    
    Deadline extension    
 February 17, 2023  Due to several requests we are extending all submission deadlines that were due April 20 with two weeks. The new deadline is Monday March 6, 2023. The web pages will be updated to reflect this. Please note that the acceptance cutoff date for journal papers is not changed.  [...]    Read more...    
    ECSCW gem nr.4    
    5 Questions With Monica Divitini    
 February 16, 2023  Who are the people behind ECSCW 2023? In this series of blogs, we ask our organizing committee some really personal questions. In this post, we talk to Monica who is one of the journal papers chairs of the conference.  [...]    Read more...    
    ECSCW gem nr.3    
    Myriam Lewkowicz and Casandra Grundstrom on the roots of CSCW    
 February 1, 2023  Listen to Casandra Grundstrom and Myriam Lewkowicz delve into the historical roots of CSCW.  [...]    Read more...    
    5 Questions With Elena Parmiggiani    
 January 30, 2023  Who are the people behind ECSCW 2023? In this series of blogs, we ask our organizing committee some really personal questions. In this post, we talk to Elena who is one of the general chairs of the conference.  [...]    Read more...    
    ECSCW gem nr.2    
 January 23, 2023  This week’s gem is the paper “PolyLens: A recommender system for groups of user” by O’Connor et al. PolyLens is a “collaborative filtering recommender system designed to recommend items for groups of users, rather than for individuals.”  [...]    Read more...    
    5 Questions With Babak A. Farshchian    
 January 23, 2023  Who are the people behind ECSCW 2023? In this series of blogs, we ask our organizing committee some really personal questions. In this post, we talk to Babak who is one of the general chairs of the conference.  [...]    Read more...    
    Submission pages are open    
 January 18, 2023  You can now submit your contributions to the different areas of our program. Please choose the type of contribution you plan to submit from the Submissions menu above and follow the link to the submission system. We use EasyChair as submission system for most of submission types.  [...]    Read more...    
    ECSCW gem nr.1    
 January 6, 2023  Did you know that some of the seminal work in CSCW, and some of the most well-known papers in practice-centered computer, were initially presented at ECSCW conferences?  [...]    Read more...    
    Seasonal greetings    
 December 22, 2022  As we step into Christmas and winter break for many of us around the world we wanted to send our best wishes to all of you and your families and friends.  [...]    Read more...    
 Copyright © EUSSET ECSCW 2023 •  Impress

output:1. ECOOP_2 information:
2. ECOOP_3 information:
3. ECRTS_0 information:
4. ECRTS_1 information:
5. ECRTS_2 information:
6. ECRTS_3 information:
7. ECSA_0 information:
8. ECSA_1 information:
9. ECSA_2 information:
10. ECSCW_0 information:
