Anmelden 
  Registrierung 
  Deutsch  English 
  Español 
  Português 
  Français 

     Dom 
  Najlepsze kategorie | CAREER & MONEY 
  PERSONAL GROWTH 
  POLITICS & CURRENT AFFAIRS 
  SCIENCE & TECH 
  HEALTH & FITNESS 
  LIFESTYLE 
  ENTERTAINMENT 
  BIOGRAPHIES & HISTORY 
  FICTION 
  Najlepsze historie 
  Najlepsze historie 
  Dodaj historię 
  Moje historie 

 Home 
  Formal Concept Analysis: 17th International Conference, ICFCA 2023, Kassel, Germany, July 17–21, 2023, Proceedings 3031359488, 9783031359484 

 Formal Concept Analysis: 17th International Conference, ICFCA 2023, Kassel, Germany, July 17–21, 2023, Proceedings 3031359488, 9783031359484   
 This book constitutes the proceedings of the 17th International Conference on Formal Concept Analysis, ICFCA 2023, which   
  633    113    5MB    
  English   Pages 214 [215]   Year 2023    
  Report DMCA / Copyright    
  DOWNLOAD FILE   
   
 Polecaj historie   

 Augmented Cognition: 17th International Conference, AC 2023 Held as Part of the 25th HCI International Conference, HCII 2023 Copenhagen, Denmark, July 23–28, 2023 Proceedings 3031350162, 9783031350160  
 This book constitutes the refereed proceedings of 17th International Conference, AC 2023, held as part of the 25th Inter  
  1,429    73    47MB    Read more   

 Augmented Cognition: 17th International Conference, AC 2023, Held as Part of the 25th HCI International Conference, HCII 2023, Copenhagen, Denmark, July 23–28, 2023, Proceedings 9783031350177, 9783031350160, 3031350170  
 This book constitutes the refereed proceedings of 17th International Conference, AC 2023, held as part of the 25th Inter  
  232    12    64MB    Read more   

 Descriptional Complexity of Formal Systems: 25th IFIP WG 1.02 International Conference, DCFS 2023, Potsdam, Germany, July 4–6, 2023, Proceedings (Lecture Notes in Computer Science) 3031343255, 9783031343254  
 This book constitutes the proceedings of the 25th International Conference on Descriptional Complexity of Format Systems  
  150    88    4MB    Read more   

 Formal Concept Analysis: 4th International Conference, ICFCA 2006, Dresden, Germany, Feburary 13-17, 2006, Proceedings (Lecture Notes in Computer Science, 3874) 3540322035, 9783540322030  
 This book constitutes the refereed proceedings of the 4th International Conference on Formal Concept Analysis, held in F  
  127    74    Read more   

 Formal Concept Analysis: 15th International Conference, ICFCA 2019, Frankfurt, Germany, June 25–28, 2019, Proceedings [1st ed.] 978-3-030-21461-6;978-3-030-21462-3  
 This book constitutes the proceedings of the 15th International Conference on Formal Concept Analysis, ICFCA 2019, held  
  447    118    16MB    Read more   

 Adaptive Instructional Systems: 5th International Conference, AIS 2023 Held as Part of the 25th HCI International Conference, HCII 2023 Copenhagen, Denmark, July 23–28, 2023 Proceedings 303134734X, 9783031347344  
 This book constitutes the refereed proceedings of the 5th International Conference, AIS 2023, held as part of the 25th I  
  676    28    20MB    Read more   

 Reachability Problems : 17th International Conference, RP 2023, Nice, France, October 11–13, 2023, Proceedings [14235, 1 ed.] 9783031452857, 9783031452864  
 This book constitutes the refereed proceedings of the 17th International Conference on Reachability Problems, RP 2023, h  
  156    84    7MB    Read more   

 Software Architecture. 17th European Conference, ECSA 2023 Istanbul, Turkey, September 18–22, 2023 Proceedings 9783031425912, 9783031425929  
  
  2,732    116    Read more   

 Advances in Swarm Intelligence: 14th International Conference, ICSI 2023, Shenzhen, China, July 14–18, 2023, Proceedings, Part II 3031366247, 9783031366246  
 This two-volume set LNCS 13968 and 13969 constitutes the proceedings of the 14th International Conference on Advances in  
  665    79    47MB    Read more   

 Computational Science – ICCS 2023: 23rd International Conference, Prague, Czech Republic, July 3–5, 2023, Proceedings, Part IV 3031360265, 9783031360268  
 The five-volume set LNCS 14073-14077 constitutes the proceedings of the 23rd International Conference on Computational S  
  583    79    83MB    Read more   

 Author / Uploaded 
  Dominik Dürrschnabel 
  Domingo López Rodríguez 
  Categories 
  Science (general) 
  International Conferences and Symposiums 

 Table of contents :  
  Preface  
  Organization  
  Abstracts of Invited Talks  
  How to Visualize Sets and Set Relations  
  Tangles: from Wittgenstein to Graph Minors and Back  
  Formal Concept Analysis in Boolean Matrix Factorization: Algorithms and Extensions to Ordinal and Fuzzy-Valued Data  
  On the -Degree of Inclusion  
  Logical Foundations of Categorization Theory  
  Modern Concepts of Dimension for Partially Ordered Sets  
  Latebreaking Result Talk  
  Breaking the Barrier: A Computation of the Ninth Dedekind Number  
  Contents  
  Theory  
  Approximating Fuzzy Relation Equations Through Concept Lattices  
  1 Introduction  
  2 Preliminaries  
  3 Approximating Fuzzy Relation Equations  
  4 Selecting the Best Approximation  
  5 Conclusions and Future Work  
  References  
  Doubly-Lexical Order Supports Standardisation and Recursive Partitioning of Formal Context  
  1 Introduction  
  2 Jointly Reverse Lectic Order  
  2.1 Lectic and Reverse Lectic Orders  
  2.2 Maxmod-Partition and Reverse Lectic Order  
  2.3 Doubly-Lexical Order  
  2.4 Jointly Reverse Lectic Order  
  2.5 JRL Order and Carve  
  3 Carve Identifies Nested Blocks in JRL-Ordered Matrix  
  3.1 Connected Components are Blocks  
  3.2 Blocks are Nested  
  4 Coordinated Browsing  
  5 Context Standardisation and Restoration  
  6 Discussion  
  References  
  Graph-FCA Meets Pattern Structures  
  1 Introduction  
  2 Preliminaries  
  2.1 Pattern Structures (PS)  
  2.2 Graph-FCA  
  3 Graph-PS: Extending Graph-FCA with Pattern Structures  
  3.1 Graph Context  
  3.2 Projected Graph Patterns (PGP)  
  3.3 Graph Concepts  
  4 Application to RDFS Graphs  
  5 Conclusion and Perspectives  
  References  
  On the Commutative Diagrams Among Galois Connections Involved in Closure Structures  
  1 Introduction  
  2 Preliminaries  
  3 Crisp Closure Systems  
  4 A Study on Commutativity of Diagrams  
  5 Conclusions and Further Work  
  References  
  Scaling Dimension  
  1 Introduction  
  2 Formal Concepts Derived from Data Tables  
  2.1 Pre-scalings  
  2.2 Interordinal Plain Scaling  
  2.3 Scale Measures and Views  
  3 Measurability  
  4 Small Case Study  
  5 Discussion and Future Work  
  6 Conclusion  
  References  
  Three Views on Dependency Covers from an FCA Perspective  
  1 Introduction and Motivation  
  2 The Relevance of the Implication Problem  
  3 Definitions  
  4 Algorithms to Compute the Closure of a Set of Attributes  
  4.1 The Closure Algorithm  
  4.2 The Linclosure Algorithm  
  4.3 Experimental Evaluation of Closure and Linclosure  
  5 Covers of Dependencies  
  5.1 Four Main Characteristics of Covers  
  5.2 The Minimal Cover in the RDBM and Its Variations  
  5.3 The Canonical-Direct Basis  
  5.4 The Duquenne-Guigues basis  
  6 Discussion and Conclusion  
  References  
  A Triadic Generalisation of the Boolean Concept Lattice  
  1 Introduction  
  2 Formal and Triadic Concept Analysis  
  2.1 Formal Concept Analysis  
  2.2 Triadic Concept Analysis  
  3 The Loss of Duality in Triadic Concept Analysis  
  4 A Triadic Generalisation of the Boolean Concept Lattice  
  5 On the Minimum Number of Objects in a Bn,m Tricontext  
  6 Discussion and Conclusion  
  References  
  Applications and Visualization  
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
  1 Introduction  
  2 Preliminaries  
  3 Finding Witness-Complete Sets  
  4 Computing All Centralising Monoids on {0,1,2}  
  References  
  Description Quivers for Compact Representation of Concept Lattices and Ensembles of Decision Trees  
  1 Introduction  
  2 Theoretical Background  
  2.1 Formal Concept Analysis  
  2.2 Difference Generators  
  3 Description Quivers for Unsupervised Setting  
  3.1 Description Quiver  
  3.2 Path in Quiver  
  4 Decision Quivers for Supervised Setting  
  4.1 Target-based Decision Quiver  
  4.2 Arrow-Based Decision Quiver  
  4.3 Summation of Arrow-Based Decision Quivers  
  4.4 Conversion of Target-Based Quivers to Arrow-Based Quivers  
  5 Experiments  
  5.1 Datasets  
  5.2 Sizes of Difference Generators  
  5.3 Summation of Decision Trees  
  6 Conclusion  
  References  
  Examples of Clique Closure Systems  
  1 Introduction  
  2 Maximal Cliques  
  3 Closed Cliques  
  4 Examples  
  References  
  On the Maximal Independence Polynomial of the Covering Graph of the Hypercube up to n=6  
  1 Introduction  
  2 Problem Statement and Basic Facts  
  2.1 Graphs and Independent Sets  
  2.2 Formal Concept Analysis and Symmetric Concepts  
  2.3 Conceptual Representation of Qn  
  3 Algorithm  
  4 Results  
  4.1 Level-Union MIS  
  4.2 Lattice-Based Results  
  4.3 Spectral-Based Results  
  5 Conclusions  
  References  
  Relational Concept Analysis in Practice: Capitalizing on Data Modeling Using Design Patterns  
  1 Introduction  
  2 Background and Motivation  
  3 Design Patterns  
  3.1 Describing a Design Pattern  
  3.2 The Design Pattern Separate/Gather Views  
  3.3 The Design Pattern Level Relations  
  4 Perspectives  
  5 Conclusion  
  References  
  Representing Concept Lattices with Euler Diagrams  
  1 Introduction  
  2 Rounded Rectangular Euler Diagrams  
  3 Reducing Concept Lattices  
  4 Two Examples of Constructing Euler Diagrams  
  5 Conclusion  
  References  
  Author Index   
 Citation preview   
  LNAI 13934  
   
  Dominik Dürrschnabel Domingo López Rodríguez (Eds.)  
   
  Formal Concept Analysis 17th International Conference, ICFCA 2023 Kassel, Germany, July 17–21, 2023 Proceedings  
   
  123  
   
  Lecture Notes in Computer Science  
   
  Lecture Notes in Artificial Intelligence Founding Editor Jörg Siekmann  
   
  Series Editors Randy Goebel, University of Alberta, Edmonton, Canada Wolfgang Wahlster, DFKI, Berlin, Germany Zhi-Hua Zhou, Nanjing University, Nanjing, China  
   
  13934  
   
  The series Lecture Notes in Artificial Intelligence (LNAI) was established in 1988 as a topical subseries of LNCS devoted to artificial intelligence. The series publishes state-of-the-art research results at a high level. As with the LNCS mother series, the mission of the series is to serve the international R & D community by providing an invaluable service, mainly focused on the publication of conference and workshop proceedings and postproceedings.  
   
  Dominik Dürrschnabel · Domingo López Rodríguez Editors  
   
  Formal Concept Analysis 17th International Conference, ICFCA 2023 Kassel, Germany, July 17–21, 2023 Proceedings  
   
  Editors Dominik Dürrschnabel Universität Kassel Kassel, Germany  
   
  Domingo López Rodríguez Universidad de Málaga Málaga, Spain  
   
  ISSN 0302-9743 ISSN 1611-3349 (electronic) Lecture Notes in Artificial Intelligence ISBN 978-3-031-35948-4 ISBN 978-3-031-35949-1 (eBook) https://doi.org/10.1007/978-3-031-35949-1 LNCS Sublibrary: SL7 – Artificial Intelligence © The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and regulations and therefore free for general use. The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty, expressed or implied, with respect to the material contained herein or for any errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional affiliations. This Springer imprint is published by the registered company Springer Nature Switzerland AG The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland  
   
  Preface  
   
  The field of Formal Concept Analysis (FCA) originated in the 1980s in Darmstadt, Germany, as a subfield of mathematical order theory, building on earlier research and developments by other groups. The original motivation for FCA was to explore complete lattices as lattices of concepts, drawing inspiration from both Philosophy and Mathematics. Over time, FCA has evolved into a broad research area with applications far beyond its initial focus, including but not limited to logic, knowledge representation, unsupervised learning, data mining, human learning, and psychology. This volume features the contributions accepted for the 17th International Conference on Formal Concept Analysis (ICFCA 2023), held during July 17–21, 2023, at the University of Kassel, Germany. The International Conference on Formal Concept Analysis serves as a platform for researchers from FCA and related disciplines to showcase and exchange their research findings. Since its inaugural edition in 2003 in Darmstadt, Germany, ICFCA has been held annually in multiple locations across Europe, Africa, America, and Australia. In 2015, ICFCA became a biennial event to alternate with the Conference on Concept Lattices and Their Applications (CLA). The previous edition, ICFCA 2021, organized by the Université de Strasbourg in France, was held online due to the COVID-19 pandemic. Now that conditions are beginning to return to the pre-pandemic situation, this edition will once again offer face-to-face opportunities as well as an online mode for the audience, making this the first hybrid ICFCA edition. This year’s ICFCA received 19 submissions from authors from ten countries. At least two different program committee members and one member of the editorial board reviewed each submission. Reviewing was done in a single-blinded fashion. Thirteen high-quality papers were selected for publication in this volume. This represents an acceptance rate of 68%. The research part of this volume is divided into two distinct sections. First, in “Theory”, we have collected papers that propose and review advances in theoretical aspects of FCA. The second section,“Applications and Visualization”, consists of advances that deal with new algorithms, applications, and different approaches to visualization techniques. In addition to the regular contributions, this volume also includes the abstracts of the six invited talks by outstanding researchers whom we were pleased to welcome to ICFCA 2023. In detail, we were pleased to host the following talks: – How to Visualize Sets and Set Relations by Oliver Deussen, Visual Computing, University of Konstanz, Germany – Tangles: from Wittgenstein to graph minors and back by Reinhard Diestel, Discrete Mathematics, University of Hamburg, Germany – Formal Concept Analysis in Boolean Matrix Factorization: Algorithms and Extensions to Ordinal and Fuzzy-Valued Data by Jan Koneˇcný, Department of Computer Science, Palacký University Olomouc, Czech Republic  
   
  vi  
   
  Preface  
   
  – On the ϕ-degree of inclusion by Manuel Ojeda Aciego, Departmento de Matemática Aplicada, Universidad de Málaga, Spain – Logical foundations of categorization theory by Alessandra Palmigiano, Department of Ethics, Governance and Society, Vrije Universiteit Amsterdam, The Netherlands – Modern Concepts of Dimension for Partially Ordered Sets by William T. Trotter, School of Mathematics, Georgia Tech Institute, USA Moreover, due to the recent computation of the ninth Dedekind number using techniques from FCA, this edition also included a late-breaking result talk: – Breaking the Barrier: A Computation of the Ninth Dedekind Number by Christian Jäkel, Methods of Applied Algebra, Dresden University of Technology, Germany We are deeply grateful to all the authors who submitted their papers to ICFCA 2023 as a venue to present their work. Our sincere appreciation goes to the members of the Editorial Board and Program Committee, as well as all the additional reviewers, whose timely and thorough reviews enabled the fruitful discussions of the high-quality papers during the conference. We would also like to express our gratitude to the local organizers, who were always quick to solve any problems that arose. We are very grateful to Springer for supporting the International Conference on Formal Concept Analysis and to the Department of Electrical Engineering and Computer Science and to the Research Center for Information System Design of the University of Kassel for hosting the event. July 2023  
   
  Dominik Dürrschnabel Domingo López-Rodríguez Gerd Stumme  
   
  Organization  
   
  Executive Committee Conference Chair Gerd Stumme  
   
  Universität Kassel, Germany  
   
  Local Organization Committee Tobias Hille Johannes Hirth Maximilian Stubbemann  
   
  Universität Kassel, Germany Universität Kassel, Germany Universität Kassel, Germany  
   
  Program and Conference Proceedings Program Chairs Dominik Dürrschnabel Domingo López-Rodríguez  
   
  Universität Kassel, Germany Universidad de Málaga, Spain  
   
  Editorial Board Jaume Baixeries Peggy Cellier Sebastien Ferrè Bernhard Ganter Tom Hanika Dmitry Ignatov Mehdi Kaytoue Sergei Kuznetsov Leonard Kwuida Florence Le Ber Rokia Missaoui Amedeo Napoli Sergei Obiedkov Manuel Ojeda-Aciego  
   
  Polytechnic University of Catalonia, Spain INSA Rennes, France Université de Rennes 1, France Technische Universität Dresden, Germany Universität Kassel, Germany Higher School of Economics, Moscow, Russia INSA-Lyon, LIRIS, France Higher School of Economics, Moscow, Russia Bern University of Applied Sciences, Switzerland Université de Strasbourg, France Université du Québec en Outaouais, Canada LORIA, Nancy, France Higher School of Economics, Moscow, Russia Universidad de Málaga, Spain  
   
  viii  
   
  Organization  
   
  Uta Priss Christian Sacarea Stefan E. Schmidt Bar¸s Sertkaya Petko Valtchev  
   
  Ostfalia University of Applied Sciences, Germany Babes-Bolyai University of Cluj-Napoca, Romania Technische Universität Dresden, Germany Frankfurt University of Applied Sciences, Germany Université du Québec à Montréal, Canada  
   
  Program Committee François Brucker Victor Codocedo Pablo Cordero Diana Cristea Christophe Demko Jean Diatta Stephan Doerfel Xavier Dolques Marianne Huchard Jan Konecny Wilfried Lex Jesús Medina Engelbert Mephu Nguifo Jan Outrata Henry Soldano Laszlo Szathmary Andreja Tepavcevic Martin Trnecka  
   
  École Centrale de Marseille, France Universidad Técnica Federico Santa María, Chile Universidad de Málaga, Spain Babes-Bolyai University Cluj-Napoca, Romania Université de La Rochelle, France Université de la Réunion, France Micromata GmbH, Germany Université de Strasbourg, France Université de Montpellier, France Palacky University of Olomouc, Czech Republic Universität Clausthal, Germany Cadiz University, Spain Université de Clermont Ferrand 2, France Palacky University of Olomouc, Czech Republic Université Paris 13, France University of Debrecen, Hungary University of Novi Sad, Serbia Palacky University of Olomouc, Czech Republic  
   
  Additional Reviewers Mohamed Hamza Ibrahim  
   
  Université du Québec en Outaouais, Canada  
   
  Abstracts of Invited Talks  
   
  How to Visualize Sets and Set Relations  
   
  Oliver Deussen Visual Computing, University of Konstanz, Germany In his talk he will focus on one particular area of information visualization: the visualization of sets and set relations (known by Venn and Euler diagrams). Unfortunately, such diagrams do not scale, they do not work for larger set numbers. Furthermore, the human ability to understand such data is limited, therefore his group developed perceptuallydriven methods to improve these visualizations. Based on a review of existing methods in information visualization he will present new approaches.  
   
  Tangles: from Wittgenstein to Graph Minors and Back  
   
  Reinhard Diestel Discrete Mathematics, University of Hamburg, Germany Tangles, a central notion from the Robertson-Seymour theory of graph minors, have recently been axiomatised in a way that allows us to capture fuzzy phenomena of connectivity and cohesion, such as mindsets in sociology, topics in text analysis, or Wittgenstein’s family resemblances in linguistics, in an entirely formal and precise way. This talk will offer a non-technical introduction to tangle theory that highlights its various potential applications. Participants interested in trying them out in their own field of interest can obtain well-documented code from us to facilitate this. I look forward to stimulating co-operation with the FCA community!  
   
  Formal Concept Analysis in Boolean Matrix Factorization: Algorithms and Extensions to Ordinal and Fuzzy-Valued Data  
   
  Jan Koneˇcný Department of Computer Science, Palacký University Olomouc, Czech Republic It has been nearly fifteen years since Belohlavek and Vychodil first highlighted the usefulness of Formal Concept Analysis (FCA) in Boolean Matrix Factorization (BMF) and introduced the initial FCA-based algorithms for BMF. This work sparked a thriving research direction within our department that persists to this day. The talk provides an overview of our ongoing research efforts, with a particular emphasis on the application of FCA in the development of algorithms for BMF. Moreover, the progress made in extending these techniques to the factorization of matrices containing ordinal and fuzzyvalued data will be discussed.  
   
  On the ϕ-Degree of Inclusion  
   
  Manuel Ojeda Aciego Departamento de Matemática Aplicada, Universidad de Málaga, Spain The notion of inclusion is a cornerstone in set theory and therefore its generalisation in fuzzy set theory is of great interest. The functional degree (or ϕ-degree) of inclusion is defined to represent the degree of inclusion between two L-fuzzy sets in terms of a mapping that determines the minimal modifications required in one L-fuzzy set to be included in another in the sense of Zadeh. Thus, this notion differs from others existing in the literature because the ϕ-degree of inclusion is considered as a mapping instead of a value in the unit interval. We show that the ϕ-degree of inclusion satisfies versions of many common axioms usually required for inclusion measures in the literature. Considering the relationship between fuzzy entropy and Young’s axioms for measures of inclusion, we also present a measure of entropy based on the ϕ-degree of inclusion that is consistent with the axioms of De Luca and Termini. We then continue to study the properties of the ϕ-degree of inclusion and show that, given a fixed pair of fuzzy sets, their ϕ-degree of inclusion can be linked to a fuzzy conjunction that is part of an adjoint pair. We also show that when this pair is used as the underlying structure to provide a fuzzy interpretation of the modus ponens inference rule, it provides the maximum possible truth value in the conclusion among all those values obtained by fuzzy modus ponens using any other possible adjoint pair. Finally, we will focus on current work on the integration of the ϕ-degree of inclusion with FCA.  
   
  Logical Foundations of Categorization Theory  
   
  Alessandra Palmigiano Department of Ethics, Governance and Society, Vrije Universiteit Amsterdam, The Netherlands Categories are cognitive tools that humans use to organize their experience, understand and function in the world, and understand and interact with each other, by grouping things together which can be meaningfully compared and evaluated. They are key to the use of language, the construction of knowledge and identity, and the formation of agents’ evaluations and decisions. Categorization is the basic operation humans perform e.g. when they relate experiences/actions/objects in the present to ones in the past, thereby recognizing them as instances of the same type. This is what we do when we try to understand what an object is or does, or what a situation means, and when we make judgments or decisions based on experience. The literature on categorization is expanding rapidly in fields ranging from cognitive linguistics to social and management science to AI, and the emerging insights common to these disciplines concern the dynamic essence of categories, and the tight interconnection between the dynamics of categories and processes of social interaction. However, these key aspects are precisely those that both the extant foundational views on categorization struggle the most to address. In this lecture, we will discuss a logical approach, semantically based on formal contexts and their associated concept lattices, which aims at creating an environment in which these three cognitive processes can be analyzed in their relationships to one another, and propose several research directions, developing which, novel foundations of categorization theory can be built.  
   
  Modern Concepts of Dimension for Partially Ordered Sets  
   
  William T. Trotter School of Mathematics, Georgia Tech Institute, USA Partially ordered sets (posets) are useful models for rankings on large data sets where linear orders may fail to exist or may be extremely difficult to determine. Many different parameters have been proposed to measure the complexity of a poset, but by far the most widely studied has been the Dushnik-Miller notion of dimension. Several alternate forms of dimension have been proposed and studied, and the pace of research on this theme has accelerated in the past 10 years. Among these variants are Boolean dimension, local dimension, fractional dimension and fractional local dimension. The last in this list holds promise for applications since it provides an answer to the natural question: How can we determine a partial order given only piecemeal observations made, often independently, and typically with conflicts, on extremely large populations? As an added bonus, this line of research has already produced results that have intrinsic mathematical appeal. In this talk, I will introduce the several concepts of dimension, outline some key results and applications for each, and close with more detailed comments on fractional local dimension.  
   
  Latebreaking Result Talk  
   
  Breaking the Barrier: A Computation of the Ninth Dedekind Number  
   
  Christian Jäkel Technische Universität Dresden, Germany The Dedekind numbers are a fast-growing sequence of integers which are exceptionally hard to compute. Introduced in 1897 by Richard Dedekind, the nth Dedekind number represents the size of the free distributive lattice with n generators, the number of antichains of subsets of an n-element set, and the number of abstract simplicial complexes with n elements. It is also equal to the number of Boolean functions with n variables, composed only of “and” and “or” operators. After three decades of being an open problem, I will present my successful approach to compute the ninth Dedekind number in this talk. Inspired by Formal Concept Analysis, I developed complexity reduction techniques to tackle this problem. In addition, I discovered formulas that facilitate the efficient computation on GPUs, resulting in significantly faster runtimes compared to conventional CPU computing.  
   
  Contents  
   
  Theory Approximating Fuzzy Relation Equations Through Concept Lattices . . . . . . . . . . David Lobo, Víctor López-Marchante, and Jesús Medina Doubly-Lexical Order Supports Standardisation and Recursive Partitioning of Formal Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Tim Pattison and Aryan Nataraja Graph-FCA Meets Pattern Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Sébastien Ferré On the Commutative Diagrams Among Galois Connections Involved in Closure Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Manuel Ojeda-Hernández, Inma P. Cabrera, Pablo Cordero, and Emilio Muñoz-Velasco  
   
  3  
   
  17  
   
  33  
   
  49  
   
  Scaling Dimension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Bernhard Ganter, Tom Hanika, and Johannes Hirth  
   
  64  
   
  Three Views on Dependency Covers from an FCA Perspective . . . . . . . . . . . . . . . Jaume Baixeries, Victor Codocedo, Mehdi Kaytoue, and Amedeo Napoli  
   
  78  
   
  A Triadic Generalisation of the Boolean Concept Lattice . . . . . . . . . . . . . . . . . . . . Alexandre Bazin  
   
  95  
   
  Applications and Visualization Computing Witnesses for Centralising Monoids on a Three-Element Set . . . . . . . 109 Mike Behrisch and Leon Renkin Description Quivers for Compact Representation of Concept Lattices and Ensembles of Decision Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Egor Dudyrev, Sergei O. Kuznetsov, and Amedeo Napoli Examples of Clique Closure Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 Elias Dahlhaus and Bernhard Ganter  
   
  xxviii  
   
  Contents  
   
  On the Maximal Independence Polynomial of the Covering Graph of the Hypercube up to n=6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 Dmitry I. Ignatov Relational Concept Analysis in Practice: Capitalizing on Data Modeling Using Design Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Agnès Braud, Xavier Dolques, Marianne Huchard, Florence Le Ber, and Pierre Martin Representing Concept Lattices with Euler Diagrams . . . . . . . . . . . . . . . . . . . . . . . . 183 Uta Priss Author Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199  
   
  Theory  
   
  Approximating Fuzzy Relation Equations Through Concept Lattices David Lobo , V´ıctor L´ opez-Marchante , and Jes´ us Medina(B) Department of Mathematics, University of C´ adiz, C´ adiz, Spain {david.lobo,victor.lopez,jesus.medina}@uca.es  
   
  Abstract. Fuzzy relation equations (FRE) is a formal theory broadly studied in the literature and applied to decision making, optimization problems, image processing, etc. It is usual that the initial data contains uncertain, imperfect or incomplete information, which can imply, for instance, the existence of inconsistencies. As a consequence, the FRE that arises from the data may be unsolvable. Taking advantage of the relationship between FRE and concept lattices, this paper is focused on three mechanisms for approximating unsolvable FRE. Several properties have been introduced and diﬀerent distances for determining the best approximation are considered and applied to an example. Keywords: Fuzzy Sets · Fuzzy Relation Equation concept lattice · Adjoint triples  
   
  1  
   
  · Property-oriented  
   
  Introduction  
   
  Formal concept analysis (FCA) has interacted with other formal tools and approaches in order to obtain robust and trustworthy intelligent systems, such as rough set theory [10,22], machine learning [18,21,28], graph theory [3,17,26], etc. From these interactions, this paper will be focused on the relationship with fuzzy relation equations (FRE), which were introduced by Elie Sanchez in 1976 [25]. This theory has been broadly studied in the literature by many authors [11,12,24,27], spreading to ﬁelds like decision making [4], bipolarity [5,6], optimization [2] and image processing [1]. The relationship between FRE and the isotone variants of FCA, that is, the property-oriented concept lattices and object-oriented concept lattices [22], was originally presented by D´ıaz-Moreno and Medina in [14]. This relation was Partially supported by the 2014–2020 ERDF Operational Programme in collaboration with the State Research Agency (AEI) in project PID2019-108991GB-I00, with the Ecological and Digital Transition Projects 2021 of the Ministry of Science and Innovation in project TED2021-129748B-I00, and with the Department of Economy, Knowledge, Business and University of the Regional Government of Andalusia in project FEDER-UCA18-108612, and by the European Cooperation in Science & Technology (COST) Action CA17124. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 3–16, 2023. https://doi.org/10.1007/978-3-031-35949-1_1  
   
  4  
   
  D. Lobo et al.  
   
  intensiﬁed with the generalization of FRE to the multi-adjoint paradigm in [13, 15]. A complete study on the computation of the whole solution set of a solvable FRE is shown in [15], where it is characterized in terms of an associated multiadjoint property-oriented concept lattice. Multi-adjoint relation equations (MARE) [13] provide a large ﬂexibility for setting the equations, due to the generality of the underlying algebraic structure and the possibility of considering diﬀerent conjunctors for each variable depending on its nature. A given FRE might be not solvable because of diﬀerent reasons. For example, because of an excess of imposed restrictions, the consideration of constrains that cannot be satisﬁed or the imposition of two incompatible conditions. It is therefore necessary to have mechanisms that allow to transform a given unsolvable FRE into a solvable one, through slight changes. We will refer to this process as approximating an unsolvable FRE to a solvable one. In addition, it is important that the FRE approximation procedures can be easily interpretable, in the sense that the eﬀect that they have on the original equation when applied are known and controlled. This paper will analyze three mechanisms with diﬀerent philosophies for approximating an unsolvable FRE and their main features will be discussed. Moreover, several distances for measuring the change made by the approximation processes and the comparison among them on an example will also be presented. The three mechanisms arise thanks to the relationship between FRE and property-oriented concept lattices and object-oriented concept lattices [13]. The ﬁrst one was recently introduced in [20] and it is based on attribute reduction in FCA [8]. The attribute reduction results in FCA were translated to property-oriented and object-oriented concept lattices and applied to FRE. As a ﬁrst consequence, a mechanism for simplifying FRE without removing relevant information was introduced, and this reduction also oﬀers the possibility of approximating FRE. The other two methods were introduced in [4], where a comparison between FRE and logic programming was done. In this paper, we present these procedures in a general framework and several properties will be studied. The paper is structured as follows. Section 2 includes the algebraic structure considered in the paper, and several basic notions and results on FRE and concept lattices. Section 3 presents the three mechanisms to approximate FRE and analyzes diverse properties. Then, Sect. 4 considers four distances in order to compare the obtained approximated FRE on an example. Finally, some conclusions and prospects for future work are given.  
   
  2  
   
  Preliminaries  
   
  The algebraic structures considered in the multi-adjoint frameworks are based on adjoint triples. These operators generalize left-continuous t-norms and its residuated implications, where the conjunctors do not need to be commutative or associative. Consequently, two diﬀerent residuated implications arise associated with these conjunctions.  
   
  Approximating FRE Through Concept Lattices  
   
  5  
   
  Definition 1 ([9]). Let (P1 , 1 ), (P2 , 2 ), (P3 , 3 ) be posets and & : P1 ×P2 → P3 ,  : P3 ×P2 → P1 ,  : P3 ×P1 → P2 mappings, then (&, , ) is an adjoint triple with respect to P1 , P2 , P3 if x 1 z  y  
   
  iﬀ  
   
  x&y 3 z  
   
  iﬀ  
   
  y 2 z  x  
   
  for each x ∈ P1 , y ∈ P2 , z ∈ P3 . The G¨ odel, L  ukasiewicz and product t-norms, together with their residuated implications are natural examples of adjoint triples. Moreover, other nonassociative and non-commutative operators, such as & : [0, 1] × [0, 1] → [0, 1], deﬁned as x & y = x2 y, for all x, y ∈ [0, 1], can be considered [16]. Another kind of interesting operators are the discretization of the t-norms [23], which are the real operators used in the computations due to the fact that every numerical computation software uses a ﬁnite number of decimals. Recall that the G¨ odel t-norm &G is deﬁned as x &G y = min{x, y} for all x, y ∈ [0, 1]; the product  ukasiewicz t-norm &p is deﬁned as x &P y = xy for all x, y ∈ [0, 1] and the L t-norm &L is deﬁned as x &L y = max{0, x + y − 1} for all x, y ∈ [0, 1]. We will consider the regular partitions of [0, 1] into m pieces, which will be denoted as [0, 1]m . For example, [0, 1]4 = {0, 0.25, 0.5, 0.75, 1} divides the unit interval into four pieces. A discretization of a t-norm & : [0, 1] × [0, 1] → [0, 1] is the operator & : [0, 1]m × [0, 1]n → [0, 1]k , where n, m, k ∈ N, deﬁned as: x&y =  
   
  k · (x & y) k  
   
  for all x ∈ [0, 1]m and y ∈ [0, 1]n , where   is the ceiling function. The discretization of the corresponding residuated implications  : [0, 1]k × [0, 1]n → [0, 1]m and  : [0, 1]k × [0, 1]m → [0, 1]n is deﬁned as: zy =  
   
  m · (z ← y) m  
   
  zx =  
   
  n · (z ← x) n  
   
  for all z ∈ [0, 1]k and y ∈ [0, 1]n , where is the ﬂoor function and ← is the residuated implication of the t-norm &. We have that (&, , ) is an adjoint triple with respect to [0, 1]n , [0, 1]m and [0, 1]k [7,23]. The concept of multi-adjoint property-oriented frame was introduced in [22] with the aim of allowing the use of several adjoint triples. For computational reasons, we will assume that two of the posets are lattices. Definition 2 ([22]). Let (L1 , 1 ), (L2 , 2 ) be two lattices, (P, 3 ) a poset and {(&i , i , i ) | i ∈ {1, . . . , n}} a set of adjoint triples with respect to P, L2 , L1 . The tuple (L1 , L2 , P, 1 , 2 , 3 , &1 , 1 , 1 , . . . , &n , n , n ) is called multi-adjoint property-oriented frame. The following deﬁnition presents the notion of context.  
   
  6  
   
  D. Lobo et al.  
   
  Definition 3 ([22]). Let (L1 , L2 , P, &1 , . . . , &n ) be a multi-adjoint propertyoriented frame. A multi-adjoint context is a tuple (A, B, R, σ) where A and B are non-empty sets, R : A × B → P is a fuzzy relation and σ : A × B → {1, ..., n} is a mapping. Given a multi-adjoint frame and a context, two mappings can be deﬁned between the fuzzy subsets of attributes A, that is LA 1 = {f | f : A → L1 }, and = {g | g : B → L2 }. Speciﬁcally, the the fuzzy subsets of objects B, that is LB 2 A ↓N A B → L and : L → L are deﬁned as mappings ↑π : LB 2 1 1 2    (1) g ↑π (a) = 1 R(a, b) &σ(a,b) g(b) | b ∈ B    N f (a) σ(a,b) R(a, b) | a ∈ A (2) f ↓ (b) = 2  
   
    B for all f ∈ LA 1 and g ∈ L2 , where 1 and 2 represent the suprema and N inﬁma of (L1 , 1 ) and (L2 , 2 ), respectively. The pair of mappings (↑π ,↓ ) forms an isotone Galois connection [22]. This leads to the deﬁnition of multi-adjoint property-oriented concept lattice. Consider the order relation πN deﬁned as g1 , f1 πN g2 , f2 if and only if f1 1 f2 , or equivalently, if and only if g1 2 g2 . The multi-adjoint property-oriented concept lattice associated with the multi-adjoint propertyoriented frame is given by  A ↓N ↑π (3) MπN (A, B, R, σ) = g, f ∈ LB × L | g = f , f = g 2 1 The set MπN endowed with the order πN is a complete lattice [22]. Given a concept g, f , the mapping g is called extent of the concept and f is called the intent of the concept. The set of intents is denoted as I(MπN ) and the extents are denoted as E(MπN ). Next, several deﬁnitions and results concerning multi-adjoint relation equation (MARE) will be recalled. For more details see [13]. A MARE is an equation of the form R  S = T , where R, S and T are fuzzy relations, R or S is unknown, and  is a sup-composition operator. There exist diﬀerent composition operators  between fuzzy relations, in this paper we will consider the following one. Definition 4 ([13]). Let U, V, W be sets, (P1 , 1 ), (P2 , 2 ), (P3 , 3 ) posets, {(&i , i , i ) | i ∈ {1, . . . , n}} a set of adjoint triples with respect P1 , P2 , P3 , σ : V → {1, . . . , n} a mapping, and R ∈ P1U ×V , S ∈ P2V ×W , T ∈ P3U ×W three fuzzy relations. If P3 is a complete lattice, the operator σ : P1U ×V × P2V ×W → P3U ×W deﬁned as  (4) R σ S(u, w) = 3{R(u, v)&σ(v) S(v, w) | v ∈ V } is called sup-&σ -composition. This sup-composition operator is used in the deﬁnition of the MARE analyzed in this paper.  
   
  Approximating FRE Through Concept Lattices  
   
  7  
   
  Definition 5 ([13]). A MARE with sup-&σ -composition is an equality of the form (5) R σ X = T where X is an unknown fuzzy relation. A MARE is solvable if there exists at least one solution, that is, a relation X exists satisfying (5). Otherwise, we say that the MARE is unsolvable. A dual equation can be developed if the relation R is the unknown relation in the equation R σ S = T . If P2 is a lower-semilattice and the MARE (5) is solvable, then its greatest solution exists and can be computed as follows. Proposition 1 ([13]). Let R σ X = T be a solvable MARE and (P2 , 2 ) a lower-semilattice. Its greatest solution X is given by  X(v, w) = 2{T (u, w) σ(v) R(u, v) | u ∈ U } for each (v, w) ∈ V × W In [13,15], diverse results related to the solvability and the computation of the solution set of a MARE were introduced based on its relationship with the isotone variants of FCA. Next, the most relevant ones in the scope of this paper will be recalled. First of all, the following deﬁnition assigns a context to a MARE. Definition 6 ([13]). The multi-adjoint context associated with the MARE Rσ X = T is the property-oriented multi-adjoint context (U, V, R, σ). The following results are based on the notion of multi-adjoint concept lattice. The resolution procedure consists of associating a MARE with a context and, consequently, a multi-adjoint property-oriented concept lattice is associated with it too. The concept lattice (MπN (U, V, R, σ), πN ) of the context associated with a MARE characterizes its solvability. Proposition 2 ([13]). Let (U, V, R, σ) be the multi-adjoint context associated with a MARE R σ X = T and (MπN , πN ) the concept lattice associated with that context. Then R σ X = T is solvable if and only if Tw ∈ I(MπN ) for all w ∈ W , where Tw (u) = T (u, w), for all u ∈ U , w ∈ W . The solution set of a MARE can be characterized in terms of its associated context as was proved in [15]. Moreover, attribute reduction in FCA allows to reduce a MARE, thus leading to the notion of reduced MARE. Definition 7 ([20]). Let Y ⊆ U and consider the relations RY = R|Y ×V , TY = T|Y ×W . The MARE RY σ X = TY is called Y -reduced MARE of R σ X = T . Reducing a MARE in a consistent set/reduct preserves its solution set. The following result is one of the most relevant ones introduced in [20]. Theorem 1 ([20]). Let R σ X = T be a solvable MARE and Y a consistent set of its associated context (U, V, R, σ). The Y -reduced equation of R σ X = T is solvable. In addition, X ∈ LV2 ×W is a solution of the Y -reduced equation if and only if it is a solution of the whole equation.  
   
  8  
   
  3  
   
  D. Lobo et al.  
   
  Approximating Fuzzy Relation Equations  
   
  This section presents three diﬀerent mechanisms for approximating unsolvable FRE, which have been adapted from [4,20]. Although the results are focused on the multi-adjoint framework, they can straightforwardly translated to other more particular settings, such as the residuated case and max-min FRE. The main common feature of the three approximation techniques is that they have been reached taking advantage of the relationship between FRE and concept lattices [13,15]. In the following, let us consider three sets U , V , W ﬁxed and a propertyoriented multi-adjoint framework (L1 , L2 , P, 1 , 2 , , &1 , 1 , 1 , . . . , &n , n , n ) A MARE is the equation R σ X = T  
   
  (6)  
   
  ×W where R ∈ P U ×V , T ∈ LU and X ∈ LV2 ×W , with X being unknown. 1 The intuition behind the ﬁrst approximation procedure is to eliminate several of the rows of an unsolvable MARE to recover its solvability. If this happens, it can be reasoned that the inconsistencies that gave rise to the unsolvability were due to the eliminated rows. However, as with reduction procedures, removing too many rows from the equation can lead to a loss of relevant information. In fact, eliminating all rows always leads to a trivially solvable equation, but no information from the original equation is preserved in that case. Therefore, we will use the approach of Theorem 1, which states that reducing a solvable equation considering a consistent set does not cause loss of information. Based on the previous considerations, we will search for a consistent set of attributes Y of its associated context, such that the Y -reduced equation will be solvable, which means that all inconsistencies have been eliminated without losing relevant information. Moreover, in order to eliminate redundant information as well, we will always take into account reducts, which gives rise to the following deﬁnition.  
   
  Definition 8. Let R σ X = T be an unsolvable MARE and (U, V, R, σ) its associated context. We say that a reduct Y ⊆ U of (U, V, R, σ) is feasible if the Y -reduced equation RY σ X = TY is solvable. Note that every consistent set contains at least one reduct. Thus, in order to include as little redundant information as possible, feasible reducts will be Y N considered from now on. Given a subset of attributes Y ⊆ U , we will use (↑π ,↓Y ) to denote the Galois connection associated with the context (Y, V, RY , σ|Y ×V ). Suppose that an unsolvable MARE R σ X = T admits a feasible reduct Y ⊆ U . Since the equation RY σ X = TY is solvable, it is clear that the inconsistencies of the original MARE correspond to the rows that have been eliminated. Now, the question that naturally arises is whether it is possible to redeﬁne the independent term of those rows and so, preserving the dimension  
   
  Approximating FRE Through Concept Lattices  
   
  9  
   
  of the original MARE but with a modiﬁed independent term oﬀering a solvable equation without the need to eliminate any row. Thus, the proposed approximation method will modify the values of the independent term associated with attributes of the set U \Y , so that the resulting MARE is solvable. The following result proves that, given a feasible reduct, it is always possible to approximate an unsolvable MARE in this way. Theorem 2 ([20]). Let Rσ X = T be an unsolvable MARE, Y a feasible reduct of its associated context (U, V, R, σ), and T *Y the relation deﬁned as T *Y (u, w) = ↓N ↑  
   
  (TY )wY π (u) for all (u, w) ∈ U × W . The equation R σ X = T *Y is solvable and RY σ X = TY is a Y -reduced equation of R σ X = T *Y , i.e., Tw (u) = Tw*Y (u) for all (u, w) ∈ Y × W Thus, this last result provides a ﬁrst way to approximate a MARE. Definition 9. Let R σ X = T be an unsolvable MARE and Y be a feasible reduct of its associated context (U, V, R, σ). We say that R σ X = T *Y is the ↓N ↑π  
   
  Y -reduced approximation of the equation R σ X = T if Tw*Y = (TY )wY all w ∈ W .  
   
  for  
   
  Note that, each feasible reduct gives rise to a diﬀerent approximation of the original equation. Thus, depending on whether some conditions (equations) are considered more important than others, we can select one reduct (approximation) with respect to the others. Moreover, it need to be emphasized that not all reducts need to be necessarily feasible, and in particular not all reducts in the associated context have to give rise to an approximation of the unsolvable equation. The following two approximation procedures were originally introduced in [4], in which FRE are used in abduction reasoning in the framework of logic programming. In a general setting, they consist in replacing Tw by the intension of some concept greater or smaller than Tw , for all w ∈ W . Given the lattice (I(MπN ), ) of concepts associated with the Eq. (6), we will consider two sets containing, for each w ∈ W , those elements of I(MπN ) that are less than Tw or greater than Tw , respectively N  
   
  Lw = {f | f ↓ , f ∈ MπN and f 1 Tw } N  
   
  Gw = {f | f ↓ , f ∈ MπN and Tw 1 f }  
   
  (7) (8)  
   
  Note that, substituting Tw by an element of Lw or of Gw , for all w ∈ W , gives rise to a solvable MARE since, by deﬁnition, the elements of these sets are intensions of concepts of MπN . The following result shows that the set Lw has a maximum element. Proposition 3. Let R σ X = T be an unsolvable MARE. For each w ∈ W , N the set Lw deﬁned on (7) has a maximum element, which is given by Tw↓ ↑π . In general, the sets of the form Gw deﬁned in (8) have no minimum element and, in certain cases, they may even be empty [15]. Therefore, we will use their minimal elements as an approximation, when they exist.  
   
  10  
   
  D. Lobo et al.  
   
  Definition 10. Let R σ X = T be an unsolvable MARE. 1. We say that R σ X = T∗ is the conservative approximation of the equation N R σ X = T if (T∗ )w = Tw↓ ↑π for all w ∈ W . 2. We say that R σ X = T ∗ , is an optimistic approximation of the equation R σ X = T if Tw∗ is a minimal element of the set Gw deﬁned in (8) for all w ∈ W. The following result shows that the conservative and optimistic approximations are the most suitable approaches if the independent term is desired to be increased or decreased at the same time in all its components, respectively. This means that it is not possible to ﬁnd another approximation closer to the original solution with such features. Proposition 4. Let R σ X = T be an unsolvable MARE. The following properties are satisﬁed: 1. If R σ X = T∗ is the conservative approximation of R σ X = T , there is no T  ∈ LV1 ×W such that R σ X = T  is solvable and, for some w ∈ W , it is satisﬁed that (T∗ )w ≺1 Tw ≺1 Tw . 2. If R σ X = T ∗ is an optimistic approximation of R σ X = T , there is no T  ∈ LV1 ×W such that R σ X = T  is solvable and, for some w ∈ W , it is satisﬁed that Tw ≺1 Tw ≺1 Tw∗ . The conservative and the optimistic approximation mechanisms are easily applicable and allow diﬀerent alternatives to recover the solvability of a given MARE. Moreover, they always exist unlike the reduced approximation mechanism. On the contrary, the reduced method has a useful control on the modiﬁed elements in the independent term (equations to be removed), which does not apply to the conservative and the optimistic approaches. The following example shows the conservative, optimistic and reduced approximations of an unsolvable MARE, illustrating some of the mentioned characteristics of these methods. Example 1. Let U = {u1 , u2 , u3 , u4 , u5 }, V = {v1 , v2 , v3 , v4 , v5 } and W = {w} be three sets, and consider ﬁxed the property-oriented multi-adjoint framework ([0, 1]8 , ≤, &P , P , P , &2 , 2 , 2 ) where (&P , P , P ) is the discretization of the adjoint triple associated to the product t-norm and (&2 , 2 , 2 ) is the discretization of the adjoint triple related to the conjunction & : [0, 1] × [0, 1] → [0, 1] given by x & y = x2 y, for all x, y ∈ [0, 1]. In this setting, consider the MARE R σ X = T  
   
  (9)  
   
  Approximating FRE Through Concept Lattices  
   
  11  
   
  where σ : V → {1, 2} assigns v1 , v2 , v5 to the ﬁrst adjoint triple and v3 , v4 to the ×V ×W and T ∈ [0, 1]U are deﬁned as second one, while the relations R ∈ [0, 1]U 8 8 ⎛ ⎞ ⎛ ⎞ 0.25 0.25 0.75 0.375 0.125 0.375 ⎜0.125⎟ ⎜0.125 0.375 0.125 0 0.25 ⎟ ⎜ ⎟ ⎜ ⎟ ⎜0.375⎟ ⎟, 0.5 0.75 0.5 0.375 0.375 T = R=⎜ ⎜ ⎟ ⎜ ⎟ ⎝0.125⎠ ⎝ 0.25 0.75 0.375 0.125 0.375⎠ 0.125 0.5 0.625 0.5 0.375 0.125 First and foremost, notice that ⎛  
   
  T↓  
   
  N  
   
  ↑π  
   
  ⎞ ↑π ⎛ ⎞ 0.25 0.125 ⎜ 0.125 ⎟ ⎜ 0.125 ⎟ ⎜ ⎟ ⎜ ⎟ ⎜ ⎟ ⎟ = ⎜ 0.5 ⎟ =⎜ ⎜ 0.125 ⎟ = T ⎝ 0.875 ⎠ ⎝ 0.125 ⎠ 0.25 0.125  
   
  Hence, by Proposition 2, we can assert that (9) is not solvable. Let us then apply the diﬀerent approximation techniques shown in this section. To begin with, the conservative approximation of (9) is the MARE R σ X = T∗ where the relation T∗ is given by  
   
  (10)  
   
  ⎛  
   
  T∗ = T ↓  
   
  N  
   
  ↑π  
   
  ⎞ 0.125 ⎜ 0.125 ⎟ ⎜ ⎟ ⎟ =⎜ ⎜ 0.125 ⎟ ⎝ 0.125 ⎠ 0.125  
   
  Notice that, the ﬁrst and the third elements of the right-hand side of the conservative MARE (10) are smaller than those of the original MARE (9), whilst the rest of elements remain unchanged. The associated concept is highlighted in blue in Fig. 1. In order to compute the optimistic approximation(s) of (9), we will make use of the concept lattice (MπN , πN ) associated with the MARE, which is illustrated in Fig. 1. It holds that the set Gw (deﬁned in (8)) has two minimal elements, which entail two optimistic approximations of (9):  
   
  where  
   
  ⎛  
   
  R σ X = T1∗  
   
  (11)  
   
  R σ X = T2∗  
   
  (12)  
   
  ⎞ 0.25 ⎜ 0.125 ⎟ ⎜ ⎟ ∗ ⎟ T1 = ⎜ ⎜ 0.375 ⎟ ⎝ 0.25 ⎠ 0.375  
   
  ⎛  
   
  ⎞ 0.375 ⎜ 0.25 ⎟ ⎜ ⎟ ∗ ⎟ T2 = ⎜ ⎜ 0.375 ⎟ ⎝ 0.375 ⎠ 0.125  
   
  12  
   
  D. Lobo et al.  
   
  In this case, one of the optimistic approximations (11) increases the value of the two last components of the right-hand side of (9), while in the second optimistic approximation (12), the ﬁrst, the second and the fourth element of the right-hand side of (9) have risen. In both cases, all other elements of the independent term are equal to the original MARE. The corresponding concepts are highlighted in orange in Fig. 1.  
   
  Fig. 1. Concept lattice associated with the MARE (9).  
   
  Lastly, making use of the procedures detailed in [8], it is satisﬁed that the context (U, V, R, σ) admits two reducts: Y1 = {u1 , u2 , u5 } and Y2 = {u2 , u4 , u5 }. On the one hand, since ⎞ ↑Y1 π 0.25 ⎛ ⎞ ⎜ 0.125 ⎟ 0.25 ⎜ ⎟ ⎟ =⎜ = ⎝ 0.125 ⎠ = TY1 ⎜ 0.5 ⎟ ⎝ 0.875 ⎠ 0.125 0.5 ⎛  
   
  1 ↓N ↑Y π  
   
  TY1Y1  
   
  Approximating FRE Through Concept Lattices  
   
  13  
   
  then the Y1 -reduced MARE RY1 σ X = TY1 is solvable. In other words, Y1 is a feasible reduct and the right-hand side of the Y1 -reduced approximation of (9) is given by ⎛ ⎞ 0.25 ⎜ 0.125 ⎟ ⎜ ⎟ ↓N Y1 * Y1 ↑π ⎟ T =T =⎜ ⎜ 0.25 ⎟ ⎝ 0.25 ⎠ 0.125 In this case, the third element of the right-hand side of (9) has been decreased and the fourth one has been increased, while the elements corresponding to the reduct Y1 remain unaltered. Notice that, this compensational feature does not occur in the conservative or optimistic approximations (10), (11) and (12). This new approximation is associated with the concept highlighted in red in Fig. 1. On the other hand, it can be checked that the reduct Y2 is also feasible, but it does not lead to a new approximation, as the Y2 -reduced approximation of (9) coincides with the conservative approximation (10).  
   
  4  
   
  Selecting the Best Approximation  
   
  The three approximation mechanisms of unsolvable MARE presented in Sect. 3 are based on diﬀerent philosophies for obtaining a new independent term such that the resulting MARE is solvable. Furthermore, two of these three mechanisms may give rise to more than one approximation, as shown in Example 1, where four diﬀerent approximations of (9) have been calculated. In order to contrast the approximations of an unsolvable MARE, a measure is necessary. In [19], three unsolvability measures were introduced to compare the original MARE with independent term Tw from its conservative approximation N Tw↓ ↑π [4]. Such study revealed how far is an unsolvable MARE from being solvable, assuming the (unique) conservative approximation. The idea here is deﬁning measures applicable to all the possible approximations of a MARE, leading to a basis to compare the approximations between them. Notice that, for instance, a MARE can be far from its conservative approximation but close to one of its optimistic approximations. It is clear that the ﬁrst measure presented in [19] (which will be recalled next) perfectly works for the other two approximation approaches, while the other two measures are meaningless for optimistic and reduced approximations. In this section, we will consider the unit interval as the underlying lattice. Hence, we will use three distances between two columns/vectors for comparing the given independent term T and an approximation T ∗ . Given two columns C1 , C2 with  
   
  14  
   
  D. Lobo et al.  
   
  k rows, we deﬁne the distance Dp : [0, 1]k × [0, 1]k → [0, 1] as k   
   
  Dp (C1 , C2 ) =  
   
  i=1  
   
  I(C1 [i], C2 [i]) k  
   
  for all C1 , C2 ∈ [0, 1]k , where the mapping I : [0, 1] × [0, 1] → {0, 1} is deﬁned as:  0 if u = w I(u, w) = 1 if u = w for all u, w ∈ [0, 1]. Basically, the measure Dp gives the average number of coordinates of the column C1 that are diﬀerent from the column C2 . Since this measure does not take into account the distance between the coordinates, another measure is required. Therefore, we will consider other natural distances, that is, the Manhattan, the Euclidean and the Chebyshev (or maximum metric) ones. Hence, the distances D1 , D2 , D∞ deﬁned for all C1 , C2 ∈ [0, 1]k as D1 (C1 , C2 ) =  
   
  k   
   
  |C1 [i] − C2 [i]|  
   
  i=1  
   
    k  2 D2 (C1 , C2 ) =  (C1 [i] − C2 [i]) i=1  
   
  D∞ (C1 , C2 ) = max{|C1 [i] − C2 [i]| | i ∈ {1, . . . , k}} will also be taken into account for comparing the columns of the original independent term of a MARE and the right-hand side of an approximation. Notice that, the resolution of a MARE of the form (6) is equivalent to the resolution of k subsystems (13) R σ Xw = Tw where k is the number of columns of T and Xw , Tw are the w-th columns of X and T , respectively. The following example applies the introduced measures to the approximations of (9) computed in Example 1. Example 2. Continuing with Example 1, Table 1 shows the diﬀerences between the independent terms given by each approximate mechanism introduced above. Therefore, in this example, the user will select the approximated FRE given by a reduct of the concept lattice associated with the FRE, which is the best approximation from the four possibilities. In the future, more relationships will be studied among the diﬀerent obtained independent terms.  
   
  Approximating FRE Through Concept Lattices  
   
  15  
   
  Table 1. Distances among the independent terms of the approximation mechanisms Approximation Method Independent term Dp  
   
  5  
   
  D1  
   
  D2  
   
  D∞  
   
  Conservative  
   
  T∗  
   
  2/5 0.375 0.279508 0.25  
   
  Optimistic  
   
  T1∗  
   
  2/5 0.375 0.279508 0.25  
   
  Optimistic  
   
  T2∗  
   
  3/5 0.5  
   
  0.306186 0.25  
   
  Reduced  
   
  T *Y1  
   
  2/5 0.25  
   
  0.176777 0.125  
   
  Conclusions and Future Work  
   
  This paper has analyzed three mechanisms to approximate FRE based on the relationship between FRE and the two isotone variants of FCA. The ﬁrst one takes advantage the attribute reduction results in FCA to remove problematic and redundant equations of the original FRE. As a consequence, unsolvable FRE becomes solvable because of removing possible inconsistencies in the systems of equations. The other two are based on looking for the intensions of the concept lattice associated with the given FRE that are closer to its independent term. Diﬀerent measures have been proposed to analyze what approximation is the most appropriated in practical cases. They have also been applied to an example. In the future, we will continue the study of approximations of unsolvable of FRE, introduce more measures and determine the impact of approximating FRE in their solution set.  
   
  References 1. Alcalde, C., Burusco, A., D´ıaz-Moreno, J.C., Medina, J.: Fuzzy concept lattices and fuzzy relation equations in the retrieval processing of images and signals. Int. J. Uncertain. Fuzziness Knowl.-Based Syst. 25(Suppl. 1), 99–120 (2017) 2. Aliannezhadi, S., Abbasi Molai, A.: A new algorithm for geometric optimization with a single-term exponent constrained by bipolar fuzzy relation equations. Iran. J. Fuzzy Syst. 18(1), 137–150 (2021) 3. Chen, J., Mi, J., Lin, Y.: A graph approach for knowledge reduction in formal contexts. Knowl.-Based Syst. 148, 177–188 (2018) 4. Cornejo, M.E., D´ıaz-Moreno, J.C., Medina, J.: Multi-adjoint relation equations: a decision support system for fuzzy logic. Int. J. Intell. Syst. 32(8), 778–800 (2017) 5. Cornejo, M.E., Lobo, D., Medina, J.: On the solvability of bipolar max-product fuzzy relation equations with the standard negation. Fuzzy Sets Syst. 410, 1–18 (2021) 6. Cornejo, M.E., Lobo, D., Medina, J., De Baets, B.: Bipolar equations on complete distributive symmetric residuated lattices: the case of a join-irreducible right-hand side. Fuzzy Sets Syst. 442, 92–108 (2022) 7. Cornejo, M.E., Medina, J., Ram´ırez-Poussa, E.: A comparative study of adjoint triples. Fuzzy Sets Syst. 211, 1–14 (2013) 8. Cornejo, M.E., Medina, J., Ram´ırez-Poussa, E.: Characterizing reducts in multiadjoint concept lattices. Inf. Sci. 422, 364–376 (2018)  
   
  16  
   
  D. Lobo et al.  
   
  9. Cornejo, M.E., Medina, J., Ram´ırez-Poussa, E.: Algebraic structure and characterization of adjoint triples. Fuzzy Sets Syst. 425, 117–139 (2021) 10. Cornelis, C., Medina, J., Verbiest, N.: Multi-adjoint fuzzy rough sets: deﬁnition, properties and attribute selection. Int. J. Approx. Reason. 55, 412–426 (2014) 11. De Baets, B.: Analytical solution methods for fuzzy relation equations. In: Dubois, D., Prade, H. (eds.) The Handbooks of Fuzzy Sets Series, vol. 1, pp. 291–340. Kluwer, Dordrecht (1999) 12. Di Nola, A., Sanchez, E., Pedrycz, W., Sessa, S.: Fuzzy Relation Equations and Their Applications to Knowledge Engineering. Kluwer Academic Publishers, Norwell (1989) 13. D´ıaz-Moreno, J.C., Medina, J.: Multi-adjoint relation equations: deﬁnition, properties and solutions using concept lattices. Inf. Sci. 253, 100–109 (2013) 14. D´ıaz-Moreno, J.C., Medina, J.: Solving systems of fuzzy relation equations by fuzzy property-oriented concepts. Inf. Sci. 222, 405–412 (2013) 15. D´ıaz-Moreno, J.C., Medina, J.: Using concept lattice theory to obtain the set of solutions of multi-adjoint relation equations. Inf. Sci. 266, 218–225 (2014) 16. D´ıaz-Moreno, J.C., Medina, J., Ojeda-Aciego, M.: On basic conditions to generate multi-adjoint concept lattices via Galois connections. Int. J. Gen. Syst. 43(2), 149– 161 (2014) 17. Gaume, B., Navarro, E., Prade, H.: A parallel between extended formal concept analysis and bipartite graphs analysis. In: H¨ ullermeier, E., Kruse, R., Hoﬀmann, F. (eds.) IPMU 2010. LNCS (LNAI), vol. 6178, pp. 270–280. Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-642-14049-5 28 18. Kuznetsov, S.O.: Machine learning and formal concept analysis. In: Eklund, P. (ed.) ICFCA 2004. LNCS (LNAI), vol. 2961, pp. 287–312. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-24651-0 25 19. Lobo, D., L´ opez-Marchante, V., Medina, J.: On the measure of unsolvability of fuzzy relation equations. Stud. Comput. Intell. (2023, in press) 20. Lobo, D., L´ opez-Marchante, V., Medina, J.: Reducing fuzzy relation equations via concept lattices. Fuzzy Sets Syst. (2023) 21. Maio, C.D., Fenza, G., Gallo, M., Loia, V., Stanzione, C.: Toward reliable machine learning with congruity: a quality measure based on formal concept analysis. Neural Comput. Appl. 35, 1899–1913 (2023) 22. Medina, J.: Multi-adjoint property-oriented and object-oriented concept lattices. Inf. Sci. 190, 95–106 (2012) 23. Medina, J., Ojeda-Aciego, M., Valverde, A., Vojt´ aˇs, P.: Towards biresiduated multiadjoint logic programming. In: Conejo, R., Urretavizcaya, M., P´erez-de-la-Cruz, J.L. (eds.) CAEPIA/TTIA -2003. LNCS (LNAI), vol. 3040, pp. 608–617. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-25945-9 60 24. Pedrycz, W.: Fuzzy relational equations with generalized connectives and their applications. Fuzzy Sets Syst. 10(1–3), 185–201 (1983) 25. Sanchez, E.: Resolution of composite fuzzy relation equations. Inf. Control 30(1), 38–48 (1976) 26. Shao, M., Hu, Z., Wu, W., Liu, H.: Graph neural networks induced by concept lattices for classiﬁcation. Int. J. Approx. Reason. 154, 262–276 (2023) 27. Turunen, E.: On generalized fuzzy relation equations: necessary and suﬃcient conditions for the existence of solutions. Acta Universitatis Carolinae. Mathematica et Physica 028(1), 33–37 (1987) 28. Valverde-Albacete, F., Pel´ aez-Moreno, C.: Leveraging formal concept analysis to improve n-fold validation in multilabel classiﬁcation. CEUR Workshop Proceedings, vol. 3151. CEUR-WS.org (2021)  
   
  Doubly-Lexical Order Supports Standardisation and Recursive Partitioning of Formal Context Tim Pattison(B) and Aryan Nataraja Defence Science and Technology Group, West Avenue, Edinburgh, SA 5111, Australia {tim.pattison,aryan.nataraja}@defence.gov.au  
   
  Abstract. Formal Concept Analysis (FCA) transforms a context bigraph, having vertices of type object and attribute, into a lattice digraph, whose vertices and arcs represent formal concepts and their covering relation. The computational complexity of most FCA algorithms is a polynomial function of the numbers of vertices in both the context bigraph and lattice digraph. While the latter quantity is ﬁxed, the former can be decreased by context standardisation, a process which we show is facilitated by the eﬃcient partition reﬁnement algorithm of Spinrad. The Carve algorithm recursively partitions the context bigraph and corresponding lattice digraph by removing universal objects and attributes and their orphans and partitioning the resultant sub-context into its connected components. The associated software prototype uses the resultant tree structure to support coordinated browsing of both. This paper describes an additional, coordinated representation of the context bigraph which makes explicit in its bi-adjacency matrix the pattern of nested sub-contexts discovered by the Carve algorithm. We show that permuting this matrix into doubly-lexical order with the aid of Spinrad’s algorithm groups together into nested rectangles the bigraph edges belonging to these sub-contexts, and facilitates the two key processing steps of the Carve algorithm.  
   
  1  
   
  Introduction  
   
  The Carve algorithm and associated software prototype [7–9] recursively partition the context bigraph and corresponding lattice digraph of amenable [9] formal contexts, and use the resultant tree structure to support coordinated browsing of both. Each vertex in the tree corresponds to a sub-context bigraph and its associated lattice digraph, and hence also to a container in an inclusion tree layout of either graph [7,9]. Instead of automating the former inclusion tree layout for the current sub-context, however, the Carve software prototype presents an unconstrained drawing of the bigraph. This paper describes an additional, coordinated representation of the sub-context bigraph which makes explicit in its bi-adjacency matrix the pattern of nested sub-contexts discovered by Carve. This representation is a permutation of the rows and columns of the bi-adjacency c Commonwealth of Australia 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 17–32, 2023. https://doi.org/10.1007/978-3-031-35949-1 2  
   
  18  
   
  T. Pattison and A. Nataraja  
   
  matrix into jointly reverse lectic (JRL) order, which reverses the doubly-lexical order [4,10]. We show that the JRL order groups together into nested rectangles the bigraph edges belonging to the nested sub-contexts identiﬁed by the Carve algorithm. The process of eﬃciently calculating suitable row and column permutations has the beneﬁcial side-eﬀect that clariﬁcation and reduction of both objects and attributes become both simpler and more computationally eﬃcient. Clariﬁcation and reduction – which are collectively referred to as context standardisation – reduce the size of a formal context without aﬀecting the structure of the resultant concept lattice and, along with the reduced labelling scheme, diminish visual clutter when drawing the lattice directed acyclic graph (DAG). Standardising the formal context also avoids redundant computation on equivalent or derivative objects and attributes when enumerating the formal concepts of Carve-indivisible sub-contexts. The Maxmod-Partition algorithm [1] uses partition reﬁnement to partition the attributes of a formal context into equivalence classes known as maxmods. The attributes in a given maxmod have the same extents, and therefore appear as attribute labels on the same formal concept. Attribute clariﬁcation of the formal context involves choosing one attribute from each maxmod as its examplar, and removing any remaining attributes. Berry et al. [2] used the Maxmod-Partition algorithm to prepare a formal context for attribute clariﬁcation. We show that the Maxmod-Partition algorithm [1] produces a reverse lectic order of the attributes with respect to the prescribed order in which the objects were processed. This reverse lectic order is consistent with the partial order of attribute extents by set inclusion, such that an attribute precedes any others whose attribute extents are subsets. Reverse lectic order localises the computation of attribute closures by excluding subsequent columns of the context bi-adjacency matrix, thereby expediting computation of the arrow relations in preparation for attribute reduction of the formal context, and facilitates onthe-ﬂy context reduction by ensuring correctness of the computed closures with respect to the attribute-reduced context. The Maxmod-Partition algorithm [1] is readily adapted to ﬁnd object equivalence classes in preparation for object clariﬁcation of the context, and to produce a reverse lectic order of objects in preparation for object reduction. The reverse lectic orders of attributes and objects obtained by separate application of Maxmod-Partition do not in general result in a jointly reverse lectic order of the context bi-adjacency matrix, even if partitioning of the objects is based on a reverse lectic order of the attributes and vice versa. Empirical observations suggest, however, that iterated alternation of Maxmod-Partition over attributes and objects eventually converges to a jointly reverse lectic order. Alternatively, Spinrad’s algorithm [10] eﬃciently permutes the rows and columns of a binary matrix into doubly-lexical order, with complexity linear in the number of possible edges in the context bigraph [10]. The rows and columns of a matrix in doubly-lexical order can be permuted into jointly reverse lectic (JRL) order simply by reversing both the row and column orders. The partition reﬁnement approach used by Spinrad’s algorithm simultaneously identiﬁes the attribute  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  19  
   
  and object equivalence classes needed for context clariﬁcation, as well as the reverse lectic orders of both the objects and attributes which facilitate context reduction. The Carve algorithm recursively removes fully-connected (“universal”) objects and attributes and their orphaned neighbours and partitions the resultant sub-context into its connected components. We show that permuting the context bi-adjacency matrix into JRL order would facilitate these steps, and that JRL order would be preserved throughout the sub-contexts identiﬁed by the Carve algorithm. For a clariﬁed context in particular, only the ﬁrst row of the bi-adjacency matrix need be tested for a universal object, and if one is identiﬁed, only the last column need be tested for an attribute orphaned by its removal. Similarly, only the ﬁrst column and conditionally the last row need be tested in relation to a universal attribute. A breadth-ﬁrst search for connected components could then be commenced from the edge at top left in the sub-context bi-adjacency matrix obtained by removing any universals and their orphans, and, after halting to remove the identiﬁed connected component from the sub-context bi-adjacency matrix, resumed from the top left of any remainder. This procedure should be iterated until there is no remainder, producing the sub-contexts in JRL order for subsequent analysis. In particular, the top-left to bottom-right order of the nested containers in the bi-adjacency matrix would then correspond to the left to right order of containers in the Carve view of the lattice digraph.  
   
  2  
   
  Jointly Reverse Lectic Order  
   
  2.1  
   
  Lectic and Reverse Lectic Orders  
   
  Let the numbers 1, 2, .., n represent the ordinal positions of the members of an arbitrary ordered set, and let \ denote set diﬀerence. For notational convenience, the lectic or lexical order over subsets of this set can be deﬁned in terms of these ordinal positions as follows [5]. Definition 1. Let X , Y ⊆ {1, 2, .., n}. Then X < Y if there exists i ∈ Y \ X such that X ∩ {1, 2, .., i − 1} = Y ∩ {1, 2, .., i − 1} Given some total order on the objects [attributes]1 of a formal context, two attribute extents [object intents] are in lectic order if and only if – henceforth iﬀ – the ﬁrst object [attribute] by which they diﬀer belongs to the second attribute extent [object intent]. The lectic order over attribute extents [object intents] induces a total order over the attributes [objects]. Thus a prescribed total order over the objects [attributes] induces a lectic order over the attribute extents [object intents], which in turn induces a total “lectic” order over the attributes [objects]. The lectic order is unique up to attribute [object] equivalence. Since X ⊆ Y ⇒ X ≤ Y [5], lectic ordering of the attribute extents [object intents] constrains the search for sets X ⊆ Y to sets X ≤ Y. This observation 1  
   
  The truth of a sentence containing terms in square brackets is unchanged by substituting these terms for those which precede them.  
   
  20  
   
  T. Pattison and A. Nataraja M  
   
  ∩1  
   
  a b c d e f g h 1 ×××× 2××× ×× 3×× ××× 4 ×× 5 ×× 6× × (a) Bi-adjacency matrix  
   
  \1  
   
  {b, c, d, e}  
   
  {a, f, g, h}  
   
  \2  
   
  ∩2 {b, c}  
   
  ∩3  
   
  {b}  
   
  {d, e}  
   
  \3  
   
  {c}  
   
  ∩5  
   
  {d}  
   
  \2  
   
  ∩2 {a, g, h}  
   
  \5  
   
  {e}  
   
  ∩6  
   
  {a, h}  
   
  \6  
   
  {f }  
   
  {g}  
   
  (b) Partition tree  
   
  Fig. 1. Bi-adjacency matrix and attribute partition tree for context from [1].  
   
  has computational beneﬁts for computing the arrow relations [6] in preparation for context reduction, as well as enumerating and transitively reducing the partial order between formal concepts. To this end, we reverse the lectic order, so that the lowest-ordered object [attribute] over whose membership two attribute extents [object intents] diﬀer belongs to the set which precedes the other in the reverse lectic order. Since a set succeeds all of its supersets in the reverse lectic order, processing extents [intents] in reverse lectic order ensures that the extents of all super-concepts [intents of all sub-concepts] of a concept of interest are processed before it. 2.2  
   
  Maxmod-Partition and Reverse Lectic Order  
   
  The Maxmod-Partition algorithm for attribute clariﬁcation of a formal context produces a total order < on the discovered attribute equivalence classes, and hence also on their exemplar attributes. Its iterated comparison of the next object intent with each part of the evolving attribute partition, and replacement of the latter with the intersection and remainder sets whenever both are non-empty, can be described by an ordered binary partition tree. Each left branch of this tree corresponds to an intersection, each right branch to a remainder, each non-leaf node to a part of an intermediate partition which has been subsequently reﬁned, and each leaf node to an attribute equivalence class. The resultant ordered partition of the attribute set into equivalence classes is reﬂected in the left-right order of the corresponding leaf nodes. Figure 1a shows the partition tree for the example context in Fig. 1b. Each binary entry of the context bi-adjacency matrix is conventionally represented as either “×” for 1 or “ ” for 0. Proposition 1. Let x, y ∈ M belong to diﬀerent attribute equivalence classes for a formal context (G, M, I). Then x < y if and only if the corresponding leaf nodes  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  21  
   
  of the partition tree have a least common ancestor and lie respectively on the left and right branches of the sub-tree rooted at that ancestor. Proposition 2. Maxmod-Partition produces a reverse lectic order on the attribute extents with respect to the prescribed total order on objects. Proof. The object intents are processed according to the prescribed total order on objects. Let x, y ∈ M belong to diﬀerent attribute equivalence classes. Then the object whose intent split their least common ancestor is the ﬁrst object in the prescribed order by which their attribute extents diﬀer. Without explicitly identifying this order as reverse lectic, Berry et al. [1] observed that an equivalence class can only dominate those which precede it. Definition 2. Attribute m dominates attribute μ if m ⊂ μ . Here, m ⊆ G denotes the extent of attribute m ∈ M , which is the set of objects adjacent to m in the context bigraph. We saw in Sect. 2.1 that their observation is a consequence of the reverse lectic order. 2.3  
   
  Doubly-Lexical Order  
   
  Definition 3. A context bi-adjacency matrix is in doubly-lexical order (DLO) [4, 10] if the objects (rows) are in lectic order with respect to the reverse order of the attributes (columns) and vice versa. Since a visualisation of the context bi-adjacency matrix which requires the user to mentally reverse the row and column orders would be cognitively demanding, we prefer to instead retain the row and column orders and deﬁne the jointly reverse lectic order accordingly as follows. 2.4  
   
  Jointly Reverse Lectic Order  
   
  Definition 4. A context bi-adjacency matrix is in jointly reverse lectic (JRL) order if the objects (rows) are in reverse lectic order with respect to the order of the attributes (columns) and vice versa. Example 1. The tables in Figs. 2a and 2b show the bi-adjacency matrix of the example formal context from [7] in JRL and doubly-lexical order, respectively. Proposition 3. A context bi-adjacency matrix in DLO can be permuted into JRL order by reversing the rows and columns. Proposition 4. The JRL order, and hence also the DLO, is not in general unique. The table in Fig. 3a illustrates Proposition 4 by providing an alternative JRL ordering of the context bi-adjacency matrix in Fig. 2b. The cells in the pink, lightblue and green rectangles are encountered in top-left to bottom-right order in Fig. 3a, whereas the contents of the light-blue rectangle are at bottom right in Fig. 2b. Similarly, the salmon rectangle occurs before the grey rectangle within the pink rectangle of Fig. 3a, whereas the contents of the former occur after those of the latter in Fig. 2b.  
   
  22  
   
  T. Pattison and A. Nataraja (a) Doubly-lexical order  
   
  (b) JRL order  
   
  LKDCABE F J I HG  
   
  GH I J F EBACDKL  
   
  7 × 3 ×× 4 × 2 × 11 ×× 9 ×××× 10 × 5 × × 12 ×× × 6 ×× × 1 ×× 8 ×××  
   
  8 1 6 12 5 10 9 11 2 4 3 7  
   
  ××× ×× × ×× × ×× × × ×  
   
  ×××× ×× × ×  
   
  ×× ×  
   
  Fig. 2. Bi-adjacency matrix for context from [7] in doubly lexical and corresponding jointly reverse lectic orders.  
   
  12 5 8 1 6 10 3 7 9 11 2 4  
   
  G F E H I J K L B A C D × × × × × × × × × × × × × × × × × × × × × × × × × (a) Bi-adjacency matrix  
   
  G  
   
  K 7  
   
  10 F  
   
  H  
   
  5  
   
  B  
   
  8  
   
  4  
   
  A 11 J  
   
  12  
   
  2  
   
  I 1  
   
  E  
   
  C  
   
  6  
   
  L 3  
   
  D 9  
   
  (b) Lattice digraph  
   
  Fig. 3. Bi-adjacency matrix and lattice digraph for example formal context from [7]. Biadjacency matrix is in JRL order with cells colour-coded according to the inner-most corresponding Carve container in the lattice digraph (Color ﬁgure online).  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  2.5  
   
  23  
   
  JRL Order and Carve  
   
  Figure 3 illustrates that the nested containers in the inclusion layout of the lattice digraph in Fig. 3b are echoed as nested rectangles in the JRL-ordered biadjacency matrix. Each rectangle corresponds to a Carve sub-context and contains the matrix entries corresponding to the internal edges of its bigraph. The leftto-right ordering of the containers in the lattice digraph corresponds to their topleft to bottom-right ordering in the JRL-ordered bi-adjacency matrix. Thus for this example, at least, permuting the bi-adjacency matrix of the context bigraph into JRL order groups together in contiguous and nested rectangles the edges between elements in the same Carve sub-context. This anecdotal observation is formalised and generalised in Sect. 3. A universal element of a context bigraph is one which is adjacent to all elements of the opposite type, and an element isolated by the removal of a universal element is referred to as its orphan. If a clariﬁed formal context has a universal attribute [object] it must be ﬁrst in the reverse lectic order, and its orphan object [attribute], if any, must be last. An element might only be “universal” with respect to its subcontext. For example, the pink sub-context of Fig. 3a has “universal” attribute G at left and orphan object 10 at bottom. Similarly, the green sub-context has “universal” object 9 at top and orphan attribute D at right. It is easily veriﬁed using Fig. 3a that removing these universals and their orphans from their respective subcontexts leaves the remainder of each sub-context in JRL order, and with one or more connected components which are Carve sub-contexts.  
   
  3 3.1  
   
  Carve Identifies Nested Blocks in JRL-Ordered Matrix Connected Components are Blocks  
   
  In this section, we show that permuting the bi-adjacency matrix into JRL order groups together in rectangles or “blocks” on the diagonal the objects and attributes belonging to each connected component of the context bigraph. We further describe a breadth-ﬁrst search of the bigraph edges which identiﬁes these blocks in the top-left to bottom-right order in which they appear in the JRL-ordered biadjacency matrix. Let the context bi-adjacency matrix I be in JRL order, and label the rows so ordered with integers 1, 2, . . . |G| and the columns so ordered with letters A, B, . . .. Lemma 1. If I(1, A) = 0, then the context bigraph contains only isolated vertices. Proof. If I(1, A) = 0, then the ﬁrst row of I must contain only zeros, since otherwise there is an attribute which belongs before A in the reverse lectic order of attributes. Similarly, the ﬁrst column contains only zeros. The ﬁrst column j > A in any row i > 1 to contain a one would place row i before row 1 in the reverse lectic order, thereby contradicting the premise that I is in JRL order. Thus I(i, j) = 0 for all pairs (i, j).  
   
  24  
   
  T. Pattison and A. Nataraja  
   
  Since a formal context consisting only of isolated vertices is fundamentally uninteresting, we henceforth safely assume that I(1, A) = 1, and hence also that object 1 is adjacent to attribute A. Consider now a breadth-ﬁrst search (BFS) of the context bigraph edges – or equivalently the vertices of the corresponding line graph – starting at edge (1, A). Depth 1 of this search discovers edges adjacent to edge (1, A) – i.e. those adjacent to object 1 or attribute A – while excluding the edge (1, A) “discovered” at depth 0. Depth 2 of this search discovers edges which are adjacent to those, but which were not discovered at depths 0 or 1, and so on. A vertex is said to be discovered at depth k of this search if it is adjacent to an edge discovered at depth k and is not adjacent to any previously-discovered edge. To derive an expression for the set of vertices discovered at depth k, we deﬁne N : P(G ∪ M ) → P(G ∪ M ) to map a set X of vertices to the union ∪x∈X x of their neighbours in the context bigraph, and denote by N k = N ◦ N k−1 the kfold composition of this neighbourhood function. Here N 0 is the identity function, and N (∅) = ∅. Note that since N ({A}) ⊇ {1}, N k ({A}) = N k−1 ◦ N ({A}) ⊇ N k−1 ({1}) for k ≥ 1 and similarly N k ({1}) ⊇ N k−1 ({A}). For odd k     N k ({A}) = N k ({A}) \ N k−1 ({1}) ∪ N k−1 ({1}) \ N k−2 ({A}) . . . ∪ {1}     N k ({1}) = N k ({1}) \ N k−1 ({A}) ∪ N k−1 ({A}) \ N k−2 ({1}) . . . ∪ {A} and for even k     N k ({A}) = N k ({A}) \ N k−1 ({1}) ∪ N k−1 ({1}) \ N k−2 ({A}) . . . ∪ {A}     N k ({1}) = N k ({1}) \ N k−1 ({A}) ∪ N k−1 ({A}) \ N k−2 ({1}) . . . ∪ {1} The attribute and object sets discovered at depth 1 of the edge-based BFS are N ({1}) \ {A} and N ({A}) \ {1}, respectively. At depth 2 they are N 2 ({A}) \ N ({1}) and N 2 ({1}) \ N ({A}), which, since attribute set N ({1}) = (N ({1}) \ {A}) ∪ {A} and object set N ({A}) = (N ({A}) \ {1}) ∪ {1}, exclude vertices of the same type discovered at depths 1 and 0. Similarly at depth 3, attribute and object sets N 3 ({1}) \ N 2 ({A}) and N 3 ({A}) \ N 2 ({1}) respectively are discovered, with the second part of each expression excluding not only vertices of the same type discovered at depth 2, but also those at depths 1 and 0. Thus, for example, the set of objects discovered at odd depth k is   k−1  k k−1 k N N ({A}) \ N ({1}) = N ({A}) \ ({1}) \ N k−2 ({A})    k−2 k−3 ({A}) \ N ({1}) . . . ∪ {1} ∪ N The ﬁrst excluded set on the right-hand side can be recognised as the union of the sets of objects discovered at depths k − 1, k − 2 . . . 0. Similar results apply for even depths, and for attributes at even or odd depths. Proposition 5. A breadth-ﬁrst search (BFS) of the edges of a context bigraph terminates when all and only objects and attributes in the connected component of the context bigraph containing the initial edge have been discovered.  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  25  
   
  The order in which vertices are discovered during an edge-based BFS of the context bigraph starting at edge (1, A) is related to the JRL order of the context bi-adjacency matrix as follows. Theorem 1. Let the bi-adjacency matrix of a formal context be in JRL order. For odd k, the attributes in N k ({1})\N k−1 ({A}) are ordered after those in N k−1 ({A}) and before those in M \ N k ({1}), and the objects in N k ({A}) \ N k−1 ({1}) are ordered after those in N k−1 ({1}) but before those in G \ N k ({A}). For even k, the attributes in N k ({A}) \ N k−1 ({1}) are ordered after those in N k−1 ({1}) but before those in M \ N k ({A}), and the objects in N k ({1}) \ N k−1 ({A}) are ordered after those in N k−1 ({A}) and before those in G \ N k ({1}). Proof. To prove Theorem 1 by induction on k, we ﬁrst prove the case k = 1. Object 1 and attribute A are by deﬁnition ﬁrst in their respective reverse lectic orders. Object 1 must be followed immediately by the remaining set of objects which have a one in their ﬁrst column, and hence which are neighbours of attribute A, and then by the remaining objects – viz. those which are not neighbours of A. Similarly, attribute A is followed by the remaining neighbours of object 1 and thereafter by those attributes which are not. We now show that if Theorem 1 holds for some k ≥ 1, then it also holds for k + 1. In particular, we prove this for attributes in the case of even k; proofs for the remaining three parameter combinations are analagous. By our premise, the attributes are partitioned into three successive parts in the JRL order – viz. N k−1 ({1}), N k ({A}) \ N k−1 ({1}) and M \ N k ({A}). The union of the ﬁrst two parts constitutes the ﬁrst part for the case k + 1, while the third is partitioned into N k+1 ({1}) \ N k ({A}) and M \ N k+1 ({1}). Since the ﬁrst two parts precede the third in the JRL order for case k, their union must precede its parts for case k + 1. It remains to prove that part M \ N k+1 ({1}) follows part N k+1 ({1}) \ N k ({A}) in the JRL order. By our premise, the objects are similarly partitioned into three successive parts in the JRL order – viz. N k−1 ({A}), N k ({1}) \ N k−1 ({A}) and M \ N k ({1}). Whereas each attribute in N k ({A}) = N ◦ N k−1 ({A}) is a neighbour of at least one object in N k−1 ({A}), the columns corresponding to those in M \ N k ({A}) must have leading zeros in the rows corresponding to the objects in N k−1 ({A}). Thus, the block of the bi-adjacency matrix corresponding to the ﬁrst row part and the last column part for case k must contain only zeros. Each attribute in N k+1 ({1}) \ N k ({A}) is a neighbour of at least one object in N k ({1}) \ N k−1 ({A}). Thus each column in N k+1 ({1}) \ N k ({A}) has a 1 in at least one row of the second row part of case k, and hence in the ﬁrst row part for case k + 1. In contrast, no attribute in M \ N k+1 ({1}) is a neighbour of any object in the ﬁrst row part N k ({1}) for case k + 1. Accordingly, the leading ones in the columns of N k+1 ({1}) \ N k ({A}) occur earlier in the JRL order of rows than those of M \ N k+1 ({1}), and hence column part N k+1 ({1}) \ N k ({A}) precedes column part M \ N k+1 ({1}) in the JRL order.  
   
  26  
   
  T. Pattison and A. Nataraja  
   
  Corollary 1. The objects and attributes discovered by a BFS from edge (1, A) precede the remainder in the JRL order, and hence form a block of contiguous rows and columns at the top left of the context bi-adjacency matrix. Lemma 2. The JRL order of this block is preserved by its removal from the JRLordered bi-adjacency matrix. Proof. Since no vertex in the connected component is adjacent to one which is not, any two vertices within the component can only diﬀer with respect to their adjacency to other vertices in the component. Lemma 3. Removal of the initial connected component from the JRL-ordered context bi-adjacency matrix leaves what remains of the latter in JRL order. Proof. The remaining objects and attributes had no neighbours in the removed component, and hence their relative lectic order remains entirely dependent on their adjacency or otherwise to the remaining elements. Lemma 4. Permuting the bi-adjacency matrix I into JRL order groups together in contiguous blocks on the diagonal the objects and attributes belonging to each connected component of the context bigraph which contains at least one object and one attribute. Proof. Iterative application of Lemma 1, Corollary 1 and Lemma 3 ensures that for a context bigraph having multiple connected components, its JRL-ordered biadjacency matrix consists of one block on the diagonal per non-trivial connected component. Each isolated vertex of the formal context is a trivial “connected” component, for which the corresponding row or column is ordered after those for all non-trivial connected components. If a formal context contains both isolated attributes and isolated objects, then these can be collectively viewed as a zero block which occurs last on the diagonal of I. If the only isolates are attributes, say, then the last block on the “diagonal” will end on the bottom row but to the left of the right-most column. If the context is clariﬁed, then there is at most one isolate of each type. Corollary 2. A formal context whose bi-adjacency matrix is in JRL order can be partitioned into its connected components using a BFS of its edges which starts at (1, A) and iteratively restarts at the top left entry of the bi-adjacency matrix of any remaining sub-context. When the search halts, the identiﬁed block of the bi-adjacency matrix is removed, and the BFS restarted at the top left element of the bi-adjacency matrix of any remaining sub-context. This procedure is iterated until no edges of the context bigraph remain undiscovered, in which case any remaining objects or attributes are isolates. Termination of the search can happen in any of four ways: both attributes and objects remain to be discovered but the top left element of the remaining subcontext is zero; or some objects and no attributes remain to be discovered; or some attributes and no objects remain to be discovered; or neither attributes nor objects remain to be discovered. A more conventional BFS of the vertices – vice edges – of the sub-context starting at either object 1 or attribute A is suﬃcient to identify the connected components in their JRL order.  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  3.2  
   
  27  
   
  Blocks are Nested  
   
  The Carve algorithm recursively alternates between removing universals and their orphans and partitioning the resultant sub-context into its connected components. In this section, we show that it preserves clariﬁcation of the identiﬁed sub-contexts and the JRL order of their bi-adjacency matrices. When combined with Lemma 4, the latter result ensures that the connected components of the subcontext are contiguous blocks nested within that of the parent (sub-)context. We further show that both clariﬁcation and the JRL order aﬀord eﬃciencies in the implementation of Carve by signiﬁcantly constraining which elements are candidates for universals, their orphans or isolates. Proposition 6. Removal by Carve of any universal attributes and objects, along with any objects and attributes orphaned by their removal, does not aﬀect the JRL of the bi-adjacency matrix of the remaining sub-context. Proof. Following the removal of any universal attributes, any diﬀerence between the objects continues to depend only on the remaining attributes. If the universal attributes had orphan objects, then any diﬀerence between the remaining attributes continues to depend only on the remaining objects. The same argument applies for universal objects and orphan attributes. Only at the outermost level of the recursive Carve algorithm, failure of the test for universal objects [attributes] is followed by a test for, and removal of any, isolated attributes [objects]. Since none of the objects [attributes] diﬀer regarding their adjacency to an isolated attribute [object], any diﬀerence between them continues to depend only on the remaining attributes [objects]. Thus the JRL order remains unaﬀected. Lemma 5. The Carve algorithm preserves the JRL order of the sub-context biadjacency matrices. Proof. Proposition 6 and the ensuing discussion demonstrates that removal by the Carve algorithm of universals and their orphans, and, at the outermost level, any isolates, does not aﬀect the JRL order of what remains of the context bi-adjacency matrix. Lemmas 2 and 3 establish that partitioning the remaining context into its connected components preserves the JRL order of the bi-adjacency matrices for those sub-contexts. Theorem 2. The connected components of the sub-context are contiguous blocks nested within that of the parent (sub-)context. Proof. This is a consequence of Lemmas 5 and 4. The ordered partitions of the objects and attributes computed by Spinrad’s algorithm [10] not only facilitate permutation of the context bi-adjacency matrix into JRL order, but also clariﬁcation of the context using the identiﬁed equivalence classes.  
   
  28  
   
  T. Pattison and A. Nataraja  
   
  Proposition 7. In a clariﬁed formal context whose bi-adjacency matrix is in JRL order, only the ﬁrst object and attribute need be tested for universality, and only the last object and attribute need be (conditionally) tested for isolates or the orphans of universals. Proposition 8. The Carve algorithm preserves sub-context clariﬁcation. Proof. Consider two objects in a clariﬁed context which are neither universals, their orphans nor isolates, and hence which survive the removal of such objects. By our premise that the context is clariﬁed, their intents must diﬀer. Since they do not diﬀer with respect to the membership of any universal, orphaned or isolated attributes, however, they continue to diﬀer after removal of those attributes. These object intents also continue to diﬀer after the resultant context bigraph is partitioned into its connected components, since this process neither adds nor removes neighbours. Lemma 5 and Proposition 8 ensure that the shortcut in Proposition 7, which applies prior to recursion of the Carve algorithm, continues to apply at all levels of the recursion.  
   
  4  
   
  Coordinated Browsing  
   
  The nested containers discovered by Carve in the context bigraph correspond to nested containers in the lattice digraph. We have seen that the former containers also correspond to nested, contiguous blocks in the JRL-ordered context biadjacency matrix. A visualisation of the bi-adjacency matrix can be coordinated with these other views using the tree discovered by Carve during its hierarchical decomposition of the context bigraph. As illustrated in Fig. 3a, each block can serve as a container whose appearance, including colour, should be chosen to emphasise its correspondence with its counterpart in the lattice digraph. The edge-based BFS described in Sect. 3.1 further ensures that as per Fig. 3, the top-left to bottom-right ordering of blocks consistently corresponds to the left-right order of the containers in the lattice digraph. Basing each of the coordinated views on the standardised context reduces visual clutter by reducing the number of visual elements which must be displayed. Nevertheless, the user should also be given the option to switch between the standardised and original contexts, with the latter requiring timely restoration of the removed elements, if any, to each of the views. Visualisation of the JRL-ordered matrix improves on the containerised variant of a two-layered drawing of the context bigraph depicted in [9, Figure 5]. Edge crossings in the latter compromise its intelligibility for larger graphs. Without elision, a matrix view comfortably scales to sub-contexts having 100 or so objects and attributes. For larger contexts, eliding the content of subordinate containers may be necessary for the outermost containers, and the legibility of row and column labels will require careful attention.  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning  
   
  5  
   
  29  
   
  Context Standardisation and Restoration  
   
  Spinrad’s algorithm [10] identiﬁes the object and attribute equivalence classes required for context clariﬁcation and facilitates permutation of the context biadjacency matrix into JRL order. Clariﬁcation chooses from each of the identiﬁed equivalence classes an exemplar, and deletes the remaining elements from the formal context. Those deleted elements can be restored to the intents and extents of the resultant concept lattice, and to the vertex labels of the corresponding lattice digraph, by substituting for each exemplar the corresponding equivalence class. As we saw in Sect. 2.1, reverse lectic orders of both the object intents and attribute extents also facilitates context reduction by ensuring that supersets occur earlier in the order than their subsets. As for clariﬁcation, reducible objects and attributes are removed from the context prior to enumeration of its formal concepts. Whereas the examplars serve as placeholders for the restoration of clariﬁed context elements, no such placeholders exist for reduced elements. Nevertheless, the closure of each such element in the reduced context can serve as both the ﬁngerprint and address of the lattice element to which it should be restored. In this section, we show how these closures can be calculated on the ﬂy during reduction of a clariﬁed context in JRL order, and stored for subsequent use in the restoration phase. We further show that JRL order is unaﬀected by the deletion of reducible context elements, and hence that the sequential application of object and attribute reduction, in either order, not only correctly reduces the context, but also preserves its JRL order.  
   
  Algorithm 1. Eﬃcient attribute reduction of formal context. Require: M is ordered set of attributes in reverse lectic order Require: M, I are attribute clariﬁed Ensure: Mr , Ir are attribute reduced and remain in reverse lectic order Ensure: H(m) ⊆ Mr is reduced intent of attribute concept for reduced m ∈ Mr 1: function Reduce-Attributes(M ,I) 2: Mr ← M 3: Ir ← I 4: for all m ∈ M do 5: Compute (m , m )  attributes μ : (μ , μ ) > (m , m ) 6: U ← m \ m  extent of meet of ancestor attribute concepts 7: K ← U 8: if K \ m == ∅ then 9: H(m) ← U  reduce 10: Mr ← Mr \ m  delete m’s column from context matrix 11: Ir ← Ir [·, Mr ] 12: end if 13: end for 14: return Mr , H, Ir 15: end function  
   
  30  
   
  T. Pattison and A. Nataraja  
   
  Based on computation of the arrow relations [6], Algorithm 1 illustrates the process for attribute reduction; its extension to object reduction is straightforward. The correctness of Algorithm 1 relies on the reverse lectic order of the attributes to ensure that any reducible attributes other than m which are in the closure m with respect to the un-reduced context have been removed from the context before attribute m is processed. Computation of the reduced closure m involves only attributes μ ≤ m in the reverse lectic order – since μ ⊇ m ⇒ μ ≤ m – and objects g ∈ m . If the context were not clariﬁed, the equivalence class of attribute m should be excluded in line 6, rather than just m. Theorem 3. The JRL order of the context bi-adjacency matrix I is unaﬀected by the removal of a reducible element. Proof. We prove the case where reducible attribute m is deleted, along with the corresponding column of I, and leave as an exercise for the reader the case where the reducible element is an object. Deletion of m does not aﬀect the reverse lectic order of the remaining attributes because the object set and its total order are unchanged. Any pair of objects whose ordered intents, prior to the deletion, ﬁrst diﬀer by some attribute other than m, will remain in the correct relative order. Assume there exist g, γ ∈ G whose ordered intents g  and γ  agree on the membership of attributes μ < m, but disagree over the membership of the reducible attribute m ∈ (m \ m) . Without loss of generality let m ∈ g  =⇒ m ⊇ g  =⇒ m ⊆ g  = g  . Since the attributes in m \ m are amongst those μ < m on which γ  and g  agree, γ  ⊇ m \ m. Hence the object concept for γ has intent γ  = γ  ⊇ (m \ m) ⊇ {m}, which contradicts the premise that γ  disagrees with g  on the membership of m. Example 2. Figure 4 shows the example context from Fig. 1a after JRL ordering followed by clariﬁcation and reduction. The reverse lectic order of the attributes diﬀers from that discovered in Fig. 1b because the reverse lectic order on the objects diﬀers from the total order shown in Fig. 1a. Here, attribute a is chosen as the exemplar for the equivalence class {a, h} and attribute h is accordingly deleted. Reducible attribute g is then removed, and ﬂagged for restoration to the formal concept having intent H(g) = {a, b} in the standardised context. These attributes are to the left of g in the reverse lectic order of attributes. As expected, the JRL order is preserved by both clariﬁcation and reduction. Had the context included a reducible attribute i, say, adjacent only to object 2, then attribute g < i would have been removed by Algorithm 1 before i was processed, and hence excluded from its closure. Any Carve-indivisible sub-contexts of a standardised context are standardised. However, the Carve algorithm relies on identifying and removing any universal – and hence also reducible – elements and their orphans from intermediate subcontexts. While Proposition 6 ensures that JRL order is thereby maintained, we note in passing that the removal of any universal elements is also a special case of Theorem 3. Importantly, none of the results in Sect. 3 rely on the original context, or any intermediate sub-context, being reduced.  
   
  Doubly-Lexical Order Supports Context Standardisation and Partitioning a h b g c f d e  
   
  a b g c f d e  
   
  a b c f d e  
   
  2××××× 3×××× × 6×× 1 × × ×× 5 × × 4 ××  
   
  2×××× 3××× × 6× 1 × × ×× 5 × × 4 ××  
   
  2××× 3×× × 6× 1 ×× ×× 5 × × 4 ××  
   
  (a) Original  
   
  31  
   
  (c) Standardised  
   
  Fig. 4. JRL-ordered bi-adjacency matrix for original, clariﬁed and standardised context from [1].  
   
  6  
   
  Discussion  
   
  While both Spinrad’s algorithm [10] and Carve [9] hierarchically partition the objects and attributes of a formal context, only the latter contributes directly to transforming the context bigraph into the concept lattice digraph. Spinrad’s partition reﬁnement algorithm eﬃciently permutes the rows and columns of a binary matrix into doubly-lexical, and hence, trivially, jointly reverse lectic order. Its low computational complexity (O(|G||M |) [10]) is important because the context standardisation and Carve decomposition it facilitates are both means to the end of identifying any Carve-indivisible sub-contexts requiring analysis by a conventional FCA algorithm. Carve’s preservation of both JRL order and clariﬁcation further obviates repeated invocation of Spinrad’s algorithm. Brucker and Pr´ea [4] used doubly-lexical ordering (DLO) of the context biadjacency matrix to superimpose on it the cover relation for dismantlable concept lattices. A lattice L is said to be dismantlable if it has an element x which is doubly-irreducible – i.e. has at most one upper and at most one lower cover – and L\{x} is also dismantlable. The Carve decomposition [9] instead targets only the supremum and inﬁmum of the current sub-lattice, regardless of whether they are doubly-irreducible, and does not require L to be dismantlable. A concept lattice is dismantlable iﬀ the associated context bigraph is chordal-bipartite [3]. A bipartite graph is chordal bipartite iﬀ one can iteratively remove a bi-simplicial edge until no edge is left. An edge (x, y) is called bi-simplicial if N ({x})∪N ({y}) is a maximal biclique, and hence corresponds to a formal concept. Berry and Sigayret [3] used DLO of the bi-adjacency matrix to eﬃciently identify a bi-simplicial edge which, in a reduced context, corresponds to a doubly-irreducible lattice element. However, the need to reduce the context upon removal of the bi-simplicial edge makes iteration of this technique ineﬃcient when generating an elimination scheme for the doubly-irreducible elements of L [3]. Theorem 2 established that the JRL order groups together in nested blocks the objects and attributes belonging to each sub-context identiﬁed by the recursive Carve algorithm. Clariﬁcation and reduction of the formal context are facilitated by, and preserve, the JRL order, which can therefore be beneﬁcial even if  
   
  32  
   
  T. Pattison and A. Nataraja  
   
  the context is not amenable [9] to Carve. Similarly, the identiﬁcation of universals, their orphans and isolates is facilitated by, and preserves, the JRL order. A breadth-ﬁrst search of the edges of a JRL-ordered sub-context, commencing at edge (1, A), identiﬁes its ﬁrst connected component. Following removal of this component, each successive connected component is identiﬁed from the remaining subcontext by iteratively restarting the search at the edge, if any, between the object and attribute thereby promoted to ﬁrst in the JRL order. This procedure identiﬁes the Carve sub-contexts in the top-left to bottom-right order in which they appear in the bi-adjacency matrix, thereby facilitating correspondence with the left-to-right order of the containers in a drawing of the lattice digraph. A visualisation of the bi-adjacency matrix with its nested containers (Fig. 3a) has been proposed, which can be coordinated with that of the lattice digraph (Fig. 3b) using the decomposition tree discovered by Carve. In future work these results will be exploited through updates to the Carve prototype.  
   
  References 1. Berry, A., Bordat, J.P., Sigayret, A.: A local approach to concept generation. Ann. Math. Artif. Intell. (2007). https://doi.org/10.1007/s10472-007-9063-4 2. Berry, A., Gutierrez, A., Huchard, M., Napoli, A., Sigayret, A.: Hermes: a simple and eﬃcient algorithm for building the AOC-poset of a binary relation. Ann. Math. Artif. Intell. (2014). https://doi.org/10.1007/s10472-014-9418-6 3. Berry, A., Sigayret, A.: Dismantlable lattices in the mirror. In: Cellier, P., Distel, F., Ganter, B. (eds.) ICFCA 2013. LNCS (LNAI), vol. 7880, pp. 44–59. Springer, Heidelberg (2013). https://doi.org/10.1007/978-3-642-38317-5 3 4. Brucker, F., Pr´ea, P.: Totally balanced formal context representation. In: Baixeries, J., Sacarea, C., Ojeda-Aciego, M. (eds.) ICFCA 2015. LNCS (LNAI), vol. 9113, pp. 169–182. Springer, Cham (2015). https://doi.org/10.1007/978-3-319-19545-2 11 5. Ganter, B.: Two basic algorithms in concept analysis. In: ICFCA 2010, pp. 312–340 (2010). https://doi.org/10.1007/978-3-030-21462-3 6. Ganter, B., Wille, R.: Formal Concept Analysis. Springer, Heidelberg (1999). https://doi.org/10.1007/978-3-642-59830-2 7. Pattison, T., Weber, D., Ceglar, A.: Enhancing layout and interaction in formal concept analysis. In: IEEE Paciﬁc Visualization Symposium, pp. 248–252. IEEE (2014). https://doi.org/10.1109/PaciﬁcVis.2014.21 8. Pattison, T.: Interactive visualisation of formal concept lattices. In: Burton, J., Stapleton, G., Klein, K. (eds.) Joint Proceedings of 4th International Workshop Euler Diagrams and 1st International Workshop Graph Visualization in Practice, vol. 1244, pp. 78–89. CEUR-WS.org (2014) 9. Pattison, T., Ceglar, A., Weber, D.: Eﬃcient formal concept analysis through recursive context partitioning. In: Ignatov, D.I., Nourine, L. (eds.) Proceedings of 2018 International Conference CLA, Olomouc, Czech Republic, vol. 2123, pp. 219–230. CEUR-WS.org (2018) 10. Spinrad, J.P.: Doubly lexical ordering of dense 0–1 matrices. Inf. Process. Lett. 45(5), 229–235 (1993). https://doi.org/10.1016/0020-0190(93)90209-R  
   
  Graph-FCA Meets Pattern Structures Sébastien Ferré(B) Univ Rennes, CNRS, Inria, IRISA, 35000 Rennes, France [email protected]   
   
  Abstract. A number of extensions have been proposed for Formal Concept Analysis (FCA). Among them, Pattern Structures (PS) bring complex descriptions on objects, as an extension to sets of binary attributes; while Graph-FCA brings n-ary relationships between objects, as well as n-ary concepts. We here introduce a novel extension named GraphPS that combines the beneﬁts of PS and Graph-FCA. In conceptual terms, Graph-PS can be seen as the meet of PS and Graph-FCA, seen as sub-concepts of FCA. We demonstrate how it can be applied to RDFS graphs, handling hierarchies of classes and properties, and patterns on literals such as numbers and dates.  
   
  1  
   
  Introduction  
   
  Formal Concept Analysis (FCA) [17] has been applied to many diﬀerent tasks – such as information retrieval, recommendation, ontology engineering, or knowledge discovery – and in many application domains, e.g., social sciences, software engineering, bioinformatics or chemoinformatics, natural language processing [15]. The variety of those tasks and application domains early called for FCA extensions in order to handle complex data. Complex data includes non-binary attributes, concrete domains, heterogeneous data, uncertain data, and structured data. The earlier extensions enable to use complex descriptions of objects in place of sets of binary attributes. Three similar extensions have been introduced at almost the same time: Generalized Formal Concept Analysis [6], Logical Concept Analysis [12], and Pattern Structures [16]. They enable to describe objects with valued attributes, intervals over numbers and dates, convex polygons, partitions, sequence patterns, tree patterns, or labelled graph patterns [15]. Other extensions address the uncertainty of object descriptions [22], notably Fuzzy FCA [5] where the incidence between an object and an attribute is a truth degree in [0, 1] instead of a crisp Boolean value. Triadic Concept Analysis [21] adds conditions to the incidence between an object and an attribute, making the formal context a ternary relation instead of a binary relation. Polyadic Concept Analysis [24] generalizes this idea by allowing any number of dimensions for the context. Finally, a number of more recent extensions add relationships between S. Ferré—This research is supported by ANR project SmartFCA (ANR-21-CE23-0023). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. Dürrschnabel and D. López Rodríguez (Eds.): ICFCA 2023, LNAI 13934, pp. 33–48, 2023. https://doi.org/10.1007/978-3-031-35949-1_3  
   
  34  
   
  S. Ferré  
   
  objects, so that the concepts do not depend only on the individual descriptions of objects but also on relationship patterns over interconnected objects. Relational Concept Analysis [23] combines several classical FCA contexts and several binary relations to form concepts whose intents are similar to description logic class expressions [3], combining object attributes, binary relations, and quantiﬁer operators. Relational structures [19] and Graph-FCA [8] add n-ary relationships between objects (n ≥ 1), and form n-ary concepts, i.e. concepts whose intents are equivalent to conjunctive queries, and whose extents are equivalent to the results of such queries, i.e. sets of n-tuples of objects. In this paper, we propose to merge two FCA extensions that are representative of the ﬁrst and last categories above: Pattern Structures (PS) and GraphFCA. The aim is to combine the beneﬁts of the two categories of extensions, in short complex descriptions and relationships between objects. Logical Concept Analysis (LCA) could have been used in place of PS but we have chosen PS as it has been more widely adopted, and because it is better suited to the eﬀective computation of concepts. In this paper we choose to merge PS with Graph-FCA but it would be perfectly relevant to do so with Relational Concept Analysis (RCA). We hope this work will encourage and facilitate the merge with RCA in a future work. The merge results in a new FCA extension called Graph-PS. It is an elegant extension in the sense that PS is a special case of Graph-PS, obtained by not using inter-object relationships; and Graph-FCA is a special case of Graph-PS, obtained by using sets of binary attributes as descriptions of individual objects and inter-object relationships. As a consequence, classical FCA is also a special case of Graph-PS. It therefore acts as an unifying FCA theory encompassing classical FCA and two mainstream FCA extensions. The paper is structured as follows. Section 2 recalls the main deﬁnitions and results of Pattern Structures and Graph-FCA, as preliminaries. Section 3 deﬁnes Graph-PS as the extension of Graph-FCA with PS-like descriptions, and illustrates the diﬀerent notions with a running example combining binary relationships, valued attributes and intervals. Section 4 describes its application to RDFS graphs by deﬁning a custom set of descriptions and similarity operator. Section 5 concludes the paper, and draws some perspectives.  
   
  2  
   
  Preliminaries  
   
  In this section, we recall the main deﬁnitions of two extensions of Formal Concept Analysis (FCA): Pattern Structures (PS) [16] and Graph-FCA [11]. The former extends FCA attributes with complex descriptions and patterns. The latter extends FCA with n-ary relations between objects, and n-ary concepts. 2.1  
   
  Pattern Structures (PS)  
   
  A pattern structure is a triple K = (O, (D, ), δ) where O is a set of objects, (D, ) is a meet-semi-lattice of patterns, and δ ∈ O → D is a mapping taking each object to its description. The meet operator d1  d2 represents the similarity between two patterns d1 and d2 . It entails a partial ordering , called  
   
  Graph-FCA Meets Pattern Structures  
   
  35  
   
  subsumption, deﬁned for all patterns d1 , d2 ∈ D as d1  d2 ⇐⇒ d1  d2 = d1 . Conversely, the pattern d1  d2 is the most speciﬁc pattern, according to , that subsumes patterns d1 and d2 . The extension of a pattern d is deﬁned as the set of objects whose description contains the pattern1 . ext(d) := {o ∈ O | d  δ(o)},  
   
  for every d ∈ D  
   
  The intension of a set of objects X is deﬁned as the most speciﬁc pattern that subsumes the description of all objects in X, i.e. the similarity between all those descriptions.  int(X) := δ(o), for every X ⊆ O o∈X  
   
  The two derivation operators (ext, int) form a Galois connection between the two posets (2O , ⊆) and (D, ). A pattern concept of a pattern structure K = (O, (D, ), δ) is a pair (X, d) with X ⊆ O and d ∈ D such that X = ext(d) and d = int(X). The component X of a pattern concept (X, d) is called the extent, and the component d is called the intent. Pattern concepts are partially ordered by (X1 , d1 ) ≤ (X2 , d2 ) ⇔ X1 ⊆ X2 ⇔ d2  d1 . This partial ordering forms a complete lattice called the pattern concept lattice. Pattern structures were ﬁrst applied to labeled graphs [16,20], e.g. to discover frequent patterns in molecular structures. They were then applied to various types of descriptions: e.g., numbers and intervals [18], partitions for characterizing functional dependencies [4], RDF graphs [1]. Classical FCA is the special case of PS when D := 2A for a given set of attributes A, and the similarity between two sets of attributes is their intersection: () := (∩). 2.2  
   
  Graph-FCA  
   
  We ﬁrst need to introduce notations for tuples. Given a set X of elements, a k-tuple of elements is an ordered collection of k elements that is written (x1 , . . . , xk ). For the sake of concision, a tuple is often written as an overlined letter x, whose element at position i can be written x[i], or simply xi if there is no ambiguity. The set of all k-tuples over X is written X k . The set of all tuples  ∗ of any arity is written X = k≥0 X k . The latter includes the empty tuple () for arity 0. Graph-FCA extends a formal context into a graph context, deﬁned as a triple K = (O, A, I) where O is a set of objects, A is a set of attributes, and I ⊆ O∗ × A is an incidence relation between tuples of objects o ∈ O∗ and attributes a ∈ A. Objects are graph nodes, attributes are graph labels, and an incidence ((o1 , . . . , ok ), a) ∈ I – also written a(o1 , . . . , ok ) – is an ordered hyper-edge between nodes o1 , . . . , ok , labeled with a. 1  
   
  The original notation for the two PS derivation operators is (.) . We use the notations ext(.) and int(.) because they are more explicit and also consistent with notations in other FCA extensions.  
   
  36  
   
  S. Ferré  
   
  A projected graph pattern of arity k (k-PGP) is a pair Q = (x, P ) where x = (x1 , . . . , xk ) ∈ V k is a tuple of k projected variables, and P ⊆ V ∗ ×A is a graph pattern. Variables are here graph nodes, and pattern elements ((y1 , . . . , yk ), a) – also written a(y1 , . . . , yk ) – are hyper-edges. The set of k-PGPs Qk is equipped, for each arity k, with a subsumption operator ⊆q and a similarity operator ∩q . The description of a tuple of objects o is the PGP Q(o) := (o, I), which uses objects as variables. The extension of a k-PGP Q is deﬁned as the set of k-tuples of objects whose description contains the PGP. ext(Q) := {o ∈ Ok | Q ⊆q Q(o)},  
   
  for every Q ∈ Qk  
   
  The intension of a set of k-tuples of objects R is deﬁned as the most speciﬁc PGP that subsumes the description of all tuples of objects in R, i.e. the PGPintersection of all those descriptions.  int(R) := Q(o), for every R ⊆ Ok o∈R  
   
  Those two derivation operators (ext, int) form a Galois connection between the k two posets (2O , ⊆) and (Qk , ⊆q ). A graph concept of a graph context K = (O, A, I) is a pair (R, Q) with R ⊆ Ok and Q ∈ Qk , for some arity k, such that R = ext(Q) and Q =q int(R). The component R of a graph concept (R, Q) is called the extent, and the component Q is called the intent. Graph concepts are partially ordered by (R1 , Q1 ) ≤ (R2 , Q2 ) ⇔ R1 ⊆ R2 ⇔ Q2 ⊆q Q1 . This partial ordering forms a complete lattice called the graph concept lattice. There is a distinct lattice for each arity. Graph-FCA has been applied to syntactic representations of texts, either for mining linguistic patterns [10] or for information extraction [2]. It has also been applied to knowledge graphs through the notion of concepts of neighbors for approximate query answering [9] and for link prediction [14]. Classical FCA is a special case of Graph-FCA when only 1-tuples (i.e., singletons) are used, for the incidence relation, the projected variables of PGPs, and hence for concepts. This implies that PGPs and concept intents have the shape ((x), ({a1 (x), . . . , ap (x)})), they use a single variable x, and hence they are equivalent to sets of attributes {a1 , . . . , ap }. Concept extents are then sets of singleton objects, which are equivalent to sets of objects.  
   
  3  
   
  Graph-PS: Extending Graph-FCA with Pattern Structures  
   
  For concision sake, we reuse the terms of Graph-FCA in Graph-PS as the graph structure remains, and only the description of nodes and edges are aﬀected by the extension. In the following, we ﬁrst deﬁne graph contexts as a common generalization of Graph-FCA contexts and pattern structures. Then, we deﬁne Projected Graph Patterns (PGP) and operations on them as they play the role of concept intents. Finally, we deﬁne graph concepts, their formation through a Galois connection, and their organization into a lattice.  
   
  Graph-FCA Meets Pattern Structures  
   
  3.1  
   
  37  
   
  Graph Context  
   
  Definition 1 (graph context). A graph context is a triple K = (O, (D, ), δ), where O is a set of objects, D is a meet-semi-lattice of descriptions, and δ ∈ O∗ → D is a mapping taking each tuple of objects to its description. The meet operator  on descriptions entails a smallest description ⊥ (called the empty description), and a partial ordering  (called subsumption), deﬁned for all descriptions c, d ∈ D as c  d ⇐⇒ c  d = c. Compared to Graph-FCA, each hyperedge is mapped to one description instead of to zero, one or several attributes. Graph-FCA is therefore equivalent to the special case of Graph-PS where descriptions are sets of attributes. An hyperedge that is mapped to the empty description is considered as a nonexistent relationship: δ((o1 , o2 )) = ⊥ means that there is no relation from o1 to o2 ; in other words, the pair (o1 , o2 ) is nothing more than a pair of objects. This can be paralleled with the blank cells ((o, a) ∈ I) in a classical formal context. Compared to PS, descriptions can not only be attached to objects but also to tuples of objects, which enables to express relationships between objects. Those relationships are taken into account, in addition to PS-like descriptions, when forming concepts. Concepts are sets of objects that have similar descriptions, and that also have similar relationships to objects that have similar descriptions, and so on. Example 1. As an example of graph context Kex , we extend an example from Graph-FCA about the British royal family, introducing taxonomic relationships between attributes, and numeric intervals. The objects are people belonging to three generations. Oex := {Charles, Diana, W illiam, Harry, Kate, George, Charlotte} They are respectively abbreviated as C, D, W, H, K, G, A. Objects (people) are described by a pair made of their gender and their birth year: δ(C) = man : 1948, δ(W ) = man : 1982,  
   
  δ(D) = woman : 1961, δ(K) = woman : 1982,  
   
  δ(G) = man : 2013,  
   
  δ(A) = woman : 2015.  
   
  δ(H) = man : 1984,  
   
  Pairs of objects are described whether the second is a parent of the ﬁrst, and with the rank among siblings. δ(W, C) = parent : 1  
   
  δ(H, C) = parent : 2  
   
  (same for D in place of C)  
   
  δ(G, W ) = parent : 1  
   
  δ(A, W ) = parent : 2  
   
  (same for K in place of W)  
   
  For instance, δ(W, C) = parent : 1 tells that William is the ﬁrst child of Charles. Any other tuple of objects has the empty description: δ(o) = ⊥. We want to take into account similarities between attributes and values. First, we deﬁne the similarity between genders, man  woman = person, saying that  
   
  38  
   
  S. Ferré  
   
  men and women have in common to be persons. Second, like in [18], we deﬁne the similarity between two numeric values as the smallest interval that contains the two values: e.g., 1  3 = [1, 3]. This extends to intervals by using the convex hull of two intervals, considering a value v as equivalent to the interval [v, v]. [u1 , v1 ]  [u2 , v2 ] = [min(u1 , u2 ), max(v1 , v2 )] However, to avoid intervals that are too large and hence meaningless, intervals [u, v] s.t. v − u >  are generalized into the symbol ∗ that represents the range of all possible values. The threshold  depends on the type of values:  = 20 for birth years so that similarity means “in the same generation”, and  = 1 for birth ranks. To summarize, the set of descriptions in our example is deﬁned as: Dex := {a : [u, v], a : ∗ | a ∈ {person, man, woman, parent}, u ≤ v ∈ Z} ∪ {⊥}, with a : v as a shorthand for a : [v, v], and ⊥ the empty description. The similarity operator d = d1  d2 is deﬁned as follows. If d1 = ⊥ or d2 = ⊥ then d = ⊥, otherwise, d1 = a1 : V1 and d2 = a2 : V2 . Then, if the attribute similarity a1  a2 is deﬁned as attribute a, then d = a : V where V = V1  V2 as deﬁned above with the  threshold depending on the attribute, else d = ⊥.   3.2  
   
  Projected Graph Patterns (PGP)  
   
  A graph pattern over a graph context shares the same structure as a graph context, with nodes and hyperedges labelled by descriptions, except that nodes are variables that range over the objects of the context. Definition 2 (graph pattern). Let K = (O, (D, ), δ) be a graph context. A graph pattern over K is a pair P = (V, δP ), where V ⊆ V is a ﬁnite set of variables (nodes), and δP ∈ V ∗ → D is a mapping taking each hyperedge to its description (hyperedge label). Compared to Graph-FCA, hyperedges are labelled by custom descriptions rather than by sets of attributes. An embedding of a graph pattern in a graph context is a mapping φ ∈ V → O from pattern variables to context objects such that for each hyperedge x, the pattern description of the edge subsumes the context description of the corresponding edge, i.e. δP (x)  δ(φ(x)). Example 2. Given the graph context in Example 1, we introduce the example graph pattern Pex = ({x, y}, δP ), where the description δP is deﬁned as follows: δP (x) = man : [1980, 1989],  
   
  δP (y) = person : ∗,  
   
  δP (x, y) = parent : [1, 2].  
   
  This description can be more concisely written as follows: δP = {x → man : [1980, 1989], y → person : ∗, (x, y) → parent : [1, 2]}. This pattern represents the situation where a man born in the eighties (x) is the ﬁrst or second child of some person with unconstrained birthdate (y). The pattern has four embeddings in the context, e.g. {x → Harry, y → Diana} because Harry is a man born in 1984, and is the second child of Diana, who is a woman and hence a person.    
   
  Graph-FCA Meets Pattern Structures  
   
  39  
   
  A Projected Graph Pattern (PGP) is a graph pattern with a tuple of distinguished variables, called projected variables. Definition 3 (PGP). A projected graph pattern (PGP) is a couple Q = (x, P ) where P = (V, δ) is a graph pattern, and x ∈ V ∗ , called projection tuple, is a tuple of variables from the pattern. |Q| = |x| denotes the arity of the PGP. We note Q the set of PGPs, and Qk the subset of k-PGPs, i.e. PGPs having arity k. A PGP can be seen as a SPARQL query SELECT x FROM { P }, whose answers are the embeddings of the pattern restricted to the projected variables. Example 3. The PGP Qex = ((x), Pex ) based on the graph pattern in Example 2 selects all men born in the eighties as the ﬁrst or second child of somebody. The answers over the example context are therefore Harry and William. The PGP   ((x, y), Pex ) would select pairs (child, parent), such as (Harry, Diana). In Graph-FCA and Graph-PS, PGPs play the role of descriptions in PS. We therefore have to deﬁne two key operations on them: inclusion ⊆q (aka. subsumption) and intersection ∩q (aka. similarity). In Graph-PS, their deﬁnitions depend on the corresponding operations on PS-like descriptions,  and . Definition 4 (PGP inclusion). Let K = (O, (D, ), δ) be a graph context. Let Q1 = (x1 , (V1 , δ1 )), Q2 = (x2 , (V2 , δ2 )) be two k-PGPs for some arity k. Q1 is included in Q2 , or equivalently Q2 contains Q1 , which is written Q1 ⊆q Q2 iﬀ ∃φ ∈ V1 → V2 : φ(x1 ) = x2 ∧ ∀y ∈ V1∗ : δ1 (y)  δ2 (φ(y)) According to this deﬁnition, the inclusion of Q1 into Q2 is analogous to the embedding of a pattern into a context, with the diﬀerence that variables are mapped to the variables of another pattern instead of the objects of the context. There is also the additional constraint that the projected variables match. Example 4. For example, the PGP Q = ((z), ({z}, {z → man : ∗})), which selects the set of men, is included in the above PGP Qex , through the embedding φ = {z → x}.   Definition 5 (PGP intersection). Let ψ be an injective mapping from pairs of variables to fresh variables. The intersection of two k-PGPs Q1 = (x1 , (V1 , δ1 )) and Q2 = (x2 , (V2 , δ2 )), written Q1 ∩q Q2 , is deﬁned as Q = (x, (V, δ)), where x = ψ(x1 , x2 ), V = {ψ(v1 , v2 ) | v1 ∈ V1 , v2 ∈ V2 }, δ(y) = δ1 (y 1 )  δ2 (y 2 ), for y = ψ(y 1 , y 2 ) ∈ V ∗ PGP intersection works as a product of two PGPs where each pair of edges (y 1 , y 2 ) makes an edge whose description is the similarity δ1 (y 1 )  δ2 (y 2 ) between the descriptions of the two edges.  
   
  40  
   
  S. Ferré  
   
  Example 5. The intersection of Qex and Q results in the PGP Q = ((xz), ({xz, yz}, {xz → man : ∗, yz → person : ∗})). Variables xz and yz result from the pairing of variables from each PGP (function ψ). The tuples of variables that are not shown in the δP part have the empty description. For instance, δP ((xz, yz)) = δex ((x, y))  δ  ((z, z)) = parent : [1, 2]  ⊥ = ⊥. In Q the description of yz is disconnected from the projected variable xz, and is therefore useless to the semantics of Q . Q can therefore be simpliﬁed to ((xz), ({xz}, {xz → man : ∗})), which is equal to Q up to renaming variable xz as x. More information about such simpliﬁcations are available in [11].   The above example suggests as expected that Q1 ⊆q Q2 implies Q1 ∩q Q2 = Q1 . The following lemma proves that this is indeed the case, like with PS descriptions. Lemma 1. Let Q1 , Q2 be two PGPs. Their PGP intersection Q1 ∩q Q2 is their inﬁmum relative to query inclusion ⊆q . Proof. To prove that Q = Q1 ∩q Q2 is a lower bound, it suﬃces to prove that Q is included in both Q1 and Q2 . To prove Q ⊆q Q1 , it suﬃces to choose the mapping φ1 (x) = (ψ −1 (x))[1] (recall that ψ is an injective mapping from 2-tuples of variables to variables), and to prove that φ1 (x) = x1 and δ(y)  δ1 (φ1 (y)) for all y ∈ V ∗ . This is easily obtained from the deﬁnition of Q. The proof of Q ⊆q Q2 is identical with φ2 (x) = (ψ −1 (x))[2]. To prove that Q1 ∩q Q2 is the greatest lower bound (the inﬁmum), we have to prove that every PGP Q that is included in both Q1 (via φ1 ) and Q2 (via φ2 ) is also included in Q. To that purpose, it suﬃces to choose φ(x ) = ψ(φ1 (x ), φ2 (x )), and to prove that φ(x ) = x and δ  (y  )  δ(φ(y  )) for all y  . This can be obtained from the deﬁnition of Q, and from the hypotheses.   3.3  
   
  Graph Concepts  
   
  As usual in FCA, concepts are composed of an extent and an intent. In Graph-PS like in Graph-FCA, k-PGPs in Qk play the role of intents. For the extents we use the answers of PGPs seen as queries, i.e. sets of tuples of objects. The latter are mathematically k-ary relations over objects: R ⊆ Ok , for some arity k ≥ 0. We k note Rk = 2O the set of k-relations over the objects of some graph context K. Example 6. The set of father-mother-child triples can be represented as the following 3-relation (with abbreviated people names). R := {(C, D, W ), (C, D, H), (W, K, G), (W, K, A)} Note that the order of objects in tuples matters while the order of tuples in the relation does not. A k-relation can be seen as a table with k unlabeled columns.  
   
  Graph-FCA Meets Pattern Structures  
   
  41  
   
  Charles Diana William Charles Diana Harry William Kate  
   
  George  
   
  William Kate  
   
  Charlotte  
   
    Before deﬁning the Galois connection between PGPs and relations, we introduce the notion of graph description γ(o) of an object or a tuple of objects. It incorporates everything that is known about an object or tuple of objects, in terms of relationships in the graph context around those objects, and in terms of D-description of those relationships. It therefore integrates the description δ of individual hyperedges. Definition 6 (graph description). Given a graph context K = (O, (D, ), δ), the graph description of any object o ∈ O is deﬁned as the PGP γ(o) := ((o), PK ) where PK = (O, δ). By extension, the description of any tuple of objects o ∈ O∗ is deﬁned as γ(o) := (o, PK ). This deﬁnition says that the graph description of an object is the whole graph context, seen as a graph pattern (objects as variables), and projected on the object. In practice, only the part of the graph context that is connected to the object is relevant. The generalization to tuples of objects enables to have a description for pairs of objects, triples of objects, and so on. From there, we can deﬁne two derivation operators between PGPs and relations, and prove that they form a Galois connection. Definition 7 (extension). Let K = (O, (D, ), δ) be a graph context. The extension of a k-PGP Q ∈ Qk is the k-relation deﬁned by ext(Q) := {o ∈ Ok | Q ⊆q γ(o)} The extension of a k-PGP is the set of k-tuples of objects whose graph description contains the PGP. It can be understood as the set of answers of the PGP seen as a query. Example 7. In the example context, the extension of the 2-PGP Q = ((x, y), ({x, y}, {x → person : ∗, y → woman : ∗, (x, y) → parent : 1})) is the 2-relation R = ext(Q) = {(W illiam, Diana), (George, Kate)},    
   
  i.e. the set of pairs (ﬁrst child, mother).  
   
  Definition 8 (intension). Let K = (O, A, I) be a graph context. The intension of a k-relation R ∈ Rk is the k-PGP deﬁned by  int(R) := γ(o) o∈R  
   
  42  
   
  S. Ferré  
   
  The intension of a k-relation is the PGP intersection of the graph descriptions of all tuples of objects in the relation, hence the most speciﬁc projected graph pattern shared by them. Example 8. In the example context, the intension of the 2-relation from Example 7 R = {(W illiam, Diana), (George, Kate)} is the 2-PGP Q = int(R) = ((x, y), ({x, y, z, w}, δP )) where δp = {x → man : ∗, y → woman : ∗, z → man : ∗, w → person : ∗, (x, y) → parent : 1, (x, z) → parent : 1, (w, y) → parent : 2, (w, z) → parent : 2}. Note that this intension expands the PGP in Example 7 with the following elements: x is a man, x is the ﬁrst child of some man z, his father, and there is a second child w of parents y and z. The extension of this expanded PGP remains the relation R, which suggests that int ◦ ext is a closure operator.   We can actually prove that ext and int form a Galois connection. This implies that int ◦ ext and ext ◦ int are closure operators, respectively on PGPs and relations. Theorem 1 (Galois connection). Let K = (O, (D, ), δ) be a graph context. For every arity k, the pair of mappings (ext, int) forms a Galois connection between (Rk , ⊆) and (Qk , ⊆q ), i.e. for every object relation R ∈ Rk and PGP Q ∈ Qk , R ⊆ ext(Q) ⇐⇒ Q ⊆q int(R) Proof. R ⊆ ext(Q) ⇐⇒ ∀o ∈ R : o ∈ ext(Q) ⇐⇒ ∀o ∈ R: Q ⊆q γ(o) (Deﬁnition 7) ⇐⇒ Q ⊆q o∈R γ(o) (Lemma 1) ⇐⇒ Q ⊆q int(R) (Deﬁnition 8)  
   
     
   
  From the Galois connection, graph concepts can be deﬁned and organized into concept lattices, like in classical FCA, with one concept lattice for each arity k. Definition 9 (graph concept). Let K = (O, (D, ), δ) be a graph context. A k-graph concept of K is a pair (R, Q), made of a k-relation (the extent) and a k-PGP (the intent), such that R = ext(Q) and Q =q int(R). Example 9. The 2-relation and 2-PGP in Example 8 form a 2-graph concept. It can be understood as the (ﬁrst child, mother) binary relationship. Its intent tells us that in the example context, every ﬁrst child whose mother is known also has a known father, and a sibling (man or woman) that was born after him.   Theorem 2 (graph concept lattices). The set of graph k-concepts Ck , partially ordered by ≤, which is deﬁned by (R1 , Q1 ) ≤ (R2 , Q2 ) : ⇐⇒ R1 ⊆ R2 ⇐⇒ Q2 ⊆q Q1 , forms a bounded lattice (Ck , ≤, ∧, ∨, , ⊥), the k-graph concept lattice.  
   
  Graph-FCA Meets Pattern Structures  
   
  43  
   
  Fig. 1. The 1-graph concept lattice of the royal family context (less the bottom concept). The descriptor parent:1 a _ in box Q5g reads δP 5 (a, g) = parent : 1, as part of the graph pattern P 5 of the intent of concept Q5g. The nodes of pattern P 5 are the boxes Q5a-g.  
   
  Figure 1 is a representation of the 1-graph concept lattice – less the bottom concept – of the royal family graph context from Example 1. This is a compact representation because each box represents at the same time a 1-concept and a node of the graph pattern of a concept intent. Each box is made of three parts: 1. A concept/node identiﬁer Qnx made of a number n and a letter x. The number identiﬁes a pattern Pn , and the letter identiﬁes a node of this pattern. Together they form the concept intent Qn = (x, Pn ). The set of nodes Vn of pattern Pn = (Vn , δPn ) is therefore made of all boxes whose identiﬁer has Qn as a preﬁx. (Some concepts also have an informal description under the identiﬁer, manually added to help the reading of the lattice.) 2. A list of pattern hyperedges in the form d y1 . . . yn , to be read as δPn (y1 , . . . , yn ) = d, where an underscore _ refers to the current node x.  
   
  44  
   
  S. Ferré  
   
  A 1-edge d _ is abbreviated as d as it corresponds to an attribute in classical FCA. 3. A list of objects composing the concept extent. A k-concept with k > 1 can be read by selecting k diﬀerent boxes that belong to the same pattern. The graph pattern is the same, whatever the nodes chosen as projected variables, so the concept intent can be read like for 1-concepts. However, the concept extent cannot be read exactly from this representation, it is a subset of the Cartesian product of the extents of the selected boxes. Example 10. Given the way diﬀerent concepts share the same graph pattern in their intent, it makes sense to interpret the concept lattice in Fig. 1 pattern by pattern. – Pattern P3 is a about a person born at any time. It has a single node a, hence there is a single concept Q3a, the concept of all persons in the context. It is the top concept. – Pattern P1 is the reﬁnement of P3 on women. – Pattern P4 is the reﬁnement of P3 on men. – Pattern P2 is the reﬁnement of P3 on people born in the eighties. – Pattern P5 has 7 nodes (a-g). It is about a man (a) that is the ﬁrst child of two parents, a man (d) and a woman (c), and about another person (b) that is the second child of the same parents. Those nodes respectively correspond to the concepts of “male ﬁrst child” (Q5a), “father” (Q5d), “mother” (Q5c), and “second child” (Q5b). The other nodes in the pattern actually deﬁne generalizations of those concepts for which the a-b-c-d pattern is always present in the context: “parent” (Q5g), “male child” (Q5e), and “child” (Q5f). It can be observed that the latter concepts (e-g) are in a lighter color and the former concepts (a-d) are in a more vivid color (called core concepts/nodes [11]). When reading a concept intent, the boxes in a lighter color can be ignored when they are not selected because the information they provide is redundant with the core nodes. – The core nodes of pattern P6 reproduce the graph context, each node corresponding to a speciﬁc object. The non-core concepts provide generalizations over single objects: “grand-parents born between 1948 and 1961” (Q6i), “parents born in 1982” (Q6h), “children born between 1982 and 1984” (Q6j), and “grand-children born between 2013 and 2015” (Q6k). From the concept lattice structure, it is possible to ﬁnd what diﬀerent people have in common. For instance, from Q6d ∨ Q6g = Q5f , we learn that what William (Q6d) and Charlotte (Q6g) have in common is that they are persons with a father (Q5d, Charles or William) and a mother (Q5c, Diana or Kate) who have together a male ﬁrst child (Q5a, William or George), and a second child (Q5b, Harry or Charlotte). We also learn that they share that with Harry and George, the other instances of concept Q5f.    
   
  Graph-FCA Meets Pattern Structures  
   
  4  
   
  45  
   
  Application to RDFS Graphs  
   
  As an application case of Graph-PS we consider RDFS graphs. An RDFS graph is a structure R, L, (C, ≤), (P, ≤), T , where R is a collection of resources (IRIs and blank nodes), L is a set of literal values of various datatypes (e.g., strings, numbers, dates), C is a hierarchy of classes, P is a hierarchy of properties, and T is a set of triples expressing the factual knowledge. In order to apply Graph-PS to RDFS graphs, we need to identify what are the objects, the descriptions, and the similarity between descriptions. From the usual RDFS graph representation that uses resources, literals, and classes as nodes, it is tempting to use them as objects. However, it is desirable to deﬁne similarity over literals and classes. The similarity between two integer literals could be an interval like in the example of the previous section. The similarity between two classes should be the most speciﬁc common ancestor class. Moreover, we think that literals and classes are more appropriate as descriptors of objects than as objects to be described. We therefore deﬁne the set of object as O = R. We now look at the description of (tuples of) objects. The description information lies in the triples. We deﬁne below their conversion into elementary descriptions, according to the three kinds of triples. – (r, rdf:type, c)  δ(r) = {c, . . .} The triple states that resource r is an instance of class c. The class is used as a descriptor of the resource, rdf:type can be ignored because it is always used with a class. We use an open set containing c because a resource can be declared an instance of several classes. – (r, p, r )  δ(r, r ) = {p, . . .} The triple states that resource r is related to resource r with property p. The property is used as a descriptor of the pair of resources, hence representing a binary edge. We again use an open set because RDFS graphs are multigraphs, i.e. several properties can relate the same resources (e.g., a person who is both the director and an actor of some ﬁlm). – (r, p, l)  δ(r) = {p : l, . . .} The triple states that resource r is related to literal l with property p. Both the property and literal are descriptors, so they must be combined into a composite descriptor, similarly to the example of previous section. We again use an open set because RDFS properties can be multi-valued, and also because resources also have classes as descriptors. To summarize, the set of descriptions can be deﬁned as follows. D = D1 ∪ D2  
   
  where  
   
  D1 = 2C × 2P×L  
   
  and  
   
  D2 = 2P  
   
  D1 is the set of descriptions of individuals resources, where a description is a pair made of a set of classes, and a set of valued properties. D2 is the set of descriptions of edges between resources, where a description is a set of properties. The empty description is therefore simply the empty set: ⊥ = ∅. From there, we  
   
  46  
   
  S. Ferré  
   
  can formally deﬁne the description of every resources and pairs of resources. δ(r) = ({c | (r, rdf:type, c) ∈ T }, {p : l | (r, p, l) ∈ T, l ∈ L}) δ(r, r ) = {p | (r, p, r ) ∈ T, r ∈ R} It remains to deﬁne the similarity operator  over descriptions. As our descriptions of RDFS resources are based on sets of elementary descriptors, we derive similarity on sets from similarity on elements. We can allow the similarity between two elements to be a set of elements, the least general generalizations (lgg). This set-based approach has already been used in Pattern Structures, e.g. for graphs and subgraphs [16]. On classes and properties, we have a partial ordering ≤ from which the lgg operator can deﬁned as follows: lgg(x, y) := M in≤ {z ∈ X | x ≤ z, y ≤ z} On literals, given that L is in general inﬁnite, it is more convenient to assume the lgg operation to be deﬁned, and to derive the partial ordering from it: x ≤ y ⇐⇒ lgg(x, y) = {y}. Here are a few examples on how lgg could be deﬁned on literals: – lgg(10, 20) = {[10, 20]}, – lgg([10, 30], [25, 50]) = {[10, 50]}, – lgg("Formal Concept Analysis", "Relational Concept Analysis") {"Concept", "Analysis"}.  
   
  =  
   
  Of course, this assumes to extend the set of literals L with all patterns that may be generated by the lgg operator, e.g. intervals. On valued properties the lgg operator can be obtained by combining the lgg operators on properties and literals. lgg(p : l , p : l ) = {p : l | p ∈ lgg(p , p ), l ∈ lgg(l , l )} Each lgg operator can be lifted to the PS similarity operator on sets of elements by collecting all least general generalizations of elements pairwise, and then ﬁltering them to keep only the most speciﬁc ones. d  d = Min ≤ {x ∈ lgg(x , x ) | x ∈ d , y  ∈ d } This is enough to deﬁne similarity on D2 -descriptions, which are sets of properties. On D1 -descriptions, similarity can be deﬁned element-wise as they are pairs (C, P L) of sets of elementary descriptors: C is a set of classes, and P L is a set of valued properties. (C  , P L )  (C  , P L ) = (C   C  , P L  P L ) Finally, the similarity between a D1 -description and a D2 -description is simply the empty description ⊥, although Graph-PS only applies similarity to the descriptions of tuples of objects with the same arity.  
   
  Graph-FCA Meets Pattern Structures  
   
  5  
   
  47  
   
  Conclusion and Perspectives  
   
  We have introduced a new extension of Formal Concept Analysis that merges two existing FCA extensions, Pattern Structures (PS) and Graph-FCA. In short, PSlike descriptions are used to describe the nodes and hyperedges of graphs, in place of sets of attributes. The new extension therefore combines the beneﬁts of the two existing extensions: complex descriptions and relationships between objects. A strength of Graph-PS is that it is a proper generalization of PS and GraphFCA, in the sense that PS and Graph-FCA – as well as FCA – are special cases of Graph-PS. Hence, all previous work about deﬁning custom pattern structures can be reused in Graph-PS, and the compact graphical representations of concept lattices in Graph-FCA can be reused in Graph-PS. We have also shown that GraphPS can accurately represent existing graph-based models like RDFS graphs. This paper focuses on the theoretical aspects of Graph-PS, and the most immediate perspectives concern its implementation and its applications. The implementation could be adapted from the existing implementation of GraphFCA [7], by taking into account the similarity operator  in the PGP operations ⊆q and ∩q . The additional cost of using Graph-PS in PS and Graph-FCA settings should be evaluated. A toolbox of components should be built in order to facilitate the design of new sets of descriptions, by capitalizing on previous applications of pattern structures, and by adopting the methodology of logic functors [13]. In the end, we plan to experiment Graph-PS in diverse knowledge graphs and other complex structures like sequences and trees.  
   
  References 1. Alam, M., Buzmakov, A., Napoli, A.: Exploratory knowledge discovery over web of data. Discret. Appl. Math. 249, 2–17 (2018) 2. Ayats, H., Cellier, P., Ferré, S.: Extracting relations in texts with concepts of neighbours. In: Braud, A., Buzmakov, A., Hanika, T., Le Ber, F. (eds.) ICFCA 2021. LNCS (LNAI), vol. 12733, pp. 155–171. Springer, Cham (2021). https://doi. org/10.1007/978-3-030-77867-5_10 3. Baader, F., Calvanese, D., McGuinness, D.L., Nardi, D., Patel-Schneider, P.F. (eds.): The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press, New York (2003) 4. Baixeries, J., Kaytoue, M., Napoli, A.: Characterizing functional dependencies in formal concept analysis with pattern structures. Ann. Math. Artif. Intell. 72, 129– 149 (2014) 5. Belohlavek, R.: Fuzzy closure operators. J. Math. Anal. Appl. 262, 473–489 (2001) 6. Chaudron, L., Maille, N.: Generalized formal concept analysis. In: Ganter, B., Mineau, G.W. (eds.) ICCS-ConceptStruct 2000. LNCS (LNAI), vol. 1867, pp. 357– 370. Springer, Heidelberg (2000). https://doi.org/10.1007/10722280_25 7. Ferré, S., Cellier, P.: Modeling complex structures in Graph-FCA: illustration on natural language syntax. In: Existing Tools and Applications for Formal Concept Analysis (ETAFCA), pp. 1–6 (2022) 8. Ferré, S.: A proposal for extending formal concept analysis to knowledge graphs. In: Baixeries, J., Sacarea, C., Ojeda-Aciego, M. (eds.) ICFCA 2015. LNCS (LNAI),  
   
  48  
   
  9.  
   
  10.  
   
  11. 12.  
   
  13.  
   
  14. 15.  
   
  16.  
   
  17. 18.  
   
  19.  
   
  20.  
   
  21.  
   
  22. 23.  
   
  24.  
   
  S. Ferré vol. 9113, pp. 271–286. Springer, Cham (2015). https://doi.org/10.1007/978-3-31919545-2_17 Ferré, S.: Answers partitioning and lazy joins for eﬃcient query relaxation and application to similarity search. In: Gangemi, A., et al. (eds.) ESWC 2018. LNCS, vol. 10843, pp. 209–224. Springer, Cham (2018). https://doi.org/10.1007/978-3319-93417-4_14 Ferré, S., Cellier, P.: Graph-FCA in practice. In: Haemmerlé, O., Stapleton, G., Faron Zucker, C. (eds.) ICCS 2016. LNCS (LNAI), vol. 9717, pp. 107–121. Springer, Cham (2016). https://doi.org/10.1007/978-3-319-40985-6_9 Ferré, S., Cellier, P.: Graph-FCA: an extension of formal concept analysis to knowledge graphs. Discret. Appl. Math. 273, 81–102 (2019) Ferré, S., Ridoux, O.: A logical generalization of formal concept analysis. In: Ganter, B., Mineau, G.W. (eds.) ICCS-ConceptStruct 2000. LNCS (LNAI), vol. 1867, pp. 371–384. Springer, Heidelberg (2000). https://doi.org/10.1007/10722280_26 Ferré, S., Ridoux, O.: A framework for developing embeddable customized logics. In: Pettorossi, A. (ed.) LOPSTR 2001. LNCS, vol. 2372, pp. 191–215. Springer, Heidelberg (2002). https://doi.org/10.1007/3-540-45607-4_11 Ferré, S.: Application of concepts of neighbours to knowledge graph completion. Data Sci. Methods Infrastruct. Appl. 4, 1–28 (2021) Ferré, S., Huchard, M., Kaytoue, M., Kuznetsov, S.O., Napoli, A.: Formal concept analysis: from knowledge discovery to knowledge processing. In: Marquis, P., Papini, O., Prade, H. (eds.) A Guided Tour of Artiﬁcial Intelligence Research, pp. 411–445. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-06167-8_13 Ganter, B., Kuznetsov, S.O.: Pattern structures and their projections. In: Delugach, H.S., Stumme, G. (eds.) ICCS-ConceptStruct 2001. LNCS (LNAI), vol. 2120, pp. 129–142. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-445838_10 Ganter, B., Wille, R.: Formal Concept Analysis. Springer, Heidelberg (1999). https://doi.org/10.1007/978-3-642-59830-2 Kaytoue, M., Kuznetsov, S.O., Napoli, A.: Revisiting numerical pattern mining with formal concept analysis. In: International Joint Conference on Artiﬁcial Intelligence (IJCAI) (2011) Kötters, J.: Concept lattices of a relational structure. In: Pfeiﬀer, H.D., Ignatov, D.I., Poelmans, J., Gadiraju, N. (eds.) ICCS-ConceptStruct 2013. LNCS (LNAI), vol. 7735, pp. 301–310. Springer, Heidelberg (2013). https://doi.org/10.1007/9783-642-35786-2_23 Kuznetsov, S.O., Samokhin, M.V.: Learning closed sets of labeled graphs for chemical applications. In: Kramer, S., Pfahringer, B. (eds.) ILP 2005. LNCS (LNAI), vol. 3625, pp. 190–208. Springer, Heidelberg (2005). https://doi.org/10. 1007/11536314_12 Lehmann, F., Wille, R.: A triadic approach to formal concept analysis. In: Ellis, G., Levinson, R., Rich, W., Sowa, J.F. (eds.) ICCS-ConceptStruct 1995. LNCS, vol. 954, pp. 32–43. Springer, Heidelberg (1995). https://doi.org/10.1007/3-54060161-9_27 Poelmans, J., Ignatov, D.I., Kuznetsov, S.O., Dedene, G.: Fuzzy and rough formal concept analysis: a survey. Int. J. General Systems 43(2), 105–134 (2014) Rouane-Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Relational concept analysis: mining concept lattices from multi-relational data. Ann. Math. Artif. Intell. 67(1), 81–108 (2013) Voutsadakis, G.: Polyadic concept analysis. Order 19, 295–304 (2002)  
   
  On the Commutative Diagrams Among Galois Connections Involved in Closure Structures Manuel Ojeda-Hern´ andez(B) , Inma P. Cabrera , Pablo Cordero , and Emilio Mu˜ noz-Velasco Universidad de M´ alaga, Andaluc´ıa Tech, M´ alaga, Spain [email protected]   
   
  Abstract. In previous works we proved that fuzzy closure structures such as closure systems, fuzzy closure systems, fuzzy closure operators and fuzzy closure relations are formal concepts of five Galois connections (three antitone and two isotone), together with the commutativity of the fuzzy part of the diagram. In this work we study the commutativity of the crisp diagram formed by three of these Galois connections.  
   
  1  
   
  Introduction  
   
  Galois connections appear in several mathematical theories and in many situation related to the theory of relations [17]. In particular, it is well-known that the derivation operators of Formal Concept Analysis form a Galois connection [9]. The extension of the notion of Galois connection to the fuzzy framework was introduced by Bˇelohl´ avek [1], which provided a way to study Fuzzy Formal Concept Analysis. Closure systems are very used in computer science and in both pure and applied mathematics [7]. The fuzzy extension of closure systems has been approached from several distinct perspectives in the literature, to cite a few we mention the following [2,6,8,10,11,14]. In this work, we will use the deﬁnition introduced in [14], which extends closure systems as meet-subsemilattices in the framework of complete fuzzy lattices. On the other hand, the so-called closure operators, have also been extended to the fuzzy setting, and most authors use the same deﬁnition, i.e., a mapping that is inﬂationary, isotone and idempotent. Fuzzy closure operators were deﬁned in [2,5] and they appear naturally in diﬀerent areas of fuzzy logic and its applications. In this paper, we continue the study started in [13,15]. The topic of [13] was the study of the mappings that relate one closure structure to the other. For a fuzzy closure system, then the mapping  c(Φ) : A → A example, if Φ ∈ LA is deﬁned as  c(Φ)(a) = (aρ ⊗ Φ) is a closure operator. This allows us to deﬁne c(Φ) for all Φ ∈ LA . Similarly, for a closure operator  c : LA → AA as Φ →  c : A → A, the mapping Ψ : AA → LA maps c to a fuzzy closure system Ψ(c), deﬁned by Ψ(c)(a) = ρ(c(a), a). One of the main results in [13] proved that the c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 49–63, 2023. https://doi.org/10.1007/978-3-031-35949-1_4  
   
  50  
   
  M. Ojeda-Hern´ andez et al.  
   
  pair ( c, Ψ) is a fuzzy Galois connection between (LA , S) and (Isot(AA ), ρ˜). Furthermore, it is proved that any pair of closure structures (Φ, c) is a formal concept of the Galois connection. This problem is also studied for fuzzy closure relations, hence studying two additional Galois connections, one between (Isot(AA ), ρ) and (IsotTot(LA×A ), ρˆ) and another one between (LA , S) and (IsotTot(LA×A ), ρˆ). In the case of paper [15], the main goal is to insert crisp closure systems in the problem. We proved the existence of crisp Galois connections between the crisp lattice (2A , ⊆) and the three sets of the previous paragraph endowed with the 1-cut of their fuzzy relations. Moreover, the existence of Galois connections and the behavior of the sets of formal concepts have been considered. The main goal of this paper is to study the commutativity of the diagram of the three Galois connections presented in [15]. We prove that, of six possible commutative diagrams, two of them are indeed commutative, another one is commutative in the case where the underlying structure is a Heyting algebra, and the remaining three diagrams are not commutative in general, not even under the Heyting algebra assumption. The outline of the paper is as follows. First, a section of preliminaries to recall already known results that are useful to understand the paper better. The next section introduces the crisp closure systems to the framework and considers the new Galois connections and their formal concepts. The main results of the paper appear in the following section, where the study of the commutativity of the diagrams is completed. Finally, there is a section of conclusions and further work where the results are discussed and some hints of future research lines are shown.  
   
  2  
   
  Preliminaries  
   
  This section presents the necessary notions and results to properly follow the paper. The general framework throughout the paper is going to be a complete residuated lattice L = (L, ∧, ∨, × →, 0, 1). For the properties of residuated lattices we refer the reader to [3, Chapter 2]. Given a L-fuzzy set X ∈ LA , the 1-cut of X, denoted by X 1 , is the crisp set {a ∈ A | X(a) = 1}. Equivalently, we will consider it as the fuzzy set whose characteristic mapping is X 1 (a) = 1 if X(a) = 1 and 0 otherwise. Given a fuzzy relation μ between A and B, i.e., a crisp mapping μ : A × B → L, and a ∈ A, the afterset aμ is the fuzzy set aμ : B → L given by aμ (b) = μ(a, b). A fuzzy relation μ is said to be total if, for all a ∈ A, the aftersets aμ are normal fuzzy sets, i.e., there exists x ∈ A such that aκ (x) = 1. For ρ being a binary L-relation in A, we say that – – – –  
   
  ρ ρ ρ ρ  
   
  is is is is  
   
  reflexive if ρ(x, x) = 1 for all x ∈ A. symmetric if ρ(x, y) = ρ(y, x) for all x, y ∈ A. antisymmetric if ρ(x, y) ⊗ ρ(y, x) = 1 implies x = y for all x, y ∈ A. transitive if ρ(x, y) ⊗ ρ(y, z) ≤ ρ(x, z) for all x, y, z ∈ A.  
   
  Definition 1. Given a non-empty set A and a binary L-relation ρ on A, the pair (A, ρ) is said to be a fuzzy poset if ρ is a fuzzy order, i.e. if ρ is reflexive, antisymmetric and transitive.  
   
  Commutating Diagrams of Galois Connections  
   
  51  
   
  A typical example of fuzzy poset is (LA , S), for any set A. If (A, ρ) is a fuzzy poset, we will also use the so-called full fuzzy powering ρ∝ , which is the fuzzy relation on LA deﬁned as follows: for all X, Y ∈ LA ,  (X(x) ⊗ Y (y)) → ρ(x, y). ρ∝ (X, Y ) = x,y∈A  
   
  Since the structure used in this paper is a complete fuzzy lattice, we require the notion of inﬁmum and supremum in the fuzzy setting. These concepts, originally introduced by Bˇelohl´ avek in [4], are deﬁned as follows. Definition 2. Let (A, ρ) be a fuzzy poset and X ∈ LA . The down-cone (resp. up-cone) of X is defined as a fuzzy set with the following membership function.     X(a) → ρ(x, a) resp. X ρ (x) = X(a) → ρ(a, x) . Xρ (x) = a∈A  
   
  a∈A  
   
  Definition 3. Let (A, ρ) be a fuzzy poset and X ∈ LA . An element a ∈ A is said to be inﬁmum (resp. supremum) of X if the following conditions hold: 1. Xρ (a) = 1 (resp. X ρ (a) = 1). 2. Xρ (x) ≤ ρ(x, a) (resp. X ρ (x) ≤ ρ(a, x)), for all x ∈ A. The fuzzy poset (A, ρ) is said to be a complete fuzzy lattice if for all X ∈ LA .  
   
    
   
  X and  
   
    
   
  X exist  
   
  Hereinafter, suprema and inﬁma in A will be denoted by and , respectively. Theorem 1. An element a ∈ A is infimum (resp. supremum) of X ∈ LA if and only if, for all x ∈ A, ρ(x, a) = Xρ (x)  
   
  (resp. ρ(a, x) = X ρ (x)).  
   
  Every fuzzy order induces a symmetric relation, called symmetric kernel relation. Definition 4. Given a fuzzy poset (A, ρ), the symmetric kernel relation is defined as ≈ : A × A → L where (x ≈ y) = ρ(x, y) ⊗ ρ(y, x) for all x, y ∈ A. The notion of extensionality was introduced in the very beginning of the study of fuzzy sets. It has also been called compatibility (with respect to the similarity relation) in the literature. Definition 5. Let (A, ρ) be a fuzzy poset and X ∈ LA . – X is said to be extensional or compatible with respect to ≈ if it satisfies X(x) ⊗ (x ≈ y) ≤ X(y), for all x, y ∈ A.  
   
  52  
   
  M. Ojeda-Hern´ andez et al.  
   
  – The extensional hull of X, denoted by X ≈ , is the smallest extensional set that contains X. Its explicit formula is the following:  (X(a) ⊗ (a ≈ x)). X ≈ (x) = a∈A  
   
  For a crisp set X ⊆ A, the expression of the extensional hull is simpliﬁed since we have   X ≈ (x) = (X(a) ⊗ (a ≈ x)) = (a ≈ x). a∈A  
   
  a∈X  
   
  We focus now on closure structures in the fuzzy framework. The deﬁnition of fuzzy closure operator in the fuzzy setting is the one used in [2,3]. Definition 6. Given a fuzzy poset (A, ρ), a mapping c : A → A is said to be a closure operator on A if the following conditions hold: 1. ρ(a, b) ≤ ρ(c(a), c(b)), for all a, b ∈ A (isotonicity) 2. ρ(a, c(a)) = 1, for all a ∈ A (inflationarity) 3. ρ(c(c(a)), c(a)) = 1, for all a ∈ A (idempotency) An element q ∈ A is said to be closed for c if ρ(c(q), q) = 1. The counterpart of closure operators are the so-called closure systems, there are various distinct approaches to this concept in the fuzzy framework, originally introduced on the fuzzy powerset lattice by Bˇelohl´ avek [2]. The extension to arbitrary complete fuzzy lattices was introduced in [14] and is the one used here. Definition 7. Let (A, ρ)be a complete fuzzy lattice. A crisp set F ⊆ A is said to be a closure system if X ∈ F for all X ∈ LF . This deﬁnition of closure system in the fuzzy framework maintains the oneto-one relation of the crisp case [11]. Theorem 2. Let (A, ρ) be a complete fuzzy lattice. The following assertions hold: 1. If c is a closure operator on (A, ρ), the crisp set Fc defined as {a ∈ A | c(a) = a} is a closure system.  2. If F is a closure system, the mapping cF : A → A defined as cF (a) = (aρ ⊗ F) is a closure operator on (A, ρ). 3. If c : A → A is a closure operator on (A, ρ), then cFc = c. 4. If F is a closure system, then F = FcF . Notice that the set Fc can be deﬁned as {a ∈ A | ρ(c(a), a) = 1} since, as c is inﬂationary, if ρ(c(a), a) = 1 we would also have ρ(a, c(a)) = 1 and then c(a) = a by antisymmetry. Since closure systems are crisp structures with certain fuzzy properties, it is natural to wonder whether a fuzzy structure can be deﬁned. An aﬃrmative answer was found in [14].  
   
  Commutating Diagrams of Galois Connections  
   
  53  
   
  Definition 8. Let (A, ρ) be a complete fuzzy lattice. A fuzzy set Φ ∈ LA is said to be a fuzzy closure system if Φ1 is a closure system and Φ is the extensional hull of Φ1 . This deﬁnition of fuzzy closure system maintains the well-known one-to-one relationship between closure systems and closure operators [14]. Theorem 3. Let (A, ρ) be a complete fuzzy lattice. The following assertions hold: 1. If c is a closure operator on (A, ρ), the fuzzy set Φc defined as Φc (a) = ρ(c(a), a) is a fuzzy closure system. 2.  If Φ is a fuzzy closure system, the mapping cΦ : A → A defined as cΦ (a) = (aρ ⊗ Φ) is a closure operator on (A, ρ). 3. If c : A → A is a closure operator on (A, ρ), then cΦc = c. 4. If Φ is a fuzzy closure system on (A, ρ), then Φ = ΦcΦ . Analogously, the same discussion can be done by extending closure operators to fuzzy closure relations, which are isotone, idempotent and inﬂationary fuzzy relations κ : A×A → L. A fuzzy closure relation that is minimal among the extensional fuzzy closure relations is named strong fuzzy closure relations. These were introduced in [12]. Therein, it was proved the one-to-one correspondence between strong fuzzy closure relations and fuzzy closure systems [12, Theorem 23]. Fuzzy Galois connections are a main concept in this paper as well. Let us recall the deﬁnition. Definition 9. ([18]). Let (A, ρA ) and (B, ρB ) be fuzzy posets, f : A → B and g : B → A be two mappings. – The pair (f, g) is called an isotone fuzzy Galois connection or fuzzy isotone Galois connection between (A, ρA ) and (B, ρB ), denoted by (f, g) :  (B, ρB ), if (A, ρA )  ρA (g(b), a) = ρB (b, f (a))  
   
  for all a ∈ A and b ∈ B.  
   
  – The pair (f, g) is called a fuzzy Galois connection between (A, ρA ) and  (B, ρB ), if (B, ρB ), denoted by (f, g) : (A, ρA )  ρA (a, g(b)) = ρB (b, f (a))  
   
  for all a ∈ A and b ∈ B.  
   
  A formal concept, also called fixed pair or fixed point, of a fuzzy Galois connection (f, g) is a couple (a, b) ∈ A × B such that f (a) = b and g(b) = a. In [13], the mappings in Theorems 2 and 3 and the relationships among them were studied. Speciﬁcally, it was proved the existence of fuzzy Galois connections between pairs of these mappings and whether the fuzzy closure structures are formal concepts of them. That is, (LA , S)  (LA , S)  (Isot(AA ), ρ)  
   
  ) ( c ,Ψ ) (κ,Ψ (−1 ,−≈ )  
   
   (Isot(AA ), ρ)  (IsotTot(LA×A ), ρˆ)  (IsotTot(LA×A ), ρˆ),  
   
  54  
   
  M. Ojeda-Hern´ andez et al.  
   
  where Isot(AA ) is the set of (crisp) isotone mappings on A, IsotTot(LA×A ) is the set of isotone and total fuzzy relations on A and the fuzzy relations ρ, ρˆ are deﬁned as follows,  ρ(f1 , f2 ) = ρ(f1 (x), f2 (x)) for all f1 , f2 ∈ AA x∈A  
   
  ρˆ(κ1 , κ2 ) =  
   
    
   
  ρ∝ (aκ1 , aκ2 ) for all κ1 , κ2 ∈ LA×A .  
   
  a∈A  
   
  The mappings in the diagram are deﬁned as follows,  c : LA → Isot(AA ) Ψ : Isot(AA ) → LA  
   
   c(Φ) = cΦ Ψ(f ) = Φf  
   
  κ : LA → IsotTot(LA×A )  
   
  κ(Φ)(a, b) =  
   
  Ψ : IsotTot(LA×A ) → LA  
   
  Ψ(μ)(x) = ρ∝ (xμ , x)  
   
    
   
  (aρ ⊗ Φ) ≈ b  
   
  Results in [13] involve fuzzy closure systems, closure operators and strong fuzzy closure relations. Speciﬁcally, there we prove the following assertions: 1. If Φ is a fuzzy closure system, (Φ,  c(Φ)) is a formal concept of the Galois connection ( c, Ψ). 2. If c is a fuzzy closure operator, (Ψ(c), c) is a formal concept of the Galois connection ( c, Ψ). 3. If Φ is a fuzzy closure system, (Φ, κ(Φ)) is a formal concept of the Galois connection (κ, Ψ). 4. If μ is a strong fuzzy closure relation, (Ψ(μ), μ) is a formal concept of the Galois connection (κ, Ψ). 5. If c is a fuzzy closure operator, (c≈ , c) is a formal concept of the fuzzy isotone Galois connection (−1 , −≈ ). 6. If μ is a strong fuzzy closure relation, (μ, μ1 ) is a formal concept of the fuzzy isotone Galois connection (−1 , −≈ ).  
   
  3  
   
  Crisp Closure Systems  
   
  Notice that closure systems as crisp sets are not considered in the Galois connections mentioned above. Thus, a natural step is to study a similar problem with the partially ordered set (2A , ⊆). This addition to the problem is not straightforward since (2A , ⊆) is a crisp poset, whereas (LA , S) and (Isot(AA ), ρ) are complete fuzzy lattices and (IsotTot(LA×A ), ρˆ) is a fuzzy preposet [13]. Thus, we will consider the 1-cut of the fuzzy relations deﬁned above and study the crisp problem. It is well-known that S 1 is Zadeh’s inclusion, hence throughout the paper we will follow the classical notation for subsethood ⊆. We will also consider the 1-cut of ρ, we will denote ρ 1 (f, g) = 1 as f g, and ρˆ1 (κ1 , κ2 ) = 1 will be denoted by κ1  κ2 , that is, f g if and only if ρ(f (a), g(a)) = 1, for all a ∈ A.  
   
  (1)  
   
  Commutating Diagrams of Galois Connections  
   
  55  
   
  κ1  κ2 if and only if xκ1 (y) ⊗ xκ2 (z) ≤ ρ(y, z) for all x, y, z ∈ A.  
   
  (2)  
   
  Observe that the set (IsotTot(LA×A ), ) is a preordered set. In addition, (L , ⊆) and (Isot(AA ), ) are complete lattices by [13, Proposition 13] and [3, Theorem 4.55]. A  
   
  Proposition 1. The following pairs of mappings form two Galois connections and an isotone Galois connection, respectively, (LA , ⊆)  (LA , ⊆)  (IsotTot(LA×A ), )  
   
  ) ( c ,Ψ ) (κ,Ψ (−1 ,−≈ )  
   
   (Isot(AA ), )  (IsotTot(LA×A ), )  (Isot(AA ), ).  
   
  The question now is whether it is possible to consider (2A , ⊆) in this problem. This is the topic discussed in [15]. Following the spirit in [13], the mappings which form the new Galois connections must be the ones relating closure systems and fuzzy (a), a) = 1} and  c(X)(a) =  ρ closure operators, i.e., F(f ) = {a ∈ A | ρ(f (a ⊗ X), for any isotone mapping f ∈ Isot(AA ) and any set X ⊆ A. Thus, the couple ( c, F) forms a Galois connection. (2A , ⊆)   
   
  ( c,F )  
   
   (Isot(AA ), )  
   
  In order to complete the scenario, our next intended goal would be to prove the existence of isotone Galois connection between (2A , ⊆) and (LA , S). Unfortunately, the couple of mappings we have been considering so far, i.e.,  (x ≈ a), Φ1 = {a ∈ A | Φ(a) = 1} and X ≈ (a) = x∈X  
   
  do not form an isotone Galois connection between these two posets. Even though this pair is not an isotone Galois connection in general, the restriction to extensional fuzzy sets does. Hence, we will work on the set of extensional fuzzy sets of A, denoted by (Ext(LA ), S). This set maintains many of the good properties of (LA , S) such as being a complete fuzzy lattice. As anticipated above, the couple of mappings (−1 , −≈ ) forms an isotone Galois connection between (2A , ⊆) and (Ext(LA ), ⊆). (2A , ⊆)  
   
  (−1 ,−≈ )  
   
   (LA , ⊆)  
   
  Restricting to extensional fuzzy sets maintains the Galois connections in Proposition 1, since the images of both Ψ˜ and Ψˆ are always extensional sets and any isotone and total relation is extensional. The formal concepts of the Galois connection introduced above are studied in the following theorem.  
   
  56  
   
  M. Ojeda-Hern´ andez et al.  
   
  Theorem 4. Let X ∈ 2A and f ∈ Isot(AA ). The following statements are equivalent: 1. The couple (X, f ) is a formal concept of the Galois connection ( c, F). 2. The crisp set X is a closure system and  c(X) = cX = f . 3. The mapping f is a closure operator and F(f ) = Ff = X. The last result shows that every formal concept of the Galois connection is a pair of fuzzy closure structures. This is interesting because this result does not hold in the general fuzzy setting. Recall that in the general fuzzy setting fuzzy closure structures were formal concepts of the Galois connections but there existed formal concepts that were not formed by fuzzy closure structures. Examples of such cases can be found in [13]. As done in the previous case, a study of the formal concepts of the isotone Galois connection (−1 , −≈ ) is necessary. This is done in the result below. Theorem 5. Let A be a complete fuzzy lattice, then 1. Let F ⊆ A be a closure system, then (F ≈ , F) is a formal concept of the isotone Galois connection. 2. Let Φ ∈ LA be a fuzzy closure system, then (Φ, Φ1 ) is a formal concept of the isotone Galois connection. As expected, fuzzy closure structures are formal concepts of the isotone Galois connection. However, there are formal concepts which are not fuzzy closure structures.  
   
  4  
   
  A Study on Commutativity of Diagrams  
   
  The purpose of this section is to examine under which conditions the diagram of all the fuzzy Galois connections in the last section is commutative. The goal is to form a diagram like the following. (2A , ⊆)    
   
  (˜ c,F )  
   
   (Isot(AA ), )        )  (ˆ c ,Ψ  1 ≈  (− ,− ) (−1 ,−≈ )        ) (κ,Ψ  (IsotTot(LA×A ), ). (Ext(LA ), ⊆)  Unfortunately, the diagram is not commutative in general. In [13] an example showing κ ◦ Ψ = −≈ and  c ◦ Ψ = −1 was presented.  
   
  Commutating Diagrams of Galois Connections  
   
  57  
   
  Some partial results in [13] showed that the following diagrams commute. (Isot(AA ), ρ)       c  (−1 ,−≈ )        κ  (IsotTot(LA×A ), ρˆ) (LA , S)  
   
  (Isot(AA ), ρ)        Ψ  (−1 ,−≈ )         Ψ (IsotTot(LA×A ), ρˆ) (LA , S)   
   
  We consider now restrictions to ensure the commutativity of, at least, the ˆ(Φ) is not a closure operator in upper part of the diagram. Let Φ ∈ LA , then c general. However,  c(Φ1 ) will be a closure operator due to Theorem 4. Thus, as expected, the diagram is not commutative in general. In the rest of this section we will give partial results on the relationships among the diﬀerent compositions. Lemma 1. Let X ∈ 2A and Φ ∈ Ext(LA ). Then,  c(X ≈ )  c(X)  
   
  and  
   
   c(Φ)  c(Φ1 )  
   
  Proof. For all X ⊆ A and a, x ∈ A, we have that  ((aρ ⊗ X ≈ ) (y) → ρ (x, y)) (aρ ⊗ X ≈ )ρ (x) = y∈A  
   
    
   
  =  
   
  ((ρ (a, y) ⊗ X ≈ (y)) → ρ (x, y))  
   
  y∈A  
   
    
   
  =  
   
   ρ (a, y) ⊗  
   
  y∈A  
   
     
   
  (i)  
   
  =  
   
    
   
   (y ≈ z)  
   
   → ρ (x, y)  
   
  z∈X  
   
  ((ρ (a, y) ⊗ (y ≈ z)) → ρ (x, y))  
   
  z∈X y∈A (ii)  
   
  ≤  
   
    
   
  (ρ (a, z) → ρ (x, z)) = (aρ ⊗ X)ρ (x)  
   
  z∈X  
   
  where, in (i), we have used [3, (2.50) and (2.52)], and, in (ii), we have considered y = z. Since inﬁma is deﬁned in terms of lower-cones we have that   ρ( c(X ≈ )(a),  c(X)(a)) = ρ( (aρ ⊗ X ≈ ), (aρ ⊗ X)) = 1. On the other hand, for all Φ ∈ Ext(LA ) and all a ∈ A, we have that Φ1 ⊆ Φ and, therefore,   ρ( c(Φ)(a),  c(Φ1 )(a)) = ρ( (aρ ⊗ Φ), (aρ ⊗ Φ1 )) = 1  
   
  58  
   
  M. Ojeda-Hern´ andez et al.  
   
  Proposition 2. The following diagram commutes  c  
   
   (Isot(AA ), )      ≈  −   c     (Ext(LA ), ⊆) (2A , ⊆)  
   
  Proof. By Lemma 1, we have that  c(X ≈ )  c(X). Let us prove the converse inequality. Let X ⊆ A and a, x ∈ A. Then,  ((aρ ⊗ X ≈ ) (y) → ρ (x, y)) (aρ ⊗ X ≈ )ρ (x) = y∈A  
   
    
   
  =  
   
  y∈A  
   
    
   
  =  
   
  ((ρ (a, y) ⊗ X ≈ (y)) → ρ (x, y))  ρ (a, y) ⊗  
   
  y∈A  
   
  =  
   
   (X (z) ⊗ (y ≈ z))  
   
   → ρ (x, y)  
   
  z∈X  
   
    
   
  (i)  
   
    
   
  ((ρ (a, y) ⊗ X (z) ⊗ (y ≈ z)) → ρ (x, y))  
   
  y,z∈A  
   
    
   
  (ii)  
   
  =  
   
  ((ρ (a, y) ⊗ ρ(y, z) ⊗ X(z)) → (ρ(z, y) → ρ (x, y)))  
   
  y,z∈A (iii)  
   
  ≥  
   
    
   
  ((ρ (a, y) ⊗ ρ(y, z) ⊗ X(z)) → ρ(x, z))  
   
  y,z∈A (iv)  
   
  ≥  
   
    
   
  ((ρ (a, z) ⊗ X(z)) → ρ(x, z)) = (aρ ⊗ X)ρ (x),  
   
  z∈A  
   
  where (i) holds due to [3, (2.50), (2.52)], (ii) holds by [3, (2.33)], (iii) holds by transitivity of ρ and the adjunction and ﬁnally (iv) holds due to transitivity and [3, (2.44)]. The following example shows that the inequality  c(Φ)  c(Φ1 ) could be strict. Therefore, the corresponding diagram does not commute in general. Example 1. Let L = ({0, 0.5, 1}, ∧, ∨, ⊗, →, 0, 1) be a L  ukasiewicz residuated lattice with three values, and (A, ρ) be the fuzzy lattice with A = {⊥, a, b, c, d, e, }  
   
  Commutating Diagrams of Galois Connections  
   
  59  
   
  and the fuzzy relation ρ : A × A → L described by the following table: ρ ⊥ a b c d e   
   
  ⊥ a b c d e  1 1 1 1 1 1 1 0.5 1 0.5 1 1 1 1 0.5 0.5 1 1 1 1 1 0.5 0.5 0.5 1 1 1 1 0 0.5 0 0.5 1 0.5 1 0 0 0.5 0.5 0.5 1 1 0 0 0 0.5 0.5 0.5 1  
   
  Consider Φ = {a/0.5, b/0.5}. It is clear that Φ1 = ∅ and  c(Φ1 ) is the constant mapping which maps every element to  whereas c ˆ(Φ)(a) = c =  . This is proved as follows.  ((aρ ⊗ Φ)(x) → ρ(c, x)) (aρ ⊗ Φ)ρ (c) = x∈A ρ  
   
  = ((a ⊗ Φ)(a) → ρ(c, a)) ∧ ((aρ ⊗ Φ)(b) → ρ(c, b)) = 1. On the other hand,  (aρ ⊗ Φ)ρ () = ((aρ ⊗ Φ)(y) → ρ(, y)) y∈A  
   
  = ((aρ ⊗ Φ)(a) → ρ(, a)) ∧ ((aρ ⊗ Φ)(b) → ρ(, b)) = (0.5 → 0) ∧ (0.5 → 0) = 0.5.  ((aρ ⊗ Φ)(y) → ρ(d, y)) = (0.5 → 0.5) ∧ (0.5 → 0) = 0.5. (a ⊗ Φ)ρ (d) = ρ  
   
  y∈A  
   
  (aρ ⊗ Φ)ρ (e) =  
   
    
   
  ((aρ ⊗ Φ)(y) → ρ(e, y)) = (0.5 → 0) ∧ (0.5 → 0.5) = 0.5.  
   
  y∈A  
   
  These values of the lower bound, by Theorem 1, imply that c ˆ(Φ)(a) = Φ) = c, thus c ˆ(Φ) =  c(Φ1 ).  
   
   ρ (a ⊗  
   
  Now we focus on the commutativity of another parts of the diagram under study, that is, we examine whether F(f ) = (Ψ(f ))1 or (F(f ))≈ = Ψ(f ) for every isotone mapping f : A → A. The answer of the ﬁrst one is aﬃrmative. Proposition 3. The following diagram commutes, (2A , ⊆)    
   
  F  
   
  (Isot(AA ), )       −1   Ψ    (Ext(LA ), ⊆).  
   
  60  
   
  M. Ojeda-Hern´ andez et al.  
   
  Proof. Let f : A → A be an isotone mapping. Then we have, Ψ(f )(x) = 1 if and only if ρ(f (x), x) = 1 if and only if f (x) ≤ x if and only if x ∈ F(f ). Therefore, (Ψ(f ))1 = F(f ). Despite the straightforwardness of the last result, the second equality is not that easy to prove. In fact, in the general case we only have one of the inequalities. Proposition 4. Let f : A → A be an isotone mapping. Then, (F(f ))≈ ⊆ Ψ(f ). Proof. Let f : A → A be an isotone mapping. Then we have, F(f ) = {x ∈ A | f (x) ≤ x}  (x ≈ a) (F(f ))≈ = a∈F (f )  
   
  Ψ(f )(x) = ρ(f (x), x). Let x ∈ A, a ∈ F(f ), then we get, (x ≈ a) = ρ(x, a) ⊗ ρ(a, x) ≤ ρ(f (x), f (a)) ⊗ ρ(a, x)  
   
  by isotonicity of f  
   
  = ρ(f (x), f (a)) ⊗ ρ(f (a), a) ⊗ ρ(a, x) by a ∈ F(f ) ≤ ρ(f (x), x) by transitivity. This argument is valid for all a ∈ F(f ), therefore a∈F (f ) (x ≈ a) ≤ ρ(f (x), x). The following example shows that the inclusion (F(f ))≈ ⊆ Ψ(f ) could be strict, and, therefore, the corresponding diagram does not commute. Example 2. Consider the residuated lattice L and the fuzzy lattice (A, ρ) given in Example 1. Let f ∈ Isot(AA ) with f (⊥) = f (a) = a, f (b) = c, f (c) = f (d) = d and f (e) = f () = . On the one hand, we have that Ψ(f ) = {/0.5, a/1, b/0.5, c/0.5, d/1, e/0.5, /1}. On the other hand, F(f ) = {a, d, } and (F(f ))≈ = {/0.5, a/1, b/0, c/0.5, d/1, e/0.5, /1} = Ψ(f ) Notice that this situation can be improved if the structure of the membership degrees is a Heyting algebra, as the following proposition assures. Proposition 5. Let (A, ρ) be a fuzzy lattice over a Heyting algebra L. The following diagram commutes, (2A , ⊆)   
   
  F  
   
  (Isot(AA ), )      −≈    Ψ     (Ext(LA ), ⊆).  
   
  Commutating Diagrams of Galois Connections  
   
  61  
   
  Proof. For all f ∈ Isot(AA ), since L is a Heyting algebra, by [16, Theorem 4], we have that Ψ(f ) is a fuzzy closure system. Then, by deﬁnition of fuzzy closure system (Deﬁnition 8), we have that ((Ψ(f ))1 )≈ = Ψ(f ). On the other hand, by Proposition 3, we have that (Ψ(f ))1 = F(f ). Therefore, (F(f ))≈ = Ψ(f ). Going back to earlier results, Example 1 shows that the equality c ˆ(Φ) =  c(Φ1 ) does not hold in general. As a matter of fact, as the following example shows, this equality does not even hold in Heyting algebras. Example 3. Let us consider A = {a, b} and the relation ρ given in the following table ρ a b a 1 1 b 0.6 1 The pair (A, ρ) is a fuzzy lattice over the Heyting algebra [0, 1]. For the set c(Φ) is the identity mapping. However,  c(Φ1 ) is the Φ = {a/0.8, b/1} we have that  constant mapping  c(Φ1 )(x) = b for all x ∈ A. Therefore, even under Heyting algebras,  c = ( c ◦ −1 ). Proposition 6. For all X ⊆ A and φ ∈ LA , we have that X ≈ ⊆ Ψ( c(X)) and c(Φ)). Φ1 ⊆ F(  Proof. First, given X ⊆ A, we have that  c(X)(a) = (aρ ⊗ X) for all a ∈ A and, by Theorem 1, it means that ρ(z,  c(X)(a)) = x∈X (ρ(a, x) → ρ(z, x)). Thus, by considering z =  c(X)(a), we have that ρ(a, x) ≤ ρ( c(X)(a), x) for all x ∈ X. Therefore, for all a ∈ A and x ∈ X, we have that (a ≈ x) = ρ(a, x) ⊗ ρ(x, a) ≤ ρ( c(X)(a), x) ⊗ ρ(x, a) ≤ ρ( c(X)(a), a) Since it is true for all x ∈ X, it means that  (a ≈ x) ≤ ρ( c(X)(a), a) = Ψ( c(X))(a) X ≈ (a) = x∈X  
   
  or, equivalently, X ≈ ⊆ Ψ( c(X)).  ∈ A, since  c(Φ)(a) = (aρ ⊗ Φ), by Theorem Consider now Φ ∈ LA . For all a  
   
  1, it means that ρ(z,  c(Φ)(a)) = x∈A ((ρ(a, x) ⊗ Φ(x)) → ρ(z, x)). Thus, by considering z =  c(Φ)(a), we have that, for all x ∈ A, 1 = ρ( c(Φ)(a),  c(Φ)(a)) ≤ (ρ(a, x) ⊗ Φ(x)) → ρ( c(Φ)(a), x) Now, considering x = a, we have that Φ(a) ≤ ρ( c(Φ)(a), a). Finally, since c(Φ)(a), a) = 1}, we conclude that Φ1 ⊆ F( c(Φ)). F( c(Φ)) = {a ∈ A | ρ( Finally, the following example shows that the equalities Ψ( c(X)) = X ≈ and 1 F( c(Φ)) = Φ do not hold in general, even when the underlying structure of membership degrees is a Heyting algebra.  
   
  62  
   
  M. Ojeda-Hern´ andez et al.  
   
  Example 4. Let (A, ρ) be the fuzzy lattice introduced in the previous example. For X = {a} we have that  c(X) is the identity mapping A and Ψ( c(X)) = A. However, X ≈ = {a/1, b/0.6} = A = Ψ( c(X)). On the other hand, for Φ = {a/0.8, b/1} we have that  c(Φ) is the identity mapping and F( c(Φ)) = A, but Φ1 = {b}.  
   
  5  
   
  Conclusions and Further Work  
   
  This paper continues the line of work which initiated in [13], where the mappings that relate fuzzy closure structures are studied from the point of view of fuzzy Galois connections, together with the commutativity of the corresponding diagrams. In [15], the crisp powerset lattice was introduced in that same framework. In this paper, we have completed following commutative diagrams.  (Isot(AA ), )        c  (−1 ,−≈ ) −≈         κ  (Ext(LA ), ⊆) (IsotTot(LA×A ), ) (2A , ⊆)  
   
   c  
   
  (2A , ⊆)  
   
    
   
    
   
  F  
   
  (Isot(AA ), )  
   
         Ψ  (−1 ,−≈ ) −1         Ψ (Ext(LA ), ⊆)  (IsotTot(LA×A ), )  
   
  In addition, when the underlying structure of the membership degrees is a Heyting algebra, the second diagram can be improved, i.e. the following diagram commute: (Isot(AA ), ) (2A , ⊆)  F         Ψ  (−1 ,−≈ ) (−1 ,−≈ )         Ψ (Ext(LA ), ⊆)  (IsotTot(LA×A ), ) As a prospect of future work, we are considering the extension of this work to more general structures, such as fuzzy posets and trellises. Acknowledgment. This research is partially supported by the State Agency of Research (AEI), the Spanish Ministry of Science, Innovation, and Universities (MCIU), the European Social Fund (FEDER) and the Universidad de M´ alaga (UMA) through the FPU19/01467 (MCIU) internship and the research project with reference PID2021127870OB-I00 (MCIU/AEI/FEDER, UE).  
   
  Commutating Diagrams of Galois Connections  
   
  63  
   
  References 1. Bˇelohl´ avek, R.: Fuzzy Galois connections. Math. Log. Q. 45, 497–504 (1999) 2. Bˇelohl´ avek, R.: Fuzzy closure operators. J. Math. Anal. Appl. 262, 473–489 (2001) 3. Bˇelohl´ avek, R.: Fuzzy Relational Systems. Springer, New York (2002). https://doi. org/10.1007/978-1-4615-0633-1 4. Bˇelohl´ avek, R.: Concept lattices and order in fuzzy logic. Ann. Pure Appl. Logic 128(1), 277–298 (2004) 5. Bˇelohl´ avek, R., De Baets, B., Outrata, J., Vychodil, V.: Computing the lattice of all fixpoints of a fuzzy closure operator. IEEE Trans. Fuzzy Syst. 18(3), 546–557 (2010) 6. Biacino, L., Gerla, G.: Closure systems and L-subalgebras. Inf. Sci. 33(3), 181–195 (1984) 7. Caspard, N., Monjardet, B.: The lattices of closure systems, closure operators, and implicational systems on a finite set: a survey. Discret. Appl. Math. 127(2), 241–269 (2003) 8. Fang, J., Yue, Y.: L-fuzzy closure systems. Fuzzy Sets Syst. 161(9), 1242–1252 (2010) 9. Ganter, B., Wille, R.: Formal Concept Analysis: Mathematical Foundation. Springer, Heidelberg (1999). https://doi.org/10.1007/978-3-642-59830-2 10. Liu, Y.-H., Lu, L.-X.: L-closure operators, L-closure systems and L-closure Lsystems on complete L-ordered sets. In: 2010 Seventh International Conference on Fuzzy Systems and Knowledge Discovery, vol. 1, pp. 216–218 (2010) 11. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: On (fuzzy) closure systems in complete fuzzy lattices. In: 2021 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), pp. 1–6 (2021) 12. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: Fuzzy closure relations. Fuzzy Sets Syst. 450, 118–132 (2022) 13. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: Fuzzy closure structures as formal concepts. Fuzzy Sets Syst. (2022). https://doi.org/10.1016/j. fss.2022.12.014 14. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: Fuzzy closure systems: motivation, definition and properties. Int. J. Approx. Reason. 148, 151– 161 (2022) 15. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: Fuzzy closure structures as formal concepts II. Fuzzy Sets and Systems (2023). (Submitted) 16. Ojeda-Hern´ andez, M., Cabrera, I.P., Cordero, P., Mu˜ noz-Velasco, E.: Fuzzy closure systems over Heyting algebras as fixed points of a fuzzy Galois connection. In: Proceedings of the Sixteenth International Conference on Concept Lattices and Their Applications (CLA 2022), vol. 3308, CEUR Workshop Proceedings, pp. 9– 18. CEUR-WS.org (2022) 17. Ore, O.: Galois connexions. Trans. Am. Math. Soc. 55(3), 493–513 (1944) 18. Yao, W., Lu, L.X.: Fuzzy Galois connections on fuzzy posets. Math. Log. Q. 55, 105–112 (2009)  
   
  Scaling Dimension Bernhard Ganter1 , Tom Hanika2,3 , and Johannes Hirth2,3(B) 1  
   
  2  
   
  TU Dresden, Dresden, Germany [email protected]  Knowledge and Data Engineering Group, University of Kassel, Kassel, Germany {tom.hanika,hirth}@cs.uni-kassel.de 3 Interdisciplinary Research Center for Information System Design, University of Kassel, Kassel, Germany  
   
  Abstract. Conceptual Scaling is a useful standard tool in Formal Concept Analysis and beyond. Its mathematical theory, as elaborated in the last chapter of the FCA monograph, still has room for improvement. As it stands, even some of the basic definitions are in flux. Our contribution was triggered by the study of concept lattices for tree classifiers and the scaling methods used there. We extend some basic notions, give precise mathematical definitions for them and introduce the concept of scaling dimension. In addition to a detailed discussion of its properties, including an example, we show theoretical bounds related to the order dimension of concept lattices. We also study special subclasses, such as the ordinal and the interordinal scaling dimensions, and show for them first results and examples. Keywords: Formal Concept Analysis · Data Scaling · Conceptual Scaling · Ferrers Dimension · Measurement · Preprocessing · Feature Compression · Closed Pattern Mining  
   
  1  
   
  Introduction  
   
  When heterogeneous data needs to be analyzed conceptually, e.g., for (closed) pattern mining [11], ontology learning [1] or machine learning [5,10], conceptual scaling [2] is a tool of choice. The task of this method is to translate given data into the standard form, that of a formal context [3]. There are many ways to do this, but not all methods are meaningful in every situation. Often the data has an implicit structure that should guide scaling. For example, it is natural to analyze ordinal data also ordinally. We propose the notion of a pre-scaling to reveal such implicit assumptions and to make them usable for a scaling. Another important aspect is the complexity of the conceptual structure created by scaling. Several authors have suggested only consider important attribute combinations [5,7,12]. We formalize this, speaking of conceptual views of the data. It turns out that such views have a natural characterization in terms of scale measures, i.e., continuous maps with respect to closure systems that are represented by means of formal contexts. This in turn opens the door to basic c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 64–77, 2023. https://doi.org/10.1007/978-3-031-35949-1_5  
   
  Scaling Dimension  
   
  65  
   
  theory questions. We address one of them here for the ﬁrst time: the question of the scaling dimension, i.e., the size of the simplest data set that has the present conceptual structure as its derivative. We study this for the case of ordinal and in particular for that of interordinal scaling, proving characterizations and showing small examples. In addition to our theoretical ﬁndings, we demonstrate the applicability of the scaling dimension based on the drive concepts data set and provide all used functions in the conexp-clj [6] tool.  
   
  2  
   
  Formal Concepts Derived from Data Tables  
   
  At ﬁrst glance, it seems very limiting that Formal Concept Analysis focuses on a single basic data type, that of a binary relation between two sets (a formal context). Data comes in many diﬀerent formats, so why restrict to one type only? But this limitation is intentional. It allows a cleaner separation of objective formal data analysis and subjective interpretation, and it allows a uniﬁed, clear structure of the mathematical theory. FCA handles the many diﬀerent data formats in a two-step process. First, the data is transformed into the standard form – that is, into a formal context – and in the second step that context is analyzed conceptually. The ﬁrst step, called conceptual scaling,1 is understood as an act of interpretation and depends on subjective decisions of the analyst, who must reveal how the data at hand is meant. It is therefore neither unambiguous nor automatic, and usually does not map the data in its full complexity. However, it is quite possible that several such conceptual views together completely reﬂect the data. In machine learning the classiﬁcation data that is used for classiﬁers are usually lists of n-tuples, as in relational databases or in so-called data tables. In FCA terminology, one speaks of a many-valued context. In such a many-valued context, the rows have diﬀerent names (thereby forming a key), and so do the columns, whose names are called (many-valued) attributes. The entries in the table are the values. Formally, a many-valued context D := (G, M, W, I) consists of a set G of objects, a set M of many-valued attributes, a set W of attribute values, and a ternary relation I ⊆ G × M × W satisfying (g, m, v) ∈ I and (g, m, w) ∈ I =⇒ v = w. This condition ensures that there is at most one value for each object-attribute pair. The absence of values is allowed. If no values are missing, then one speaks of a complete many-valued context. The value for the object-attribute pair  
   
  1  
   
  The word “scaling” refers to measurement theory, not whether algorithms can be applied to large data sets.  
   
  66  
   
  B. Ganter et al.  
   
  (g, m), if present, sometimes is denoted by m(g), and m(g) = ⊥ indicates that the value is missing. It was mentioned above that in order to derive a conceptual structure from a many-valued context, Formal Concept Analysis requires the interpretative step of conceptual scaling, which determines the concept-forming attributes which are derived from the many-valued context. Such a formalism is required for this is illustrated by the following example. Suppose that one of the many-valued attributes is “size”, with values “very small”, “small”, “large”, “very large”. A simple approach would be to use the values as attribute names, introducing attributes “size = very small”, “size = small”, etc., with the obvious interpretation: an object g has the attribute “size = small” if m(g) = small when m = size. In this nominal interpretation the attribute extent for the attribute “size = small” contains those objects which are “small”, but excludes those which are “very small”, which perhaps is not intended. To repair this, one could use the implicit order very small < small < large < very large of the values and derived attributes such as size ≤ large, etc. But this interordinal interpretation can equally lead to undesired attribute extents, since the attribute size ≤ large applies to all object which are “very small”, “small”, or “large”, but excludes those for which no value was noted because their size was unremarkable, neither small nor large. A biordinal interpretation can take this into account [3]. 2.1  
   
  Pre-scalings  
   
  Some data tables come with slightly richer information, for which we introduce an additional deﬁnition. A pre-scaling of a many-valued context D := (G, M, W, I) is a family (W (m) | m ∈ M ) of sets W (m) ⊆ W such that W = m∈M W (m) and (g, m, w) ∈ I =⇒ w ∈ W (m) for all g ∈ G, m ∈ M . We call W (m) the value domain of the many-valued attribute m. A tuple (vm | m ∈ M ) matches a pre-scaling iﬀ vm ∈ W (m) ∪ {⊥} holds for all m ∈ M . (G, M, W (m)m∈M , J) may be called a stratified manyvalued context. It is also allowed that the value domains additionally carry a structure, e.g., are ordered. This also falls under the deﬁnition of “pre-scaling”. We remain a little vague here, because its seems premature to give a sharp deﬁnition. Prediger [13] suggests the notion of a relational many-valued context. This may be formalized as a tuple (G, M, (W (m), Rm )m∈M , I), where (G, M, W (m)m∈M , I) is a stratiﬁed many valued-context as deﬁned above, where on each value domain W (m) a family Rm of relations is given. Prediger and Stumme [12] then discuss deriving one-valued attributes using expressions in a suitable logical language, such as one of the OWL-variants. They call this logical scaling.  
   
  Scaling Dimension  
   
  2.2  
   
  67  
   
  Interordinal Plain Scaling  
   
  A scale for an attribute m of a many-valued context (G, M, W (m)m∈M , I) is a formal context Sm := (Gm , Mm , Im ) with W (m) ⊆ Gm . The objects of a scale are the scale values, the attributes are called scale attributes. By specifying a scale a data analyst determines how the attribute values are used conceptually. For plain scaling a formal context (G, N, J) is derived from the manyvalued context (G, M, W (m)m∈M , I) and the scale contexts Sm , m ∈ M , as follows: – The object set is G, the same as for the many-valued context, – the attribute set is the disjoint union of the scale attribute sets, formally  {m} × Mm , N := m∈M  
   
  – and the incidence is given by g J (m, n) :⇐⇒ (g, m, v) ∈ I and v Im n. The above deﬁnition may look technical, but what is described is rather simple: Every column of the data table is replaced by several columns, one for each scale attribute of Sm , and if the cell for object g and many-valued attribute m contains the value v, then that is replaced by the corresponding “row” of the scale. Choosing the scales is already an act of interpretation, deriving the formal context when scales are given is deterministic. Pre-scaling, as mentioned above, may suggest the scales to use. An ordered pre-scaling naturally leads to an interordinal interpretation of data, using only interordinal scales. We repeat the standard deﬁnition of interordinal scaling: Definition 1 (Interordinal Scaling of D). When D := (G, M, W, I) is a many-valued context with linearly ordered value sets (W (m), ≤m ), then the formal context I(D) derived from interordinal scaling has G as its object set and attributes of the form (m, ≤m , v) or (m, ≥m , v), where v is a value of the many valued attribute m. The incidence is the obvious one, an object g has e.g., the attribute (m, ≤m , v) iﬀ the value of m for the object g is ≤m v. Instead of (m, ≤m , v) or (m, ≥m , v) one writes m : ≤ v and m : ≥ v, respectively. Formally I(D) := (G, N, J), where N := {m : ≤ v | m ∈ M, v ∈ W (m)} ∪ {m : ≥ v | m ∈ M, v ∈ W (m)} and (g, m : ≤ v) ∈ J :⇐⇒ m(g) ≤ v,  
   
  (g, m : ≥ v) ∈ J :⇐⇒ m(g) ≥ v.  
   
  For simplicity, attributes which apply to all or to no objects are usually omitted. Remark: The formal context derived from a many-valued context D with linearly ordered value sets via ordinal plain scaling is denoted O(D).  
   
  68  
   
  2.3  
   
  B. Ganter et al.  
   
  Scale Measures and Views  
   
  By deﬁnition, the number of attributes of a derived context is the sum of the numbers of attributes of the scales used, and thus tends to be large. It is therefore common to use selected subsets of these derived attributes, or attribute combinations. This leads to the notion of a view : Definition 2. A view of a formal context (G, M, I) is a formal context (G, N, J), where for each n ∈ N there is a set An ⊆ M such that g J n :⇐⇒ An ⊆ g I . A contextual view of a many-valued context K is a view of a derived context of K; the concept lattice of such a contextual view is a conceptual view of K. In order to compare contexts derived by conceptual scaling, the notion of a scale measure is introduced. Definition 3. Let K := (G, M, I) and S := (GS , MS , IS ) be formal contexts. A mapping σ : G → GS is called an S-measure of K if the preimage σ −1 (E) of every extent E of S is an extent of K. An S-measure is full if every extent of K is the preimage of an extent of S. Proposition 1. A formal context K1 := (G, N, J) is a view of K := (G, M, I) if and only if the identity map is a K1 -measure of K. Proof. When (G, N, J) is a view of (G, M, I), then every extent E of (G, N, J) J is of the form  E = B I for some B ⊆ N . Then E also is an extent of (G, M, I), since E = ( n∈B An ) . Conversely, if the identity map is a (G, N, J)-measure of (G, M, I), then for each n ∈ N the preimage of its attribute extent nJ (which, of course, is equal to nJ ) must be an extent of (G, M, I) and therefore be of the form AIn for some set An ⊆ M . As shown by Proposition 1 there is a close tie between contextual views and canonical representation of scale-measures as proposed in Proposition 10 of Hanika and Hirth [7]. Said representations provide for a scale-measure σ of K into S an equivalent scale-measure based on the identity map of K into a context of the form (G, A, ∈) where A ⊆ Ext(K), i.e., the set of extents. With the now introduced notions we understand the context (G, A, ∈) as contextual view of K.  
   
  3  
   
  Measurability  
   
  A basic task in the theory of conceptual scaling is to decide if a given formal context K is derived from plain scaling (up to isomorphism). More precisely, one would like to decide whether K can be derived using a set of given scales, e.g., from interordinal scaling.  
   
  Scaling Dimension  
   
  69  
   
  A key result here is Proposition 122 of the FCA book [3]. It answers the following question: Given a formal context K and a family of scales S, does there exist some many-valued context D such that K is (isomorphic to) the context derived from plain scaling of D using only scales from S? The proposition states that this is the case if and only if K is fully S-measurable (cf. Deﬁnition 94 in Ganter and Wille [3]), i.e., fully measurable into the semiproduct of the scales in S. Based on this proposition, Theorem 55 of the FCA book also gives some simple characterizations for measurability, one of them concerning interordinal scaling: Theorem 1 (Theorem 55 [3]). A ﬁnite formal context is derivable from interordinal scaling iﬀ it is atomistic (i.e., {g} ⊆ {h} =⇒ {g} = {h} ) and the complement of every attribute extent is an extent. While this characterization may seem very restrictive there are potential applications machine learning. In Hanika and Hirth [5] the authors discuss how Decision Trees or Random Forest classiﬁers can be conceptually understood. Similar investigations have been made for latent representations of neural networks [10]. The nature of the decision process suggests an interordinal scaling on the data set. They study several conceptual views based on interordinal scalings, asking if they can be used to explain and interprete tree based classiﬁers. One of these possibilities they call the interordinal predicate view of a set of objects G with respect to a decision tree classiﬁer T . We refer to Hanika and Hirth [5] for a formal deﬁnition and a thorough investigation of how to analyze ensembles of decision tree classiﬁers via views. Proposition 2. The interordinal predicate view IP (G, T ) is derivable from interordinal scaling. Proof. The interordinal predicate view context is atomistic, as shown in Proposition 1 of Hanika and Hirth [5]. For every attribute P ∈ T (P) we ﬁnd that {P } ∈ Ext(IP (G, T )). We have to show that G \ {P } ∈ Ext(IP (G, T )). This is true since we know that for any predicate P that {P } = {g ∈ G | g |= P }   by deﬁnition and therefore G \ {P } = {g ∈ G | g |= P } = {¬P } , which is an extent. The equality () follows directly from the fact that the many valued context D is complete. Thus, by Sect. 3 the proposition holds. Other characterizations (also in Theorem 55 of the FCA book [3]) show that while every context is fully ordinally measurable, a context is fully nominally measurable iﬀ it is atomistic. Thus every fully interordinally measurable context is also fully nominally measurable. In addition to that, the scale families of contranominal, dichtomic and interordinal scales are equally expressive. While equally expressive, a natural quantity in which these families and scaling in general diﬀers in how complex the scaling is in terms of the size the manyvalued context D. This is expressed by the scaling dimension, to be introduced in the following deﬁnition.  
   
  70  
   
  B. Ganter et al.  
   
  Definition 4 (Scaling Dimension). Let K := (G, M, I) be a formal context and let S be a family of scales. The scaling dimension of K with respect to S is the smallest number d such that there exists a many-valued context D := (G, MD , WD , ID ) with |MD | = d, such that K has the same extents as the context derived from D when only scales from S are used. If no such scaling exists, the dimension remains undeﬁned. The so-deﬁned dimension is related to the feature compression problem. Even when it is known that K can be derived from a particular data table, it may be that there is another, much simpler table from which one can also derive K (cf. Figure 1 for an example). To prove properties of the scaling dimension, we need results about scale measures which were published elsewhere [3,7]. The following lemma follows from Propositions 120 and 122 from Ganter and Wille [3]. Lemma 1. Let D be a complete many-valued context. For every many-valued attribute m of D let Sm := (Gm , Mm , Im ) be a scale for attribute m, i.e., with W (m) ⊆ Gm . Furthermore, let K be the formal context derived from D through plain scaling with the scales (Sm | m ∈ M ). Recall that K and D have the same object set G, and that for every m ∈ M the mapping σm : G → W (m), deﬁned by g → m(g), is a scale measure from K to Sm . Then the extents of K are exactly the intersections of preimages of extents of the scales Sm . A ﬁrst result on the scaling dimension is easily obtained for the case of ordinal scaling. It was already mentioned that every formal context is fully ordinally measurable, which means that every context is (up to isomorphism) derivable from a many-valued context D through plain ordinal scaling. But how large must this D be, how many many-valued attributes are needed? The next proposition gives the answer. For simplicity, we restrict to the ﬁnite case. Proposition 3. The ordinal scaling dimension of a ﬁnite formal context K equals the width of the ordered set of inﬁmum-irreducible concepts. Proof. The width is equal to the smallest number of chains Ci covering the ⊆-ordered set of irreducible attribute extents. From these chains we can construct a many-valued context D with one many-valued attribute mi per chain Ci . The values of mi are the elements of the chain Ci , and the order of that chain is understood as an ordinal prescaling. The derived context by means of ordinal scaling has exactly the set of all  intersections of chain extents as extents (Proposition 120 [3]), i.e., the set of all A where A ⊆ C1 × · · · × Cw . Those are exactly the extents of K. This implies that the scaling dimension is less or equal to the width. But the converse inequality holds as well. Suppose K has ordinal scaling dimension w. Then by Lemma 1 every extent of K is the intersection of preimages of extents of the individual scales. For ∩-irreducible extents this means that they must each be a preimage of an extent from one of the scales. Incomparable extents cannot come from the same (ordinal) scale, and thus the scaling must use at least w many ordinal scales.  
   
  Scaling Dimension  
   
  71  
   
  As a proposition we obtain that the ordinal scaling dimension must be at least as large as the order dimension: Proposition 4 (Ordinal Scaling Dimension and Order Dimension). The order dimension of the concept lattice B(K) is a lower bound for the ordinal scaling dimension of K. Proof. It is well known that the order dimension of B(K) equals the Ferrers dimension of K [3, Theorem 46], which remains the same when K is the standard context. The Ferrers relation is the smallest number of staircase-shaped relations to ﬁll the complement of the incidence relation of K. For a context with ordinal scaling dimension equal to w we can conclude that the (irreducible) attributes can be partitioned into w parts, one for each chain, such that for each part the incidence is staircase-shaped, and so are the nonincidences. Thus we can derive w Ferrers relations to ﬁll all non-incidences. A simple example that order dimension and ordinal scaling dimension are not necessarily the same is provided by any context with the following incidence: ×  
   
  ×  
   
  ×  
   
  Its Ferrers dimension is two, but there are three pairwise incomparable irreducible attributes, which forces its ordinal scaling dimension to be three. A more challenging problem is to determine the interordinal scaling dimension of a context K. We investigate this with the help of the following deﬁnition. Definition 5. An extent ladder of K is a set R ⊆ Ext(K) of nonempty extents that satisﬁes: i) the ordered set (R, ⊆) has width ≤ 2, i.e., R does not contain three mutually incomparable extents, and ii) R is closed under complementation, i.e., when A ∈ R, then also G \ A ∈ R. Note that a ﬁnite (and nonempty) extent ladder is the disjoint union of two chains of equal cardinality, for the following reason: Consider a minimal extent E in the ladder. Any other extent must either contain E or be contained in the complement of E, because otherwise there would be three incomparable extents. The extents containing E must form a chain, and so do their complements, which are all contained in the complement of E. Theorem 2 (Interordinal Scaling Dimension). The interordinal scaling dimension of a ﬁnite formal context K, if it exists, is equal to the smallest number of extent ladders, the union of which contains all meet-irreducible extents of K. Proof. Let K be a formal context with interordinal scaling dimension d. W.l.o.g. we may assume that K was derived by plain interordinal scaling from a manyvalued context D with d many-valued attributes. We have to show that the  
   
  72  
   
  B. Ganter et al. b  
   
  Ib Inew  
   
  a  
   
  Ia  
   
  Fig. 1. This figure displays the a and b feature of five data points and their respective interordinal scales Ia and Ib (black). The interordinal scaling dimension of this data set is one and the respective reduced interodinal scale Inew is depicted in red. The reduction would then remove the a and b data column and substitute it for a new column given by Inew .  
   
  irreducible attribute extents of K can be covered by d extent ladders, but not by fewer. To show that d extent ladders suﬃce, note that the extents of an interordinal scale form a ladder, and so do their preimages under a scale measure. Thus Lemma 1 provides an extent ladder for each of the d scales, and every extent is an intersection of those. Meet-irreducible extents cannot be obtained from a proper intersection and therefore must all be contained in one of these ladders. For the converse assume that K contains l ladders covering all meetirreducible extents. From each such ladder Ri we deﬁne a formal context Ri , the attribute extents of which are precisely the extents of that ladder, and note that this context is an interordinal scale (up to clariﬁcation). Deﬁne a manyvalued context with l many-valued attributes mi . The attribute values of mi are the minimal non-empty intersections of ladder extents, and the incidence is declared by the rule that an object g has the value V for the attribute mi if g ∈ V . The formal context derived from this many-valued context by plain interordinal scaling with the scales Ri has the same meet-irreducible extents as K, and therefore the same interordinal scaling dimension. Thus l ≥ d. Proposition 5. Let w denote the width of the ordered set of meet-irreducible extents of the formal context K. The interordinal scaling dimension of K, if deﬁned, is bounded below by w/2 and bounded above by w. Proof. An extent ladder consists of two chains, and w is the smallest number of chains covering the meet-irreducible extents. So at least w/2 ladders are required.  
   
  Scaling Dimension  
   
  73  
   
  Conversely from any covering of the irreducible extents by w chains a family of w ladders is obtained by taking each of these chains together with the complements of its extents. The last inequality OSD(K) ≤ 2 · ISD(K) results from using each two chains of the extent ladders as ordinal scales, where OSD(K) denotes the ordinal scaling dimension and ISD(K) the interordinal scaling dimension of K. This results in an upper bound for the ordinal scaling dimension and a lower bound for the interordinal scaling dimension. A context where OSD(K) = 2·ISD(K) is depicted in the next section in Fig. 4. Another inequality that can be found in terms of many-valued contexts. For a many-valued context D and its ordinal scaled context O(D) and interordinal scaled context I(D) is the ISD of I(D) in general not equal to the OSD of O(D). Consider for this the counter example given in Fig. 2. The depicted many-valued context has two ordinally pre-scaled attributes that form equivalent interordinal scales. D m1 m2 g1 g2 g3 g4  
   
  1 2 3 4  
   
  d c b a  
   
  Fig. 2. Example many-valued context where the attribute values are ordinally prescaled by 1 < 2 < 3 < 4 and a < b < c < d. The interordinal scaling dimension of I(D) is one and the ordinal scaling dimension of O(D) is two.  
   
  4  
   
  Small Case Study  
   
  To consolidate the understanding of the notions and statements on the (interordinal) scaling dimension we provide an explanation based on a small case example taken from the drive concepts [3] data set. This data set is a many-valued context consisting of ﬁve objects, which characterize diﬀerent ways of arranging the engine and drive chain of a car, and seven many-valued attributes that measure De + C l M + E + R + Dl + Conventional All-Wheel Mid-Wheel Rear-Wheel Front-Wheel  
   
  × × × ×  
   
  × × × ×  
   
  × ×  
   
  × ×  
   
  × × ×  
   
  ×  
   
  ×  
   
  × × × ×  
   
  Fig. 3. The standard context of the drive concepts lattice, cf. Figure 1.13 in Ganter and Wille [3].  
   
  74  
   
  B. Ganter et al.  
   
  Dl +  
   
  R+  
   
  M+  
   
  De +  
   
  De ++, Dl ++ E+  
   
  Cl  
   
  Su  
   
  C m, M ++, De -  
   
  E-  
   
  M-  
   
  C h, S u/n  
   
  Conventional Allwheel  
   
  R ++, Dl -, C vl, E ++ Frontwheel  
   
  S n, E –, M – Midengine  
   
  S o, R – Rearwheel  
   
  Fig. 4. Concept lattice for the context of drive concepts (cf. Figure 1.13 and 1.14 in Ganter and Wille [3]). The extent ladders indicating the three interordinal scales are highlighted in color. The ordinal scaling dimension as well as order dimension of this context is four.  
   
  quality aspects for the driver, e.g., economy of space. The data set is accompanied by a scaling that consists of a mixture of bi-ordinal scalings of the quality (attribute) features, e.g., good < excellent and very poor < poor, and a nominal scaling for categorical features, e.g., for the steering behavior. The concept lattice of the scaled context consists of twenty-four formal concepts and is depicted in Fig. 4. First we observe that the concept lattice of the example meets the requirements to be derivable from interordinal scaling (Sect. 3). All objects are annotated to the atom concepts and the complement of every attribute extent is an extent as well. The interordinal scaling dimension of the scaled drive concept context is three which is much smaller than the original seven many-valued attributes. Using the extent ladder characterization provided in Theorem 2 we highlighted three extent ladders in color in the concept lattice diagram (see Fig. 4). The ﬁrst and largest extent ladder (highlighted in red) can be inferred from the outer most concepts and covers sixteen out of twenty-four concepts. The remaining two extent ladders have only two elements and are of dichotomic scale.  
   
  Scaling Dimension  
   
  5  
   
  75  
   
  Discussion and Future Work  
   
  The presented results on the scaling dimension have a number of interfaces and correspondences to classical data science methods. A natural link to investigate would be comparing the scaling dimension with standard correlation measures. Two features that correlate prefectly, e.g., Fig. 1, induce an equivalent conceptual scaling on the data. An analog of the scaling dimension in this setting would be the smallest number of independent features. Or, less strict, the smallest number of features such that these features do not correlate more than some parameter. This obvious similarity of both methods is breached by a key advantage of our approach. In contrast to correlation measures, our method relies solely on ordinal properties [14] and does not require the introduction of measurements for distance or ratios. Proposition 4 has already shown that there is a relationship between an aspect of the scaling dimension of a formal context and the order dimension of its concept lattice. The assumption that further such relationships may exist is therefore reasonable. Yet, a thorough investigation of these relationships is an extensive research program in its own right and therefore cannot be addressed within the scope of this paper. An investigation on how the scaling dimension relates to other measures of dimension within the realm of FCA [9,15] is therefore deemed future work. Due to novel insights into the computational tractability of recognizing scalemeasures [7] (that is in preparation and will be made public later this year) we have little hope that the scaling dimension and interordinal scaling dimension can be decided in polynomial time. Despite that, eﬃcient algorithms for real-world data that compute the scaling dimension and its speciﬁc versions, i.e., ordinal, interordinal, nominal, etc., may be developed. In addition to that, so far it is unknown if an approximation of the scaling dimension, e.g., with respect to some degree of conceptual scaling error [8] or bounds, is tractable. If computationally feasible, such an approximation could allow larger data sets to be handled. Another line of research that can be pursued in future work is how the scaling dimension can be utilized to derive more readable line diagrams. We can envision that diagrams of concept lattices that are composed of fewer scales, i.e., have a lower scaling dimension, are more readable even if they have slightly more concepts. An open problem that needs to be solved here is: for a context K and k ∈ N identify k scales that cover the largest number of concepts from B(K) with respect to scale measures.  
   
  6  
   
  Conclusion  
   
  With our work, we contributed towards a deeper understanding of conceptual scaling [2]. In particular, we introduced the notion of pre-scaling to formalize background knowledge on attribute domains, e.g., underlying order relations, that can be used and extended to scales in the process of conceptual scaling. To deal with the complexity of scalings selection or logical compression methods  
   
  76  
   
  B. Ganter et al.  
   
  have been proposed to reﬂect parts of the conceptual structure [7]. Furthermore, we introduced the notions of conceptual and contextual views to characterize these methods and provided a ﬁrst formal deﬁnition. We extended the realm of conceptual measurability [4] by the scaling dimension, i.e., the least number of attributes needed to derive a context by the means of plain scaling. This notion does not only provide insight towards the complexity of an underlying scaling but can also be applied for many-valued feature compression. For the identiﬁcation of the scaling dimension, we provided characterizations for the ordinal and interordinal scaling dimension in terms of structural properties of the concept lattice. These employ chains of meet-irreducible extents and newly introduced extent ladders. We demonstrated their applicability based on the drive concepts data set and highlighted the identiﬁed extent ladders and chains in the concept lattice diagram. Our analysis showed that while the manyvalued context consists of seven many-valued attributes an equivalent scaling can be derived from three interordinally scaled or four ordinal scaled many-valued attributes. In addition to the structural characterizations of the scaling dimensions, we provided bounds for the interordinal and ordinal scaling dimension. In detail, we showed upper and lower bounds in terms of the width and the order dimension of the concept lattice. This result shows in particular how far-reaching and therefore necessary a future in-depth investigation of the scaling dimension is.  
   
  References 1. Cimiano, P., Hotho, A., Stumme, G., Tane, J.: Conceptual knowledge processing with formal concept analysis and ontologies. In: Eklund, P. (ed.) ICFCA 2004. LNCS (LNAI), vol. 2961, pp. 189–207. Springer, Heidelberg (2004). https://doi. org/10.1007/978-3-540-24651-0 18 2. Ganter, B., Wille, R.: Conceptual scaling. In: Roberts, F. (eds.) Applications of Combinatorics and Graph Theory to the Biological and Social Sciences. The IMA Volumes in Mathematics and Its Applications, vol. 17, pp. 139–167. Springer, New York (1989). https://doi.org/10.1007/978-1-4684-6381-1 6 3. Ganter, B., Wille, R.: Formal Concept Analysis: Mathematical Foundations. Springer, Berlin, pp. x+284 (1999) 4. Ganter, B., Stahl, J., Wille, R.: Conceptual measurement and many-valued contexts. In: Gaul, W., Schader, M. (eds.) Classification as a tool of research, pp. 169–176. North-Holland, Amsterdam (1986) 5. Hanika, T., Hirth, J.: Conceptual views on tree ensemble classifiers. Int. J. Approximate Reasoning 159, 108930 (2023). https://doi.org/10.1016/j.ijar.2023.108930 6. Hanika , T., Hirth, J.: Conexp-Clj - a research tool for FCA. In: Cristea, D., et al. (ed ) ICFCA (Suppl.), vol. 2378. CEUR-WS.org, pp. 70–75 (2019) 7. Hanika, T., Hirth, J.: On the lattice of conceptual measurements. Inf. Sci. 613, 453–468 (2022). https://doi.org/10.1016/j.ins.2022.09.005 8. Hanika, T., Hirth, J.: Quantifying the conceptual error in dimensionality reduction. In: Braun, T., Gehrke, M., Hanika, T., Hernandez, N. (eds.) ICCS 2021. LNCS (LNAI), vol. 12879, pp. 105–118. Springer, Cham (2021). https://doi.org/10.1007/ 978-3-030-86982-3 8  
   
  Scaling Dimension  
   
  77  
   
  9. Hanika, T., Schneider, F.M., Stumme, G.: Intrinsic dimension of geometric data sets. In: Tohoku Mathematical Journal (2018) 10. Hirth, J., Hanika, T.: Formal conceptual views in neural networks (2022). https:// arxiv.org/abs/2209.13517 11. Kaytoue, M., Duplessis, S., Kuznetsov, S.O., Napoli, A.: Two FCA-based methods for mining gene expression data. In: Ferr´e, S., Rudolph, S. (eds.) ICFCA 2009. LNCS (LNAI), vol. 5548, pp. 251–266. Springer, Heidelberg (2009). https://doi. org/10.1007/978-3-642-01815-2 19 12. Prediger, S., Stumme, G.: Theory-driven logical scaling. In: Proceedings of 6th International Workshop Knowledge Representation Meets Databases (KRDB 1999). Ed. by E. F. et al. vol. CEUR Workshop Proc. 21. Also. In: P. Lambrix et al. (eds.): Proceedings of International WS on Description Logics (DL 1999). CEUR Workshop Proc. vol. 22, 1999 (1999) 13. Prediger, S.: Logical scaling in formal concept analysis. In: Lukose, D., Delugach, H., Keeler, M., Searle, L., Sowa, J. (eds.) ICCS-ConceptStruct 1997. LNCS, vol. 1257, pp. 332–341. Springer, Heidelberg (1997). https://doi.org/10.1007/ BFb0027881 14. Stevens, S.S. On the theory of scales of measurement. Science 103(2684), 677–680 (1946). ISSN: 0036–8075 15. Tatti, N., et al.: What is the dimension of your binary data? In: Sixth International Conference on Data Mining (ICDM 2006), pp. 603–612 (2006)  
   
  Three Views on Dependency Covers from an FCA Perspective Jaume Baixeries1(B) , Victor Codocedo2 , Mehdi Kaytoue3 , and Amedeo Napoli4 1  
   
  Universitat Polit`ecnica de Catalunya, Barcelona, Catalonia [email protected]  2 Instituto para la Resiliencia ante Desastres, Santiago, Chile 3 Universit´e de Lyon. CNRS, INSA-Lyon, LIRIS, Lyon, France 4 Universit´e de Lorraine, CNRS, LORIA, Nancy, France [email protected]   
   
  Abstract. Implications in Formal Concept Analysis (FCA), Horn clauses in Logic, and Functional Dependencies (FDs) in the Relational Database Model, are very important dependency types in their respective ﬁelds. Moreover, they have been proved to be equivalent from a syntactical point of view. Then notions and algorithms related to one dependency type in a ﬁeld can be reused and applied to another dependency type in the other ﬁeld. One of these notions is that of cover, also known as a basis, i.e., a compact representation of a complete set of implications, FDs, or Horn clauses. Although the notion of cover exists in the three ﬁelds, the characterization and the related uses of a cover are diﬀerent. In this paper, we study and compare, from an FCA perspective, the principles on which rely the most important covers in each ﬁeld. Finally, we discuss some open questions that are of interest in the three ﬁelds, and especially to the FCA community.  
   
  Keywords: Functional dependencies Dependency Covers · Closure  
   
  1  
   
  · Implications · Horn Clauses ·  
   
  Introduction and Motivation  
   
  A dependency is a relation between sets of attributes in a dataset. In this paper, they are represented as X → Y , where the type of the subsets of attributes X and Y , and the semantics of → may vary w.r.t. the context. There are many diﬀerent kinds of dependencies: complete and comprehensive surveys, from a Relational Database Theory perspective, can be found in [18] and in [13]. Here, we focus on those dependencies that follow the so called Armstrong axioms, this is, reﬂexivity, augmentation and transitivity, which appear in diﬀerent ﬁelds of computer science: functional dependencies (FDs) in the Relational Database Model, Horn clauses in logic and logic programming, and implications in Formal Concept Analysis. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 78–94, 2023. https://doi.org/10.1007/978-3-031-35949-1_6  
   
  Three Views on Dependency Covers from an FCA Perspective  
   
  79  
   
  Functional dependencies [27] are of paramount importance in the Relational Database Model (RDBM), where they are used to express constraints or rules that need to hold in a database, to help the design of a database or to check for errors and inconsistencies. A set of Horn clauses [16] is a special case of Boolean functions that are crucial in logic programming [19,23] and artiﬁcial intelligence (see [9] for a detailed explanation). Implications are at the core of Formal Concept Analysis (FCA) where they are used to model and deduce relevant information that is contained in a formal context [14,15]. Although all three of them appear in diﬀerent ﬁelds, have been applied on different kinds of data and have been used for diﬀerent purposes, they all share the same axioms, which means that, from a syntactical point of view, they are all equivalent. More speciﬁcally, the equivalence between functional dependencies and Horn clauses is presented in [17,25] (see also [9] for a more detailed explanation). The equivalence between functional dependencies and implications is explained in [15] and the equivalence between implications and Horn clauses is explained in Sect. 5.1 in [14] as well as in [8]. These equivalences allow us to talk in a generic way of Armstrong dependencies or, simply, dependencies. One of the consequences of this equivalence is the transversality of concepts, problems and algorithms between these three ﬁelds. One of the most typical examples is the decision problem of the logical implication which consists in, given a set of dependencies Σ and a single dependency σ, to determine whether σ is logically entailed by Σ, that is, Σ |= σ. Entailment means that σ can be derived from Σ by the iterative application of the Armstrong axioms. This problem is named implication problem in the RDBM [1,20] and FCA ﬁelds, and deduction in logic [9]. It is of capital interest in all three ﬁelds. In the RDBM it allows to test whether two diﬀerent sets of functional dependencies are equivalent [13], and it also allows to compute a more succinct set of functional dependencies, which is relevant to assist the design process of databases [4,22]. In logic the deduction problem is used to check whether a logical expression is consistent w.r.t. a knowledge base and to compute the prime implicants of a Horn function [9]. In Formal Concept Analysis this problem is used, for instance, in attribute exploration [14], which consists in creating a data table (context) in agreement w.r.t. a set of attributes and a set of objects, and also for computing the Duquenne-Guigues basis [11]. Roughly speaking, the computation of the logical implication problem Σ |= X → Y is performed by iterating over Σ and applying the Armstrong axioms to infer new dependencies until a positive or negative answer is found. However, this problem can be reduced to the computation of the closure of X with respect to Σ (closureΣ (X)). This closure returns the largest set such that Σ |= X → closureΣ (X) holds. Therefore, the implication problem Σ |= X → Y boils down to testing whether Y ⊆ closureΣ (X). As an example of transversality, the algorithm that computes closureΣ (X) appears in most of the main database textbooks, where it is called closure [1, 20,27], and also in logic, where it is called forward chaining [9], while in FCA the same algorithm that ﬁrst appeared in the RDBM is discussed and reused in [14]. An improved version of Closure is Linclosure [4]. Both Closure and  
   
  80  
   
  J. Baixeries et al.  
   
  Linclosure have two parameters: a set of attributes X and a set of dependencies Σ. The performance of both algorithms is ﬁrst determined by their worst-case complexity: quadratic in the case of Closure, linear in the case of Linclosure, always with respect to the size of Σ, although the nature and the size of Σ greatly aﬀect the performance of both algorithms outside of the worst case. Another “transversal notion” which is present in all three ﬁelds is the notion of cover. In general terms, it is not suitable to handle the set Σ of all dependencies that hold, because of its potential large size, but rather a subset of Σ that contains the same information and that is signiﬁcantly smaller in size. By “containing the same information” we mean that this subset may generate, thanks to the application of the Armstrong axioms, the complete set Σ. This compact and representative subset is called “cover” in the RDBM, “basis” in FCA and “set of prime implicants” in logic. Moreover, each ﬁeld has deﬁned and used a diﬀerent kind of cover. While in the RDBM this base is the Canonical-Direct Basis or the Minimal Cover, the cover of choice in FCA is the so-called Duquenne-Guigues basis. Both the implication problem and the problem of computing a cover are related: the implication problem is used in the algorithm Canonical Basis (Algorithm 16, page 103 in [14]) to compute the Duquenne-Guigues basis, and it is also used in the algorithm Direct (Sect. 5.4, Chap. 5 in [20]) which is used to compute the Minimal Cover. Again, the transversality of the Armstrong dependencies appears in a general concept (computing a cover) but in diﬀerent forms (Duquenne-Guigues basis and Minimal Cover). The purpose of this study is to present in a single paper the main diﬀerent covers used in the RDBM, in Logic, and in FCA, and to discuss two closely related questions: (i) the computation of the closure of a set of attributes w.r.t. a set of Armstrong dependencies, (ii) the representation of such a set of the dependencies in a cover. To do so, we ﬁrst present both Closure and Linclosure, debate their complexity and the diﬀerent factors that may aﬀect their performance. Afterwards, we review three diﬀerent main covers that appeared in the literature. To the best of our knowledge, this is the ﬁrst time that such a comprehensive study is proposed, where the connections between the relational database model, Logic, and FCA are examined from the implication problem perspective. The paper is organized as follows. Section 2 presents the main aspects of the implication problem in the RDBM, Logic, and FCA. Then Sect. 3 provides the necessary deﬁnitions needed in the paper. Section 4 makes precise the Closure and Linclosure algorithms, while Sect. 5 includes a detailed comparison of the main covers. Finally, Sect. 6 concludes the paper and proposes an extensive discussion about these diﬀerent and important covers.  
   
  2  
   
  The Relevance of the Implication Problem  
   
  In this section we brieﬂy explain why the implication problem, that is, to check whether a dependency σ can be derived from a set of dependencies Σ by the  
   
  Three Views on Dependency Covers from an FCA Perspective  
   
  81  
   
  iterative application of the Armstrong axioms is of importance in RDBM, logic, and FCA. We start by quoting the survey [13] which comes from the Relational Database ﬁeld: Most of the papers in dependency theory deal exclusively with various aspects of the implication problem, that is, the problem of deciding for a given set of dependencies Σ and a dependency σ whether Σ logically implies σ. The reason for the prominence of this problem is that an algorithm for testing implication of dependencies enables us to test whether two given sets of dependencies are equivalent or whether a given set of dependencies is redundant. A solution for the last two problems seems a signiﬁcant step towards automated database schema design, which some researchers see as the ultimate goal for research in dependency theory. In what way are those two problems a signiﬁcant step towards automated database schema design and what is the reason of the prominence of the implication problem? Functional dependencies are used to design relational schemes (see for example the extensive Chap. 12.2 Nonloss decomposition and functional dependencies in [10]). However, some of the FDs that are used to describe the data base may be redundant in the sense that they are derivable from the others. These (redundant) FDs used to assist this method of schema design will induce redundancy in the relational schema, which is to be avoided since redundancy in relations creates serious problems in maintaining a consistent data base. Hence, one needs to be able to compute a covering (here we will use the term cover ) of a set of dependencies, this is, a non-redundant set of FDs that yields the same closure with respect to the axioms for FDs. And, the problem of ﬁnding a covering reduces to computing the predicate σ ∈ Σ + , that is, Σ |= σ (all portions of text in italic are citations from [6]). Summing up, the implication problem for FDs is of importance because it solves the problem of computing a cover of a set of FDs which, in turn, prevents the propagation of redundancy in the design of a database scheme using functional dependencies. In FCA, the basic data structure is the binary context which can have two related representations, namely the concept lattice and the basis of implications. The latter is the Duquenne-Guigues basis which is unique, minimal, and non redundant (see 5). There is an equivalence between these three views of an initial dataset. Moreover, one can be also interested in the so-called equivalence classes which are associated with one closed set and possibly several generators of diﬀerent types [21]. A typical implication is related to any equivalence class which is of the form X → Y where Y is a closed set and closure(X) = Y . Then, a minimal basis has all its importance since it provides a summary of the dataset under study with a minimum number of elements. In particular, the number of implications in say the Duquenne-Guigues basis is much smaller than the number of concepts, that is, a substantial number of implications can be inferred from this minimum basis. This is also of importance when the problem of construction or reconstruction is considered, that is, starting with a set of  
   
  82  
   
  J. Baixeries et al.  
   
  implications, design the whole related dataset. This problem is present in the RDBM, in Logic and especially in the design of a theory or of an ontology, and as well in FCA with the attribute exploration process [14].  
   
  3  
   
  Definitions  
   
  In this section we introduce the deﬁnitions used in this paper. We do not provide the references for all of them because they can be found in all the textbooks and papers related to the RDBM, Logic and FCA. As explained in the introduction, implications [15], functional dependencies [20] and Horn clauses [16] are dependencies between sets of attributes, which are equivalent from a syntactical point of view, since they are in agreement with the Armstrong axioms. Definition 1. Given set of attributes U, for any X, Y, Z ⊆ U, the Armstrong axioms are: 1. Reflexivity: If Y ⊆ X, then X → Y holds. 2. Augmentation. If X → Y holds, then XZ → Y Z holds. 3. Transitivity. If X → Y and Y → Z hold, then X → Z holds. When we write that a dependency X → Y holds, we mean all the instances in which this dependency is valid or true. Therefore, the sentence “If X → Y holds, then XZ → Y Z holds” can be rephrased as “In any instance in which X → Y is valid, the dependency XZ → Y Z is valid as well”. The Armstrong axioms allow us to deﬁne the closure of a set of dependencies as the iterative application of these axioms over a set of dependencies. Definition 2. Σ + denotes the closure of a set of dependencies Σ, and can be constructed thanks to the iterative application of the Armstrong axioms over Σ. This iterative application terminates when no new dependency can be added, and it is ﬁnite. Therefore, Σ + contains the largest set of dependencies that hold in all instances in which all the dependencies in Σ hold. The closure of a set of dependencies induces the deﬁnition of the cover of such a set of dependencies. Definition 3. The cover or basis of a set of dependencies Σ is any set Σ  such that Σ + = Σ + . We deﬁne now the concept of a closure of a set of attributes X ⊆ U with respect to a set of implications Σ. Definition 4. The closure of X with respect to a set of dependencies Σ is closureΣ (X) = { Y | X → Y ∈ Σ + } that is, closureΣ (X) is the largest set of attributes Y such that X → Y can be derived by the iterative application of the Armstrong axioms over the set Σ. This closure operation returns the largest set of attributes such that Σ |= X → closureΣ (X). Therefore, the implication problem Σ |= X → Y boils down to testing whether Y ⊆ closureΣ (X).  
   
  Three Views on Dependency Covers from an FCA Perspective  
   
  4  
   
  83  
   
  Algorithms to Compute the Closure of a Set of Attributes  
   
  Below we review two most well-known algorithms to compute closureΣ . 4.1  
   
  The Closure Algorithm  
   
  The ﬁrst algorithm Closure appears in most of the main database textbooks, e.g., [1,20,27], and also in logic, where it is called forward chaining [9]. In Formal Concept Analysis the same algorithm that ﬁrst appeared in the RDBM is reused as for example in [14].  
   
  Function Closure(X, Σ) Input : A set of attributes X ⊆ U and a set of implications Σ Output: closureΣ (X) 1 2 3 4 5 6 7 8 9 10 11 12  
   
  stable ← false while not stable do stable ← true forall A → B ∈ Σ do if A ⊆ X then X ←X ∪B stable ← f alse Σ ← Σ \ {A → B} end end end return X  
   
  // Outer loop // Inner loop  
   
  In Table 1 we list diﬀerent complexities of Closure as they are given in a classic database textbook [20], a FCA textbook [14] and the pioneer paper of Linclosure [4]1 . In general terms, the complexity of Closure depends on its two loops which are marked in the code as outer and inner loops. This algorithm iterates in the outer loop as long as there is a change in the computation of closureΣ (X). This means that in the worst case, the closure may be incremented by only one single attribute at each iteration of the outer loop, which implies that the outer loop is of order O(|U|). Regarding the inner loop, it necessarily iterates over all the dependencies that are in Σ, that is, it is of order O(|Σ|). Then the total number of iterations, in the worst case, is of order O(|U| × |Σ|). Since in some cases it may happen that |Σ| = |U|, the complexity of this algorithm can be, in the worst case, of order O(|Σ|2 ). 1  
   
  Other relevant textbooks on RDBM line [1, 27] provide the same complexity analysis as in Table 1.  
   
  84  
   
  J. Baixeries et al.  
   
  However, there are two extra comments about this complexity analysis. First, we have stated that the inner loop (line 4) iterates over all the dependencies in Σ, but all the dependencies that have been used to compute closureΣ (X) are deleted in line 8. But even if this removal is performed, the number of iterations is still of order |Σ|, since in the worst case, we may remove only one single dependency from Σ at each iteration of the inner loop. Also, in line 5, there is a subset containment check of order O(|U|) that is performed as many times as there are iterations of the inner loop. This fact, which is only considered in [20], induces a complexity of order O(|U| × |Σ|2 ). As we can observe in Table 1, the consensus is that the complexity of Closure is of order O(|Σ|2 ) (in the worst case scenario |U| = |Σ|). However, in cases when |U| 2 or m > 2. c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × × × × × × × a2 × × × a3 × × × × × × o1 o2 o3  
   
  c1 × × ×  
   
  c2 c 3 × × × o4  
   
  c1 c2 c3 c1 c2 c3 × × × × × × × × × × × × o5 o6  
   
  Fig. 9. A 6 × 3 × 3 B3,3 tricontext.  
   
  Let us start with the case n = m and illustrate with n = m = 3 without loss of generality. As the n + m irreducible rectangles have to appear somewhere, if we want to construct a Bn,m tricontext on n + m − 1 objects, we have to put two irreducible rectangles on the same object. For instance, ({a1 , a2 }, {c1 , c2 , c3 }) and ({a1 , a2 , a3 }, {c2 , c3 }). c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × × × × a2 × × × ××× a3 ×× ××× ××× o1 o2 o3  
   
  c1 × × ×  
   
  c2 c3 × × × o4  
   
  c1 c2 c3 c1 c2 c3 × × × × × × o5 o6  
   
  However, if we do this, their intersection ({a1 , a2 }, {c2 , c3 }) is not the description of a triconcept anymore. The ({a1 , a2 }, {c2 , c3 }) rectangle must thus appear as a maximal rectangle in the description of another object. The only option is to put it on its own object and then we go back to having n + m objects. From there, being able to construct a Bn,m tricontext on n + m − 1 objects implies being able to construct a Bn−1,m−1 tricontext on n + m − 3 objects (in the greyed area) as two objects are already taken by the two irreducible rectangles and their intersection.  
   
  A Triadic Generalisation of the Boolean Concept Lattice  
   
  103  
   
  c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × ×× a2 × × × ×× a3 ×× o1 o2 o3 o4 o5 It is possible to construct a B2,2 tricontext with 3 objects (see Fig. 8): two pairs of irreducible rectangles are put on two objects and both their intersections coexist on a third object. To show that this is only one way to do so, up to permutation of rows and columns, is left as an exercise for the reader. The construction of a hypothetical B3,3 tricontext on 5 objects would thus proceed as follows: c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × ×× ×× × × ×× × ×× × a2 × × × a3 ×× o1 o2 o3 o4 o5 As the irreducible rectangles still need to appear somewhere, the only way to have them appear without destroying the B2,2 subcontext is thus as follows: c1 c2 c3 c1 c2 c3 c1 c2 a1 × × × ×× ×× ×× × a2 × × × ×× ×× a3 o1 o2 o3  
   
  c3 × × ×  
   
  c1 × × ×  
   
  c2 c3 c1 c2 c3 × × ×× × ×× o4 o5  
   
  The coexistence of irreducible rectangles on the same object again causes their intersection to stop being descriptions of triconcepts, so we have to add ({a1 , a3 }, {c1 , c3 }) and ({a2 , a3 }, {c1 , c2 }) as maximal rectangles in the description of an object. One of them can be added to the description of o5 but it can be seen that none of them can be added to the description of o2 . For example, adding ({a2 , a3 }, {c1 , c2 }) would cause ({a2 }, {c2 , c3 }) to stop being the description of a triconcept, creating the need for a sixth object. We are thus stuck, and conclude that B3,3 trilattices require at least 6 objects. From this we deduce that Bn,n trilattices require at least 2n objects (Fig. 10). c1 c2 c3 c1 c2 c3 c1 c2 a1 × × × × × × × a2 × × × × × × × × × × a3 o1 o2 o3  
   
  c3 × × ×  
   
  c1 × × ×  
   
  c2 c3 c1 c2 c3 c1 c2 c3 × × × × × × × × × × × × × × o4 o5 o6  
   
  Fig. 10. Another way to build a B3,3 trilattice on 6 objects.  
   
  Now, we show analogously that B2,m trilattices require at least 2 + m objects. We illustrate on a B2,3 trilattice but assert that the same construction and reasoning apply  
   
  104  
   
  A. Bazin  
   
  to m > 3. As for the 3 × 3 case, all irreducible rectangles in a 2 × m crosstable have to appear in the description of an object. c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × × ×× ××× a2 × × × × ×× ××× o1 o2 o3 o4 o5 In order to reduce the number of objects, two such rectangles have to be put on the same object. Their intersection ceases to be the description of a triconcept so we have to put it on its own object. c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × × × a2 × × o1 o2 o3 o4 If it is possible to construct a B2,m trilattice on 2 + m − 1 objects, then it is possible to construct a B1,m−1 trilattice on 2 + m − 3 objects. It is the case here. In order to complete the tricontext so that all irreducible rectangles appear as maximal rectangles in the description of an object, the unused horizontal irreducible rectangle (({a2 }, {c1 , c2 , c3 }) here) has to coexist with another irreducible rectangle. Their intersection thus has to appear as a maximal rectangle in the description of another object and it easy to see, on such a small example, that it is impossible without having rectangles cease to be descriptions of triconcepts (adding it to o2 would cause ({a1 }, {c1 }) to stop being the description of a triconcept). c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 c1 c2 c3 a1 × × × × × × × ×× a2 × × ××× ×× × × o1 o2 o3 o4 o5 Hence, Bn,m trilattices require at least n + m objects when either n > 2 or m > 2.  
   
  6 Discussion and Conclusion The generalisation of Boolean concept lattices proposed in this paper is only one of many but we feel that its properties are interesting for both pattern mining and the study of the maximal size of concept trilattices. The latter is still an open question as, for instance, powerset trilattices are not the biggest trilattices that can be built in a n × n × n tricontexts and do not fit. The next step would be to further generalise these structures to the n-dimensional case. The definition is straightforward but our proof of the minimum number of objects required to build the trilattice is hardly scalable as it relies on handmade contexts that would be too big and numerous in higher dimensions. We also plan on further studying the structure of the classes of trilattices/n-lattices defined in Sect. 3 and the consequences of that loss of duality on implications. Acknowledgements. This work was supported by the ANR SmartFCA project Grant ANR-21CE23-0023 of the French National Research Agency.  
   
  A Triadic Generalisation of the Boolean Concept Lattice  
   
  105  
   
  References 1. Albano, A., Chornomaz, B.: Why concept lattices are large: extremal theory for generators, concepts, and VC-dimension. Int. J. Gen Syst 46(5), 440–457 (2017) 2. Bazin, A.: On implication bases in n-lattices. Discrete Appl. Math. 273, 21–29 (2020) 3. Biedermann, K.: Powerset trilattices. In: Mugnier, M.-L., Chein, M. (eds.) ICCSConceptStruct 1998. LNCS, vol. 1453, pp. 209–221. Springer, Heidelberg (1998). https:// doi.org/10.1007/BFb0054916 4. Biedermann, K.: An equational theory for trilattices. Algebra Univers. 42, 253–268 (1999). https://doi.org/10.1007/s000120050002 5. Birkhoff, G.: Lattice Theory, vol. 25. American Mathematical Society (1940) 6. Ferr´e, S., Cellier, P.: Graph-FCA: an extension of formal concept analysis to knowledge graphs. Discrete Appl. Math. 273, 81–102 (2020) 7. Ganter, B., Kuznetsov, S.O.: Pattern structures and their projections. In: Delugach, H.S., Stumme, G. (eds.) ICCS-ConceptStruct 2001. LNCS (LNAI), vol. 2120, pp. 129–142. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-44583-8 10 8. Ganter, B., Obiedkov, S.: Implications in triadic formal contexts. In: Wolff, K.E., Pfeiffer, H.D., Delugach, H.S. (eds.) ICCS-ConceptStruct 2004. LNCS (LNAI), vol. 3127, pp. 186– 195. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-27769-9 12 9. Ganter, B., Wille, R.: Formal Concept Analysis: Mathematical Foundations. Springer, Heidelberg (2012) 10. Lehmann, F., Wille, R.: A triadic approach to formal concept analysis. In: Ellis, G., Levinson, R., Rich, W., Sowa, J.F. (eds.) ICCS-ConceptStruct 1995. LNCS, vol. 954, pp. 32–43. Springer, Heidelberg (1995). https://doi.org/10.1007/3-540-60161-9 27 11. Poelmans, J., Ignatov, D.I., Kuznetsov, S.O., Dedene, G.: Fuzzy and rough formal concept analysis: a survey. Int. J. Gen Syst 43(2), 105–134 (2014) 12. Rouane-Hacene, M., Huchard, M., Napoli, A., Valtchev, P.: Relational concept analysis: mining concept lattices from multi-relational data. Ann. Math. Artif. Intell. 67(1), 81–108 (2013). https://doi.org/10.1007/s10472-012-9329-3 13. Voutsadakis, G.: Polyadic concept analysis. Order 19(3), 295–304 (2002)  
   
  Applications and Visualization  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set Mike Behrisch1,2(B) 1  
   
  and Leon Renkin1,3  
   
  Institute of Discrete Mathematics and Geometry, Technische Universit¨ at Wien, Vienna, Austria 2 Institut f¨ ur Algebra, Johannes Kepler Universit¨ at Linz, Linz, Austria [email protected]  , [email protected]  3 Department of Mathematics, ETH Z¨ urich, Z¨ urich, Switzerland  
   
  Abstract. We use a formal concept theoretic approach to computationally validate the classiﬁcation of all 192 centralising monoids on threeelement sets by Machida and Rosenberg. We determine a manageable ﬁnite (and row-reduced) context the intents of which are exactly all centralising monoids on {0, 1, 2}. As an advantage of our method, we are able to compute a list with a witness for each of the 192 monoids, which has not been available to date and allows for an immediate veriﬁcation of the ﬁgure 192 as a lower bound for the number of centralising monoids. We also conﬁrm that the 192 centralising monoids split into 48 conjugacy classes and we provide a list of all conjugacy types including witnesses.  
   
  Keywords: Centralising monoid  
   
  1  
   
  · Witness · Context reduction  
   
  Introduction  
   
  Commutation of unary functions f, g : A → A in the sense f (g(x)) = g(f (x)) for all x ∈ A has a natural generalisation to operations f : An → A and g : Am → A of higher arities m, n ∈ N. We say that f and g commute, and denote this as f ⊥ g, if for every matrix X ∈ Am×n with rows r1 , . . . , rm ∈ An and columns c1 , . . . , cn ∈ Am the following equation with m · n arguments holds: f (g(c1 ), . . . , g(cn )) = g(f (r1 ), . . . , f (rm )).  
   
  (†)  
   
  If we write the row-wise application (f (r1 ), . . . , f (rm )) of f to the matrix X as f (X) and if X  denotes the transpose of X, then we may restate the commutation property in the form f (g(X  )) = g(f (X)) for all X ∈ Am×n , which resembles the familiar statement for m = n = 1. The content of this article is based on the bachelor dissertation [25] of the secondnamed author. The ﬁrst-named author gratefully acknowledges partial support by the Austrian Science Fund (FWF) under project number P33878. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨ urrschnabel and D. L´ opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 109–126, 2023. https://doi.org/10.1007/978-3-031-35949-1_8  
   
  110  
   
  M. Behrisch and L. Renkin  
   
   n Condition (†) deﬁnes a binary relation ⊥ on the set OA = n∈N+ AA of all ﬁnitary operations on A and as such an (inﬁnite) context Kc = (OA , OA , ⊥) that we refer to as the context of commutation. Since ⊥ is a symmetric relation, both derivation operators on Kc are identical: for any F ⊆ OA they compute F ∗ := { g ∈ OA | ∀f ∈ F : f ⊥ g}, the centraliser of F . Therefore, the systems of intents and extents of Kc each coincide with the set C A = I (Kc ) = E (Kc ) of all so-called centraliser clones on A, i.e., with all those F ⊆ OA satisfying F ∗∗ = F (such sets of operations are also called bicentrally closed ). Commuting functions have found applications in aggregation theory in relation with the task of merging (aggregating) matrix data into a single value, cf. [2, 4,9,12,13] for more information. In particular, sets F of aggregation functions such that F ⊆ F ∗ , called bisymmetric in aggregation theory, have been subject to investigation, see [9,10]; in algebra such sets are simply called self-commuting and the algebras they induce are said to be entropic, generalising the classic notion of mediality for groupoids, quasigroups and semigroups, cf., e.g., [15,23]. For ﬁnite sets A, the lattice C A of all centralisers is ﬁnite [8, Corollary 4], but even for small sets A its structure is quite complicated and well  still not very   understood. Thus, the unary parts M := F ∗(1) = s ∈ AA  ∀f ∈ F : f ⊥ s of centralisers have received special attention in recent work, see, e.g. [2,3,6,11,16–   21]. They are the intents of the (still inﬁnite) subcontext1 K1 = OA , AA , ⊥ of Kc , and since they always form transformation monoids, they have been termed centralising monoids. Clearly, the representation of a centralising monoid M in the form M = F ∗(1) is not unique, and any set F ⊆ OA satisfying this condition is called a witness of M . It is, however, immediate that the corresponding extent M ∗ = F ∗(1)∗ ⊇ F is always a maximal witness of M under set inclusion. For f : An → A and s : A → A, condition (†) specialises to the requirement f (s(x1 ), . . . , g(xn )) = s(f (x1 , . . . , xn ))  
   
  (‡)  
   
  for all x1 , . . . , xn ∈ A, which precisely expresses that s is an endomorphism of the algebra A; f . Therefore, for F ⊆ OA the functions s ∈ F ∗(1) are exactly the endomorphisms of the algebra A; F , i.e., F ∗(1) = End A; F . In other words, this means that for ﬁxed A the (dually ordered) intent lattice of K1 is precisely the lattice of all possible endomorphism monoids of any possible algebraic structure on A, ordered by set inclusion. By inspecting the lattice, one may locate endomorphism monoids that are so-called ‘cores’, which is relevant for determining the complexity of solving systems of equations over algebras. This article is concerned with the task of computationally enumerating all centralising monoids on a three-element set A, of giving witnesses for them in an automated fashion and of counting them. Rephrased in terms of algebraic structures, this means determining the elements and cardinality of the lattice of 1  
   
  For brevity we shall forego restricting the general commutation relation by intersection with OA ∩AA even though this would be required to be meticulously correct.  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  111  
   
  endomorphism monoids on a three-element set, and, for each monoid, presenting an algebra such that the monoid is its endomorphism monoid. For |A| ≤ 2, every transformation monoid appears as the endomorphism monoid of some algebra. Machida and Rosenberg in [16] initiated a systematic study of centralising monoids (at the time called endoprimal monoids) on ﬁnite sets with a description of three co-atoms in the lattice of centralising monoids on {0, 1, 2}. This investigation was continued with the witness lemma from [17], giving a simple to check characterisation of when a set F ⊆ OA is a witness of a centralising monoid M on some set A. With the help of the witness lemma, Machida and Rosenberg determined (by hand) all 51 centralising monoids on A = {0, 1,  by unary functions, that is, the set of intents of the sub 2} witnessed context AA , AA , ⊥ of K1 . Moreover, Theorem 2.5 from [17] states the fundamental fact that every centralising monoid on a ﬁnite set A can be described by a ﬁnite witness, and a more reﬁned version of the proof of [17, Theorem 2.5] will also be central for our investigations. In [18] it was observed that each maximal centralising monoid, i.e., a co-atom in the lattice under inclusion, can always be witnessed by a single minimal function appearing in the classiﬁcation of minimal clones. Exploiting this connection for |A| = 3, precisely 10 maximal centralising monoids and corresponding singleton witnesses were determined in [18]. Extending these arguments, in [19] a strategy to determine all centralising monoids on {0, 1, 2} was presented, and it was reported that their total number amounts to 192, splitting into 48 conjugacy types [19, Table 3]. Unfortunately, due to page restrictions, [19] does not contain complete details on how the monoids were obtained, nor a full list of all the monoids or any of their witnesses. The idea behind the proof is to consider all possible submonoids of each of the ten maximal centralising monoids and to sort out those that fail to be centralising. Failures are demonstrated by showing that a submonoid M is not closed under the intent-closure of K1 , i.e., that M ∗∗(1)  M ; the remaining ones are veriﬁed to be centralising by constructing witnesses, either directly, or by intersecting other already known centralising monoids. These steps are also outlined in the extended version [21] of [19], where tables with all 192 centralising monoids on {0, 1, 2} can be found2 . Both papers contain a few exemplary applications of the method sketched above, however, many details of how the 192 monoids on {0, 1, 2} were computed and why they form a complete list are not given, neither in [19], nor in [21]. In particular, a complete step by step proof, as well as a list of 192 witnesses that would at least allow for straightforward checking of the given 192 monoids is still lacking. We note that, in theory, one could use the corresponding extent M ∗ as a maximal witness for each listed monoid M , but as M ∗ is inﬁnite, it does not lend itself well to an automated check. We are therefore interested in a computer-supported, mostly automated veriﬁcation of Rosenberg and Machida’s classiﬁcation of all centralising monoids on A = {0, 1, 2}. For any ﬁnite set A, this is, in principle, a ﬁnite task, since there can be at most as many intents of K1 as there are subsets of AA , but this naive |A| upper bound 2|A| already for |A| = 3 gives 227 = 134 217 728, which is every2  
   
  Based on Sect. 4, our computations [5] will show that these are actually correct.  
   
  112  
   
  M. Behrisch and L. Renkin  
   
  thing but small.3 However, as the number of intents (and thus concepts) of K1 is ﬁnite, only a ﬁnite (in view of the number 192 from [21] possibly very small) portion of the inﬁnite set OA of objects of this context will actually be needed to discern all concepts. Still, a priori, it is not altogether clear where to make the cut, and ﬁnding a suitable division line will be a key challenge that we solve in this paper. With a little analysis (cf. [22, Theorem 3.1]) one can see—and we will also observe this as a consequence of our Theorem 14—that functions of  |A|  arity |A| suﬃce as objects, that is, the ﬁnite subcontext K|A|,1 = AA , AA , ⊥ has the same set of intents as K1 , i.e., it describes all centralising monoids on A. However, for |A| = 3, this still gives 327 ternary operations as objects, which is even more unwieldy than 227 and certainly too large in order to enumerate all concepts of K3,1 with basic formal concept analysis tools. In fact, already storage of K3,1 would become problematic, even if each cross in the table only took one bit of memory.   We will call a set W ⊆ OA witness-complete if I (K1 ) = I W, AA , ⊥ , that is, if every centralising monoid M on A possesses a witness F ⊆ W . Clearly, every superset of a witness-complete set W ⊆ OA remains witness-complete. In the terminology of formal concept analysis, witness-complete sets W correspond to speciﬁc dense subcontexts of K1 where the attribute set is not restricted. By |A| results of [22], for ﬁnite A the object set WA = AA is always ﬁnite and witnesscomplete. However, the previous discussion makes clear that already for |A| = 3 we need to be more precise and determine a much smaller witness-complete set in order to be able to enumerate the intents of K1 in a reasonable amount of time. This is what we will achieve by a careful analysis of the commutation relation of K1 in Sect. 3. We then describe how to implement our approach in practice, in order to obtain an object-clariﬁed subcontext K of (WA , AA , ⊥), where WA is still witness-complete and, for the case |A| = 3, contains only 183 functions as objects. Moreover, for the carrier set {0, 1, 2}, we will be able to present a rowreduced subcontext K of K with only 51 objects, from which one obtains the standard context of K1 by only deleting two redundant attributes. By computing the concept lattice of K (or K ), we will be able to verify the total number 192 of centralising monoids on {0, 1, 2} given by Machida and Rosenberg in [19] and to check that there are 48 conjugacy types of them. Moreover, the concepts will allow us to present the list of monoids including their witnesses, which turns at least any future veriﬁcation of the ﬁgure 192 as a lower bound into an immediate task. To infer the completeness of this list of 192 monoids, one still has to trust the correctness of Machida and Rosenberg’s or our computations. In order to facilitate that, we shall deposit the code we used and supplementary data in [5].  
   
  3  
   
  Since our purpose is to verify the results of [19], we are not going to rely on the bound 192 for the number of concepts.  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  2  
   
  113  
   
  Preliminaries  
   
  We ﬁrst introduce some notation regarding operations that has not already been explained in the introduction. Furthermore, we recollect some known facts that will be necessary to study the context K1 . We write N = {0, 1, 2, . . . } for the set of natural numbers and abbreviate N+ := N\ {0}. We denote the set of functions from B to A as AB . If f : C → B and g : B → A, we understand their composition from right to left, that is, g ◦ f : C → A maps any x ∈ C to g(f (x)) ∈ A. For n ∈ N, an n-ary operation on A is just a map f : An → A; the parameter n is referred to as the arity of f . For a unary constant operation with value a ∈ A we use the notationca : A → A. n We collect all ﬁnitary (non-nullary) operations on A in the set OA = n∈N+ AA . n For a set F ⊆ OA and n ∈ N, we denote by F (n) := F ∩ AA its n-ary part, n n (n) in particular we have OA = AA . Moreover, we set F (≤n) := j=0 F (j) . With   (1) this notation, the context K1 becomes OA , OA , ⊥ , and for |A| = k ∈ N we  (k) (1)  have Kk,1 = OA , OA , ⊥ . We also understand tuples x ∈ An as maps x = (x(0), . . . , x(n − 1)) from n = {0, . . . , n − 1} into A; given 0 ≤ i < n, we often write xi for x(i). We are thus able to compose tuples with maps h : A → B from the outside, givn ing h ◦ x = (h(x0 ), . . . , h(xn−1  )) ∈ B I, or with maps α : I → n from then inside, resulting in x ◦ α = xα(i) i∈I ∈ A . In this way, if n, m ∈ N, f : A → A and α : n → m, we can deﬁne the minor of f induced by α as the operation δα f : Am → A given by δα f (x) := f (x ◦ α) for all x ∈ Am . Computing minors is functorial, that is, if we take another index map β : m →  with  ∈ N, then we have δβ (δα f )(x) = δα f (x ◦ β) = f (x ◦ β ◦ α) = δβ◦α f (x) for all x ∈ A , implying δβ (δα f ) = δβ◦α f , i.e., δβ ◦ δα = δβ◦α . Moreover, δidn f = f , i.e., δidn = idO(n) . If α A is non-injective, arguments of f get identiﬁed by δα f ; if α is non-surjective, δα f will incur ﬁctitious arguments. We will call those minors of f where α is surjective identiﬁcation minors (or just variable identiﬁcations) of f , and we will speak of proper variable identiﬁcations if α is surjective, but not injective. The former notion necessitates that n ≥ m for α : n → m, and the latter that m < n. A particulary relevant example of a proper variable identiﬁcation is given for 0 ≤ i < j < n by the map αij : n → n−1, deﬁned as αij () :=  if 0 ≤  ≤ j−1, αij (j) := i and αij () := −1 if j +1 ≤  < n. We will call Δij f := δαij f the (i, j)-variable identiﬁcation (minor) of f ; let us note that Δij f (x0 , . . . , xn−2 ) = f (x0 , . . . , xj−1 , xi , xj , . . . , xn−2 ) for all x0 , . . . , xn−2 ∈ A. We will say that a set F ⊆ OA is closed under (proper) variable identiﬁcations if it contains with each member f ∈ F also any (proper) identiﬁcation minor of f . We will use an analogous deﬁnition for F ⊆ OA being closed under taking general minors.  
   
  114  
   
  M. Behrisch and L. Renkin  
   
  For n ∈ N+ and 0 ≤ i < n, we deﬁne the i-th n-ary projection to be the opera(n) (n) (n) tion ei ∈ OA given by ei (x0 , . . . , xn−1 ) := xi for every (x0 , . . . , xn−1 ) ∈ An . (1) The operation idA = e0 is the identity operation on A. For n, m ∈ N+ and (n) (m) f ∈ OA , g0 , . . . , gn−1 ∈ OA , we deﬁne their composition h := f ◦(g0 , . . . , gn−1 ) (m) as the operation h ∈ OA given for x ∈ Am by h(x) := f (g0 (x), . . . , gn−1 (x)). A (n) clone on A is any set F ⊆ OA such that ei ∈ F for every n ∈ N+ and 0 ≤ i < n and F is closed under composition, that is, we require f ◦ (g0 , . . . , gn−1 ) ∈ F whenever f, g0 , . . . , gn−1 ∈ F are of matching arities. The following basic lemma about clones is evident. Lemma 1. If F ⊆ OA is a clone, then it is closed under taking minors. Proof. For n, m ∈ N+ , f ∈ F (n) , α : n → m, the minor δα f can be expressed as   (m) (m)   a composition of f and projections: δα f = f ◦ eα(0) , . . . , eα(n−1) ∈ F . We shall need the fact that all centralisers are clones. For this we will introduce the notion of polymorphism of a set of relations. For m ∈ N, an m-ary relation on A is just any subset  ⊆ Am . The set of all relations on A of any possible (n) arity m ∈ N+ is denoted as RA . We say that an operation f ∈ OA preserves  if for all tuples r1 , . . . , rn ∈  it is the case that the m-tuple f ◦ (r1 , . . . , rn ) obtained by component-wise application of f also belongs to . We symbolise the truth of this fact by f  . The set of polymorphisms of a set Q ⊆ RA of relations is then deﬁned as Pol Q := { f ∈ OA | ∀ ∈ Q : f  }, i.e., it is one derivation operator of the context (OA , RA , ). It is well known that the extents, that is, all polymorphism sets, are clones. Lemma 2 ([24, 1.1.15 Satz]). For any Q ⊆ RA the set Pol Q is a clone on A. We can represent centralisers as polymorphism clones by understanding the functions that are centralised as relations via their graphs. That is, for n ∈ N+    (n) and f ∈ OA we deﬁne f • := (x0 , . . . , xn ) ∈ An+1  f (x0 , . . . , xn−1 ) = xn to be the graph of f , and we set F • := { f • | f ∈ F } for any F ⊆ OA . Then we have the following (also well-known) connection to the centraliser of F . ¨ 2.10, p. 75]). For every F ⊆ OA we have F ∗ = Pol F • . Lemma 3 ([24, Ub. As centralisers are the central topic of this article, we supply a short proof.  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  115  
   
  Proof Let m, n ∈ N, g ∈ OA and f ∈ F (m) . If g ∈ Pol F • , then g  f • and thus for any matrix (xij )1≤i≤m,1≤j≤n ∈ Am×n we have ⎛ ⎞ (n)  
   
  ⎜ ⎝  
   
  g(x11 ,...,x1n )  
   
  .. .  
   
  g(xm1 ,...,xmn ) g(f (x11 ,...,xm1 ),...,f (x1n ,...,xmn ))  
   
  ⎟ • ⎠∈f ,  
   
  since for each 1 ≤ j ≤ n the column (x1j , . . . , xmj , f (x1j , . . . , xmj )) belongs to f • . The latter is equivalent to g(f (x11 , . . . , xm1 ), . . . , f (x1n , . . . , xmn )) being equal to f (g(x11 , . . . , x1n ), . . . , g(xm1 , . . . , xmn )), whence g ⊥ f . For the converse implication, we start from g ∈ F ∗ , implying g ⊥ f and thus entailing the truth of the previous equality. Therefore, g indeed maps any n tuples in f • , which are given as the columns of an (m × n)-matrix extended by an additional row of   column values, into f • . Hence g preserves f • . Corollary 4. For any F ⊆ OA , the centraliser F ∗ is a clone, and is hence closed under taking minors, in particular, it is closed under variable identiﬁcations. Proof. By Lemma 3, F ∗ = Pol F • is a polymorphism set, which by Lemma 2 is a clone and therefore closed under taking minors, see Lemma 1.   Another direct consequence of Corollary 4 is that each centralising monoid F ∗(1) is a transformation monoid, for it is the unary part of the clone F ∗ and thus contains idA and is closed under composition. With respect to centralising monoids we also cite the following result from [22], which we will improve in Theorem 14. Lemma 5 ([22, Theorem 3.1]). Any centralising monoid M on a ﬁnite set A (≤k) has a ﬁnite witness F ⊆ OA consisting of functions of arity at most k = |A|. We also need a description of centralisers of constants, which is easy to verify. Lemma 6 ([18, Lemma 5.2],[6, Lemma 5]). For any set A and every a ∈ A ∗ we have {ca } = Pol {{a}}, i.e., for f ∈ OA we have f ⊥ ca iﬀ f (a, . . . , a) = a.  
   
  3  
   
  Finding Witness-Complete Sets  
   
  The following simple observation lies at the basis of our construction of witnesscomplete sets. (n)  
   
  (1)  
   
  Lemma 7. Let n ∈ N, 0 ≤ i < j < n, f ∈ OA and s ∈ OA . Moreover, let a = (a0 , . . . , an−1 ) ∈ An be such that ai = aj and s(f (a)) = f (s ◦ a). Then Δij f ∗ has arity n − 1 and does not belong to {s} .  
   
  116  
   
  M. Behrisch and L. Renkin  
   
  Proof. Since aj = ai and thus also s(aj ) = s(ai ), we have s(Δij f (a0 , . . . , aj−1 , aj+1 , . . ., an ) = s(f (a0 , . . . , aj−1 , ai , aj+1 , . . . , an )) = s(f (a0 , . . . , aj−1 , aj , aj+1 , . . . , an )) = f (s(a0 ), . . . , s(aj−1 ), s(aj ), s(aj+1 ), . . . , s(an )) = f (s(a0 ), . . . , s(aj−1 ), s(ai ), s(aj+1 ), . . . , s(an )) = Δij f (s(a0 ), . . . , s(aj−1 ), s(aj+1 ), . . . , s(an )), whence Δij f fails to commute with s on the tuple (a0 , . . . , aj−1 , aj+1 , . . . , an−1 )   in An−1 . The following result collects basic properties of non-commuting operations of least possible arity. (1)  
   
  Proposition 8. Let A be a ﬁnite set, s ∈ OA , F ⊆ OA be closed under proper ∗ variable identiﬁcations and f ∈ F \ {s} be of minimal arity n ∈ N+ . Then the following facts hold: (i) (ii) (iii) (iv)  
   
  ∗  
   
  Every proper variable identiﬁcation of f belongs to {s} . The arity n is bounded above by |A|, that is, n ≤ |A|. For every non-injective tuple a ∈ An we have s(f (a)) = f (s ◦ a). There is some injective tuple b ∈ An for which s(f (b)) = f (s ◦ b).  
   
  Proof. Let m < n and α : n → m be any surjective (and necessarily noninjective) map. Since F is closed under proper variable identiﬁcations and f ∈ F , ∗ we have δα f ∈ F (m) . As f has least possible arity in F \ {s} and m < n, the ∗ ∗ / {s} must fail, for otherwise δα f would belong to F \ {s} . condition δα f ∈ ∗ Hence, δα f ∈ {s} , proving (i). If a = (a0 , . . . , an−1 ) is any non-injective tuple in An , then there are indices 0 ≤ i < j < n such that ai = aj . As F is closed under proper variable identiﬁcations, Δij f ∈ F (n−1) . If s(f (a)) = f (s ◦ a), then, by Lemma 7, we have ∗ Δij f ∈ F (n−1) \ {s} , in contradiction to the minimality of n. Hence, we have (iii). ∗ Since f ∈ / {s} there must be some tuple b ∈ An for which s(f (b)) = f (s ◦ b). By (iii), this tuple cannot be non-injective, thus b is injective and (iv) holds. If n were larger than |A|, then every n-tuple would be non-injective, hence a tuple b as promised in (iv) could not exist. Thus, we have n ≤ |A|, i.e., (ii).   In order to sharpen Lemma 5, we shall rely on the following result. (1)  
   
  Lemma 9. For any ﬁnite set A and each s ∈ OA , there exists ns ∈ N, subject to 1 ≤ ns ≤ |A| := k, such that for every F ⊆ OA that is closed under proper ∗ ∗ variable identiﬁcations, the implication F  {s} =⇒ F (≤ns )  {s} holds. ∗ If, moreover, F is closed under taking minors, then F  {s} even implies ∗ F (ns )  {s} .  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  117  
   
  (1)  
   
  Proof. Let s ∈ OA and an identiﬁcation closed set F ⊆ OA be ∗ given, and assume that F  {s} . This means there exists some opera∗ tion f ∈ F \ {s} ; let us choose such a function f of minimum possible Proposition 8(ii) we have ns,F ≤ k, wherefore arity ns,F  ∈ N+ . From ∗ Is := ns,G | G  {s} closed w.r.t. proper variable identiﬁcations is a nonempty subset of {1, . . . , k}, and hence ns := max Is satisﬁes 1 ≤ ns ≤ k. As ∗ ∗ ns,F ∈ Is , we infer ns,F ≤ ns ≤ k. Thus, f ∈ F (ns,F ) \ {s} ⊆ F (≤ns ) \ {s} , ∗ and therefore F (≤ns )  {s} . If we assume F to be closed under minors in general, then we can use the ﬁctitious minor g := δα f ∈ F , where α : ns,F → ns ∗ ∗ is the identical embedding, to prove that g ∈ F (ns ) \ {s} , i.e., F (ns )  {s} . Namely, by using the identiﬁcation map β : ns → ns,F given as β() :=  for indices 0 ≤  < ns,F and β() := ns,F − 1 else, we have β(α()) = β() =  for 0 ≤  < ns,F , and thus β ◦ α = idns,F . By functoriality of taking minors, ∗ / {s} , which by Corolwe conclude δβ g = δβ (δα f ) = δβ◦α f = δidns,F f = f ∈ ∗ ∗ lary 4 implies that indeed g ∈ / {s} , for otherwise the centraliser {s} would have   to contain the minor δβ g = f . As an immediate consequence we may uniformly take ns = |A| for every (1) s ∈ OA to satisfy the implication of Lemma 9 on a ﬁnite set A. (1)  
   
  Corollary 10. For any ﬁnite set A of size |A| = k, each s ∈ OA and every ∗ F ⊆ OA satisfying F  {s} and being closed under proper variable identiﬁca∗ tions, we have F (≤k)  {s} . (1)  
   
  Proof. Given s ∈ OA , take ns ≤ k constructed in Lemma 9. Then any function ∗ set F  {s} that is closed under proper variable identiﬁcations fulﬁls, again by ∗ ∗   Lemma 9, ∅ = F (≤ns ) \ {s} ⊆ F (≤k) \ {s} , as required. (1)  
   
  For any ﬁnite set A of size |A| = k and every s ∈ OA , Lemma 9 guarantees ∗ the existence of a smallest arity ns ∈ {1, . . . , k} such that every F  {s} ∗ (≤ns ) that is closed under variable identiﬁcations satisﬁes F  {s} . We shall mainly exploit this implication for very speciﬁc types of clones, in fact, speciﬁc (1) centraliser clones, and it may well be that for some s ∈ OA there exists a smaller arity ns which satisﬁes the implications claimed by Lemma 9 under this restriction. We shall not explore ﬁnding the smallest possible value of ns in detail, except for simple but important cases. ∗  
   
  Lemma 11. If s = idA or s = ca for some a ∈ A, then F  {s} implies ∗ F (1)  {s} for all F ⊆ OA that are closed under proper variable identiﬁcations. ∗  
   
  Proof. If s = idA the implication holds since the assumption F  {s} = OA is never satisﬁed. Let us hence consider s = ca with a ∈ A. By Lemma 6 we know ∗ ∗ {ca } = Pol {{a}}, thus for any F ⊆ OA we have F \ {ca } = ∅ iﬀ there is f ∈ F such that f (a, . . . , a) = a, i.e., iﬀ there is f ∈ F for which δα f (a) = a holds with α being the unique map into 1 = {0}. Assuming that F is closed under proper variable identiﬁcations, we have δα f ∈ F (1) , hence the previous condition ∗ ∗   implies that F (1) \ {ca } = ∅, or equivalently F (1)  {ca } .  
   
  118  
   
  M. Behrisch and L. Renkin  
   
  In our construction of witnesses for ﬁnite A we shall follow the proof outlined (1) in [17, Theorem 2.5], but we treat each s ∈ OA individually and exploit minimal arities of counterexamples to commutation, thus being able to obtain a smaller (|A|) witness-complete set than OA . Keeping Proposition 8(i) in mind, we ﬁrst (1) deﬁne the following set Φs,n for each s ∈ OA and n ∈ N+ . (1)  
   
  Definition 12. For s ∈ OA and each n ∈ N+ , we set   (n)  Φs,n := f ∈ OA  ∀0 ≤ m < n ∀surjective α : n  m :  
   
  ∗  
   
  δα f ∈ {s}  
   
    
   
  .  
   
  For computational purposes, the following characterisation is useful. (1)  
   
  Lemma 13. Given any s ∈ OA and n ∈ N+ we have the equivalent description    (n)  ∗ Φs,n = f ∈ OA  ∀0 ≤ i < j < n : Δij f ∈ {s}    (n)  ∗ = f ∈ OA  ∀0 ≤ m < n ∀α : n → m : δα f ∈ {s} . ∗  
   
  Proof. If f ∈ Φs,n and 0 ≤ i < j < n, then clearly Δij f = δαij ∈ {s} because αij : n  n − 1 is surjective and non-injective due to i < j. For the second (n) ∗ inclusion assume that f ∈ OA satisﬁes Δij f ∈ {s} for all 0 ≤ i < j < n and consider any m < n and any α : n → m. As m < n, the map α cannot be injective, hence there are 0 ≤ i < j < n for which α(i) = α(j). By our assumption ∗ we have Δij f ∈ {s} . We deﬁne β : n − 1 → m by β() := α() if 0 ≤  < j and β() := α( + 1) if j ≤  ≤ n − 2. Hence, β(αij ()) = β() = α() if 0 ≤  < j, β(αij (j)) = β(i) = α(i) = α(j), and β(αij ()) = β( − 1) = α( − 1 + 1) = α() for all j <  < n. Thus, we have β ◦ αij = α, and, by functoriality of taking ∗ minors, we infer δβ ◦ δαij = δβ◦αij = δα , that is, δα f = δβ (Δij f ) ∈ {s} because ∗ ∗ Δij f ∈ {s} and the centraliser {s} is closed under minors by Corollary 4. The  remaining containment relation in Φs,n obviously follows by specialisation.  We now provide the theoretical backbone for constructing smaller witnesscomplete sets. The result is obtained by reﬁning the proof techniques used in [17, Theorem 2.5] and [22, Theorem 3.1]. Theorem 14. Let A be a ﬁnite set of size |A| = k, and let (ns )s∈O(1) \{idA } (1)  
   
  A  
   
  be any tuple of integers 1 ≤ ns ≤ k such that for each  s ∈ OA \ {idA } the implication claimed byLemma 9 is satisﬁed. Setting Φs := 1≤≤ns Φs, for each s = idA , the set Φ := s∈O(1) \{id } Φs is witness-complete w.r.t. K1 . A  
   
  (1)  
   
  A  
   
  Proof. Let M ⊆ OA be a centralising monoid, i.e., an intent of K1 . Thus, M = M ∗∗(1) is intent-closed, hence M = F ∗(1) for the witness F = M ∗ . We observe from Corollary 4 that F = M ∗ is closed under arbitrary minors, in particular under (proper) variable identiﬁcations. We want to reduce F to a subset G ⊆ F ∩ Φ that still witnesses M . Clearly, we have G∗(1) ⊇ F ∗(1) = M for any G ⊆ F ; the crucial point is to keep enough functions of F ∩ Φ in G  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  119  
   
  such that this inclusion does not become proper. In other words, we need to (1) ensure that G∗(1) ⊆ M , or, equivalently, that the complement of M in OA has empty intersection with G∗ . For this reason, we consider an arbitrary function (1) (1) / M = F ∗(1) , s ∈ OA \M ; since idA ∈ M , we have s = idA . As s ∈ OA but s ∈ ∗ ∗ there is some fs ∈ F = M where fs ⊥ s fails, i.e., fs ∈ F \ {s} . Let us, in fact, ∗ choose fs ∈ F \ {s} of least possible arity n ∈ N+ . From Proposition 8(i) we ∗ know that every proper variable identiﬁcation of fs belongs to {s} , i.e., that ∗ ∗ fs ∈ Φs,n . Since fs ∈ F \ {s} we have F  {s} ; moreover, F is closed under (proper) variable identiﬁcations. Therefore, we can invoke Lemma 9 to conclude ∗ ∗ that F (≤ns )  {s} , which means that there is some gs ∈ F \ {s} of arity m ≤ ns . ∗ Since by our choice fs had minimum possible arity in F \ {s} , it follows that n ≤ m ≤ ns . Therefore, we have fs ∈ Φs,n ⊆ Φ s ⊆ Φ. Picking now  one such fs (1)  
   
  for each s = idA , we have found a subset G = fs | s ∈ OA \M ⊆ F ∩ Φ, for   (1) (1) which OA \M ∩ G∗ = ∅ since every s ∈ OA \M does not commute with its ∗  
   
  chosen fs ∈ F \ {s} . Thus G∗(1) ⊆ M = F ∗(1) ⊆ G∗(1) and G ⊆ Φ is a witness of M .   Corollary 10 allows us to instantiate all values ns in Theorem 14 in the form (≤k) ns = k = |A|, wherefore Φs ⊆ OA for each s = idA , and thus the theorem (≤k) produces a witness-complete set Φ ⊆ OA . As every superset of a witness(≤k) complete set retains this property, we conclude that OA is witness-complete, i.e., Lemma 5 is a special case of Theorem 14. For practical application we shall combine Theorem 14 with the idea of object-clariﬁcation. We say that objects f, g ∈ OA of K1 are equivalent in K1 , and denote this fact by f ≡ g, if they witness the same centralising monoid, that ∗(1) ∗(1) is, {f } = {g} . A transversal picks exactly one representative from each ≡-class, and we will now proceed to show that any superset of a transversal of a witness-complete set is still suitable for our purpose. Proposition 15. Let A be a set, W ⊆ OA be witness-complete w.r.t. K1 and let T ⊆ OA be such that each f ∈ W is equivalent to some g ∈ T ; then T is also witness-complete. Proof. Let M = F ∗(1) ⊆ OA be a centralising monoid, witnessed by F ⊆ W . We deﬁne G := { g ∈ T | ∃f ∈ F : f ≡ g} ⊆ T , and claim that G∗(1) = F ∗(1) = M . Since F ⊆ W , for each f ∈ F there is some gf ∈ T such that f ≡ gf , that ∗(1) ∗(1) = {gf } . By deﬁnition of G we have gf ∈ G, wherefore we obtain is, {f }    ∗(1) ∗(1) ∗(1) = f ∈F {gf } ⊆ g∈G {g} = G∗(1) . Conversely, F ∗(1) = f ∈F {f } each g ∈ G is equivalent to some f ∈ F by the deﬁnition of G. Hence, by a symmetric argument, we infer G∗(1) ⊆ F ∗(1) , and thus M = F ∗(1) = G∗(1) with G ⊆ T.    
   
  120  
   
  4  
   
  M. Behrisch and L. Renkin  
   
  Computing All Centralising Monoids on {0, 1, 2}  
   
  In principle,  it is possible  to apply the steps shown in this section to sim(1) plify K1 = OA , OA , ⊥ for any ﬁnite set A. However, for |A| ≤ 2 the problem is trivial, and in view of data from [1,6], it seems unlikely that the approach shown here will be feasible for |A| ≥ 4 from a computational perspective. We shall therefore only discuss the case A = {0, 1, 2} = 3 in this section. Let us deﬁne the integer sequence (ns )s∈O(1) by ns := 1 if s = id3 or s = ca 3 with 0 ≤ a < 3, and ns := 3 else. By Corollary 10 and Lemma 11, this sequence can be used as a parameter in Theorem 14 to produce an initial witness-complete  (1) (≤2) set Φ = s∈O(1) \{id3 } Φs . Since Φca ⊆ O3 and Φs,n ⊆ O3 for n ≤ 2 and any 3  (1) (≤2) (1) s ∈ O3 , we have Φ ⊆ O3 ∪ s∈U 3 Φs,3 where U 3 := O3 \ {id3 , c0 , c1 , c2 }. Let ι : 1 → 2 be the identical inclusion; we certainly have u ≡ δι u for any (1) (2) u ∈ O3 , where δι u ∈ O3 is u with a ﬁctitious argument added. Thus, by  (2) Proposition 15, the set T := O3 ∪ s∈U 3 Φs,3 is witness-complete. Our goal is to enumerate a superset of T , to clarify it and use it as objects of a subcontext ∗ of K1 : For each s ∈ U 3, we can easily enumerate all binary operations in {s}  (2)  by brute force, as O3  = 39 = 19 683. Then, for any f ∈ Φs,3 where s ∈ U 3 , we ∗  
   
  know from Lemma 13 that Δ01 f, Δ02 f, Δ12 f ∈ {s} . Moreover, for any x ∈ A and ij ∈ {01, 02, 12}, we must have f (x, x, x) = Δij f (x, x), that is, the functions Δ01 f, Δ02 f, Δ12 f must be ‘compatible on the diagonal’. Thus we will be enumerating all f in a superset Ψs ⊇ Φs,3 if we iterate over all possible combi∗(2) that are nations of g1 , g2 , g3 ∈ {s}  compatible on the diagonal, iterate over S all functions h ∈ A where S = (x, y, z) ∈ A3  x = y = z = x and deﬁne f (x, y, z) := g1 (y, z) if x = y, f (x, y, z) := g2 (x, y) if x = z, f (x, y, z) := g3 (x, y) if y = z, and f (x, y, z) := h(x, y, z) if (x, y, z) ∈ S. While enumerating the  (2) witness-complete superset O3 ∪ s∈U 3 Ψs ⊇ T , we can apply Proposition 15 on ∗(1)  
   
  the ﬂy by not storing a function f as an object a second time if its intent {f } has already been encountered before. This drastically reduces the amount of  (2) stored functions to a witness-complete subset W ⊆ O3 ∪ s∈U 3 Ψs such that   (1) |W | = 183 and K = W, O3 , ⊥ is an object-clariﬁed subcontext of K1 with identical set of intents. The context K can be found in [25, Sections 7.2, 7.3]. We remark that the computation of K for |A| = 3 is feasible for the following (1) ∗(2) reasons. Brute-force enumeration of {s} for s ∈ O3 is not of any concern. The crucial point, however, lies in the ability to exploit Lemma 11 to reduce the (1) union over all s ∈ O3 \ {id3 } in Φ to the union over all s ∈ U 3 in T . Namely,  ∗(2)  maxs∈U 3 {s}  = 162, while a constant ca commutes with all 38 = 6 561 binary operations b satisfying b(a, a) = a (Lemma 6). Luckily, AS  = 36 = 729 is small. The core loop in the enumeration of W [5] thus reduces from at most  3 (33 − 1) · 36 · 38 = 5 353 169 434 460 874  33+6+24 = 333 loop iterations to only ≤ 23 · 36 · 1623 = 71 285 369 976 intent computations, the true number being even further below at 1 196 142 471.  
   
  Computing Witnesses for Centralising Monoids on a Three-Element Set  
   
  121  
   
  Once K is known, we can employ standard formal concept analysis methods for further simpliﬁcation, such as object reduction, yielding the context K with only 51 objects (see Table 1), or full reduction, leading to the standard context of K1 , which only diﬀers from K by deleting the superﬂuous attribute id3 and by merging the mutually inverse cyclic permutations s = (0 1 2) and s−1 = (2 1 0) into a single attribute. The standard context ([5], [25, Section 7.4]) is therefore not explicitly shown. We have performed these tasks as well as the computation of all concepts with the help of readily available implementations such as [7,14]. Remark 16. In order to present the context K (see Table 1), we introduce some notation for its objects and attributes. The objects are certain binary and ternary functions on {0, 1, 2} that we represent by their value tuples (ai )0≤i 2 on n + 1 nodes. Let mis(Pn | k) denote the number of MIS of Pn that contain node k (the nodes are numbered from the left end to the right end starting from 0). To obtain MIS in Pn containing n we can simply extend each MIS of Pn−2 containing n − 2 and each MIS of Pn−3 containing n − 3 by adding node n, i.e., mis(Pn | n) = mis(Pn−3 | n − 3) + mis(Pn−2 | n − 2). Similarly, mis(Pn | n − 1) = mis(Pn−3 | n − 3) + mis(Pn−3 | n − 4). However, mis(Pn−3 | n − 3) = mis(Pn−2 | n − 3). Therefore, an = mis(Pn | n) + mis(Pn | n − 1) = an−2 + an−3 since an−2 = mis(Pn−2 | n − 2) + mis(Pn−2 | n − 3) and an−3 = mis(Pn−3 | n − 3) + mis(Pn−3 | n − 4) by the disjointness of any two MIS families that contain diﬀerent neighbouring nodes. Corollary 1. Let Qn be a hypercube then  the number of maximal independent sets obtained as the union of its levels [n] k has the following generation function: x2 + 2x + 1 . 1 − x2 − x3 Proof. Let g(x) =  
   
  ∞  n=0  
   
  an xn be the generating function of an . From Theorem 1  
   
  we have ∞   
   
  an xn =  
   
  n=3  
   
  ∞   
   
  an−2 xn +  
   
  n=3  
   
  ∞   
   
  an−3 xn .  
   
  n=3  
   
  Further, g(x) − a0 − a1 x − a2 x2 = x2 (g(x) − a0 ) + x3 g(x) or g(x)(1 − x2 − x3 ) = a0 + a1 x + (a2 − a0 )x2 . Corollary 2. Let Qn be a hypercube then   the number of maximal independent is as follows: sets obtained as the union of its levels [n] k a(n) =  
   
   z∈ {α,β,γ}  
   
  7  
   
  [n] k  
   
  are subsets of [n] of size k.  
   
  1 2 + 2z + z 2 , where z n 2z + 3z 2  
   
  160  
   
  D. I. Ignatov  
   
  α is the real root of x3 + x2 = 1 and β and γ are the complex conjugate roots. Proof. It immediately follows from Theorem 1 and the solution for the general linear third-order recurrence equation an = Aan−1 + Ban−2 + Can−3 [18].   
   
  an = a1  
   
  z∈ {α,β,γ}  
   
  z −n − (Aa1 − a2 ) A + 2zB + 3z 2 C  
   
   z∈ {α,β,γ}  
   
    
   
  − (Ba1 + Aa2 − a3 )  
   
  z∈ {α,β,γ}  
   
  z 1−n A + 2zB + 3z 2 C  
   
  z 2−n , where A + 2zB + 3z 2 C  
   
  α, β, γ are the roots of Ax + Bx2 + Cx3 = 1.  √  √ The value ρ = 1/α = 3 9+18 69 + 3 9−18 69 = 1.3247179572... is known as the plastic number and describes Perrin8 and Padovan9 sequences via similar expressions. Proposition 2. The asymptotic behaviour of an is an ∼  
   
  2ρ2 + 2ρ + 1 1 2 + 2α + α2 . = ρn n 2 α 2α + 3α 2ρ + 3  
   
  Proof. From  Corollary 2 we know is the real root of x3 + x2 = 1, i.e.  that α √ √ 3 1 3 1 1 α = 3 (−1 + 2 (25 − 3 69) + 2 (25 + 3 69)) ≈ 0.75488, while β and γ are the conjugate roots β ≈ −0.87744 − 0.74486i and γ ≈ −0.87744 + 0.74486i. Since the absolute values of α and β are both greater than 1 (≈ 1.151), the reciprocals of the powers of these roots tend to 0 for large n, and we can omit the terms containing them from the asymptotic formula. The obtained approximation is very accurate even for the beginning values in Table 1. Table 1. an and its approximation n  
   
  0  
   
  1  
   
  2  
   
  3  
   
  4  
   
  5  
   
  6  
   
  7  
   
  8  
   
  9  
   
  10  
   
  an  
   
  1  
   
  2  
   
  2  
   
  3  
   
  4  
   
  5  
   
  7  
   
  9  
   
  12  
   
  16  
   
  21  
   
  1.68  
   
  2.22  
   
  2.95  
   
  3.90  
   
  5.17  
   
  6.85  
   
  9.07  
   
  12.02 15.92 21.10  
   
  approximation 1.27 relative error  
   
  0.211 0.191 0.101 0.018 0.025 0.0328 0.022 0.008 0.002 0.005 0.004  
   
  Theorem 1 does not say much about the structure of the obtained solutions, however, its proof contains a direct way to enumerate and count these MIS. 8 9  
   
  https://oeis.org/A001608. https://oeis.org/A000931.  
   
  Maximal Independence Polynomial of Hypercube  
   
  161  
   
  Our Python-based implementation helped to identify the following MIS for n = 6 and n = 7 in Table 2. The sizes of the obtained MIS tell us which coefﬁcients in the maximal independence polynomials are non-zeros. Moreover, we can easily reconstruct the found MIS via the indices k (saying which subsets of which size should be taken from the vertices of Qn ). Table 2. Indices k of MIS in the form n = 6 Indices 0, 2, 4, 6 0, 2, 5 Size 32 22  
   
   [n] k  
   
  0, 3, 5 27  
   
  k  
   
  along with the MIS sizes for Q6 and Q7  
   
  0, 3, 6 22  
   
  1, 3, 5 1, 3, 6 32 27  
   
  1, 4, 6 22  
   
  n = 7 Indices 0, 2, 4, 6 0, 2, 4, 7 0, 2, 5, 7 0, 3, 5, 7 0, 3, 6 1, 3, 5, 7 1, 3, 6 1, 4, 6 1, 4, 7 Size 64 58 44 58 43 64 49 49 43  
   
  4.2  
   
  Lattice-Based Results  
   
  Let K(Qn ) = (2[n] , 2[n] , I) be a formal context obtained from the adjacency matrix of a hypercube Qn as follows: for g, m ∈ 2[n] gIm ⇐⇒ A(Qn )mg = 1, where A(Qn ) is the adjacency matrix of Qn . Then, the complementary context of K(Qn ) is Kc (Qn ) = (2[n] , 2[n] , (2[n] × [n] 2 ) \ I). From the comparison of the known number of formal concepts |Kc (Qn )| and mis(Qn ) in Table 3, we make the following conjecture. Table 3. Known mis(Qn ) and |B(Kc (Qn ))| values n  
   
  0 1 2 3  
   
  4  
   
  5  
   
  6  
   
  mis(Qn )  
   
  1 2 2 6  
   
  42  
   
  1 670  
   
  1 281 402  
   
  |B(Kc (Qn ))| 1 4 4 36 1 764 2 788 900 1 641 991 085 604  
   
  Conjecture 1. mis(Qn ) =  

  |B(Kc (Qn ))| .  
   
  Property 1. If Conjecture 1 is valid, then the parity of mis(Qn ) coincides with the parity of |B(Kc (Qn ))|. Property 2. If Conjecture 1 is valid, then the number of concepts of Kc (Qn ) with the non-equal extent and intent of equal sizes is even.  
   
  162  
   
  D. I. Ignatov  
   
  Proof. Since every maximal independent set S is in one-to-one correspondence with (S, S), the formal concept of Kc (Qn ), mis(Qn ) = |M+ (Qn )|, where M+ (Qn ) = {(S, S) | (S, S) ∈ B(Kc (Qn ))}. 2 . Let us also denote Let us denote mis(Qn ) as M+ , then |Kc (Qn )| = M+ by M− all the remaining concepts with equally sized extent and intent, not contained in M+ (Qn ). 2 = M+ + M− + 2l, where 2l counts all the concepts with unequal Hence, M+ sizes of extent and intent (it is even due to the existence of concept (B, A) for each (A, B) with |A| = |B|). Since, (M+ − 1)M+ is even, M− is even.  
   
  Table 4. Maximal independence polynomials n Imax (Qn , x) 0 1 2 3 4 5  
   
  1 2x1 2x2 2x4 + 4x2 2x8 + 16x5 + 24x4 2x16 + 32x12 + 176x10 + 320x9 + 1140x8  
   
  6 2x32 + 64x27 + 480x24 + 1856x22 + 8320x20 + 3840x21 + 40320x19 + 116320x18 + 337920x17 + 736440x16 + 25920x15 + 9600x14 + 320x12  
   
  Analysing Table 4, with the maximal independence polynomials, we can hypothesise the following statement. Conjecture 2. 1) For n > 2, the second smallest exponent of Imax (Qn , x) is 2n−1 − n + 1, while 2) for n > 3, its coeﬃcient is 2n . 4.3  
   
  Spectral-Based Results  
   
  Graph Laplacian is used for spectral graph clustering [14], for example, to ﬁnd communities in social networks. However, we can use this technique for heuristic MIS search for a hypercube as follows: 1. 2. 3. 4.  
   
  Take the complement of the adjacency matrix for Qn = (V, E). Compute its Laplacian matrix L. Solve Lx = λx. Sort vertices of V by the descending order of x components for every solution. And go to Step 5. 5. Add the sorted vertices one-by-one to a current set S in that order until S is IS.  
   
  Maximal Independence Polynomial of Hypercube  
   
  163  
   
  6. If S is MIS, store it. If there are still non-tested solutions, go to Step 4; stop, otherwise. The graph Laplacian of Γ = (V, E) is L(Γ ) = D(Γ )−A(Γ ) where D(Γ ) is the diagonal matrix with deg(v), the degree of vertices v ∈ V , on the main diagonal. The second smallest eigenvalue of this matrix and its eigenvector (also known as Fiedler vector) delivers the minimum value of the mincut(A, B) function over all partitions of V into two parts A and B, i.e. the minimal number of edges that should be deleted from E to make A and B disconnected. We tested this approach with two more variations of the mincut function (namely, ratio- and normalised cuts) and used eigenvectors for all the larger eigenvalues with the help of scipy.linalg Python module (Fig. 5).  
   
  Fig. 5. Adjacency matrix of Q7 reordered with respect to the smallest eigenvectors of its Laplacian L(Q7 ); zero cells are shown in black  
   
  164  
   
  D. I. Ignatov  
   
  Since the tools we used are based on implicitly restarted Arnoldi method to ﬁnd the eigenvalues and eigenvectors, then we cannot guarantee that all possible sizes of MIS for Q7 have been found [13]. However, now thanks to this heuristic approach, in addition to the monomials with non-zero coeﬃcients x64 , x58 , x49 , x44 , x43 obtained in Sect. 4.1, we conﬁrm that the maximal independence polynomial of Q7 also contains x40 , x38 , x36 , x34 , and x32 .  
   
  5  
   
  Conclusions  
   
  We hope the obtained results both can stimulate the interest of FCA practitioners in the problems of combinatorial enumeration in Graph Theory and attract mathematicians with the discovered facts and posed conjectures obtained with the help of concept lattices. The subsequent study of the problem includes further development and performance optimisation of the available FCA-based inventory in connection with tools from Linear Algebra and Generating Functions suitable for larger n, as well as theoretical proofs and reﬁnements of the posed conjectures and investigation of both the structural properties and analytical (asymptotic) behaviour of the maximal independence polynomials. Acknowledgement. This paper is an output of a research project implemented as part of the Basic Research Program at the National Research University Higher School of Economics (HSE University). This research was also supported in part through computational resources of HPC facilities at HSE University We would like to thank N.J.A. Sloane and OEIS editors for their assistance and the anonymous reviewers for their useful suggestions.  
   
  References 1. Boginski, V., Butenko, S., Pardalos, P.M.: Statistical analysis of ﬁnancial networks. Comput. Stat. Data Anal. 48(2), 431–443 (2005). https://doi.org/ 10.1016/j.csda.2004.02.004. https://www.sciencedirect.com/science/article/pii/ S0167947304000258 2. Butenko, S., Pardalos, P., Sergienko, I., Shylo, V., Stetsyuk, P.: Estimating the size of correcting codes using extremal graph problems. In: Pearce, C., Hunt, E. (eds.) Optimization. Springer Optimization and Its Applications, vol. 32, pp. 227–243. Springer, New York (2009). https://doi.org/10.1007/978-0-387-98096-6 12 3. Duﬀus, D., Frankl, P., R¨ odl, V.: Maximal independent sets in bipartite graphs obtained from Boolean lattices. Eur. J. Comb. 32(1), 1–9 (2011). https://doi.org/ 10.1016/j.ejc.2010.08.004 4. Duﬀus, D., Frankl, P., R¨ odl, V.: Maximal independent sets in the covering graph of the cube. Discret. Appl. Math. 161(9), 1203–1208 (2013). https://doi.org/10. 1016/j.dam.2010.09.003 5. Erd¨ os, P.: On cliques in graphs. Israel J. Math. 4(4), 233–234 (1966). https://doi. org/10.1007/BF02771637 6. Ganter, B., Obiedkov, S.A.: Conceptual Exploration. Springer, Cham (2016). https://doi.org/10.1007/978-3-662-49291-8  
   
  Maximal Independence Polynomial of Hypercube  
   
  165  
   
  7. Ganter, B., Wille, R.: Formal Concept Analysis - Mathematical Foundations. Springer, Cham (1999). https://doi.org/10.1007/978-3-642-59830-2 8. Hu, H., Mansour, T., Song, C.: On the maximal independence polynomial of certain graph conﬁgurations. Rocky Mt. J. Math. 47(7), 2219–2253 (2017). https://doi. org/10.1216/RMJ-2017-47-7-2219 9. Ignatov, D.I.: Introduction to formal concept analysis and its applications in information retrieval and related ﬁelds. In: Braslavski, P., Karpov, N., Worring, M., Volkovich, Y., Ignatov, D.I. (eds.) RuSSIR 2014. CCIS, vol. 505, pp. 42–141. Springer, Cham (2015). https://doi.org/10.1007/978-3-319-25485-2 3 10. Ilinca, L., Kahn, J.: Counting maximal antichains and independent sets. Order 30(2), 427–435 (2013). https://doi.org/10.1007/s11083-012-9253-5 11. Kahn, J., Park, J.: The number of maximal independent sets in the hamming cube. Comb. 42(6), 853–880 (2022). https://doi.org/10.1007/s00493-021-4729-9 12. Kuznetsov, S.O.: A fast algorithm for computing all intersections of objects from an arbitrary semilattice. Nauchno-Tekhnicheskaya Informatsiya Seriya 2Informatsionnye Protsessy i Sistemy (1), 17–20 (1993) 13. Lehoucq, R.B., Sorensen, D.C., Yang, C.: ARPACK Users’ Guide: Solution of Large-Scale Eigenvalue Problems with Implicitly Restarted Arnoldi Methods. SIAM, New Delhi (1998) 14. von Luxburg, U.: A tutorial on spectral clustering. Stat. Comput. 17(4), 395–416 (2007). https://doi.org/10.1007/s11222-007-9033-z 15. Tsukiyama, S., Ide, M., Ariyoshi, H., Shirakawa, I.: A new algorithm for generating all the maximal independent sets. SIAM J. Comput. 6(3), 505–517 (1977). https:// doi.org/10.1137/0206036 16. Weisstein, E.W.: Independence Number. From MathWorld-A Wolfram Web Resource (2023). https://mathworld.wolfram.com/IndependenceNumber.htm 17. Weisstein, E.W.: Independence Polynomial. From MathWorld-A Wolfram Web Resource (2023). https://mathworld.wolfram.com/IndependencePolynomial.html 18. Weisstein, E.W.: Linear Recurrence Equation. From MathWorld-A Wolfram Web Resource (2023). https://mathworld.wolfram.com/LinearRecurrenceEquation. html 19. Xiao, M., Nagamochi, H.: Exact algorithms for maximum independent set. Inf. Comput. 255, 126–146 (2017). https://doi.org/10.1016/j.ic.2017.06.001  
   
  Relational Concept Analysis in Practice: Capitalizing on Data Modeling Using Design Patterns Agnès Braud1 , Xavier Dolques1 , Marianne Huchard2(B) , Florence Le Ber1 , and Pierre Martin3 1  
   
  Université de Strasbourg, CNRS, ENGEES, ICube UMR 7537, 67000 Strasbourg, France {agnes.braud,dolques}@unistra.fr, [email protected]  2 LIRMM, Univ. Montpellier, CNRS, Montpellier, France [email protected]  3 CIRAD, UPR AIDA, 34398 Montpellier, France [email protected]  Abstract. Many applications of Formal Concept Analysis (FCA) and its diverse extensions have been carried out in recent years. Among these extensions, Relational Concept Analysis (RCA) is one approach for addressing knowledge discovery in multi-relational datasets. Applying RCA requires stating a question of interest and encoding the dataset into the input RCA data model, i.e. an Entity-Relationship model with only Boolean attributes in the entity description and unidirectional binary relationships. From the various concrete RCA applications, recurring encoding patterns can be observed, that we aim to capitalize taking software engineering design patterns as a source of inspiration. This capitalization work intends to rationalize and facilitate encoding in future RCA applications. In this paper, we describe an approach for defining such design patterns, and we present two design patterns: “Separate/Gather Views” and “Level Relations”.  
   
  Keywords: Formal Concept Analysis Design patterns  
   
  1  
   
  · Relational Concept Analysis ·  
   
  Introduction  
   
  Formal Concept Analysis (FCA [15]) has gained importance in knowledge discovery thanks to both theoretical advances and the multiplication of concrete application projects in many domains [31]. Part of these advances are extensions of FCA suitable to handle complex data, going far beyond basic formal contexts. A few of these extensions are dedicated to deal with datasets comprising multiple object categories and multiple relationships between these objects, namely Graph-FCA [12], Relational Concept Analysis (RCA) [17], and the approach described by [22]. Each of these approaches has its own practical application c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. Dürrschnabel and D. López Rodríguez (Eds.): ICFCA 2023, LNAI 13934, pp. 166–182, 2023. https://doi.org/10.1007/978-3-031-35949-1_12  
   
  RCA in Practice  
   
  167  
   
  and implementation constraints, but has speciﬁc qualities for knowledge discovery. E.g. Graph-FCA provides concepts highlighting graph patterns shared by tuples, while RCA provides interconnected concept lattices, one per object category. This paper focuses on RCA. RCA is based on a simple input data model composed of objects described by Boolean attributes and unidirectional binary relationships between these objects. Practical application raised the issue of encoding a dataset into this formalism, which was more or less easy according to the dataset model structure, such as converting a ternary relation into binary relations [21]. Similar problems arise for encoding object descriptions with particular attribute values (e.g. numerical) into a formal context made of Boolean ones. The latter can be addressed, for example, using scaling approaches [15] or Pattern Structures [14]. To facilitate access of new users to RCA, capitalizing the experience gained in applying RCA in various existing applications is a need. This paper aims to describe a general approach, to pave the way for the deﬁnition of design patterns for RCA application. To this end, we present what such design patterns might look like, and give a few illustrations. Section 2 presents basics of RCA, some typical applications, and our motivation for capitalizing the encoding practices as design patterns. Section 3 outlines the design pattern notion, inspired by its deﬁnition in the ﬁeld of software engineering, and illustrates it through two examples. Section 4 discusses opportunities for developing the approach. We conclude and give a few perspectives of this work in Sect. 5.  
   
  2  
   
  Background and Motivation  
   
  Formal Concept Analysis. FCA is a mathematical framework focusing on the analysis of binary relations using concept lattices. FCA considers as input a formal context K = (O, A, I) where O is a set of objects, A is a set of attributes and I ⊆ O×A is the incidence relation. We deﬁne the functions f : P(O) → P(A) and g : P(A) → P(O) such that f (X) = {y ∈ A|X × {y} ⊆ I} and g(Y ) = {x ∈ O|{x} × Y ⊆ I}. The concept lattice L computed from K is the set of concepts {(X, Y )|X ⊆ O, Y ⊆ A, f (X) = Y and g(Y ) = X}, provided with a partial order relation based on inclusion. X is the concept extent, Y is the concept intent. A concept (Xsub , Ysub ) is lower in the lattice, i.e. is a sub-concept of a concept (Xsup , Ysup ) when Xsub ⊆ Xsup . Relational Concept Analysis. RCA aims at extending FCA to take into account a dataset where objects of several categories are described by attributes and by relations to objects [17]. The dataset is called a Relational Context Family (RCF). An RCF is a (K, R) pair where: K = {Ki }i=1,...,n is a set of Ki = (Oi , Ai , Ii ) contexts (i.e. Formal Contexts), and R = {rj }j=1,...,m is a set of rj relations (i.e. Relational Contexts) where rj ⊆ Oi1 × Oi2 for some i1 , i2 ∈ {1, . . . , n}. An example of an RCF composed of two formal contexts introducing pests and crops respectively and one relational context indicating which pest attacks which crop is shown in Table 1. From the RCF, RCA iteratively builds concepts. In a ﬁrst step, concepts are built for each formal context,  
   
  168  
   
  A. Braud et al.  
   
  Table 1. Example of a Relational Context Family made of the Formal Contexts Pest and Crop, and the Relational Context attacks. FC Pest  
   
  FC Crop  
   
  diptera beetle hemiptera insect fungi  
   
  Contarinia tritici  
   
  x  
   
  Oulema melanopa Lepidosaphes ulmi  
   
  x x  
   
  cereal fruit tree  
   
  RC attacks  
   
  wheat barley apple tree apricot tree  
   
  x  
   
  wheat  
   
  x  
   
  Contarinia tritici  
   
  x  
   
  barley  
   
  x  
   
  Oulema melanopa  
   
  x  
   
  apple tree  
   
  x  
   
  Lepidosaphes ulmi  
   
  apricot tree  
   
  x  
   
  Verticillium dalhiae  
   
  Verticillium dalhiae  
   
  x  
   
  x x x x  
   
  e.g. concept C_Crop_15 that groups wheat and barley for the common attribute cereal (right-hand side lattice of Fig. 1). At the next step, the relational context attacks is used to form relational attributes that express a relation that a pest object may have with a crop concept, such as ∃attacks(C_Crop_15) assigned to Contarinia triciti and Oulema melanopa because they attack at least one crop of C_Crop_15. This causes the creation of concept C_Pest_18, which would not be there without ∃attacks(C_Crop_15) (left-hand side lattice of Fig. 1). The relational attributes can be formed with diﬀerent quantiﬁers (e.g. ∃∀, ⊇, or with percentages). The number of iterations depends on the data model. The same process can be applied to more complex datasets, eventually containing circuits.  
   
  C_Pest_7 attacks(C_Crop_14)  
   
  C_Pest_12 insect  
   
  C_Pest_18  
   
  C_Pest_19  
   
  attacks(C_Crop_15)  
   
  attacks(C_Crop_17)  
   
  C_Crop_14  
   
  C_Pest_8  
   
  C_Pest_10  
   
  C_Pest_11  
   
  C_Pest_13  
   
  C_Crop_15  
   
  diptera  
   
  beetle  
   
  hemiptera  
   
  fungi  
   
  cereal  
   
  fruit tree  
   
  Contarinia tritici  
   
  Oulema melanopa  
   
  Lepidosaphes ulmi  
   
  Verticillium dalhiae  
   
  wheat barley  
   
  apple tree apricot tree  
   
  C_Pest_9  
   
  C_Crop_17  
   
  C_Crop_16  
   
  attacks(C_Crop_16)  
   
  Fig. 1. Lattices obtained from the Relational Context Family of Table 1.  
   
  Overview on RCA Applications. RCA was used for analyzing data in various domains. Hydroecological datasets were studied in [11,28], e.g. to correlate physico-chemical parameters and characteristics of taxons living in sample sites. Agro-ecology, and more precisely ﬁnding plant-based extracts that can serve as alternative to synthetic pesticides and antimicrobials, was considered in [24]. Using RCA in Information Retrieval (IR) is discussed in [8], and was,  
   
  RCA in Practice  
   
  169  
   
  for instance, used for querying collections of legal documents connected through cross references [25]. In the ﬁeld of Semantic Web, it was for instance used to design ontologies [20,32] and extract consistent families of dependent link key candidates in RDF data [4]. RCA was used in industrial information systems to make tools inter-operate, e.g. in the domain of brain activity measurement [35]. It was also applied to identify anomalies in aluminum die casting process description [34]. Finally, RCA was applied in Software Engineering in order to solve diﬀerent problems: normalize (by factorization) a UML class model [16,19] or a UML use case model [10]; for refactoring [26]; learn model transformation patterns [9]; build directories of Web services or components [5]; structure [7] or analyze [2,18] the variability in software product lines. Motivation. Applying RCA to a dataset is easy when their data models are compliant. But the model of the dataset is often more complex, and has to be transformed. For instance, it may contain bidirectional or N-ary relations. The relations may have speciﬁc semantics, e.g. is-a, instance-of, and contains. In such case, converting an is-a relation connecting an entity Esub to another entity Esuper into an RCA relation conducts to assign attributes of Esuper to both entities. Identical problems arise when applying FCA to multi-valued attributes. A solution is to use one of the scaling schemes [15] that convert non-Boolean attributes into Boolean ones. Mastering these scaling schemes is a key for FCA practitioners to select the most appropriate one to meet the modeling objective. The aim of this work is therefore to capitalize on the recurrent data encoding patterns for RCA and thus to increase the eﬃciency of RCA practitioners in developing applications. In this work, the considered encoding includes values, instances (objects), and data model transformations. The main source of inspiration for this work originated from the domain of Software Engineering, namely the design patterns [13].  
   
  3  
   
  Design Patterns  
   
  This section introduces our proposed description of design patterns (DPs) for RCA (Sect. 3.1) and presents two DPs : Separate/Gather Views (Sect. 3.2) and Level Relations (Sect. 3.3). The ﬁrst DP aims to handle (i.e. separates or groups) attributes to facilitate the analysis of a dataset through speciﬁc views, and the second one to represent multivalued attributes from the same category discretized into the same set of values using both relational and formal contexts. Both DPs were used in diﬀerent applications. 3.1  
   
  Describing a Design Pattern  
   
  Data modeling is a recurrent and fundamental problem in various approaches or domains, including databases, ontologies or software engineering. This last domain is the one where capitalization and sharing of models have been the most developed. The work by Gamma et al. [13] is a seminal reference for DP in the domain of Software Engineering. It has been inspired by the work of the  
   
  170  
   
  A. Braud et al.  
   
  architect Christophe Alexander [3]. Gamma et al. oﬀers a catalog of DPs for object-oriented designers to transfer knowledge, in particular from experts to beginners, to help them achieve a good design by choosing among several proven alternatives. In the catalog, four essential parts are highlighted to describe a DP: the pattern name, the problem, the solution, and the consequences. The pattern name is important as it becomes part of a shared vocabulary. Describing the problem involves deﬁning the context and the favorable conditions of the DP application. The solution describes the diﬀerent elements that take part to the design in an abstract and conﬁgurable way. The consequences include predictable eﬀects of the pattern application and compromises that may have to be done between diﬀerent qualities of the results. In addition, each DP is described in the catalog using more than ten sections. While some sections are speciﬁc to objectoriented design (e.g. classes/objects participants, or sample code), others can be adopted for other domains. In this paper, to remain synthetic, the following ﬁve description sections are used: – Problem. The problem is expressed in terms of dataset content and analysis objective. As in [13], this is the most tricky part of the description. – Solution. For RCA, the solution consists in expressing how to formally design and populate a Relational Context Family from the problem description. – Example. This section presents a short example of the pattern application. – Known uses. This section reports existing case studies of the literature where the DP has been applied. – Consequences. This section reviews alternatives and discusses the consequences of the application of the DP relatively to the analysis objective, in particular in terms of usability/readability of the result. 3.2  
   
  The Design Pattern Separate/Gather Views  
   
  Problem. This design pattern applies when: – The objects identiﬁed in the dataset are described either by attributes with domain values of various cardinalities (Case 1), or by Boolean attributes (Case 2). Case 1 can be reduced to Case 2 using a scaling operation [15]. Attributes can be gathered into groups and categories for Case 1 and 2 respectively; – Each attribute or attribute group of Case 1 or each Boolean attribute category of Case 2 is a coherent view on objects; – It is relevant to analyze objects through the perspective of a single view or considering several views, ﬁrst separately and then together. Solution. The solution, outlined in Fig. 2 (left-hand side), is deﬁned as follows: – Formal contexts • One formal context denoted as FC for the initial objects ∗ FC objects (O) are the initial objects, FC attributes (A) are initial object identiﬁers, or other description, or none: F C = (O, A, R), R ⊆ O×A  
   
  RCA in Practice  
   
  171  
   
  Ingredient  
   
  FC2V1  
   
  V1  
   
  S2I FC  
   
  FC2V2  
   
  V2  
   
  ........... ........... FC2Vn  
   
  Vn  
   
  Sushis S2W  
   
  seaweed:boolean salad:boolean salmon:boolean tuna:boolean avocado:boolean rice:boolean tobiko:boolean cucumber:boolean cream-cheese:boolean Weight 20g:boolean 30g:boolean  
   
  Fig. 2. Schema of the Relational Context Family for the Design Pattern Separate/Gather Views (left-hand side). Schema for the sushis example (right-hand side). Both schemas are represented with the UML class diagram notation.  
   
  • One formal context denoted as Vi for each view i, 1 ≤ i ≤ n: ∗ Vi objects (Oi ) are views on the initial objects, Vi attributes (Ai ) are Boolean attributes of one view: Vi = (Oi , Ai , Ri ), Ri ⊆ Oi × Ai . For each view i, there is a one-to-one mapping between objects of O and their projection in Oi denoted as proji : O −→ Oi . – Relational contexts • For each i, 1 ≤ i ≤ n, one relational context F C2Vi connects an object of FC to its corresponding view object in a Vi : F C2Vi = (O, Oi , ri ), ri ⊆ O × Oi , ri = {(o, proji (o))|o ∈ O} Example. Table 2 presents the dataset, i.e. sushis described by weight and ingredients, with domain values {20g, 30g} and {seaweed, ...cream_cheese} respectively. Applying the DP Separate/Gather Views to this dataset consists in identifying the objects and the views. As Sushis are the objects, weight and ingredients are candidates for the views. Figure 2 (right-hand side) graphically outlines the DP application with a UML class model. Class Sushis represents the main formal context; classes Ingredient and Weight represent secondary formal contexts (the views on sushis). UML associations S2I and S2W represent the relational contexts connecting each object to its view object. The values of the attributes Weight and Ingredient lead to Boolean attributes such as seaweed (in Ingredients) or 20g (in Weight). Table 3 shows the resulting RCF: F C is Table Sushis, where there are only objects and no additional description by attributes. V1 is Table Weight, which associates weight views of sushis (e.g. california salmon Wght) with the corresponding weight (e.g. 20g). V2 is Table Ingredient, which associates ingredient views of sushis (e.g. california salmon Ing) with the corresponding ingredients (e.g. seaweed). RC1 = S2W connects a sushi to its weight view; RC2 = S2I connects a sushi to its ingredient view.  
   
  172  
   
  A. Braud et al.  
   
  Table 2. A tiny sushi dataset. A sushi is described by its weight and its ingredients. Sushis  
   
  Weight Ingredients  
   
  california salmon 20 g  
   
  seaweed, salad, salmon, avocado, rice  
   
  california tuna  
   
  30 g  
   
  seaweed, salad, tuna, avocado, rice  
   
  maki cheese  
   
  20 g  
   
  salad, avocado, rice, cream-cheese  
   
  maki tobiko  
   
  30 g  
   
  seaweed, avocado, rice, tobiko, cucumber  
   
  Table 3. A Relational Concept Family for sushis: F C Sushis, V1 weight view, V2 ingredient view, RC1 = S2W connects a sushi to its weight view, RC2 = S2I connects a sushi to its ingredient view. V1 Weight california salmon Wght  
   
  california tuna  
   
  california tuna Wght  
   
  maki cheese  
   
  maki cheese Wght  
   
  maki tobiko  
   
  maki tobiko Wght  
   
  x x  
   
  california tuna  
   
  x  
   
  maki cheese  
   
  x x  
   
  ng aI  
   
  on maki tobiko  
   
  cal  
   
  ma  
   
  ki  
   
  ifo  
   
  rni  
   
  at un  
   
  alm as RC2 S2I california salmon  
   
  x  
   
  Ing  
   
  x  
   
  iko  
   
  x  
   
  tob  
   
  x  
   
  x  
   
  ki  
   
  x  
   
  Ing  
   
  x x  
   
  rni  
   
  ma ki tob iko Wg ht  
   
  ma ki ch ees eW gh t  
   
  at un rni ifo cal  
   
  cal  
   
  ifo  
   
  rni  
   
  as  
   
  alm  
   
  on  
   
  aW gh t  
   
  Wg ht  
   
  x  
   
  x x  
   
  Ing  
   
  x  
   
  maki tobiko Ing  
   
  maki tobiko  
   
  x  
   
  ifo  
   
  maki cheese Ing  
   
  x  
   
  ma  
   
  x  
   
  maki cheese  
   
  x  
   
  ese  
   
  x  
   
  x  
   
  california tuna  
   
  x x  
   
  ch e  
   
  x  
   
  california tuna Ing  
   
  RC1 S2W  
   
  x  
   
  seaweed salad salmon tuna avocado rice tobiko cucumber cream-cheese  
   
  california salmon Ing  
   
  california salmon  
   
  20g 30g  
   
  cal  
   
  V2 Ingredient  
   
  FC Sushis california salmon  
   
  x x x x  
   
  Using this encoding, RCA builds the concept lattices presented in Fig. 3 and 4. Figure 3 presents the views for weight and for ingredients. The weight concept lattice helps analyzing groups of sushis sharing the same weight, i.e. 20g versus 30g. The ingredient concept lattice highlights other sushi groups, e.g. Concept_Ingredient_11 groups the California sushis (separated in the weight view) because of their four shared ingredients (avocado, rice, seaweed, salad). Figure 4 gathers both views and gives combined information, such as the implication rule that a sushi weighed 20g contains salad: ∃S2W (Concept_Weight_19) −→ ∃S2I(Concept_Ingredient_12). In this example, the resulting RCA lattice is similar to a FCA lattice. But each view could be more complex, e.g. with hierarchical values or a combination of various types of attributes with consistent semantics. This approach justiﬁes to build a lattice for each view and one lattice gathering all views.  
   
  RCA in Practice  
   
  173  
   
  Concept_Ingredient_9 avocado rice  
   
  Concept_Weight_18  
   
  Concept_Ingredient_10  
   
  Concept_Ingredient_12  
   
  seaweed  
   
  salad  
   
  Concept_Ingredient_16  
   
  Concept_Ingredient_11  
   
  Concept_Ingredient_17  
   
  tobiko cucumber  
   
  cream-cheese maki cheese Ing  
   
  maki tobiko Ing  
   
  Concept_Weight_19  
   
  Concept_Weight_21  
   
  20g  
   
  30g  
   
  Concept_Ingredient_13  
   
  california salmon Wght maki cheese Wght  
   
  california tuna Wght maki tobiko Wght  
   
  salmon  
   
  tuna  
   
  california salmon Ing  
   
  california tuna Ing  
   
  Concept_Weight_20  
   
  Concept_Ingredient_15  
   
  Concept_Ingredient_14  
   
  Fig. 3. Views on sushis: according to their weight (left-hand side) and their ingredients (right-hand side).  
   
  Known Uses. This DP has been implemented for the analysis of visual accessibility options in operating systems (OS) in [23]. This analysis had diﬀerent purposes, including making recommendations to OS developers to design a new version, to assist end-users ﬁnding an accessibility conﬁguration close to the current conﬁguration when the OS upgrades, or when end-users have to change OS. In this study, the objects are operating systems (OS) and the views cover three visual accessibility options categories (contrast, text, zoom). Separating the views allows to analyze the OS along a single problematic, e.g. to observe commonly shared contrast options, which OS provides more contrast options than another, or which options are never provided together. Gathering the views classiﬁes the OS in a global way, e.g. helping identifying which ones are equivalent on all option categories, how they diﬀer from each other, and how the options of the diﬀerent categories interact. Moreover, an application has been developed by [18] using this DP to assist Feature location (FL) in Software Product Line Engineering. Consequences. Part of the value of this pattern relies on the relevance of the designed views. It may be more or less complex to determine which set of attributes corresponds to a view, as a single semantics should be associated with this view, e.g. habitat versus food for animals. Note that partitioning attributes participating to diﬀerent coherent sets is not relevant, e.g. for animals, the Boolean attribute aquatic environment can be an attribute in views natural habitat and growing conditions. An additional interest of using this RCA DP may occur when considering the pattern variation in which an object can have several views, corresponding for instance to diﬀerent versions. Diﬀerent quantiﬁers can thus be used in the diverse relations, e.g. in the Sushis example,  
   
  174  
   
  A. Braud et al. Concept_Sushis_1 S2I(C_Ingredient_9) S2W(C_Weight_18)  
   
  Concept_Sushis_24  
   
  Concept_Sushis_22  
   
  S2I(C_Ingredient_12)  
   
  S2I(C_Ingredient_10)  
   
  Concept_Sushis_30  
   
  Concept_Sushis_23  
   
  Concept_Sushis_31  
   
  S2W(C_Weight_19)  
   
  S2I(C_Ingredient_11)  
   
  S2W(C_Weight_21)  
   
  Concept_Sushis_29  
   
  Concept_Sushis_25  
   
  Concept_Sushis_27  
   
  Concept_Sushis_28  
   
  S2I(C_Ingredient_17)  
   
  S2I(C_Ingredient_13)  
   
  S2I(C_Ingredient_15)  
   
  S2I(C_Ingredient_16)  
   
  maki cheese  
   
  california salmon  
   
  california tuna  
   
  maki tobiko  
   
  Concept_Sushis_26 S2I(C_Ingredient_14) S2W(C_Weight_20)  
   
  Fig. 4. Sushis concept lattice (gathered views).  
   
  ∃ on S2W and ∃∀ on S2I, to ﬁnd sushis having versions containing only certain types of ingredients, such as vegan ingredients, considering that this ingredient description was included in V2 Ingredient. One might wonder whether using FCA on (1) each formal context Vi , and (2) on a simple formal context gathering all the Boolean attributes would be more relevant than applying this pattern, in particular to obtain more readable lattices since relational attributes add some reading complexity. Using the single formal context with all attributes would present these drawbacks: if some attributes of a view are equivalent and correspond to an interesting abstraction (shared by the same object set), then they would be mixed with other attributes of the other views where it will be diﬃcult to observe the equivalence, the implication, or the mutual exclusion between diﬀerent abstractions coming from diﬀerent views. In addition, if the description of the attributes is complex, FCA cannot consider this complexity to classify the objects while, in the RCA framework, this complexity can be converted into objects supporting this description. It consists in extending the Relational Context Family in which the whole description is used for classifying the initial objects. To improve the readability of the relational attributes, which is a drawback of RCA, the simpliﬁcation proposed by [33,34] can be applied: a concept identiﬁer in a relational attribute can be replaced by the intent of the concept at its creation time (possibly recursively). Other authors proposed to deliver the extracted knowledge, not in terms of concepts and relational attributes, but as sentences [29] or as logical formulas in source code macros [18].  
   
  RCA in Practice  
   
  3.3  
   
  175  
   
  The Design Pattern Level Relations  
   
  Problem. This design pattern applies when: – The objects identiﬁed in the dataset are described by numerical attributes. The attributes belong to the same semantic category; – Numerical attributes are discretized into the same set of values; – Value Levels give interesting information by themselves; – It is relevant to factorize values to limit the size of the context. Diﬀerent quantiﬁers can be applied to the various levels.  
   
  Fig. 5. Schema of the Relational Context Family for the Design Pattern Level Relations (left-hand-side). Schema for the sushi restaurant example (right-hand side).  
   
  Solution. The solution is outlined in Fig. 5 (left-hand-side) and deﬁned as follows: – Formal contexts • One formal context denoted as FC for the initial objects: ∗ FC objects (O) are the initial objects, FC attributes (A) are initial object identiﬁers, or other description, or none: FC = (O, A, I), I ⊆ O×A • One formal context denoted as AL: ∗ AL objects (Ω) are the initial attributes, AL attributes (B) are attribute identiﬁers or categories of attributes: AL = (Ω, B, J), J ⊆ Ω × B. – Relational contexts • For i ∈ [1, n], n being the number of levels, the relational context FC2AL_i connects an object of FC to an attribute in AL if i is the level of this attribute for the object: FC2AL_i = (O, Ω, ri ), ri = {(o, ω)|o ∈ O, ω ∈ Ω, i is the value of ω(o) in the initial dataset} Example. Table 4 outlines the dataset of the tiny example: sushi restaurants are described by their evaluation on price, food quality, food variety, and service, being multi-valued attributes with the three same values. Figure 5 (right-hand side) graphically outlines the DP application with an UML class model. Class Sushi Restaurants represents the main formal context; Class Evaluation represents a secondary formal context (the attributes). UML associations R2E_Low,  
   
  176  
   
  A. Braud et al.  
   
  R2E_Medium and R2E_High represent the relational contexts connecting each object to each attribute according to its value level. Applying the DP Level Relations to Table 4 conducted to obtain Table 5. Two objects contexts are deﬁned, i.e. one for the restaurants, the other for the evaluations. Three relational contexts are deﬁned, i.e. one for each evaluation level (low, medium, and high).  
   
  C_Resto_1 Medium(C_Eval_6) High(C_Eval_6)  
   
  C_Resto_12 Low(C_Eval_6)  
   
  C_Resto_15 Low(C_Eval_9) High(C_Eval_10) sushi2  
   
  C_Resto_16  
   
  C_Resto_18  
   
  C_Resto_20  
   
  Medium(C_Eval_7) Medium(C_Eval_11)  
   
  High(C_Eval_11)  
   
  C_Eval_6  
   
  Medium(C_Eval_10) High(C_Eval_9)  
   
  C_Resto_13 Low(C_Eval_7) Low(C_Eval_10) Medium(C_Eval_9)  
   
  C_Resto_17  
   
  sushi4  
   
  C_Resto_19  
   
  C_Eval_7  
   
  C_Eval_9  
   
  C_Eval_10  
   
  C_Eval_11  
   
  High(C_Eval_7)  
   
  Price  
   
  Quality  
   
  Variety  
   
  Service  
   
  sushi3  
   
  Price  
   
  Quality  
   
  Variety  
   
  Service  
   
  sushi1  
   
  C_Resto_14 Low(C_Eval_8) Low(C_Eval_11) Medium(C_Eval_8) High(C_Eval_8)  
   
  C_Eval_8  
   
  Fig. 6. Sushis restaurant concept lattices. For the sake of space: Restaurant has been shorten in Resto, Evaluation has been shorten in Eval, R2E has been removed before Low, Medium and High.  
   
  Table 4. A tiny sushi restaurant evaluation. Restaurant Price  
   
  Quality Variety  
   
  sushi1  
   
  low  
   
  medium low  
   
  sushi2  
   
  medium low  
   
  sushi3  
   
  high  
   
  sushi4  
   
  medium high  
   
  high  
   
  high  
   
  Service high medium  
   
  medium high medium medium  
   
  The lattices obtained from this RCF are shown on Fig. 6. Concepts of the restaurant lattice (left on Fig. 6) have attributes pointing to evaluation concepts (right on Fig. 6). For instance, concept C_Resto_16 gathers restaurants that have a medium evaluation on Price and on Service. Concept C_Resto_1 gathers all restaurants, showing that all have both a medium and a high evaluation on some criteria.  
   
  RCA in Practice  
   
  177  
   
  Table 5. A Relational Context Family for sushis restaurants: F C Restaurant, AL Evaluation. Identifiers of objects are not shown for a sake of space. R1 =R2E-Low connects a sushi restaurant to its low evaluations, R2 =R2E-Medium connects a sushi restaurant to its medium evaluations, R3 =R2E-High connects a sushi restaurant to its high evaluations. Restaurants  
   
  Evaluation  
   
  sushi1  
   
  Price  
   
  sushi1  
   
  sushi2  
   
  Quality  
   
  sushi2  
   
  sushi3  
   
  Variety  
   
  sushi3  
   
  sushi4  
   
  Service  
   
  sushi2  
   
  R2E-Low Price Quality Variety Service  
   
  R2E-Medium Price Quality Variety Service sushi1 sushi2 sushi2  
   
  x  
   
  x x  
   
  x  
   
  x x  
   
  R2E-High Price Quality Variety Service sushi1  
   
  x  
   
  sushi3  
   
  x  
   
  x  
   
  sushi3 x  
   
  x  
   
  sushi2 sushi2  
   
  x x  
   
  x  
   
  x  
   
  x  
   
  Known Uses. DP Level Relations has been applied for modeling a water dataset, where stream sites are described by physico-chemical parameters (pH, nitrates, phosphates, etc.) and fauna information [11]. Data are modeled with several relations to represent the diﬀerent value levels of physico-chemical parameters (ﬁve level relations), macro-invertebrate populations (three level relations), and characteristics (life traits) of the macro-invertebrates (six level relations). Finally the RCF contains four formal contexts (stream sites, physico-chemical parameters, life traits and macro-invertebrates) and 14 relational contexts. Moreover, this DP was also used by [27] to analyze a dataset on hydrosystem restoration projects. In this work, river sites are characterized by temporal heterogeneous information, including measures of physico-chemical parameters, biological indicators, and the composition of the surrounding land use. Biological indicators are described with 5 quality values. Physico-chemical parameters are discretized into 5 values. Land use is assessed within two increasing buﬀers. Part of diﬀerent types of land use is summarized into three values, low, medium and high. The river sites belong to river segments where restoration operations have been undertaken. Finally the RCF contains 6 formal contexts and 21 relational contexts. Consequences. The lattice on sushi restaurants (left on Fig. 6, called lattice R in the following) obtained with RCA based on the DP Level Relations applied on the dataset described in Table 4 can be compared with a lattice obtained with a simple scaling of the multi-valued attributes into Boolean ones. This second lattice, called lattice B in the following, is shown in Fig. 7. Concepts introducing the objects (restaurant) are similar in both lattices. More general concepts are diﬀerent: lattice R has one more concept, i.e. C_Resto_12, which groups restaurants having a low evaluation on some criteria. In such case, RCA produces relational attributes in which only the level (∃ medium | high) is represented and not the value (which attribute). Such attributes can be interesting for experts.  
   
  178  
   
  A. Braud et al.  
   
  Furthermore the tops of the lattices are diﬀerent: it is empty in lattice B while it contains two relational attributes in lattice R. DP Level Relations is thus relevant when values provide an interesting information.  
   
  C_Resto_9  
   
  C_Resto_17 Service-High  
   
  C_Resto_16  
   
  C_Resto_12  
   
  Quality-High Variety-Medium  
   
  Price-Medium Service-Medium  
   
  C_Resto_10 Price-Low Quality-Medium Variety-Low  
   
  C_Resto_13  
   
  C_Resto_15  
   
  sushi3  
   
  C_Resto_14 Quality-Low Variety-High  
   
  Price-High sushi4  
   
  sushi1  
   
  sushi2  
   
  C_Resto_11 Service-Low  
   
  Fig. 7. Lattice obtained from Table 4 with a scaling of multi-valued attributes.  
   
  4  
   
  Perspectives  
   
  Section 3 presented two DPs, that were used in concrete applications, focusing on various aspects of relational data, as can be considered in the RCA framework. Several perspectives are oﬀered by this work. Two of them are discussed in this section, i.e. identifying additional DPs that can be useful to help RCA users and revisiting existing applications. New Opportunities for Defining DPs. Additional DPs were identiﬁed along the existing applications. A few examples are introduced hereafter. Some data models included a specialization/generalization (is-a) relationship. Analyzing the associated dataset required to ﬂatten the hierarchical descriptions [10,16,19], to discover abstractions previously hidden. This new DP could be named Collapse Specialization. The DP Reify Relation may consist in introducing a formal context in the RCF for describing the tuples of a relation. This approach was used by [21] to derive a binary representation of an N-ary relation, without loosing information. The link reiﬁcation, as realized in [9] and [4], could be considered through the same perspective. The DP, dual to Separate/Gather Views, is Separate/Gather Objects, in which objects of a same category can be separated into several subsets to analyze each subset apart or all subsets as a whole. This approach was considered by [16] to normalize a UML class model to detect candidate attribute generalizations on diverse criteria, e.g. name, substring in the name, synonyms, type, default value. The DP Instances2Model  
   
  RCA in Practice  
   
  179  
   
  may address objects with multi-valued attributes to extract a schema, as it has been done from instance descriptions in [9]. It consists in simplifying the description considering that an object has a value for an attribute (but not the value). Introducing virtual objects representing a Query has been proposed by authors in the context of FCA. This can be extended to the context of RCA, such as in [6], introducing several virtual objects in formal contexts and virtual links in relational contexts. This approach has been adopted for solving the problem of replacing a failing web service in a web service workﬂow [5]. Finally, sequences can be modeled into RCA input with a transitive relation ’precedes’ or ’succeeds’, according to the DP Temporal [28]. Other transitive relations (e.g. part-of/includes, or down/upstream-of [27]) may also correspond to this DP. Revisiting Applications with the DPs. The DP Separate/Gather Views presented in Sect. 3 could be applied to revisit and improve a previous work on component catalog FCA-based building [1], in which software components were described with provided/required interfaces, each interface containing a set of services. In this catalog, the description was made using a single formal context. The catalog then organized the software components with this description and exposed possible substitution between components from the two viewpoints as a whole (provided as well as required services). This hardly helps the lattice exploration considering only one viewpoint, e.g. a user may want to search a component with provided services, and consider in a second step the required services, that other components could provide. Another potential use of the DP Separate/Gather Views could be to consider positive versus negative description of objects, a question that has been addressed in [30], to complete their approach using an additional point of view.  
   
  5  
   
  Conclusion  
   
  This paper presented a general approach that aims to capitalize lessons learned in encoding datasets in the RCA input format. Two DPs were described to illustrate the approach. These DPs have been extracted from existing RCA applications, and could be applied to improve or complete the analysis in other applications. Additional DPs to formalize were also reported. Short-term future work includes continuing the DPs formalization and deﬁning a data modeling process involving the DPs. In the longer term, a new area of research could be extending this approach to other FCA extensions, such as Pattern Structures, Graph-FCA, and Polyadic FCA. Using DPs could be a gateway to use several FCA extensions in synergy, as they could improve their implementation in case studies. Acknowledgements. This work was supported by the ANR SmartFCA project, Grant ANR-21-CE23-0023 of the French National Research Agency.  
   
  References 1. Aboud, N., et al.: Building hierarchical component directories. J. Object Technol. 18(1), 2:1–37 (2019)  
   
  180  
   
  A. Braud et al.  
   
  2. Al-Msie’deen, R., Seriai, A., Huchard, M., Urtado, C., Vauttier, S.: Documenting the mined feature implementations from the object-oriented source code of a collection of software product variants. In: 6th International Conference on Software Engineering and Knowledge Engineering (SEKE), pp. 138–143 (2014) 3. Alexander, C.: A Pattern Language: Towns, Buildings, Construction. Oxford University Press, Oxford (1977) 4. Atencia, M., David, J., Euzenat, J., Napoli, A., Vizzini, J.: Link key candidate extraction with relational concept analysis. Discret. Appl. Math. 273, 2–20 (2020) 5. Azmeh, Z., Driss, M., Hamoui, F., Huchard, M., Moha, N., Tibermacine, C.: Selection of composable web services driven by user requirements. In: IEEE International Conference on Web Services (ICWS), pp. 395–402. IEEE Computer Society (2011) 6. Azmeh, Z., Huchard, M., Napoli, A., Hacene, M.R., Valtchev, P.: Querying relational concept lattices. In: 8th International Conference on Concept Lattices and Their Applications (CLA). Proceedings of CEUR Workshop, vol. 959, pp. 377–392 (2011) 7. Carbonnel, J., Huchard, M., Nebut, C.: Modelling equivalence classes of feature models with concept lattices to assist their extraction from product descriptions. J. Syst. Softw. 152, 1–23 (2019) 8. Codocedo, V., Napoli, A.: Formal concept analysis and information retrieval – a survey. In: Baixeries, J., Sacarea, C., Ojeda-Aciego, M. (eds.) ICFCA 2015. LNCS (LNAI), vol. 9113, pp. 61–77. Springer, Cham (2015). https://doi.org/10.1007/ 978-3-319-19545-2_4 9. Dolques, X., Huchard, M., Nebut, C., Reitz, P.: Learning transformation rules from transformation examples: an approach based on relational concept analysis. In: Workshops on Proceedings of the 14th IEEE International Enterprise Distributed Object Computing Conference (EDOCW), pp. 27–32 (2010) 10. Dolques, X., Huchard, M., Nebut, C., Reitz, P.: Fixing generalization defects in UML use case diagrams. Fundam. Inf. 115(4), 327–356 (2012) 11. Dolques, X., Le Ber, F., Huchard, M., Grac, C.: Performance-friendly rule extraction in large water data-sets with AOC posets and relational concept analysis. Int. J. Gen Syst 45(2), 187–210 (2016) 12. Ferré, S., Cellier, P.: Graph-FCA: an extension of formal concept analysis to knowledge graphs. Discrete Appl. Math. 273, 81–102 (2020) 13. Gamma, E., Helm, R., Johnson, R., Vlissides, J.: Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley Longman, Boston (1995) 14. Ganter, B., Kuznetsov, S.O.: Pattern structures and their projections. In: Delugach, H.S., Stumme, G. (eds.) ICCS-ConceptStruct 2001. LNCS (LNAI), vol. 2120, pp. 129–142. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-445838_10 15. Ganter, B., Wille, R.: Formal Concept Analysis - Mathematical Foundations. Springer, Cham (1999) 16. Guédi, A.O., Miralles, A., Huchard, M., Nebut, C.: A practical application of relational concept analysis to class model factorization: lessons learned from a thematic information system. In: 10th International Conference on Concept Lattices and Their Applications (CLA). CEUR Workshop Proceedings, vol. 1062, pp. 9–20 (2013) 17. Hacene, M.R., Huchard, M., Napoli, A., Valtchev, P.: Relational concept analysis: mining concept lattices from multi-relational data. Ann. Math. Artif. Intell. 67(1), 81–108 (2013)  
   
  RCA in Practice  
   
  181  
   
  18. Hlad, N., Lemoine, B., Huchard, M., Seriai, A.: Leveraging relational concept analysis for automated feature location in software product lines. In: The ACM SIGPLAN International Conference on Generative Programming: Concepts & Experiences (GPCE), Chicago, IL, USA, pp. 170–183. ACM (2021) 19. Huchard, M., Hacene, M.R., Roume, C., Valtchev, P.: Relational concept discovery in structured datasets. Ann. Math. Artif. Intell. 49(1–4), 39–76 (2007) 20. Kasri, S., Benchikha, F.: Refactoring ontologies using design patterns and relational concepts analysis to integrate views: the case of tourism. Int. J. Metadata Semant. Ontol. 11(4), 243–263 (2016) 21. Keip, P., Ferré, S., Gutierrez, A., Huchard, M., Silvie, P., Martin, P.: Practical comparison of FCA extensions to model indeterminate value of ternary data. In: 15th International Conference on Concept Lattices and Their Applications (CLA). CEUR Workshop Proceedings, vol. 2668, pp. 197–208 (2020) 22. Kötters, J., Eklund, P.W.: Conjunctive query pattern structures: a relational database model for formal concept analysis. Discrete Appl. Math. 273, 144–171 (2020) 23. Kouhoué, A.W., Bonavero, Y., Bouétou, T.B., Huchard, M.: Exploring variability of visual accessibility options in operating systems. Fut. Internet 13(9), 230 (2021) 24. Mahrach, L., et al.: Combining implications and conceptual analysis to learn from a pesticidal plant knowledge base. In: Braun, T., Gehrke, M., Hanika, T., Hernandez, N. (eds.) ICCS 2021. LNCS (LNAI), vol. 12879, pp. 57–72. Springer, Cham (2021). https://doi.org/10.1007/978-3-030-86982-3_5 25. Mimouni, N., Fernández, M., Nazarenko, A., Bourcier, D., Salotti, S.: A relational approach for information retrieval on XML legal sources. In: International Conference on Artificial Intelligence and Law (ICAIL), pp. 212–216. ACM (2013) 26. Moha, N., Rouane Hacene, A.M., Valtchev, P., Guéhéneuc, Y.-G.: Refactorings of design defects using relational concept analysis. In: Medina, R., Obiedkov, S. (eds.) ICFCA 2008. LNCS (LNAI), vol. 4933, pp. 289–304. Springer, Heidelberg (2008). https://doi.org/10.1007/978-3-540-78137-0_21 27. Nica, C., Braud, A., Le Ber, F.: Exploring heterogeneous sequential data on river networks with relational concept analysis. In: Chapman, P., Endres, D., Pernelle, N. (eds.) ICCS 2018. LNCS (LNAI), vol. 10872, pp. 152–166. Springer, Cham (2018). https://doi.org/10.1007/978-3-319-91379-7_12 28. Nica, C., Braud, A., Le Ber, F.: RCA-SEQ: an original approach for enhancing the analysis of sequential data based on hierarchies of multilevel closed partiallyordered patterns. Discrete Appl. Math. 273, 232–251 (2020) 29. Ouzerdine, A., Braud, A., Dolques, X., Huchard, M., Le Ber, F.: Adjusting the exploration flow in relational concept analysis - an experience on a watercourse quality dataset. In: Jaziri, R., Martin, A., Rousset, M.C., Boudjeloud-Assala, L., Guillet, F. (eds.) Advances in Knowledge Discovery and Management, Studies in Computational Intelligence, vol. 1004, pp. 175–198. Springer, Cham (2019) 30. Pérez-Gámez, F., Cordero, P., Enciso, M., López-Rodríguez, D., Mora, Á.: Computing the mixed concept lattice. In: Davide, C., et al., (eds.) Information Processing and Management of Uncertainty in Knowledge-Based Systems (IPMU), IPMU 2022, vol. 1601 pp. 87–99. Springer, Cham (2022). https://doi.org/10.1007/978-3031-08971-8_8 31. Poelmans, J., Ignatov, D.I., Kuznetsov, S.O., Dedene, G.: Formal concept analysis in knowledge processing: a survey on applications. Expert Syst. Appl. 40(16), 6538–6560 (2013)  
   
  182  
   
  A. Braud et al.  
   
  32. Rouane Hacene, A.M., Napoli, A., Valtchev, P., Toussaint, Y., Bendaoud, R.: Ontology learning from text using relational concept analysis. In: International MCETECH Conference on e-Technologies (2008) 33. Wajnberg, M.: Analyse relationnelle de concepts : une méthode polyvalente pour l’extraction de connaissance. (Relational concept analysis: a polyvalent tool for knowledge extraction). Ph.D. thesis, Univ. du Québec à Montréal (2020) 34. Wajnberg, M., Valtchev, P., Lezoche, M., Massé, A.B., Panetto, H.: Concept analysis-based association mining from linked data: a case in industrial decision making. In: Joint Ontology Workshops 2019 Episode V: The Styrian Autumn of Ontology. CEUR Workshop Proceedings, vol. 2518. CEUR-WS.org (2019) 35. Wajnberg, M., Lezoche, M., Blondin-Massé, A., Valchev, P., Panetto, H., Tyvaert, L.: Semantic interoperability of large systems through a formal method: relational concept analysis. IFAC-PapersOnLine 51(11), 1397–1402 (2018)  
   
  Representing Concept Lattices with Euler Diagrams Uta Priss(B) Fakult¨at Informatik, Ostfalia University, Wolfenb¨uttel, Germany [email protected]  http://www.upriss.org.uk/  
   
  Abstract. The Hasse diagrams of Formal Concept Analysis (FCA) concept lattices have the disadvantages that users need to be trained in reading the diagrams and diagrams of larger lattices tend to be too cluttered to be comprehensible. This paper therefore discusses how to reduce lattices and then represent them with a specific type of Euler diagram instead of Hasse diagrams. A semi-automated process of reducing concept lattices is described and supported by algorithms.  
   
  1 Introduction Formal Concept Analysis (Ganter and Wille, 1999) provides a mathematical method for data analysis which includes graphical representations in form of Hasse1 diagrams of concept lattices2 . Unfortunately diagrams for concept lattices with more than a small number of concepts contain many edges rendering them difficult to visually parse. Without being trained in reading diagrams, people often misread Hasse diagrams, for example, by mistaking the edges to be vectors3 . Small Euler diagrams, however, can usually be read by people without any significant amount of training4 . But Euler diagrams require a small size and careful layout algorithms in order to be comprehensible. Therefore two questions arise: first, how can formal contexts be reduced or partitioned so that their diagrams are sufficiently small to be easier to represent and, second, in order to avoid training users in reading diagrams, how can concept lattices be represented as Euler diagrams? We are arguing in this paper that an optimal layout of Hasse or Euler diagrams cannot be provided via a purely deterministic algorithm because it may also depend on the content of the data. For example, some objects or attributes may be similar, belong to a shared domain or enhance or contradict each other and should be represented in a manner that reflects such relationships. These other relationships amongst objects 1  
   
  2  
   
  3 4  
   
  The diagrams should not be named after Hasse because he did not invent them, but the name is widely established in the literature. An introduction to FCA is not included in this paper. Standard FCA terminology is used: intension, extension, a cross table for the formal context, and so on. An object concept is the lowest concept which has the object in its extension. Attribute concepts are defined dually. Based on the author’s personal teaching experience with introductory mathematics courses. Again based on the author’s teaching experience. “Small” in this paper means < 20 concepts.  
   
  c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  D. D¨urrschnabel and D. L´opez Rodr´ıguez (Eds.): ICFCA 2023, LNAI 13934, pp. 183–197, 2023. https://doi.org/10.1007/978-3-031-35949-1_13  
   
  184  
   
  U. Priss  
   
  or attributes can be considered background knowledge which might change with each application and need not necessarily be mathematically precise. Therefore, instead of a single algorithm that produces optimal layouts, a semi-automated process is favourable that uses heuristics and interacts with users by asking them questions about the data and by giving them choices between layout options. Such a process is similar to “conceptual exploration” (Ganter and Obiedkov 2016) but conceptual exploration tends to modify the data contained in formal contexts whereas this paper assumes that only the diagrams are modified but not the original data. Most existing research papers that discuss FCA diagram layouts or data reduction are not relevant for this paper because their lattices are still larger than in this paper, use fuzzy or probabilistic reduction methods or focus on navigation through a lattice (e.g. Vogt and Wille (1995), Cole, Eklund and Stumme (2003) or Alam, Le and Napoli (2016)). There is a large body of research on visualisations with Euler diagrams (e.g. Chapman et al. 2014), but not relating to concept lattices. The aim of this paper is to improve visualisations of conceptual hierarchies that are small, non-fuzzy but with background knowledge, for example visualisations of relationships in lexical databases (Priss and Old 2010) and of conceptual representations used for teaching. A goal is to improve existing software5 by providing fairly simple generic algorithms for operations as outlined in the Appendix. Mathematically, such algorithms need not be complicated. Complexity considerations are not relevant for small data sets and not discussed in this paper. A challenge, however, is to respect user preferences and preserve implicit information within the data according to background knowledge. Furthermore, generating Euler diagrams is more challenging than generating Hasse diagrams as explained in the next section. Digital tools for mathematics education often rely on “multiple linked representations (MLR)” which connect different visualisations so that changes in one part affect changes in other parts (Ainsworth 1999). In the case of FCA, an MLR display can show a formal context, its lattice and its implication base simultaneously. Changes in the context will then, for example, instantly change the lattice and the implication base6 Pedagogically, MLRs are useful because according to educational research, mathematical thinking often involves simultaneously imagined representations and fast shifting between them. For example, Venn and Euler diagrams are suitable means for teaching introductory set theory. But the fact that the empty set is a subset of every other set cannot be shown with a Venn or Euler diagram. It can only be concluded from the definition of “subset” by logical reasoning. Thus students need to learn that some knowledge can be represented diagrammatically (such as the subset relationship in Euler diagrams) whereas other knowledge must be represented textually using logical formulas. Applying the idea of MLRs to FCA, one can argue that it is not necessary to represent all information contained in a formal context as a diagram of a concept lattice but instead that some information can be presented diagrammatically and some textually using implications or other logical statements. Therefore a strategy for reducing concept lattices proposed in this paper is to offload some information from diagrams into 5 6  
   
  https://github.com/upriss/educaJS. An example of such an MLR of context and lattice can be found at https://upriss.github.io/ educaJS/binaryRelations/fcaExample.html.  
   
  Representing Concept Lattices with Euler Diagrams  
   
  185  
   
  a textual representation. In some cases “a picture is worth a 1000 words”. But in other cases, textual representations are simpler. For example, compared to drawing a Boolean lattice, a statement that all attributes from a set occur in any possible combination may be simpler. The decision as to which information should be presented diagrammatically or textually is often not based on mathematics but instead on background knowledge. The next section introduces the specific type of Euler diagram that is suggested in this paper. Section 3 compiles a list of reduction methods that are applicable to non-fuzzy, non-probabilistic data. Section 4 demonstrates how in particular a reduction method that utilises concept extensions for partitioning objects is promising for generating Euler diagrams. Section 5 provides a short conclusion. An Appendix contains algorithms for the reduction methods.  
   
  2 Rounded Rectangular Euler Diagrams This section argues that rounded rectangular Euler diagrams are ideally suited for representing small concept lattices and other set inclusion hierarchies. Euler diagrams are a form of graphical representation of set theory that is similar to Venn diagrams but leaves off any zones that are known to be empty (Fig. 1). Most authors define the notion of “Euler diagram” in a semi-formal manner (Rodgers 2014) because a formal definition that captures all aspects of an Euler diagram is complex. Furthermore, mainly a certain subset of well-formed diagrams is of interest but so far no algebraic characterisation of that subset has been found. Euler diagrams consist of closed curves with labels representing sets. The smallest undivided areas in an Euler diagram are called minimal regions (Rodgers 2014). Regions are defined as sets (or unions) of minimal regions. Zones are maximal regions that are within a set of curves and outwith the remaining curves. In this paper, Euler diagrams are required to be well-formed in the sense that at most two curves intersect in any point and that each zone must not be split into several regions. Thus it is not necessary to distinguish between zones and minimal regions. The left half of Fig. 1 shows a well-formed Euler diagram with 6 zones (including the outer zone). partial function  
   
  partial function  
   
  function  
   
  function injective  
   
  surjective  
   
  injective  
   
  surjective  
   
  bijective = injective AND surjective  
   
  Fig. 1. Rectangular Euler diagrams with and without rounded corners and distortion  
   
  It is generally accepted that well-formed diagrams are easier to read than non-wellformed diagrams (Rodgers 2014) but not all subsets of a powerset can be represented as a well-formed diagram. In order to represent more, shading can be applied to zones that  
   
  186  
   
  U. Priss  
   
  are meant to be empty. With shading any subset of a powerset can be drawn as a wellformed Venn or Euler diagram. But shading several non-adjacent zones also renders diagrams difficult to read and thus should be used sparingly. There is some indication that being a lattice, or at least complete with respect to intersections, increases the probability of being representable as a well-formed Euler diagram but that is neither a necessary nor a sufficient condition (Priss 2020). Tree-like set hierarchies can always be represented as well-formed Euler diagrams. For lattices, it helps if one is allowed to omit the bottom concept, thus rendering the structure slightly more tree-like. A further common condition for being well-formed is that curves must not be concurrent which means disallowing curves to meet in more than one adjacent point. This condition is actually dropped in this paper because it allows more subsets of a powerset to be represented. For example, a set of 3 elements has a powerset of 8 elements which has 28 = 256 possible different subsets. If one considers only those where the outer zone is not empty (i.e. 128 subsets), only about 35 of these can be drawn as wellformed Euler diagrams without shading if each set is represented as a circle. If sets are represented as rectangles and curves are allowed to be concurrent, then we counted about 100 subsets that are representable without shading. The left and middle images in Fig. 2 show two examples that are representable in the manner suggested in this paper, but not representable using circles without shading. Boolean lattices with more than 4 sets cannot be represented as rectangular Euler diagrams, but are also difficult to read as Hasse diagrams. A fifth set can be added as a concave curve, as shown with the dashed line in Fig. 2 (right image). Because not all formal contexts with more than 4 elements are Boolean, it is still possible to represent some concept lattices with more than 4 attributes with rectangular Euler diagrams.  
   
  A A B  
   
  C  
   
  B  
   
  C  
   
  Fig. 2. Euler diagrams that cannot be “well-drawn”, two dimensional {A, B, C, ABC} (left) and one dimensional {A, B, AC, ABC} (middle). Boolean lattice with 5 elements on the right (three dimensional).  
   
  Blake et al. (2014) conduct a usability study and conclude that circular Euler diagrams are much more readable than rectangular ones. The Euler diagrams in this paper, however, are not strictly rectangular, but instead rounded rectangular Euler diagrams with distortion, abbreviated as RD-Euler diagrams. In this case “rounded” refers to the corners. As demonstrated on the right hand side of Fig. 1, if the corners are not rounded, then all sets and their intersections have the same shape and are difficult to distinguish. In circular diagrams only the sets are circles, whereas the intersections are composed of circle segments. Using RD diagrams (i.e. with purposeful imperfections) has the effect of changing the shape of the intersections and rendering them easier to discern. An alternative would be to use different colours for different sets but that potentially interferes with shading. Because of the distortion it is possible to see the shape of each set  
   
  Representing Concept Lattices with Euler Diagrams  
   
  187  
   
  in Fig. 2. The small intersections between the concurrent edges are meant to not exist or in other words be empty. It is assumed that users will consider them drawing errors and ignore them (but a usability study should determine which size and shape of distortion is still acceptable to users and at what point shading is required). Figure 2 also shows that in some cases the sets and their intersections can be arranged in a linear sequence as one dimensional diagrams. Petersen (2010) describes the conditions under which concept lattices can be linearised in that manner. Chapman et al. (2014) observe that one dimensional linear diagrams (containing lines instead of curves) have a higher usability for certain tasks than Euler diagrams because users read them faster and more accurately even though instead of shading such diagrams use repetition of attributes. Two dimensional diagrams can be embedded into direct products of one dimensional diagrams. Thus for small formal contexts a simple algorithm consists of repeatedly splitting the sets of attributes in half and then checking for linearity in order to compute a representation as an RD-Euler diagram. We are arguing that two dimensional diagrams are not significantly more complicated than one dimensional ones because only two directions (horizontal and vertical) need to be observed and should thus have similar advantages as observed by Chapman et al. (2014). Three dimensional diagrams (Fig. 2 on the right) are difficult to read unless the sets of the third dimension are small and convex. Apart from being able to express more subsets of a powerset than circular Euler diagrams, another advantage is that RD-Euler diagrams are easier to shade and label when drawn with software. In order to shade intersections one needs to compute their exact geometrical shape which is easier for rectangles than for circles. Furthermore it is more difficult to attach labels to circles. For rectangles, labels can be written adjacent to the edge of a curve either exactly horizontally or exactly rotated by 90◦ . Intersections cannot be labelled in that manner and do require a line or arrow as in the left half of Fig. 1 for either circular or RD-Euler diagrams.  
   
  3 Reducing Concept Lattices This section provides a brief summary of methods for reducing concept lattices by offloading information from diagrams and instead storing it as logical expressions. The resulting RD-Euler diagrams then focus on information that is easier to represent graphically whereas the expressions focus on information that is more suited to textual representation. As mentioned in the introduction, the topic of reducing lattices has been discussed in the literature but usually with a focus on special properties or using fuzzy/probabilistic methods. The methods discussed in this section are more general, simple and mostly well-known. But the practical, joint use of diagrams and textual information has not yet received much attention. The assumptions about the data of a given formal context for this paper are: crisp, non-fuzzy data: probability or other approximations are not relevant for this paper. background knowledge may be available providing further relations, groupings, domains and so on for the objects and attributes. three valued logic applies to most formal contexts because a missing cross can either mean that an attribute does not apply or that it is unknown whether it applies.  
   
  188  
   
  U. Priss  
   
  negatable attributes use binary logic in that objects either definitely do or do not have such attributes according to background knowledge. supplemental concepts are concepts that can never be object concepts according to background knowledge even if more objects are added to a formal context (Priss 2020).  
   
  A formal context can be split into parts that are implications, diagrams and cross tables as long as it is clear how the original context can be recomputed from the different parts. A step-wise reduction should start by storing the original set of implications, because reduction can change implications. At any reduction step, if implications are lost, they must be extracted and stored as well. As a final step, only the implications that are not visible from the diagrams should be displayed textually. How to structure implications so that they are most effective for human users is not trivial and still an open research question that has been discussed elsewhere (Ganter 2019). Using general logical expressions instead of implications complicates matters but only if logical properties are to be computed, not if information is just displayed. Furthermore, as discussed in the introduction, it is assumed that the methods described here are executed in a semi-automated manner. Users will be asked questions about the data and then be presented with diagrams and texts using different reduction methods. Users can then choose which displays they prefer and whether to stop or try further methods. The following listing summarises reduction methods, many of which are well known in some form, but according to our knowledge the approach of offloading information from each reduction step into a textual expression has not yet been studied much. The first four methods are discussed by Priss (2021). They can be easily implemented via an algorithm that searches through a formal context as shown in the Appendix. In our opinion the last method is particularly interesting and has not yet received as much attention in the literature. As a rule, contexts with fewer crosses result in less complicated diagrams. Thus a guiding strategy is to remove attributes and crosses or to split contexts. SYNONYM-reduction: if several attributes have the same extensions then all but one can be removed. Expressions should be added using “:=”. AND-reduction: an attribute whose attribute concept is a meet of other concepts can be removed. An expression using “AND” should be added (e.g. “bijective” in Fig. 1). OR-reduction: an attribute whose attribute concept is a supplemental concept can be removed if its extension is a union of extensions of other attribute concepts. An expression using “OR” should be added. Caution: if several OR-reducible attributes exist, they cannot be removed simultaneously because removal of one may affect the others. NOT-reduction: if an attribute is a negation of another attribute and both are negatable, the one with more crosses can be removed. An expression using “NOT” should be added. NEGATION-reduction: if an attribute is negatable and its column in a context is filled more than half with crosses, then it can be replaced by its negation. An expression using “NOT” should be added. FACTORISATION-reduction: if a context can be factorised using binary matrix multiplication so that the set of factors is smaller than the original set of attributes or smaller than a chosen value, then the set of factors can replace the set of original attributes (Belohlavek and Vychodil 2010). An expression using “AND” should be stored for each factor. Caution: factors cut the lattice vertically in half. Thus the height of the lattice is reduced but the horizontal structure at the level of the cut remains the same. Also, background knowledge may determine whether or not factors are a reasonable choice for a domain.  
   
  Representing Concept Lattices with Euler Diagrams  
   
  189  
   
  HORIZONTAL SPLIT: applicable if removing the top and the bottom concepts (which must both be supplemental) partitions the Hasse diagram into several separate graphs. The only implications that involve attributes from different parts use the bottom concept and may not even be of interest according to background knowledge. If the different parts have nothing in common, then no expressions need to be stored. LOWER HORIZONTAL SPLIT: if removing the bottom concept and some supplemental concepts other than the top concept partitions the Hasse diagram into several separate graphs so that all object concepts are below the removed concepts. (This is different from factorisation because only object concepts matter for this type of splitting.) PARTITIONING attributes: this is commonly used in FCA, for example, for nested line diagrams (Ganter and Wille, 1999). Caution: it changes the set of implications and there is no easy manner in which to store the lost information as expressions. PARTITIONING objects: no implications are lost but each partition may have additional implications which do not hold in the original context. CONCEPTUAL-PARTITIONING: same as the previous one but the set of objects is partitioned so that each partition is an extension of a concept or an extension of a concept of a negated attribute. The additional implications that are generated can be expressed using quantification over extensions: “FOR ALL ... that belong to extension ... : ...”.  
   
  AND-reduction does not change a concept lattice. The methods of OR-and NOTreduction and horizontal split are very effective at reducing a diagram, but the conditions for applying these are not met by many formal contexts. Factorisation depends on background knowledge and might not reduce the complexity of a diagram significantly. Negation reduction is very promising but requires a binary logic for its attribute. Therefore, partitioning appears to be the most interesting reduction method. As far as we are aware, the Darmstadt FCA group around Rudolf Wille favoured partitioning attributes over partitioning objects. As explained below, at least with respect to implications, partitioning objects is a much more promising choice. In our opinion, while nested line diagrams have proven to be useful for some applications, the diagrams are not easy to visually comprehend as a whole. If users zoom into one part of a nested diagram, they need to memorise where they are and what the relevant outer attributes are. For conceptual partitioning, the set of objects is partitioned so that each partition can be expressed using statements involving attributes. For example, if the extensions of attributes a and b partition the set of objects, then the two partitions can be referred to as “objects having a” and “objects having b”. If attributes are negatable, then one can also partition into “objects having a” and “objects not having a” or into “objects having a”, “objects having b” and “objects having neither a nor b”. Most likely negation should be used sparingly and not nested in order to avoid creating very complicated statements. For the same reason, not too many partitions should be created and it is ideal if the attributes chosen provide some obvious categorisation according to background knowledge (for example, “people in their 20s”, “people in their 30s”, and so on). Horizontal split is a type of conceptual partitioning because the extensions of the immediate lower neighbours of the top concept partition the set of objects. Lower horizontal split is a type of conceptual partitioning if the objects of each part exactly correspond to an extension of a concept. Figure 3 in the next section shows an example. With regard to evaluating the effectiveness of reduction methods, a few simple measures can be defined:  
   
  190  
   
  U. Priss  
   
  Mcpt : total number of concepts in a lattice Mobj , Matt , Moa : numbers of object and attribute concepts and concepts that are simultaneously object and attribute concept, respectively Mspl : number of supplemental concepts Mlbl : number of labelled concepts, Mlbl := Mobj + Matt − Moa  
   
  For the sake of avoiding unnecessary concepts, an optimally reduced lattice should have Mcpt ≈ Mlbl if information about supplemental concepts is not available and Mcpt ≈ Mcpt − Mspl otherwise. In general, supplemental concepts should be minimised because they do not add any useful information about objects that is not already contained in other concepts. But concepts that are neither object nor attribute concepts and not supplemental should not be removed during reduction because their extensions are important sets according to background knowledge. In order to avoid losing such concepts during reduction, a strategy is to add objects so that Mcpt − Mspl = Mlbl . Unfortunately, whether a concept is supplemental can only rarely be deduced from its neighbouring concepts: if a concept a is OR-reducible, then all concepts between a and an attribute concept below it, will be supplemental. In general, if a concept is supplemental, then its lower neighbours should be checked because they could also be supplemental. Sometimes background knowledge provides simple rules about supplemental concepts. For example, if it is known that every object has at least 3 attributes, then any concept at the top of the lattice with fewer than 3 attributes must be supplemental. As demonstrated in the examples below for conceptual partitioning, it can be important to check whether the immediate upper neighbours of object concepts and the joins of object concepts are supplemental because they might be removed during conceptual partitioning.  
   
  4 Two Examples of Constructing Euler Diagrams In this section, the Euler diagrams of two well known examples of lattices are drawn after applying conceptual partitioning. The examples are the body of waters lattice that is on the cover of Ganter and Wille (1999) and the lattice of binary relations (in the same book, after page 85). Ganter and Wille present these lattices as additive or nested line diagrams which highlights Boolean sublattices and symmetries. But based on Chapman et al. (2014), it can be expected that one or two dimensional Euler diagrams will be easier to read for most people. Figure 3 shows a Hasse diagram for the body of waters example on the left. All of the concepts in the upper half are supplemental (drawn as empty circles) because objects are meant to have 4 attributes. Only object “channel” has 3 attributes because it has not been decided whether it is natural or artificial. In this case, supplemental concepts can be determined by asking users the single question as to whether “channel” is an exception and otherwise objects are expected to have 4 attributes. A goal of a reduction should then be to remove the supplemental concepts. In this example, NOT-reduction might appear promising. But because the set of attributes is a set of 4 antonymic pairs, it is not clear which pair to choose. If NOT-reduction is applied to all 4 pairs, then only the attributes “temporary”, “running”, “artificial” and “maritime” would be kept. The lattice would consist of very few concepts and most of the supplemental concepts would  
   
  Representing Concept Lattices with Euler Diagrams natural  
   
  inland  
   
  stagnant  
   
  inland constant  
   
  constant  
   
  stagnant  
   
  stagnant natural temporary inland  
   
  running  
   
  channel  
   
  temporary puddle  
   
  artificial lake pool  
   
  river stream  
   
  canal  
   
  maritime pond reservoir  
   
  artificial  
   
  natural  
   
  channel  
   
  running  
   
  191  
   
  puddle lake  
   
  river  
   
  pool  
   
  stream maritime constant  
   
  pond  
   
  canal lagoon sea  
   
  reservoir  
   
  lagoon sea  
   
  Fig. 3. Body of waters Hasse diagram (left), Euler diagrams “inland AND constant” (middle) and “NOT inland OR NOT constant” (right)  
   
  disappear but the lattice would be almost an antichain and not contain much information about the relationships amongst the objects anymore. Therefore after users have seen the results of NOT-reduction, they should be asked whether they would also like to see the result of other reduction methods. In this case a lower horizontal split is possible (the dashed line in Fig. 3) and results in conceptual partitioning using the negatable extension “{inland, constant}”. The right half of Fig. 3 shows the resulting partitions “inland AND constant” and “NOT inland OR NOT constant”. Implications can still be read from the partitioned Euler diagrams but they need to be quantified. For example: for all objects that are “NOT inland OR NOT constant”, inland implies stagnant.  
   
  reflexive  
   
  irreflexive  
   
  semi− anti− connex symmetric transitive symmetric  
   
  connex  
   
  asymmetric preorder  
   
  O9  
   
  total preorder poset  
   
  tolerance rel. equiv. rel.  
   
  O7 coreflexive  
   
  total order  
   
  universal rel.  
   
  O4  
   
  strict partial order  
   
  strict total order  
   
  O2  
   
  O3  
   
  empty rel.  
   
  O1  
   
  Fig. 4. A concept lattice of types of binary relations  
   
  The second example shows a lattice of properties of binary relations (Ganter and Wille 1999). The details of the content of the lattice are not relevant for this paper. A Hasse diagram of the original concept lattice is shown in Fig. 4. In this example, there are only very few supplemental concepts for which Wikipedia can be consulted as a source of background knowledge: if a type of a relation has a name in Wikipedia, then it should not be supplemental and its name can be added as an object. For example, a reflexive and transitive binary relation is called “preorder” in Wikipedia. Although  
   
  192  
   
  U. Priss  
   
  not all supplemental concepts can be decided in that manner, adding objects already has an impact as discussed below. A few of the original objects from Ganter and Wille (1999) do not have special names but must be kept because their object concepts are irreducible. For example, O9 is a connex and antisymmetric relation, but there is no special name for a connex and antisymmetric relation.  
   
  symmetric transitive  
   
  reflexive tolerance equi− rel. valence rel.  
   
  antisymm. semiconnex core− flexive irreflexive rel. emp− ty (O1) (O3) rel. (O4) (O2)  
   
  asymmetric = antisymmetric AND irreflexive  
   
  univ− ersal rel.  
   
  connex = semiconnex AND reflexive  
   
  Fig. 5. Hasse and Euler diagram for a concept lattice of symmetric relations  
   
  A first obvious choice for reduction would be to use negation on “reflexive” or “irreflexive” or to partition the objects according to whether they are reflexive or irreflexive. But after adding the object “coreflexive” during the search for supplemental concepts, the attributes “reflexive” and “irreflexive” are no longer negatable and no longer partition the set of objects. A lower horizontal split is not possible for this example. A next step is to offer users conceptual partitioning for any of the other attributes whose attribute concepts are lower neighbours of the top concept after checking with users that these are indeed negatable. Based on background knowledge it can be detected that the word “order” in the strings of the object names correlates with “NOT symmetric”. Thus partitioning into “symmetric” and “NOT symmetric” is a promising choice. The resulting Hasse and Euler diagrams are shown in Figs. 5 and 6. Figure 5 employs two kinds of shading: horizontal lines for supplemental concepts and diagonal lines for zones that are not concepts of the lattice. The bottom concept has been omitted. If the condition of being a lattice is dropped, then the top 3 shaded zones can be removed leaving a diagram with only 1 shaded zone. Although the Euler diagrams are not showing all of the symmetries of the lattice, they are easy to read. For example, in order to determine the properties of a total order in the Euler diagram of Fig. 6 one only needs to look up (reflexive and semiconnex) and right (transitive and antisymmetric). Optionally below the diagram, it is furthermore stated that connex = reflexive AND semiconnex. Thus connex applies as well.  
   
  Representing Concept Lattices with Euler Diagrams  
   
  193  
   
  semiconnex  
   
  reflexive  
   
  partial order  
   
  total order  
   
  (O9)  
   
  connex = reflexive AND semiconnex  
   
  strict total order (O7)  
   
  strict partial order  
   
  antisymmetric  
   
  total preorder  
   
  transitive  
   
  preorder  
   
  irreflexive asymmetric = antisymmetric AND irreflexive  
   
  Fig. 6. Hasse and Euler diagram for a concept lattice of relations that are not symmetric  
   
  5 Conclusion This paper discusses means for generating RD-Euler diagrams for representing concept lattices by reducing the information contained in the diagrams, potentially separating the information into several diagrams and implications or other logical expressions. While some algorithms have already been implemented (and are shown in the Appendix), an important future step will be to develop an algorithm for the precise layout of nicely formatted Euler diagrams. A semi-automated algorithm which produces some initial layouts to be further manipulated by users would already be a significant achievement because currently such software appears to be lacking. But a discussion of such algorithms will be left to another paper. Conducting a user study comparing Hasse and Euler diagrams would also be of interest but would be difficult. Such a study is only sensible if the users have received some training in reading Hasse diagrams. If the study was conducted within the FCA community, then the users might be biased towards Hasse diagrams and furthermore they would have some mathematical background and thus possibly higher spatial reasoning abilities than the average population. FCA knowledge has an impact on reading Hasse diagrams as well. Anybody who observes the Boolean lattice over “total order” in Fig. 6 will instantly read its attributes from the diagram. Anybody who has not been trained in FCA will have to follow all edges that are leading up from “total order”. This will be more error prone than reading an Euler diagram if one considers Chapman et al.’s (2014) results. Thus future user studies evaluating numbers of errors in reading RDEuler diagrams and comparing them to other Euler diagrams might be more insightful than comparing Hasse and Euler diagrams. Since software for producing Hasse diagrams exists, it would be easy to simply add such software to Euler diagram software and give users a choice whether to display Hasse or Euler diagrams.  
   
  194  
   
  U. Priss  
   
  Appendix: Algorithms This appendix provides a few of the discussed algorithms. Factorisation algorithms are omitted because they are described by Belohlavek and Vychodil (2010). The algorithms are to be used with existing FCA software. Therefore it can be assumed that the following exist: • • • • •  
   
  lists O, A, C of objects, attributes, concepts list L of logical statements (e.g. implications) lists OC and AC for the object/attribute concepts 2-dimensional Boolean array J of size |O| × |A| for the formal context 2-dimensional Boolean array N of size |C| × |C| containing the immediate upper neighbours for each concept (i.e. the edges of the Hasse diagram) The following should be computed:  
   
  • 2-dimensional array P of size |A| × |A| computed by pairwise comparison of the column bitvectors of the attributes. Contains: “e” if the two attributes are equal, “s” for “smaller not equal” (i.e. for every 1 of the first there must be a 1 in the second), “g” for “greater not equal”, “n” for negation and “0” otherwise. • procedure delete(a) removes an attribute a from A and J and recomputes everything else as required • procedure neigh(c) returns the set of upper neighbours of concept c according to N • procedure meet(a) returns a (shortest) list of attributes with binary intersection a or NONE. • procedure join(a) returns a (shortest) list of attributes with binary union a or NONE. The algorithm SynAndOrNot computes attributes that are reducible with Synonym-, AND-, OR- or NOT-reduction. The algorithm Negate computes NEGATION-reduction. Horizontal splits are computed with the final algorithm. For a lower horizontal split, the algorithm HorizontalSplit is used but is stopped as soon as the immediate upper neighbours of all object concepts have been processed. Then the top concepts are removed from each partition and it is checked whether the partitions remain unchanged if all lower neighbours (apart from the bottom concept) are added to each partition. An Algorithm for Conceptual Partitioning is not provided in detail. Several different steps and strategies can be used to determine which concept extensions are most suitable for partitioning the objects: • determine which concepts are supplemental and whether objects should be added to non-supplemental concepts • check whether any other reduction methods are applicable • run a LOWER HORIZONTAL SPLIT algorithm and determine whether each set of objects corresponds to a concept extension • any negatable attribute always partitions the set of objects, therefore identify negatable attributes that partition the set of objects approximately in half (can involve single attributes, but also 2 or 3 attributes) • in order to compare all different possibilities of partitioning, determine which one reduces the number of supplemental concepts • show different versions to users and ask them which they prefer  
   
  Representing Concept Lattices with Euler Diagrams  
   
  Algorithm 1. Algorithm SynAndOrNot 1: for i = 0; i < length(A)-1 do 2: if P(A[i],A[i+1]) == “e” then 3: ask user to choose one of the two 4: a1 = user’s choice to be deleted 5: delete(a1) 6: append “A[i] = A[i+1]” to L 7: else if N(A C(A[i])) contains more than one 1 then 8: (A1, ..., An) = meet(A[i]) 9: delete(A[i]) 10: append “A[i] = A1 AND ... AND An” to L 11: else if P(A[i],A[i+1]) == “g” and A[i] not in O C then 12: (A1, ..., An) = join(A[i]) 13: if not NULL then 14: ask user whether concept is supplemental 15: if yes then 16: delete(A[i]) 17: append “A[i] = A1 OR ... OR An” to L 18: else if P(A[i],A[i+1]) == “n” then 19: if J(A[i]) contains more than length(O)/2 1s then 20: a1 = A[i] 21: else 22: a1 = A[i+1] 23: delete(a1) 24: append “A[i] = NOT A[i+1]” to L 25: else 26: next  
   
  Algorithm 2. Algorithm Negate 1: for i = 0; i < length(A) do 2: if J(A[i]) contains more than length(O)/2 1s then 3: ask user whether A[i] is negatable 4: if yes then 5: replace A[i] with NOT(A[i]) 6: change A and J accordingly 7: recompute everything as required  
   
  195  
   
  196  
   
  U. Priss  
   
  Algorithm 3. Algorithm HorizontalSplit 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26:  
   
  initialise Set1 as a list of sets for item in neigh(bottom concept) do Set1[item] = neigh(item) Cpts = union(neigh(bottom concept)) to process = Cpts processed = {bottom concept, top concept} while length(processed) < length(C) do for c2 in to process do for item1 in Set1 do if c2 not in Set1[item1] then next for item2 in Set1 do if item1 == item2 then next if c2 in Set1[item2] then Set1[item1].add(Set1[item2]) Set1[item2].add(Set1[item1]) for item1 in Set1 do for c3 in intersect(Set1[item1],to process) do Set1[item1].add(neigh(c3)) Cpts = union(Cpts,neigh(c3)) processed = union(processed,to process) to process = Cpts - processed for item in Set1 do if length(Set1[item]) < length(C)-2 then print(Set1[item] - top/bottom concept is a partition)  
   
  References Ainsworth, S.: The functions of multiple representations. Comput. Educ. 33(2–3), 131–152 (1999) Alam, M., Le, T.N.N., Napoli, A.: Steps towards interactive formal concept analysis with latviz. In: Proceedings of 5th International Workshop “What can FCA do for Artificial Intelligence”? CEUR Workshop Series (2016). https://ceur-ws.org/Vol-1703/ Belohlavek, R., Vychodil, V.: Discovery of optimal factors in binary data via a novel method of matrix decomposition. J. Comput. Syst. Sci. 76(1), 3–20 (2010) Blake, A., Stapleton, G., Rodgers, P., Cheek, L., Howse, J.: The impact of shape on the perception of Euler diagrams. In: Dwyer, T., Purchase, H., Delaney, A. (eds.) Diagrams 2014. LNCS (LNAI), vol. 8578, pp. 123–137. Springer, Heidelberg (2014). https://doi.org/10.1007/978-3662-44043-8 16 Chapman, P., Stapleton, G., Rodgers, P., Micallef, L., Blake, A.: Visualizing sets: an empirical comparison of diagram types. In: Dwyer, T., Purchase, H., Delaney, A. (eds.) Diagrams 2014. LNCS (LNAI), vol. 8578, pp. 146–160. Springer, Heidelberg (2014). https://doi.org/10.1007/ 978-3-662-44043-8 18  
   
  Representing Concept Lattices with Euler Diagrams  
   
  197  
   
  Cole, R., Eklund, P., Stumme, G.: Document retrieval for e-mail search and discovery using formal concept analysis. Appl. Artif. Intell. 17(3), 257–280 (2003) Ganter, B., Wille, R.: Formal Concept Analysis. Mathematical Foundations. Springer, Berlin (1999). https://doi.org/10.1007/978-3-642-59830-2 Ganter, B.: “Properties of Finite Lattices” by S. Reeg and W. Weiß, Revisited. In: Cristea, D., Le Ber, F., Sertkaya, B. (eds.) ICFCA 2019. LNCS (LNAI), vol. 11511, pp. 99–109. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-21462-3 8 Ganter, B., Obiedkov, S.: Conceptual Exploration. Springer, Heidelberg (2016). https://doi.org/ 10.1007/978-3-662-49291-8 Petersen, W.: Linear coding of non-linear hierarchies: revitalization of an ancient classification method. In: Fink, A., Lausen, B., Seidel, W., Ultsch, A. (eds.) Advances in Data Analysis, Data Handling and Business Intelligence. Studies in Classification, Data Analysis, and Knowledge Organization, pp. 307–316. Springer, Berlin (2009). https://doi.org/10.1007/978-3-64201044-6 28 Priss, U., Old, L.J.: Concept neighbourhoods in lexical databases. In: Kwuida, L., Sertkaya, B. (eds.) ICFCA 2010. LNCS (LNAI), vol. 5986, pp. 283–295. Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-642-11928-6 20 Priss, U.: Set visualisations with Euler and Hasse diagrams. In: Cochez, M., Croitoru, M., Marquis, P., Rudolph, S. (eds.) GKR 2020. LNCS (LNAI), vol. 12640, pp. 72–83. Springer, Cham (2021). https://doi.org/10.1007/978-3-030-72308-8 5 Priss, U.: Modelling conceptual schemata with formal concept analysis. In: Proceedings of FCA4AI2021 (2021) Rodgers, P.: A survey of Euler diagrams. J. Vis. Lang. Comput. 25(3), 134–155 (2014) Vogt, F., Wille, R.: TOSCANA — a graphical tool for analyzing and exploring data. In: Tamassia, R., Tollis, I.G. (eds.) GD 1994. LNCS, vol. 894, pp. 226–233. Springer, Heidelberg (1995). https://doi.org/10.1007/3-540-58950-3 374  
   
  Author Index  
   
  B Baixeries, Jaume 78 Bazin, Alexandre 95 Behrisch, Mike 109 Braud, Agnès 166 C Cabrera, Inma P. 49 Codocedo, Victor 78 Cordero, Pablo 49 D Dahlhaus, Elias 143 Dolques, Xavier 166 Dudyrev, Egor 127 F Ferré, Sébastien  
   
  33  
   
  K Kaytoue, Mehdi 78 Kuznetsov, Sergei O. 127 L Le Ber, Florence 166 Lobo, David 3 López-Marchante, Víctor  
   
  3  
   
  M Martin, Pierre 166 Medina, Jesús 3 Muñoz-Velasco, Emilio 49 N Napoli, Amedeo 78, 127 Nataraja, Aryan 17  
   
  G Ganter, Bernhard 64, 143  
   
  O Ojeda-Hernández, Manuel  
   
  H Hanika, Tom 64 Hirth, Johannes 64 Huchard, Marianne 166  
   
  P Pattison, Tim 17 Priss, Uta 183  
   
  I Ignatov, Dmitry I. 152  
   
  R Renkin, Leon  
   
  49  
   
  109  
   
  © The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 D. Dürrschnabel and D. López Rodríguez (Eds.): ICFCA 2023, LNAI 13934, p. 199, 2023. https://doi.org/10.1007/978-3-031-35949-1  

 Report "Formal Concept Analysis: 17th International Conference, ICFCA 2023, Kassel, Germany, July 17–21, 2023, Proceedings 3031359488, 9783031359484"  
 ×    

 --- Select Reason ---  Pornographic  Defamatory  Illegal/Unlawful  Spam  Other Terms Of Service Violation  File a copyright complaint     

 Close  Submit    

    Contact information  
 Michael Browner   
   [email protected]    
   
   Address:   
 1918 St.Regis, Dorval, Quebec, H9P 1H6, Canada.   
   
 Support & Legal  
  O nas 
  Skontaktuj się z nami 
  Prawo autorskie 
  Polityka prywatności 
  Warunki 
  FAQs 
  Cookie Policy 
    
 Subscribe to our newsletter  
  Be the first to receive exclusive offers and the latest news on our products and services directly in your inbox.  
   Subscribe     

 Copyright © 2024 DOKUMEN.PUB. All rights reserved.        

 Unsere Partner sammeln Daten und verwenden Cookies zur Personalisierung und Messung von Anzeigen. Erfahren Sie, wie wir und unser Anzeigenpartner Google Daten sammeln und verwenden  .   Cookies zulassen