Foundations of Software Science and Computation Structures | springerprofessional.de  Skip to main content    Menu   Disciplines Chevron down icon     Chevron up icon        Automotive    Business IT + Informatics    Construction + Real Estate    Electrical Engineering + Electronics    Energy + Sustainability    Insurance + Risk    Finance + Banking    Management + Leadership    Marketing + Sales    Mechanical Engineering + Materials      
   
 Events       
   
 DE    EN     

 Books       
   
 Journals       
   
 Topic Page Chevron down icon     Chevron up icon        Marketing      

 Start single access now       
   
 Access for companies       

 Springer Professional     
   
   Search   Enter your search terms       Search     
  
 EXTENDED SEARCH      

  Log in      

 Springer Professional  

 JAVASCRIPT NEEDED    
 Please enable JavaScript on your browser, so that you can use all features of this website.   

  INTERNET EXPLORER IS NO LONGER SUPPORTED    
 Your version of Internet Explorer is no longer supported by this system. Please install one of the following browsers: Microsoft Edge, Safari, Chrome or Firefox   

 Top    

 Open Access  2023 | Open Access | Book  

 Foundations of Software Science and Computation Structures  
 26th International Conference, FoSSaCS 2023, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2023, Paris, France, April 22–27, 2023, Proceedings  
 Editors: Orna Kupferman, Pawel Sobocinski   
   
 Publisher: Springer Nature Switzerland    
 Book Series : Lecture Notes in Computer Science    
 Part of: Springer Professional "Wirtschaft+Technik"  ,   Springer Professional "Technik"  ,   Springer Professional "Wirtschaft"    
   
 Table of Contents    

      Search      
 insite    
 SEARCH    

 About this book  
 This open access book constitutes the proceedings of the 26th International Conference on Foundations of Software Science and Computational Structures, FOSSACS 2023, which was held during April 22-27, 2023, in Paris, France, as part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2023.  
 The 26 regular papers presented in this volume were carefully reviewed and selected from 85 submissions. They deal with research on theories and methods to support the analysis, integration, synthesis, transformation, and verification of programs and software systems.  

 MyTopic Alert   
  Login for updating and creating your alerts.  

 Advertisement   

 Table of Contents  
 Frontmatter  
 PDF    
  
 Open Access   
 When Programs Have to Watch Paint Dry  
  Abstract   
 We explore type systems and programming abstractions for the safe usage of resources. In particular, we investigate how to use types to modularly specify and check when  programs are allowed to use their resources, e.g., when programming a robot arm on a production line, it is crucial that painted parts are given enough time to dry before assembly. We capture such temporal resources  using a time-graded variant of Fitch-style modal type systems, develop a corresponding modally typed, effectful core calculus, and equip it with a graded-monadic denotational semantics illustrated by a concrete presheaf model. Our calculus also includes graded algebraic effects and effect handlers. They are given a novel temporally aware treatment in which operations’ specifications include their execution times and their continuations know that an operation’s worth of additional time has passed before they start executing, making it possible to safely access further temporal resources in them.   
   
 Danel Ahman   
   
 PDF  View full text    
  
 Open Access   
 Deciding Contextual Equivalence of -Calculus with Effectful Contexts  
  Abstract   
 We prove decidability for contextual equivalence of the \(\lambda \mu \nu \)  -calculus, that is the simply-typed call-by-value \(\lambda \mu \)  -calculus equipped with booleans and fresh name creation, with contexts taken in \(\lambda \mu _{\texttt{ref}}\)  , that is \(\lambda \mu \nu \)  -calculus extended with higher-order references.   
 The proof exploits a labelled transition system capturing the interactions between \(\lambda \mu \nu \)  programs and \(\lambda \mu _{\texttt{ref}}\)  contexts. The induced bisimulation equivalence is characterized as equality of certain trees, inspired by the work of Lassen. Since these trees are computable and finite, decidability follows. Bisimulation coincides also with trace equivalence, which in turn coincides with contextual equivalence.   
   
 Daniel Hirschkoff, Guilhem Jaber, Enguerrand Prebet   
   
 PDF  View full text    
  
 Open Access   
 Kantorovich Functors and Characteristic Logics for Behavioural Distances  
  Abstract   
 Behavioural distances measure the deviation between states in quantitative systems, such as probabilistic or weighted systems. There is growing interest in generic approaches to behavioural distances. In particular, coalgebraic methods capture variations in the system type (nondeterministic, probabilistic, game-based etc.), and the notion of quantale  abstracts over the actual values distances take, thus covering, e.g., two-valued equivalences, (pseudo)metrics, and probabilistic (pseudo)metrics. Coalgebraic behavioural distances have been based either on liftings  of \(\textsf{Set}\)  -functors to categories of metric spaces, or on lax extensions  of \(\textsf{Set}\)  -functors to categories of quantitative relations. Every lax extension induces a functor lifting but not every lifting comes from a lax extension. It was shown recently that every lax extension is Kantorovich, i.e. induced by a suitable choice of monotone predicate liftings, implying via a quantitative coalgebraic Hennessy-Milner theorem that behavioural distances induced by lax extensions can be characterized by quantitative modal logics. Here, we essentially show the same in the more general setting of behavioural distances induced by functor liftings. In particular, we show that every functor lifting, and indeed every functor on (quantale-valued) metric spaces, that preserves isometries is Kantorovich, so that the induced behavioural distance (on systems of suitably restricted branching degree) can be characterized by a quantitative modal logic.   
   
 Sergey Goncharov, Dirk Hofmann, Pedro Nora, Lutz Schröder, Paul Wild   
   
 PDF  View full text    
  
 Open Access   
 A Logical Framework with Higher-Order Rational (Circular) Terms  
  Abstract   
 Logical frameworks provide natural and direct ways of specifying and reasoning within deductive systems. The logical framework LF and subsequent developments focus on finitary proof systems, making the formalization of circular proof systems in such logical frameworks a cumbersome and awkward task. To address this issue, we propose \( \text {CoLF} \)  , a conservative extension of LF with higher-order rational terms and mixed inductive and coinductive definitions. In this framework, two terms are equal if they unfold to the same infinite regular Böhm tree. Both term equality and type checking are decidable in \( \text {CoLF} \)  . We illustrate the elegance and expressive power of the framework with several small case studies.   
   
 Zhibo Chen, Frank Pfenning   
   
 PDF  View full text    
  
 Open Access   
 A Higher-Order Language for Markov Kernels and Linear Operators  
  Abstract   
 Much work has been done to give semantics to probabilistic programming languages. In recent years, most of the semantics used to reason about probabilistic programs fall in two categories: semantics based on Markov kernels and semantics based on linear operators.   
 Both styles of semantics have found numerous applications in reasoning about probabilistic programs, but they each have their strengths and weaknesses. Though it is believed that there is a connection between them there are no languages that can handle both styles of programming.   
 In this work we address these questions by defining a two-level calculus and its categorical semantics which makes it possible to program with both kinds of semantics. From the logical side of things we see this language as an alternative resource interpretation of linear logic, where the resource being kept track of is sampling instead of variable use.   
   
 Pedro H. Azevedo de Amorim   
   
 PDF  View full text    
  
 Open Access   
 A Formal Logic for Formal Category Theory  
  Abstract   
 We present a domain-specific type theory for constructions and proofs in category theory. The type theory axiomatizes notions of category, functor, profunctor and a generalized form of natural transformations. The type theory imposes an ordered linear restriction on standard predicate logic, which guarantees that all functions between categories are functorial, all relations are profunctorial, and all transformations are natural by construction, with no separate proofs necessary. Important category-theoretic proofs such as the Yoneda lemma and Co-yoneda lemma become simple type-theoretic proofs about the relationship between unit, tensor and (ordered) function types, and can be seen to be ordered refinements of theorems in predicate logic. The type theory is sound and complete for a categorical model in virtual equipments  , which model both internal and enriched category theory. While the proofs in our type theory look like standard set-based arguments, the syntactic discipline ensure that all proofs and constructions carry over to enriched and internal settings as well.   
   
 Max S. New, Daniel R. Licata   
   
 PDF  View full text    
  
 Open Access   
 A Strict Constrained Superposition Calculus for Graphs  
  Abstract   
 We propose a superposition-based proof procedure to reason on equational first order formulas defined over graphs. First, we introduce the considered graphs that are directed labeled graphs with lists of roots standing for pins or interfaces for replacements. Then the syntax and semantics of the considered logic are defined. The formulas at hand are clause sets built on equations and disequations on graphs. Afterwards, a sound and complete proof procedure is provided, and redundancy criteria are introduced to dismiss useless clauses and improve the efficiency of the procedure. In a first step, a set of inferences rules is provided in the case of uninterpreted labels. In a second step, the proposed rules are lifted to take into account labels defined as terms interpreted in some arbitrary theory. Particular formulas of interest are Horn clauses, for which stronger redundancy criteria can be devised. Essential differences with the usual term superposition calculus are emphasized.   
   
 Rachid Echahed, Mnacho Echenim, Mehdi Mhalla, Nicolas Peltier   
   
 PDF  View full text    
  
 Open Access   
 A Programming Language Characterizing Quantum Polynomial Time  
  Abstract   
 We introduce a first-order quantum programming language, named foq  , whose terminating programs are reversible. We restrict foq  to a strict and tractable subset, named pfoq  , of terminating programs with bounded width, that provides a first programming language-based characterization of the quantum complexity class fbqp  . We finally present a tractable semantics-preserving algorithm compiling a pfoq  program to a quantum circuit of size polynomial in the number of input qubits.   
   
 Emmanuel Hainry, Romain Péchoux, Mário Silva   
   
 PDF  View full text    
  
 Open Access   
 On the Existential Arithmetics with Addition and Bitwise Minimum  
  Abstract   
 This paper presents a similar approach for existential first-order characterizations of the languages recognizable by finite automata, by Parikh automata, and by multi-counter machines over the alphabet \(\left\{ 0,1,...,k-1\right\} ^{n}\)  for some \(k\ge 2\)  . The set of k  -FA-recognizable relations coincides with the set of relations, which are existentially definable in the structure  , where  corresponds to the bitwise minimum of base k  . In order to obtain an existential first-order description of k  -Parikh automata languages, we extend this structure with the predicate \( EqNZB _{k}(x,y)\)  which is true if and only if x  and y  have the same number of non-zero bits in k  -ary encoding. Using essentially the same ideas, we encode computations of k  -multi-counter machines and thus show that every recursively enumerable relation over the natural numbers is existentially definable in the aforementioned structure supplemented with concatenation \(z=x\smallfrown _{k} y\rightleftharpoons z = x + k^{l_{k}(x)}y\)  , where \(l_{k}(x)\)  is the bit-length of x  in base k  . This result gives us another proof of DPR-theorem.   
   
 Mikhail R. Starchak   
   
 PDF  View full text    
  
 Open Access   
 Coverability in 2-VASS with One Unary Counter is in NP  
  Abstract   
 Coverability in Petri nets finds applications in verification of safety properties of reactive systems. We study coverability in the equivalent model: Vector Addition Systems with States (VASS).   
 A k  -VASS can be seen as k  counters and a finite automaton whose transitions are labelled with k  integers. Counter values are updated by adding the respective transition labels. A configuration in this system consists of a state and k  counter values. Importantly, the counters are never allowed to take negative values. The coverability problem asks whether one can traverse the k  -VASS from the initial configuration to a configuration with at least the counter values of the target.   
 In a well-established line of work on k  -VASS, coverability in 2-VASS is already PSPACE  -hard when the integer updates are encoded in binary. This lower bound limits the practicality of applications, so it is natural to focus on restrictions. In this paper we initiate the study of 2-VASS with one unary counter. Here, one counter receives binary encoded updates and the other receives unary encoded updates. Our main result is that coverability in 2-VASS with one unary counter is in NP  . This improves upon the inherited state-of-the-art PSPACE  upper bound. Our main technical contribution is that one only needs to consider runs in a certain compressed linear form.   
   
 Filip Mazowiecki, Henry Sinclair-Banks, Karol Węgrzycki   
   
 PDF  View full text    
  
 Open Access   
 On History-Deterministic One-Counter Nets  
  Abstract   
 We consider the model of history-deterministic one-counter nets (OCNs). History-determinism is a property of transition systems that allows for a limited kind of non-determinism which can be resolved ‘on-the-fly’. Token games, which have been used to characterise history-determinism over various models, also characterise history-determinism over OCNs. By reducing 1-token games to simulation games, we are able to show that checking for history-determinism of OCNs is decidable. Moreover, we prove that this problem is \(\textbf{PSPACE}\)  -complete for a unary encoding of transitions, and \(\textbf{EXPSPACE}\)  -complete for a binary encoding and undecidable for one-counter automata (OCA), which are OCNs that can test for zeroes.   
 We then study the language properties of history-deterministic OCNs. We show that the resolvers of non-determinism for history-deterministic OCNs are eventually periodic. As a consequence, for a given history-deterministic OCN, we construct a language equivalent deterministic OCA. We also show the decidability of comparing languages of history-deterministic OCNs, such as language inclusion and language universality.   
   
 Aditya Prakash, K. S. Thejaswini   
   
 PDF  View full text    
  
 Open Access   
 Unboundedness Problems for Machines with Reversal-Bounded Counters  
  Abstract   
 We consider a general class of decision problems concerning formal languages, called “(one-dimensional) unboundedness predicates”, for automata that feature reversal-bounded counters (RBCA). We show that each problem in this class reduces—non-deterministically in polynomial time—to the same problem for just finite automata. We also show an analogous reduction for automata that have access to both a pushdown stack and reversal-bounded counters (PRBCA).   
 This allows us to answer several open questions: For example, we show that it is \(\textsf{coNP}\)  -complete to decide whether a given (P)RBCA language L  is bounded, meaning whether there exist words \(w_1,\ldots ,w_n\)  with \(L\subseteq w_1^*\cdots w_n^*\)  . For PRBCA, even decidability was open. Our methods also show that there is no language of a (P)RBCA of intermediate growth. This means, the number of words of each length grows either polynomially or exponentially. Part of our proof is likely of independent interest: We show that one can translate an RBCA into a machine with \(\mathbb {Z}\)  -counters in logarithmic space, while preserving the accepted language.   
   
 Pascal Baumann, Flavio D’Alessandro, Moses Ganardi, Oscar Ibarra, Ian McQuillan, Lia Schütze, Georg Zetzsche   
   
 PDF  View full text    
  
 Open Access   
 Reverse Bisimilarity vs. Forward Bisimilarity  
  Abstract   
 Reversibility is the capability of a system of undoing its own actions starting from the last performed one, in such a way that a past consistent state is reached. This is not trivial for concurrent systems, as the last performed action may not be uniquely identifiable. There are several approaches to address causality-consistent reversibility, some including a notion of forward-reverse bisimilarity. We introduce a minimal process calculus for reversible systems to investigate compositionality properties and equational characterizations of forward-reverse bisimilarity as well as of its two components, i.e., forward bisimilarity and reverse bisimilarity, so as to highlight their differences. The study is conducted not only in a nondeterministic setting, but also in a stochastic one where time reversibility and lumpability for Markov chains are exploited.   
   
 Marco Bernardo, Sabina Rossi   
   
 PDF  View full text    
  
 Open Access   
 Explainability of Probabilistic Bisimilarity Distances for Labelled Markov Chains  
  Abstract   
 Probabilistic bisimilarity distances measure the similarity of behaviour of states of a labelled Markov chain. The smaller the distance between two states, the more alike they behave. Their distance is zero if and only if they are probabilistic bisimilar. Recently, algorithms have been developed that can compute probabilistic bisimilarity distances for labelled Markov chains with thousands of states within seconds. However, say we compute that the distance of two states is 0.125. How does one explain that 0.125 captures the similarity of their behaviour?   
 In this paper, we address this question by returning to the definition of probabilistic bisimilarity distances proposed by Desharnais, Gupta, Jagadeesan, and Panangaden more than two decades ago. We use a slight variation of their logic to construct for each pair of states a sequence of formulas that explains the probabilistic bisimilarity distance of the states. Furthermore, we present an algorithm that computes those formulas and we show that each formula can be computed in polynomial time.   
 We also prove that our logic is minimal. That is, if we leave out any operator from the logic, then the resulting logic no longer provides a logical characterization of the probabilistic bisimilarity distances.   
   
 Amgad Rady, Franck van Breugel   
   
 PDF  View full text    
  
 Open Access   
 Weighted and Branching Bisimilarities from Generalized Open Maps  
  Abstract   
 In the open map approach to bisimilarity, the paths and their runs in a given state-based system are the first-class citizens, and bisimilarity becomes a derived notion. While open maps were successfully used to model bisimilarity in non-deterministic systems, the approach fails to describe quantitative system equivalences such as probabilistic bisimilarity. In the present work, we see that this is indeed impossible and we thus generalize the notion of open maps to also accommodate weighted and probabilistic bisimilarity. Also, extending the notions of strong path and path bisimulations into this new framework, we show that branching bisimilarity can be captured by this extended theory and that it can be viewed as the history preserving restriction of weak bisimilarity.   
   
 Jérémy Dubut, Thorsten Wißmann   
   
 PDF  View full text    
  
 Open Access   
 Preservation and Reflection of Bisimilarity via Invertible Steps  
  Abstract   
 In the theory of coalgebras, distributive laws give a general perspective on determinisation and other automata constructions. This perspective has recently been extended to include so-called weak distributive laws, covering several constructions on state-based systems that are not captured by regular distributive laws, such as the construction of a belief-state transformer from a probabilistic automaton, and ultrafilter extensions of Kripke frames.   
 In this paper we first observe that weak distributive laws give rise to the more general notion of what we call an invertible step: a pair of natural transformations that allows to move coalgebras along an adjunction. Our main result is that part of the construction induced by an invertible step preserves and reflects bisimilarity. This covers results that have previously been shown by hand for the instances of ultrafilter extensions and belief-state transformers.   
   
 Ruben Turkenburg, Clemens Kupke, Jurriaan Rot, Ezra Schoen   
   
 PDF  View full text    
  
 Open Access   
 Quantitative Safety and Liveness  
  Abstract   
 Safety and liveness are elementary concepts of computation, and the foundation of many verification paradigms. The safety-liveness classification of boolean properties characterizes whether a given property can be falsified by observing a finite prefix of an infinite computation trace (always for safety, never for liveness). In quantitative specification and verification, properties assign not truth values, but quantitative values to infinite traces (e.g., a cost, or the distance to a boolean property). We introduce quantitative safety and liveness, and we prove that our definitions induce conservative quantitative generalizations of both (1) the safety-progress hierarchy of boolean properties and (2) the safety-liveness decomposition of boolean properties. In particular, we show that every quantitative property can be written as the pointwise minimum of a quantitative safety property and a quantitative liveness property. Consequently, like boolean properties, also quantitative properties can be \(\min \)  -decomposed into safety and liveness parts, or alternatively, \(\max \)  -decomposed into co-safety and co-liveness parts. Moreover, quantitative properties can be approximated naturally. We prove that every quantitative property that has both safe and co-safe approximations can be monitored arbitrarily precisely by a monitor that uses only a finite number of states.   
   
 Thomas A. Henzinger, Nicolas Mazzocchi, N. Ege Saraç   
   
 PDF  View full text    
  
 Open Access   
 On the Comparison of Discounted-Sum Automata with Multiple Discount Factors  
  Abstract   
 We look into the problems of comparing nondeterministic discounted-sum automata on finite and infinite words. That is, the problems of checking for automata \({\mathcal {A}}\)  and \({\mathcal {B}}\)  whether or not it holds that for all words w  , \({\mathcal {A}}(w)={\mathcal {B}}(w), {\mathcal {A}}(w)\le {\mathcal {B}}(w)\)  , or \({\mathcal {A}}(w)<{\mathcal {B}}(w)\)  .   
 These problems are known to be decidable when both automata have the same single integral discount factor, while decidability is open in all other settings: when the single discount factor is a non-integral rational; when each automaton can have multiple discount factors; and even when each has a single integral discount factor, but the two are different.   
 We show that it is undecidable to compare discounted-sum automata with multiple discount factors, even if all are integrals, while it is decidable to compare them if each has a single, possibly different, integral discount factor. To this end, we also provide algorithms to check for given nondeterministic automaton \({\mathcal {N}}\)  and deterministic automaton \({\mathcal {D}}\)  , each with a single, possibly different, rational discount factor, whether or not \({\mathcal {N}}(w) = {\mathcal {D}}(w)\)  , \({\mathcal {N}}(w) \ge {\mathcal {D}}(w)\)  , or \({\mathcal {N}}(w) > {\mathcal {D}}(w)\)  for all words w  .   
   
 Udi Boker, Guy Hefetz   
   
 PDF  View full text    
  
 Open Access   
 Fast Matching of Regular Patterns with Synchronizing Counting  
  Abstract   
 Fast matching of regular expressions with bounded repetition  , aka counting  , such as \(\texttt {(ab)\{50,100\}}\)  , i.e., matching linear in the length of the text and independent of the repetition bounds, has been an open problem for at least two decades. We show that, for a wide class of regular expressions with counting, which we call synchronizing  , fast matching is possible. We empirically show that the class covers nearly all counting used in usual applications of regex matching. This complexity result is based on an improvement and analysis of a recent matching algorithm that compiles regexes to deterministic counting-set automata (automata with registers that hold sets of numbers).   
   
 Lukáš Holík, Juraj Síč, Lenka Turoňová, Tomáš Vojnar   
   
 PDF  View full text    
  
 Open Access   
 Compositional Learning for Interleaving Parallel Automata  
  Abstract   
 Active automata learning has been a successful technique to learn the behaviour of state-based systems by interacting with them through queries. In this paper, we develop a compositional algorithm for active automata learning in which systems comprising interleaving parallel components are learned compositionally. Our algorithm automatically learns the structure of systems while learning the behaviour of the components. We prove that our approach is sound and that it learns a maximal set of interleaving parallel components. We empirically evaluate the effectiveness of our approach and show that our approach requires significantly fewer numbers of input symbols and resets while learning systems. Our empirical evaluation is based on a large number of subject systems obtained from a case study in the automotive domain.   
   
 Faezeh Labbaf, Jan Friso Groote, Hossein Hojjat, Mohammad Reza Mousavi   
   
 PDF  View full text    
  
 Open Access   
 Pebble minimization: the last theorems  
  Abstract   
 Pebble transducers are nested two-way transducers which can drop marks (named “pebbles”) on their input word. Such machines can compute functions whose output size is polynomial in the size of their input. They can be seen as simple recursive programs whose recursion height is bounded. A natural problem is, given a pebble transducer, to compute an equivalent pebble transducer with minimal recursion height. This problem has been open since the introduction of the model.   
 In this paper, we study two restrictions of pebble transducers, that cannot see the marks (“blind pebble transducers” introduced by Nguyên et al.), or that can only see the last mark dropped (“last pebble transducers” introduced by Engelfriet et al.). For both models, we provide an effective algorithm for minimizing the recursion height. The key property used in both cases is that a function whose output size is linear (resp. quadratic, cubic, etc.) can always be computed by a machine whose recursion height is 1 (resp. 2, 3, etc.). We finally show that this key property fails as soon as we consider machines that can see more than one mark.   
   
 Gaëtan Douéneau-Tabot   
   
 PDF  View full text    
  
 Open Access   
 Fixed Points and Noetherian Topologies  
  Abstract   
 Noetherian spaces are a generalisation of well-quasi-orderings to topologies, that can be used to prove termination of programs. They find applications in the verification of transition systems, some of which are better described using topology. The goal of this paper is to allow the systematic description of computations using inductively defined datatypes via Noetherian spaces. This is achieved through a fixed point theorem based on a topological minimal bad sequence argument.   
   
 Aliaume Lopez   
   
 PDF  View full text    
  
 Open Access   
 An Efficient Cyclic Entailment Procedure in a Fragment of Separation Logic  
  Abstract   
 An efficient entailment proof system is essential to compositional verification using separation logic. Unfortunately, existing decision procedures are either inexpressive or inefficient. For example, Smallfoot is an efficient procedure but only works with hardwired lists and trees. Other procedures that can support general inductive predicates run exponentially in time as their proof search requires back-tracking to deal with a disjunction in the consequent.   
 This paper presents a decision procedure to derive cyclic entailment proofs for general inductive predicates in polynomial time. Our procedure is efficient and does not require back-tracking; it uses normalisation rules that help avoid the introduction of disjunction in the consequent. Moreover, our decidable fragment is sufficiently expressive: It is based on compositional predicates and can capture a wide range of data structures, including sorted and nested list segments, skip lists with fast-forward pointers, and binary search trees. We implemented the proposal in a prototype tool, called \(\mathtt {S2S_{Lin}}\)  , and evaluated it over challenging problems from a recent separation logic competition. The experimental results confirm the efficiency of the proposed system.   
   
 Quang Loc Le, Xuan-Bach D. Le   
   
 PDF  View full text    
  
 Open Access   
 Just Testing  
  Abstract   
 The concept of must testing is naturally parametrised with a chosen completeness criterion, defining the complete runs of a system. Here I employ justness as this completeness criterion, instead of the traditional choice of progress. The resulting must-testing preorder is incomparable with the default one, and can be characterised as the fair failure preorder of Vogler. It also is the coarsest precongruence preserving linear time properties when assuming justness.   
 As my system model I here employ Petri nets with read arcs. Through their Petri net semantics, this work applies equally well to process algebras. I provide a Petri net semantics for a standard process algebra extended with signals; the read arcs are necessary to capture those signals.   
   
 Rob van Glabbeek   
   
 PDF  View full text    
  
 Open Access   
 Model and Program Repair via Group Actions  
  Abstract   
 Given a textual representation of a finite-state concurrent program \(P\)  , one can construct the corresponding Kripke structure \(\mathcal {M}\)  . However, the size of \(\mathcal {M}\)  can be exponentially larger than the textual size of \(P\)  . This state explosion can make model checking properties of \(P\)  via \(\mathcal {M}\)  expensive or even infeasible. The action of a symmetry group \(G\)  on \(\mathcal {M}\)  can be used to produce a smaller Kripke structure \(\overline{\mathcal {M}}\)  . Various authors have exploited the direct correspondence between \(\mathcal {M}\)  and \(\overline{\mathcal {M}}\)  to perform model checking. When the structure \(\mathcal {M}\)  does not satisfy a formula, one can look for a substructure that will satisfy the formula. We call this substructure-repair  : identifying a substructure \(\mathcal {N}\)  of \(\mathcal {M}\)  that satisfies a given temporal logic formula.   
 In this paper we extend previous work by showing that repairs of \(\overline{\mathcal {M}}\)  lift to repairs of \(\mathcal {M}\)  . In other words, we can repair a computer program \(P\)  , which exhibits a high degree of symmetry, by repairing the smaller Kripke structure \(\overline{\mathcal {M}}\)  and then symmetrizing the corresponding program. To do this we arrange the substructures of \(\mathcal {M}\)  and \(\overline{\mathcal {M}}\)  into substructure lattices that are ordered by substructure inclusion. We show that the substructures of \(\mathcal {M}\)  preserved by \(G\)  form a (sub)lattice that maps to the substructure lattice of \(\overline{\mathcal {M}}\)  . When restricted to the lattice of substructures of \(\mathcal {M}\)  that are “maximal” with the action of \(G\)  on \(\mathcal {M}\)  , the above map is a lattice isomorphism.   
 These results enable us to repair \(\overline{\mathcal {M}}\)  and then to lift the repair to \(\mathcal {M}\)  . In cases where a program has a high degree of symmetry, such as in many concurrent programs, we can repair the program by repairing the small Kripke structure \(\overline{\mathcal {M}}\)  .   
   
 Paul C. Attie, William L. Cocke   
   
 PDF  View full text    
  
 Open Access   
 Subgame Optimal Strategies in Finite Concurrent Games with Prefix-Independent Objectives  
  Abstract   
 We investigate concurrent two-player win/lose stochastic games on finite graphs with prefix-independent objectives. We characterize subgame optimal strategies and use this characterization to show various memory transfer results: 1) For a given (prefix-independent) objective, if every game that has a subgame almost-surely winning  strategy also has a positional one, then every game that has a subgame optimal  strategy also has a positional one; 2) Assume that the (prefix-independent) objective has a neutral color. If every turn-based  game that has a subgame almost-surely winning strategy also has a positional one, then every game that has a finite-choice  (notion to be defined) subgame optimal strategy also has a positional one.   
 We collect or design examples to show that our results are tight in several ways. We also apply our results to Büchi, co-Büchi, parity, mean-payoff objectives, thus yielding simpler statements.   
   
 Benjamin Bordais, Patricia Bouyer, Stéphane Le Roux   
   
 PDF  View full text    
  
 Backmatter  
 PDF    

 Metadata   

 Title  Foundations of Software Science and Computation Structures    
 Editors  Orna Kupferman  
  Pawel Sobocinski  
     
 Copyright Year  2023    
 Publisher  Springer Nature Switzerland     
   
 Electronic ISBN  978-3-031-30829-1    
 Print ISBN  978-3-031-30828-4    
 DOI  https://doi.org/10.1007/978-3-031-30829-1     

 Premium Partner  

 Image Credits  Neuer Inhalt/© ITandMEDIA   

 Disciplines | Automotive 
  Business IT + Informatics 
  Construction + Real Estate 
  Electrical Engineering + Electronics 
  Energy + Sustainability 
  Insurance + Risk 
  Finance + Banking 
  Management + Leadership 
  Marketing + Sales 
  Mechanical Engineering + Materials 
  Books 
  Journals 
  Topic Page | Marketing 
  Events 
  Start single access now 
  Access for companies 

  About us:     
  
 Who we are    Help    Contact us    Payment Methods      
 Our products:     
  
 Individual access    Access for companies    PatentFit    MyAlerts    Professional Book Archive    MyNewsletter    Carl Hanser Publishing House - Books    AI-assisted search      
 Legal Information:     
  
 Imprint    Terms & Conditions    Privacy Policy    Cookies    Manage cookies/Do not sell my data    California Consumer Privacy Statement      
 Further links:     
  
 RSS-Feeds    Social Media    Media data    Corporate Solutions      
   
 Springer Nature Logo    © Springer Fachmedien Wiesbaden GmbH  
   
 Version: 0.3926.0