Onward! 2023: Proceedings of the 2023 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software  
  Full Citation in the ACM Digital Library    
 SESSION: Papers  
 Scalable Spreadsheet-Driven End-User Applications with Incremental Computation   
 Sean Hadar 
  Shachar Itzhaky 
  Spreadsheets are a popular programming model among both novice and advanced users. It allows for quick development of computational tasks over the user's data set. It has also been suggested as a model for lightweight, low-code development of small-scale personal and collaborative applications for managing data. A barrier is hit when trying to scale up these applications: as the volume of the data grows, performance of spreadsheet computations degrades noticeably, making their maintenance more difficult and frustrating. This paper explores one aspect in which spreadsheets can be boosted significantly - by making computations more incremental, such that small changes to the data would incur a respectively small cost of update. This is particularly interesting in the context of aggregate operations - applied to sets of data elements, producing a single value, such as their sum or average. We propose a compilation phase in which a compiler transforms a spreadsheet table into a program that accepts a stream of changes and produces a stream of updates. We show how to adapt classical results from finite differencing to this interesting modern scenario, and demonstrate that it yields asymptotic improvements to resource usage.  

 Towards an Industrial Stateful Software Rejuvenation Toolchain using Model Learning   
 Mathijs Schuts 
  Jozef Hooman 
  We present our vision for creating an industrial legacy software rejuvenation toolchain. The goal is to semi automatically remove code smells from stateful software used in Cyber Physical Systems (CPS). Compared to existing tools that remove code smells, our toolchain can remove more than one type of code smell. Additionally, our approach supports multiple programming languages because we use abstract models obtained by means of model learning. Supporting more than one programming language is often lacking in state of art refactoring tools.  

 Cloning and Beyond: A Quantum Solution to Duplicate Code   
 Samyak Jhaveri 
  Alberto Krone-Martins 
  Cristina V. Lopes 
  Quantum computers are becoming a reality. The advantage of quantum computing is that it has the potential to solve computationally complex problems in a fixed amount time, independent of the size of the problem. However, the kinds of problems for which these computers are a good fit, and the ways to express those problems, are substantially different from the kinds of problems and expressions used in classical computing. Quantum annealers, in particular, are currently the most promising and available quantum computing devices in the short term. However, they are also the most foreign compared to classical programs, as they require a different kind of computational thinking. In order to ease the transition into this new world of quantum computing, we present a novel quantum approach to a well-known software problem: code clone detection. We express code clone detection as a subgraph isomorphism problem that is mapped into a quadratic optimization problem, and solve it using a DWave quantum annealing computer. We developed a quantum annealing algorithm that compares Abstract Syntax Trees (AST) and reports an energy value that indicates how similar they are.  
 The motivation behind this research goes well beyond code duplicate detection: our approach paves the way into how to express software engineering problems as optimization problems that can be solved by quantum annealers.  

 Trustworthy Formal Natural Language Specifications   
 Colin S. Gordon 
  Sergey Matskevich 
  Interactive proof assistants are computer programs carefully constructed to check a human-designed proof of a mathematical claim with high confidence in the implementation. However, this only validates truth of a formal claim, which may have been mistranslated from a claim made in natural language. This is especially problematic when using proof assistants to formally verify the correctness of software with respect to a natural language specification. The translation from informal to formal remains a challenging, time-consuming process that is difficult to audit for correctness.  
 This paper shows that it is possible to build support for specifications written in expressive subsets of natural language, within existing proof assistants, consistent with the principles used to establish trust and auditability in proof assistants themselves. We implement a means to provide specifications in a modularly extensible formal subset of English, and have them automatically translated into formal claims, entirely within the Lean proof assistant. Our approach is extensible (placing no permanent restrictions on grammatical structure), modular (allowing information about new words to be distributed alongside libraries), and produces proof certificates explaining how each word was interpreted and how the sentence's structure was used to compute the meaning.  
 We apply our prototype to the translation of various English descriptions of formal specifications from a popular textbook into Lean formalizations; all can be translated correctly with a modest lexicon with only minor modifications related to lexicon size.  

 Code Merging using Transformations and Member Identity   
 André Teles 
  André Santos 
  Conventionally, merging code files is performed using generic line-based merging algorithms (e.g., diff3) that are unaware of the syntax and semantics of the programming language, outputting conflicts that could be avoided. Structured and semistructured merging techniques are capable of reducing conflicts, but they still suffer from false positives (conflicts that could be avoided) and false negatives (conflicts that go undetected). We propose a merging technique that combines semistructured and transformation-based strategies, where conflict detection is aware of semantic aspects of the programming language. We extract transformations of two branches and apply a merging process that analyzes incompatible transformations, avoiding false positives and false negatives that occur in existing approaches. We developed Jaid, a prototype merging tool for Java based on the assumption that structural code elements evolve with attached UUIDs (representing identity). We performed an early experiment with 63 merge scenarios from two open-source projects to test the technique and assess its feasibility.  

 Time-Awareness in Object Exploration Tools: Toward In Situ Omniscient Debugging   
 Christoph Thiede 
  Marcel Taeumel 
  Robert Hirschfeld 
  Exploration of state and behavior is essential for understanding and debugging object-oriented programs. Many time-related questions about object communication – an object’s history – only arise in the context of a specific error in the here and now. At such a specific point in time, however, it is often distracting to involve omniscient debugging tools such as program tracers, because they do not integrate well with the programmer’s current focus on space-related questions and the informational cues at hand. In this paper, we present a novel way to provide a tangible, consolidated notion of both space and time in object exploration tools to make it more likely that programmers will use the available means to explore the evolution of particular objects. With programmers remaining informed about and in control of a program’s space and time, we promote the scientific method for debugging and leverage exploratory programming practices. We evaluate our model with hands-on experiences in the Squeak/Smalltalk programming system, using a program tracer that we have integrated into existing exploration tools to promote both spatial and temporal views. We believe that a clear, tangible notion of spacetime can help tool designers provide a better programming experience for those constantly recurring “What happened to this object?” situations.  

 Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers   
 Assaf Avishahar-Zeira 
  David H. Lorenz 
  By 2030 for each filled position in Software Engineering, two positions would remain unfilled. This already apparent loss of productivity has the software industry scrambling to fill the missing positions with citizen developers---technical people with little or no programming skills---who would be using No-Code platforms to program various software solutions in specific domains. However, currently available platforms have fairly limited abstractions, lacking the flexibility of a general purpose programming language.  
 To break the No-Code abstraction barrier, a very simple yet expressive general purpose No-Code programming language might provide citizen developers with an alternative to domain-specific No-Code platforms. Unfortunately, these requirements seem contradictory. Making a language very simple and specific might render it crippled, thus limited to a certain domain of problems. Conversely, making a language very expressive and general, might render it too complicated for citizen developers.  
 In this work we argue that a multi-paradigm minimalist approach can bridge the gap between simplicity and expressiveness by including only abstractions considered intuitive to citizens. As a concrete proof-of-concept, we present a general purpose programming language designed for citizen developers that is on the one hand very powerful and on the other hand very simple. In fact, this language is so simple that the entire development is accomplished by flowcharts using mouse actions only, without typing a single line of code, thus demonstrating a general purpose No-Code programming language candidate for citizen developers.  

 Concept-Centric Software Development: An Experience Report   
 Peter Wilczynski 
  Taylor Gregoire-Wright 
  Daniel Jackson 
  Developers have long recognized the importance of the concepts underlying the systems they build, and the primary role that concepts play in shaping user experience. To date, however, concepts have tended to be only implicit in software design with development being organized instead around more concrete artifacts (such as wireframes and code modules).  
 Palantir, a software company whose data analytics products are widely used by major corporations, recently reworked the internal representation of its software development process to bring concepts to the fore, making explicit the concepts underlying its products, including how they are clustered together, used in applications, and governed by teams. With a centralized repository of concepts, Palantir engineers are able to align products more closely based on shared concepts, evolve concepts in response to user needs, and communicate more effectively with non-engineering groups within the company.  
 This paper reports on Palantir's experiences to date, analyzing both successes and challenges, and offers advice to other organizations considering adopting a concept-centric approach to software development.  

 Toward Programming Languages for Reasoning: Humans, Symbolic Systems, and AI Agents   
 Mark Marron 
  Integration, composition, mechanization, and AI assisted development are the driving themes in the future of software development. At their core these concepts are rooted in the increasingly important role of computing in our world, the desire to deliver functionality faster, with higher quality, and to empower more people to benefit from programmatic automation. These themes, and how they impact the human developers driving them, are the foundations for the next generation of programming languages. At first glance the needs of mechanization tools, AI agents, and human developers along with the various goals around development velocity, software quality, and software democratization are a broad and seemingly diverse set of needs. However, at their core is a single challenge that, once resolved, enables us to make radical progress in all of these areas.  
 Our hypothesis is that, fundamentally, software development is a problem of reasoning about code and semantics. This is true for human developers implementing a feature, symbolic tools building models of application behaviour, and even for language based AI agents as they perform tasks. While the particular aspects of reasoning that each agent struggles with varies to some degree, they share many common themes and, surprisingly, most mainstream languages extensively employ (anti)features that make this task harder or infeasible! This paper proposes a novel approach to this challenge – instead of new language features or logical constructs, that add more complexity to what is already a problem of complexity, we propose radical simplification in the form of the Bosque platform and language.  

 SESSION: Essays  
 Will Code Remain a Relevant User Interface for End-User Programming with Generative AI Models?   
 Advait Sarkar 
  The research field of end-user programming has largely been concerned with helping non-experts learn to code sufficiently well in order to achieve their tasks. Generative AI stands to obviate this entirely by allowing users to generate code from naturalistic language prompts. In this essay, we explore the extent to which "traditional" programming languages remain relevant for non-expert end-user programmers in a world with generative AI. We posit the "generative shift hypothesis": that generative AI will create qualitative and quantitative expansions in the traditional scope of end-user programming. We outline some reasons that traditional programming languages may still be relevant and useful for end-user programmers. We speculate whether each of these reasons might be fundamental and enduring, or whether they may disappear with further improvements and innovations in generative AI. Finally, we articulate a set of implications for end-user programming research, including the possibility of needing to revisit many well-established core concepts, such as Ko's learning barriers and Blackwell's attention investment model.  

 Whither Problem-Solving Environments?   
 Matthew Dinmore 
  During the 1990s and first decade of the 2000s, problem-solving environments (PSEs) were a topic of research among a community with the vision to create software systems “with all of the computational facilities necessary to solve a target class of problems.” Use of the term has since declined, with fewer papers focused on core PSE research topics. What happened? Did we achieve the design vision for PSEs through other means – namely computational notebooks – or is there more to do? In this essay, we explore the history and objectives of PSE research, the rise of computational notebooks, whether they achieve these objectives, and why the time is right to renew our PSE research efforts.  

 Sharing a Perspective on the 𝜆-Calculus   
 Beniamino Accattoli 
  The λ-calculus models the core of functional programming languages. This essay discusses a gap between the theory of the λ-calculus and functional languages, namely the fact that the former does not give a status to sharing  , the essential ingredient for efficiency in the lattter.  
 The essay provides an overview of the perspective of the author, who has been and still is studying sharing from various angles. In particular, it explains how sharing impacts the equational  and denotational  semantics of the λ-calculus, breaking some expected properties, and demanding the development of new, richer semantics of the λ-calculus.  

 programmingLanguage as Language;   
 James Noble 
  Robert Biddle 
  Programming languages are languages --- “unnatural” languages because they are constructed explicitly; “formal” languages because they rely on mathematical notations and are described mathematically; “machine” languages because they are used to communicate with machines. Above all, programming languages are “human” languages. Programs in programming languages are spoken and read and written and designed and debugged and debated by humans, supported by human communities and forming those communities in turn. Langauge implementations, being programs themselves, are likewise designed and debugged and debated by humans.  
 Programming languages adopt structural elements from natural language, including syntax, grammar, vocabulary, and even some sentence structure. Other aspects of language have received less attention, including noun declension, verb tense, and situation-appropriate register. Semiotics shows how language use can connote and imply, and will lead to interpretation. Language involves larger level structure too: conversations, stories, and documents of all kinds. Language supports both cognitive and affective processes, and is involved in building mental models that we use to recall, reason, and respond.  
 Programming is a complex activity, uncertain yet precise, individual and social, involving intent and interpretation. Language is not the accident of programming --- it is the essence.