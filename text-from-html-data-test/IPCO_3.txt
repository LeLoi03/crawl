Anmelden 
  Registrierung 
  Deutsch  English 
  Español 
  Português 
  Français 

     Dom 
  Najlepsze kategorie | CAREER & MONEY 
  PERSONAL GROWTH 
  POLITICS & CURRENT AFFAIRS 
  SCIENCE & TECH 
  HEALTH & FITNESS 
  LIFESTYLE 
  ENTERTAINMENT 
  BIOGRAPHIES & HISTORY 
  FICTION 
  Najlepsze historie 
  Najlepsze historie 
  Dodaj historię 
  Moje historie 

 Home 
  Integer Programming and Combinatorial Optimization. 24th International Conference, IPCO 2023 Madison, WI, USA, June 21–23, 2023 Proceedings 9783031327254, 9783031327261 

 Integer Programming and Combinatorial Optimization. 24th International Conference, IPCO 2023 Madison, WI, USA, June 21–23, 2023 Proceedings 9783031327254, 9783031327261   
   
  600    82    13MB    
  English   Pages 494   Year 2023    
  Report DMCA / Copyright    
  DOWNLOAD FILE   
   
 Polecaj historie   

 Integer Programming and Combinatorial Optimization: 24th International Conference, IPCO 2023, Madison, WI, USA, June 21–23, 2023, Proceedings 9783031327261, 9783031327254, 3031327268  
 This book constitutes the refereed proceedings of the 24th International Conference on Integer Programming and Combinato  
  168    46    44MB    Read more   

 Integer Programming and Combinatorial Optimization: 24th International Conference, IPCO 2023, Madison, WI, USA, June 21–23, 2023, Proceedings (Lecture Notes in Computer Science, 13904) [1st ed. 2023] 9783031327254, 303132725X  
 This book constitutes the refereed proceedings of the 24th International Conference on Integer Programming and Combinato  
  417    107    13MB    Read more   

 Integer Programming and Combinatorial Optimization: 21st International Conference, IPCO 2020, London, UK, June 8–10, 2020, Proceedings (Lecture Notes in Computer Science, 12125) [1st ed. 2020] 3030457702, 9783030457709  
 This book constitutes the refereed proceedings of the 21st International Conference on Integer Programming and Combinato  
  378    64    6MB    Read more   

 Combinatorial Optimization and Applications: 16th International Conference, COCOA 2023, Hawaii, HI, USA, December 15–17, 2023, Proceedings, Part I (Lecture Notes in Computer Science, 14461) 3031496108, 9783031496103  
 The two-volume set LNCS 14461 and LNCS 14462 constitutes the refereed proceedings of the 17th International Conference o  
  142    71    14MB    Read more   

 Combinatorial Optimization and Applications: 16th International Conference, COCOA 2023, Hawaii, HI, USA, December 15–17, 2023, Proceedings, Part II (Lecture Notes in Computer Science, 14462) 3031496132, 9783031496134  
 The two-volume set LNCS 14461 and LNCS 14462 constitutes the refereed proceedings of the 17th International Conference o  
  141    24    17MB    Read more   

 Integer Programming and Combinatorial Optimization: 20th International Conference, IPCO 2019, Ann Arbor, MI, USA, May 22-24, 2019, Proceedings [1st ed.] 978-3-030-17952-6;978-3-030-17953-3  
 This book constitutes the refereed proceedings of the 20th International Conference on Integer Programming and Combinato  
  495    67    11MB    Read more   

 Integer Programming and Combinatorial Optimization: 23rd International Conference, IPCO 2022, Eindhoven, The Netherlands, June 27–29, 2022, Proceedings (Lecture Notes in Computer Science, 13265) [1st ed. 2022] 3031069005, 9783031069000  
 This book constitutes the refereed proceedings of the 23rd International Conference on Integer Programming and Combinato  
  336    98    6MB    Read more   

 Artificial Intelligence in Education: 24th International Conference, AIED 2023, Tokyo, Japan, July 3–7, 2023, Proceedings 3031362713, 9783031362712  
 This book constitutes the refereed proceedings of the 24th International Conference on Artificial Intelligence in Educat  
  2,625    104    52MB    Read more   

 Algorithms and Complexity: 13th International Conference, CIAC 2023, Larnaca, Cyprus, June 13–16, 2023, Proceedings 3031304470, 9783031304477  
 This book constitutes the refereed proceedings of the 13th International Conference on Algorithms and Complexity, CIAC 2  
  486    96    10MB    Read more   

 Algorithms and Complexity: 13th International Conference, CIAC 2023, Larnaca, Cyprus, June 13–16, 2023, Proceedings 9783031304484, 9783031304477, 3031304489  
 This book constitutes the refereed proceedings of the 13th International Conference on Algorithms and Complexity, CIAC 2  
  207    96    38MB    Read more   

 Author / Uploaded 
  Alberto Del Pia 
  Volker Kaibel 

 Table of contents :  
  Preface  
  Organization  
  Contents  
  Information Complexity of Mixed-Integer Convex Optimization  
  1 First-order Information Complexity  
  1.1 Our Results  
  1.2 Formal Definitions and Statement of Results  
  1.3 Discussion and Future Avenues  
  2 Proof Sketches  
  2.1 Proof Sketch of Theorem 1  
  2.2 Proof of Theorem 3  
  2.3 Proof Sketch of Theorem 5  
  2.4 Proof Sketch of Theorems 2 and 4  
  References  
  Efficient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
  1 Introduction  
  2 RLT for Bilinear Products  
  3 Detection of Implicit Products  
  4 Separation Algorithm  
  4.1 Row Marking  
  4.2 Projection Filtering  
  5 Computational Results  
  5.1 Setup  
  5.2 Impact of RLT Cuts  
  5.3 Separation  
  5.4 Experiments with Gurobi  
  5.5 Summary  
  References  
  A Nearly Optimal Randomized Algorithm for Explorable Heap Selection  
  1 Introduction  
  2 The Explorable Heap Selection Problem  
  3 A New Algorithm  
  3.1 The Algorithm  
  3.2 Proof of Correctness  
  3.3 Running Time Analysis  
  3.4 Space Complexity Analysis  
  4 Lower Bound  
  References  
  Sparse Approximation over the Cube  
  1 Introduction and Literature Review  
  2 Preliminaries  
  3 The l1-Relaxation for Random Targets b  
  4 Proximity Between Optimal Solutions of ([P0]P0) and ([P1]P1)  
  5 A Deterministic Algorithm  
  6 Extension  
  References  
  Recycling Inequalities for Robust Combinatorial Optimization with Budget Uncertainty  
  1 Introduction  
  2 Recycling Valid Inequalities  
  3 Facet-Defining Recycled Inequalities  
  4 Computational Study  
  4.1 Robust Independent Set  
  4.2 Robust Bipartite Matching  
  5 Conclusion  
  References  
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
  1 Introduction  
  1.1 Our Result  
  1.2 Pivot Rules for Circuit-Augmentation Algorithms  
  1.3 Related Works  
  2 Proof of Theorem 1  
  2.1 Preliminaries  
  2.2 Reduction  
  2.3 Proof of Lemma 3  
  References  
  Monoidal Strengthening and Unique Lifting in MIQCPs  
  1 Introduction  
  2 Monoidal Strengthening in the Homogeneous Case  
  3 Monoidal Strengthening in the Non-homogeneous Case  
  3.1 A Technical Consideration for Sg  
  3.2 Monoid Construction  
  4 Solving the Monoidal Strengthening Problem  
  5 Unique Lifting  
  6 Computational Results  
  References  
  From Approximate to Exact Integer Programming  
  1 Introduction  
  1.1 Contributions of This Paper  
  1.2 Related Work  
  2 Preliminaries  
  3 The Cut-Or-Average Algorithm  
  3.1 Bounding the Number of Iterations  
  3.2 Correctness and Efficiency of Subroutines  
  3.3 Conclusion on the Cut-Or-Average Algorithm  
  4 An Asymmetric Approximate Carathéodory Theorem  
  5 IPs with Polynomial Variable Range  
  References  
  Optimizing Low Dimensional Functions over the Integers  
  1 Introduction  
  1.1 Applications  
  1.2 Overview of Techniques  
  2 Non-negative Variables  
  3 Bounded Variables  
  4 Overview of Hunkenschröder Et Al. ch9hunkenschroder2022optimizing and Related Improvements  
  5 Conclusion and Open Questions  
  References  
  Configuration Balancing for Stochastic Requests  
  1 Introduction  
  1.1 Our Results  
  1.2 Technical Overview  
  1.3 Related Work  
  2 Configuration Balancing with Stochastic Requests  
  2.1 Structural Theorem  
  2.2 Offline Setting  
  2.3 Online Setting  
  3 Load Balancing on Related Machines  
  References  
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
  1 Introduction  
  2 Preliminaries  
  2.1 Optimal Solutions and Proximity  
  2.2 The Centroid Mapping  
  3 The Update-and-Stabilize Framework  
  4 Analysis  
  5 Computational Experiments  
  References  
  Stabilization of Capacitated Matching Games  
  1 Introduction  
  2 Preliminaries and Notation  
  3 M-vertex-stabilizer  
  4 Vertex-Stabilizer  
  5 Capacitated Cooperative Matching Games  
  References  
  Designing Optimization Problems with Diverse Solutions  
  1 Introduction  
  2 Statement of Main Results  
  2.1 The Cyclic Polytope  
  2.2 Results and Techniques  
  3 Preliminaries  
  4 Upper Bound (Proof of Theorem 1)  
  5 General Lower Bound (Proof of Theorem 2)  
  5.1 Construction Based on Moment Curve  
  5.2 Dual Certificate for Loadouts  
  5.3 Counting the Number of k-Loadouts  
  6 Conclusion  
  References  
  ReLU Neural Networks of Polynomial Size for Exact Maximum Flow Computation  
  1 Introduction  
  1.1 Our Main Results  
  1.2 Discussion of the Results  
  1.3 Further Related Work  
  2 Algorithms and Proof Overview  
  References  
  On the Correlation Gap of Matroids  
  1 Introduction  
  1.1 Our Techniques  
  2 Preliminaries  
  3 Locating the Correlation Gap  
  4 Lower Bounding the Correlation Gap  
  4.1 Lower Bounding G(x*)  
  4.2 Lower Bounding H(x*)  
  4.3 Putting Everything Together  
  References  
  A 4/3-Approximation Algorithm for Half-Integral Cycle Cut Instances of the TSP  
  1 Introduction  
  2 Preliminaries  
  3 Proof of Theorem 1  
  4 Conclusion and Open Questions  
  References  
  The Polyhedral Geometry of Truthful Auctions  
  1 Introduction  
  2 Preliminaries  
  3 Characterization of One-Player Mechanisms  
  4 Sensitivity of Mechanisms  
  5 Conclusion  
  References  
  Competitive Kill-and-Restart and Preemptive Strategies for Non-clairvoyant Scheduling  
  1 Introduction  
  2 Preliminaries  
  3 Lower Bound  
  4 The b-scaling Strategy  
  4.1 The Deterministic b-scaling Strategy  
  4.2 The Randomized b-scaling Strategy  
  5 Weighted Shortest Elapsed Time First  
  6 Upper Bounds for More General Settings  
  7 Conclusion  
  References  
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
  1 Introduction  
  1.1 High Level Proof Overview  
  2 Preliminaries  
  2.1 Notation  
  2.2 Randomized Algorithm of ch19KKO21a  
  2.3 Polyhedral Background  
  3 Computing Probabilities  
  3.1 Notation  
  3.2 Matrix Tree Theorem  
  3.3 Computing Parities in a Simple Case  
  4 A Deterministic Algorithm in the Degree Cut Case  
  5 General Case  
  References  
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
  1 Introduction  
  2 Notation and Background  
  3 Correspondence Between PRLP and CGLP Solutions  
  3.1 Simple VPCs  
  3.2 Relaxations Without Primal Degeneracy  
  3.3 Relaxations with Primal Degeneracy  
  4 Computational Experiments  
  5 Choosing a Relaxation Amenable to Strengthening  
  6 Conclusion  
  References  
  Optimal General Factor Problem and Jump System Intersection  
  1 Introduction  
  1.1 General Factor Problem  
  1.2 Jump System Intersection  
  1.3 Our Contribution: Jump System with SBO Property  
  1.4 Organization  
  2 Preliminaries  
  3 Algorithm and Correctness  
  4 Outline of the Proof of Lemma 1  
  4.1 Minimal Counterexample  
  4.2 Part of Case Analysis: |U|=3  
  5 Extension to Valuated Problem  
  6 Weighted Optimal General Factor Problem  
  7 Concluding Remarks  
  References  
  Decomposition of Probability Marginals for Security Games in Abstract Networks  
  1 Introduction  
  1.1 Motivation  
  1.2 Abstract Networks  
  1.3 Previous Results  
  1.4 Our Results  
  1.5 Notation  
  2 Feasible Decompositions in Abstract Networks  
  3 Computing Feasible Decompositions  
  4 Computing Shortest Paths in Abstract Networks  
  5 Dahan et al.'s Network Security Game  
  6 The Conservation Law for Partially Ordered Sets  
  7 Other Set Systems  
  References  
  Set Selection Under Explorable Stochastic Uncertainty via Covering Techniques  
  1 Introduction  
  2 Algorithmic Framework  
  2.1 Offline Problems and Hardness of Approximation  
  2.2 Algorithmic Framework  
  3 MinSet with Deterministic Right-Hand Sides  
  4 MinSet Under Uncertainty  
  5 Disjoint MinSet  
  References  
  Towards a Characterization of Maximal Quadratic-Free Sets  
  1 Introduction  
  1.1 Contributions  
  2 Examples of Maximal Homogeneous Quadratic-Free Sets  
  3 A Proof of Theorem 5  
  4 A Proof of Theorem 1  
  5 A Proof of Theorem 2  
  6 Preliminary Results on Non-expansive Functions  
  7 A Proof of Theorem 3  
  8 A Proof of Theorem 4  
  References  
  Compressing Branch-and-Bound Trees  
  1 Introduction  
  2 The Tree Compression Problem (TCP)  
  3 Complexity Results and Lower Bounds  
  4 Compression Algorithms  
  4.1 An Exact Method  
  4.2 A Heuristic Method  
  5 Computational Experiments  
  5.1 Methodology  
  5.2 Full Strong Branching Results  
  5.3 Reliability Branching with Plunging  
  6 Future Work  
  References  
  Exploiting the Polyhedral Geometry of Stochastic Linear Bilevel Programming  
  1 Introduction  
  1.1 Problem Formulation and Contributions  
  2 Preliminaries  
  3 Vertex-Supported Beliefs and Bayesian Formulation  
  3.1 Sample Average Formulation  
  4 Geometrical Structure of Vertex-Supported Beliefs  
  5 Algorithms  
  5.1 Enumeration Algorithm  
  5.2 Monte-Carlo Approximation Scheme  
  6 Numerical Experiments  
  References  
  Towards an Optimal Contention Resolution Scheme for Matchings  
  1 Introduction  
  1.1 Our Results  
  1.2 Our Techniques  
  2 An Optimal CRS When "026B30D x"026B30D 0  
  2.1 The Karp-Sipser Algorithm  
  2.2 Random Trees  
  2.3 The Karp-Sipser Algorithm on Trees  
  2.4 Putting It Together  
  3 Improved CRSs for Bipartite Matchings  
  3.1 A 0.480-Balanced Scheme for Bipartite Matchings  
  3.2 A 0.509-Balanced Scheme for Bipartite Matchings  
  References  
  Advances on Strictly -Modular IPs  
  1 Introduction  
  1.1 Group-Constrained Problems and Proof Strategy for Theorem 1  
  1.2 Further Related Work  
  1.3 Structure of the Paper  
  2 GCTUF with Transposed Network Constraint Matrices  
  3 Overview of Our Techniques Leading to Theorem 3  
  3.1 Reducing to a Simpler Problem When the Target Elements Form a Union of Cosets  
  3.2 Decomposing the Problem  
  3.3 Handling Patterns  
  References  
  Cut-Sufficient Directed 2-Commodity Multiflow Topologies  
  1 Introduction  
  1.1 Other Related Work  
  2 Preliminaries  
  2.1 Cut-Deceptive Weights and Minors of Multiflow Topologies  
  3 Relevant Minors and Entry-Exit Connected Edge Sets  
  3.1 Relevant Minors  
  3.2 Contractions of Entry-Exit Connected Sets  
  4 Characterizations of Cut-Sufficiency  
  4.1 Opposingly Ordered Paths  
  4.2 Characterization for Roundtrip and Two-Path Demands  
  5 NP-Hardness of Recognizing Cut-Sufficiency  
  6 Towards a Complete 2-Commodity Characterization  
  References  
  Constant-Competitiveness for Random Assignment Matroid Secretary Without Knowing the Matroid  
  1 Introduction  
  2 Random-Assignment MSP and Densities  
  3 Outline of Our Approach  
  3.1 Rank-Density Curves  
  3.2 Proof Plan for Theorem1 via Rank-Density Curves  
  4 Learning Rank-Density Curves from a Sample  
  5 The Main Algorithm and Its Analysis  
  5.1 Proof (Sketch) of Theorem5  
  References  
  A Fast Combinatorial Algorithm for the Bilevel Knapsack Problem with Interdiction Constraints  
  1 Introduction  
  2 A Combinatorial Algorithm for BKP  
  2.1 The Bound Test  
  2.2 Computing Initial Bounds  
  3 Lower Bound  
  4 Computational Results  
  4.1 Implementation  
  4.2 Instances  
  4.3 Results  
  5 Conclusion  
  References  
  Multiplicative Auction Algorithm for Approximate Maximum Weight Bipartite Matching  
  1 Introduction  
  1.1 Dynamic Matching Algorithms  
  1.2 Linear Program for MWM  
  1.3 Multiplicative Weight Updates for Packing LPs  
  1.4 Auction Algorithms  
  1.5 Our Contribution  
  2 The Static Algorithm  
  2.1 Improving the Running Time  
  3 Dynamic Algorithm  
  A Combinatorial proof of Lemma 2  
  References  
  A Linear Time Algorithm for Linearizing Quadratic and Higher-Order Shortest Path Problems  
  1 Introduction  
  2 Notations and Preliminaries  
  3 A Characterization of Linearizable Instances of the GSPP on Acyclic Digraphs  
  4 A Linear Time Algorithm for the LinSPPd  
  4.1 The All Paths Equal Cost Problem of Order-d (APECPd)  
  4.2 The Linear Time LinSPPd algorithm  
  5 The Subspace of Linearizable Instances  
  References  
  Author Index   
 Citation preview   
  LNCS 13904  
   
  Alberto Del Pia · Volker Kaibel (Eds.)  
   
  Integer Programming and Combinatorial Optimization 24th International Conference, IPCO 2023 Madison, WI, USA, June 21–23, 2023 Proceedings  
   
  Lecture Notes in Computer Science Founding Editors Gerhard Goos Juris Hartmanis  
   
  Editorial Board Members Elisa Bertino, Purdue University, West Lafayette, IN, USA Wen Gao, Peking University, Beijing, China Bernhard Steffen , TU Dortmund University, Dortmund, Germany Moti Yung , Columbia University, New York, NY, USA  
   
  13904  
   
  The series Lecture Notes in Computer Science (LNCS), including its subseries Lecture Notes in Artificial Intelligence (LNAI) and Lecture Notes in Bioinformatics (LNBI), has established itself as a medium for the publication of new developments in computer science and information technology research, teaching, and education. LNCS enjoys close cooperation with the computer science R & D community, the series counts many renowned academics among its volume editors and paper authors, and collaborates with prestigious societies. Its mission is to serve this international community by providing an invaluable service, mainly focused on the publication of conference and workshop proceedings and postproceedings. LNCS commenced publication in 1973.  
   
  Alberto Del Pia · Volker Kaibel Editors  
   
  Integer Programming and Combinatorial Optimization 24th International Conference, IPCO 2023 Madison, WI, USA, June 21–23, 2023 Proceedings  
   
  Editors Alberto Del Pia University of Wisconsin-Madison Madison, WI, USA  
   
  Volker Kaibel Otto-von-Guericke-Universität Magdeburg, Sachsen-Anhalt, Germany  
   
  ISSN 0302-9743 ISSN 1611-3349 (electronic) Lecture Notes in Computer Science ISBN 978-3-031-32725-4 ISBN 978-3-031-32726-1 (eBook) https://doi.org/10.1007/978-3-031-32726-1 © The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and regulations and therefore free for general use. The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty, expressed or implied, with respect to the material contained herein or for any errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional affiliations. This Springer imprint is published by the registered company Springer Nature Switzerland AG The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland  
   
  Preface  
   
  This volume contains extended abstracts of the papers presented at IPCO 2023, the 24th Conference on Integer Programming and Combinatorial Optimization, held on June 21–23, 2023 in Madison, Wisconsin, USA. IPCO is under the auspices of the Mathematical Optimization Society. Since its first edition, held at the University of Waterloo, Canada in May 1990, it has become a most important forum for presenting the latest results on the theory and practice of the various aspects of discrete optimization. For this year’s 24th edition the conference had a Program Committee consisting of 16 members. In response to the Call for Papers, we received 119 submissions and accepted 33 papers, with an acceptance ratio of 28%. In a single-blind review process, each submission was reviewed by at least three Program Committee members, and 246 additional reviews were provided by external experts. Because of the limited number of time slots for presentations, many excellent submissions could not be accepted. The page limit for contributions to these proceedings was set to 15. We expect the full versions of the extended abstracts appearing in this Lecture Notes in Computer Science volume to be submitted for publication in refereed journals. A special issue of Mathematical Programming, Series B containing such versions is in process. As has become a good tradition, IPCO 2023 had a Best Paper Award, which was given to Daniel Dadush, Friedrich Eisenbrand, and Thomas Rothvoss for their paper “From approximate to exact integer programming.” This year, IPCO was preceded by a Summer School held during June 19–20, 2023, with lectures by Amitabh Basu (Johns Hopkins University, USA), Fatma Kilinç-Karzan (Carnegie Mellon University, USA), and Domenico Salvagnin (University of Padova, Italy). We thank them warmly for their contributions. We would also like to thank – – – – –  
   
  the authors who submitted their research to IPCO; the members of the Program Committee; the expert additional reviewers; the members of the Local Organizing Committee; the Mathematical Optimization Society, in particular the members of its IPCO Steering Committee, Karen Aardal, Oktay Günlük, Jochen Könemann, and Giacomo Zambelli; – EasyChair for making the paper management simple and effective; and – Springer for their efficient cooperation in producing this volume and for financial support for the Best Paper Award. We would further like to thank the following sponsors for their financial support: the Wisconsin Institute for Discovery and the Department of Industrial & Systems Engineering at the University of Wisconsin-Madison, the Air Force Office of Scientific Research,  
   
  vi  
   
  Preface  
   
  the Office of Naval Research, FICO, Google, Gurobi Optimization, and The Optimization Firm. March 2023  
   
  Alberto Del Pia Volker Kaibel  
   
  Organization  
   
  Program Committee Merve Bodur Jose Correa Alberto Del Pia Yuri Faenza Volker Kaibel (Chair) Simge Kucukyavuz Andrea Lodi Diego Moran Giacomo Nannicini Britta Peis Mohit Singh Martin Skutella Juan Pablo Vielma Jens Vygen Stefan Weltge Giacomo Zambelli  
   
  University of Toronto, Canada Universidad de Chile, Chile University of Wisconsin-Madison, USA Columbia University, USA OVGU Magdeburg, Germany Northwestern University, USA Cornell Tech, USA Universidad Adolfo Ibañez, Chile University of Southern California, USA RWTH Aachen, Germany Georgia Institute of Technology, USA TU Berlin, Germany Massachusetts Institute of Technology, USA University of Bonn, Germany TU München, Germany London School of Economics and Political Science, UK  
   
  viii  
   
  Organization  
   
  Sponsors  
   
  Organization  
   
  ix  
   
  Contents  
   
  Information Complexity of Mixed-Integer Convex Optimization . . . . . . . . . . . . . . Amitabh Basu, Hongyi Jiang, Phillip Kerger, and Marco Molinaro  
   
  1  
   
  Efficient Separation of RLT Cuts for Implicit and Explicit Bilinear Products . . . Ksenia Bestuzheva, Ambros Gleixner, and Tobias Achterberg  
   
  14  
   
  A Nearly Optimal Randomized Algorithm for Explorable Heap Selection . . . . . . Sander Borst, Daniel Dadush, Sophie Huiberts, and Danish Kashaev  
   
  29  
   
  Sparse Approximation over the Cube . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Sabrina Bruckmeier, Christoph Hunkenschröder, and Robert Weismantel  
   
  44  
   
  Recycling Inequalities for Robust Combinatorial Optimization with Budget Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Christina Büsing, Timo Gersing, and Arie M. C. A. Koster  
   
  58  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes . . . . . . . . . . . Jean Cardinal and Raphael Steiner  
   
  72  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs . . . . . . . . . . . . . . . . . . . . Antonia Chmiela, Gonzalo Muñoz, and Felipe Serrano  
   
  87  
   
  From Approximate to Exact Integer Programming . . . . . . . . . . . . . . . . . . . . . . . . . . 100 Daniel Dadush, Friedrich Eisenbrand, and Thomas Rothvoss Optimizing Low Dimensional Functions over the Integers . . . . . . . . . . . . . . . . . . . 115 Daniel Dadush, Arthur Léonard, Lars Rohwedder, and José Verschae Configuration Balancing for Stochastic Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Franziska Eberle, Anupam Gupta, Nicole Megow, Benjamin Moseley, and Rudy Zhou An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 Satoru Fujishige, Tomonari Kitahara, and László A. Végh Stabilization of Capacitated Matching Games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 Matthew Gerstbrein, Laura Sanità, and Lucy Verberk  
   
  xii  
   
  Contents  
   
  Designing Optimization Problems with Diverse Solutions . . . . . . . . . . . . . . . . . . . 172 Oussama Hanguir, Will Ma, and Christopher Thomas Ryan ReLU Neural Networks of Polynomial Size for Exact Maximum Flow Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Christoph Hertrich and Leon Sering On the Correlation Gap of Matroids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 Edin Husi´c, Zhuan Khye Koh, Georg Loho, and László A. Végh A 4/3-Approximation Algorithm for Half-Integral Cycle Cut Instances of the TSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Billy Jin, Nathan Klein, and David P. Williamson The Polyhedral Geometry of Truthful Auctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231 Michael Joswig, Max Klimm, and Sylvain Spitz Competitive Kill-and-Restart and Preemptive Strategies for Non-clairvoyant Scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246 Sven Jäger, Guillaume Sagnol, Daniel Schmidt genannt Waldschmidt, and Philipp Warode A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP . . . . 261 Anna R. Karlin, Nathan Klein, and Shayan Oveis Gharan Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts . . . . . . . . . . . . 275 Aleksandr M. Kazachkov and Egon Balas Optimal General Factor Problem and Jump System Intersection . . . . . . . . . . . . . . 291 Yusuke Kobayashi Decomposition of Probability Marginals for Security Games in Abstract Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306 Jannik Matuschke Set Selection Under Explorable Stochastic Uncertainty via Covering Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319 Nicole Megow and Jens Schlöter Towards a Characterization of Maximal Quadratic-Free Sets . . . . . . . . . . . . . . . . . 334 Gonzalo Muñoz, Joseph Paat, and Felipe Serrano Compressing Branch-and-Bound Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348 Gonzalo Muñoz, Joseph Paat, and Álinson S. Xavier  
   
  Contents  
   
  xiii  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear Bilevel Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363 Gonzalo Muñoz, David Salas, and Anton Svensson Towards an Optimal Contention Resolution Scheme for Matchings . . . . . . . . . . . 378 Pranav Nuti and Jan Vondrák Advances on Strictly Δ-Modular IPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393 Martin Nägele, Christian Nöbel, Richard Santiago, and Rico Zenklusen Cut-Sufficient Directed 2-Commodity Multiflow Topologies . . . . . . . . . . . . . . . . . 408 Joseph Poremba and F. Bruce Shepherd Constant-Competitiveness for Random Assignment Matroid Secretary Without Knowing the Matroid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 Richard Santiago, Ivan Sergeev, and Rico Zenklusen A Fast Combinatorial Algorithm for the Bilevel Knapsack Problem with Interdiction Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438 Noah Weninger and Ricardo Fukasawa Multiplicative Auction Algorithm for Approximate Maximum Weight Bipartite Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453 Da Wei Zheng and Monika Henzinger A Linear Time Algorithm for Linearizing Quadratic and Higher-Order Shortest Path Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466 Eranda Çela, Bettina Klinz, Stefan Lendl, Gerhard J. Woeginger, and Lasse Wulf Author Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481  
   
  Information Complexity of Mixed-Integer Convex Optimization Amitabh Basu1 , Hongyi Jiang2 , Phillip Kerger1 , and Marco Molinaro3,4(B) 1  
   
  2  
   
  Department of Applied Mathematics and Statistics, Johns Hopkins University, Baltimore, USA {abasu9,pkerger}@jhu.edu School of Civil and Environmental Engineering, Cornell University, Ithaca, USA [email protected]  3 Microsoft Research, Redmond, USA [email protected]  4 Computer Science Department, PUC-Rio, Rio de Janeiro, Brazil  
   
  Abstract. We investigate the information complexity of mixed-integer convex optimization under diﬀerent kinds of oracles. We establish new lower bounds for the standard ﬁrst-order oracle, improving upon the previous best known lower bound. This leaves only a lower order linear term (in the dimension) as the gap between the lower and upper bounds. Further, we prove the ﬁrst set of results in the literature (to the best of our knowledge) on information complexity with respect to oracles based on ﬁrst-order information but restricted to binary queries, and discuss various special cases of interest thereof. Keywords: Mixed-integer optimization  
   
  1  
   
  · Information complexity  
   
  First-order Information Complexity  
   
  We consider the problem class of mixed-integer convex optimization: inf{f (x, y) : (x, y) ∈ C, (x, y) ∈ Zn × Rd },  
   
  (1)  
   
  where f : Rn × Rd → R ∪ {+∞} is a convex (possibly nondiﬀerentiable) function and C ⊆ Rn × Rd is a closed, convex set. Given ε > 0, we wish to report a point in S((f, C), ε) := {(x, y) ∈ C ∩ dom(f ) ∩ (Zn × Rd ) : f (x, y) ≤ f (x , y ) + ε, ∀(x , y ) ∈ C ∩ dom(f ) ∩ (Zn × Rd )}. The ﬁrst and third authors gratefully acknowledge support from Air Force Oﬃce of Scientiﬁc Research (AFOSR) grant FA95502010341 and National Science Foundation (NSF) grant CCF2006587. The fourth author was supported in part by the Coordena¸ca ˜o de Aperfei¸coamento de Pessoal de N´ıvel Superior (CAPES, Brasil) - Finance Code 001, by Bolsa de Produtividade em Pesquisa #312751/2021-4 from CNPq, and FAPERJ grant “Jovem Cientista do Nosso Estado”. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 1–13, 2023. https://doi.org/10.1007/978-3-031-32726-1_1  
   
  2  
   
  A. Basu et al.  
   
  A point in S((f, C), ε) will be called an ε-approximate solution and points in C ∩ dom(f ) ∩ (Zn × Rd ) will be called feasible solutions. We say that x1 , . . . , xn are the integer-valued decision variables or simply the integer variables of the problem, and y1 , . . . , yd are called the continuous variables. The notion of information complexity (a.k.a oracle complexity or analytical complexity) goes back to foundational work by Nemirovski and Yudin [8] on convex optimization (without integer variables) and is based on the following. An algorithm for reporting an ε-approximate solution to an instance (f, C) must be “given” the instance somehow. Allowing only instances with explicit, algebraic descriptions (e.g., the case of linear programming) can be restrictive. To work with more general, nonlinear instances, the algorithm is allowed to make queries to an oracle to collect information about the instance. The standard oracle that has been studied over the past several decades is the so-called ﬁrst-order oracle, which consists of two parts: i) a separation oracle that receives a point z ∈ Rn+d and reports “YES” if z ∈ C and otherwise reports a separating hyperplane for z and C, ii) a subgradient oracle that receives a point z ∈ Rn+d and reports f (z) and a subgradient for f at z. The goal is to design a query strategy that can report an ε-approximate solution after making the smallest number of queries. Tight lower and upper bounds (diﬀering by only a small constant factor) on the number of queries were obtained by Nemirovski and Yudin in their seminal work  case with no integer variables); roughly speaking, the bound is  [8] (the Θ d log 1ε . These insights were extended to the mixed-integer setting in [2,3, 9], with the best known lower and upper bounds stated in [2]. Observe that the response to any separation/subgradient query is a vector in Rn+d . Thus, each query reveals at least n+d bits of information about the instance. A more careful accounting that measures the “amount of information” accrued would track the total number of bits obtained as opposed to just the total number of oracle queries made. A natural question, posed in [2], is whether the bounds from the classical analysis would change if one uses this new measure of the total number of bits, as opposed to the number  of queries. The intuition, roughly, is that one should need a factor (n + d) log 1ε larger than   the number of ﬁrst-order queries, because one should need to probe at least log 1ε bits in n+d coordinates to recover the full subgradient/separating hyperplane (up to desired approximations). We attempt to make some progress on this question in this paper. The above discussion suggests that one should consider oracles that return a desired bit of a desired coordinate of the separating hyperplane vector or subgradient. However, one can imagine making other binary queries on the instance; for example, one can pick a direction and ask for the sign of the inner product of the subgradient and this direction. In fact, one can consider more general binary queries that have nothing to do with subgradients/separating hyperplanes. If one allows all possible binary queries, i.e., one can use any function from the space of instances to {0, 1} as a query, then one can simply ask for the appropriate bits of the true minimizer and in O((n + d) log(1/ε)) queries, one can get an ε-approximate solution. A matching lower bound follows from a fairly straightforward counting argument. Thus, allowing for all possible binary queries gives the same information complexity bound as the original Nemirovski-Yudin bound  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  3  
   
  with subgradient queries in the n = 0 (no integer variables) case, but is an exponential improvement when n ≥ 1 (see [2] and the discussion below). What this shows is that the bounds on information complexity can be quite diﬀerent under diﬀerent oracles. With all possible binary queries, while each query reveals only a single bit of information, the queries themselves are a much richer class and this compensates to give the same bound in the continuous case and exponentially better bounds in the presence of integer variables. Thus, to get a better understanding of this trade-oﬀ, we restrict to queries that still extract information from the subgradient or separating hyperplane at a point, and are thus “local” in a sense. (In,d,R,ρ,M is the set of instances we focus on throughout the paper, see Deﬁnition 2 for a formal deﬁnition.) Definition 1. An oracle using ﬁrst-order information consists of two parts: 1. For every z ∈ [−R, R]n+d , there exist two maps gzsep : In,d,R,ρ,M → Rn+d and gzsub : In,d,R,ρ,M → R × Rn+d such that for all (f, C) ∈ In,d,R,ρ,M the following properties hold. (a) C ⊆ {z ∈ Rn+d : gzsep (C), z < gzsep (C), z } if z ∈ C and gzsep (C) = 0 if z ∈ C. In other words, gzsub (f ) returns a (normal vector to a) separating hyperplane if z ∈ C. We will assume that a nonzero response gzsep (C) has norm 1, since scalings do not change the separation property. (b) gzsub (f ) ∈ {f (z)} × ∂f (z), where ∂f (z) denotes the subdiﬀerential (the set of all subgradients) of f at z. In other words, gzsub (f ) returns the function value and a subgradient for f at z. If f (z) = +∞, gzsub (f ) returns a separating hyperplane for z and the domain of f .1 Such maps will be called ﬁrst-order maps. A collection of ﬁrst-order maps, one for every z, is called a (complete) ﬁrst-order chart and will be denoted by G. 2. There are two sets of functions Hsep and Hsub with domains Rn+d and R × Rn+d respectively. We will use the notation H = Hsep ∪ Hsub . H will be called the collection of permissible queries of the oracle. The algorithm, at any iteration, can choose a point z and a function h ∈ H  and it receives the response h(gzsep (f)) or h(gzsub (C)), depending on whether sep sub   or h ∈ H , where (f , C) is the unknown instance. h∈H In particular, when Hsep and Hsub consist only of the identity function, we recover a standard ﬁrst-order oracle. We will also study the cases where Hsep and Hsub consist of functions that map a vector to a particular bit of a particular coordinate, or the sign of the inner product with a particular direction, or the set of all possible binary functions. In the last case, the oracle will be called the general binary oracle based on G.  
   
  1  
   
  When the function value is +∞, we will count this as a separation query. In other words, below we will assume without further comment that every functional query returns a ﬁnite real value for the function and a subgradient at the queried point.  
   
  4  
   
  1.1  
   
  A. Basu et al.  
   
  Our Results  
   
  It is not hard to see that if we consider all possible instances of (1), then any adaptive query strategy has inﬁnite information complexity because a ﬁnite number of queries cannot distinguish between all possible instances. Thus, bounds on the information complexity must be based on appropriate parameterizations of the problem. We will focus on the following standard parameterization. Definition 2. In,d,R,ρ,M is the set of all instances of (1) such that (i) C ∩ dom(f ) is contained in the box {z ∈ Rn × Rd : z∞ ≤ R}. ˆ ∈ Rd (ii) If (x , y ) is an optimal solution of the instance, then there exists y  ˆ ∞ ≤ ρ} ⊆ C. In other words, there is a “strictly satisfying {(x , y) : y − y ˆ ) in the same ﬁber as the optimum (x , y ). feasible” point (x , y (iii) f is Lipschitz continuous with respect to the  · ∞ -norm with Lipschitz constant M on {x} × [−R, R]d for all x ∈ [−R, R]n ∩ Zn , where we use the convention that if f is identically +∞ on {x}×[−R, R]d , then any M works on this ﬁber. In other words, for any (x, y), (x, y ) ∈ (Zn ×Rd )∩[−R, R]n+d with y −y ∞ ≤ R, |f (x, y)−f (x, y )| ≤ M y −y ∞ with the convention that ∞ − ∞ = 0. We obtain the following results in this paper. Results for n ≥ 1 (allowing integer variables). 1. In the classical setting where Hsep and Hsub consist only of the identity function (i.e. each query receives the entire subgradient/separating hyperplane), we improve the best known lower bound (from [2]) on the number of queries needed for the general mixed-integer case. In particular, we show that one   MR n queries, improving upon the previous needs at least Ω 2 d log min{ρ,1}ε    R bound of Ω 2n d log ρ . We mention here that the ﬁrst lower bound on information complexity with integer constrained variables was established in [3], for a speciﬁc class of algorithms/query strategies called cutting-plane schemes. The lower bounds stated here (and in [2]) do not make any assumptions on the algorithms/query strategies.    MR n for the classical setting is com2. This lower bound of Ω 2 d log min{ρ,1}ε    MR in the litplemented by an upper bound of O 2n d(n + d) log min{ρ,1}ε erature. This was ﬁrst obtained in [9]; see [2] for a self-contained exposition. As mentioned before, we expect the information complexity in the setting of binary  oracles using ﬁrst-order information to be at most a factor MR larger than the classical setting. We rigorously prove (n + d) log min{ρ,1}ε this, under the additional assumption that the ﬁber containing the optimal solution contains a point that is ρ-deep inside the feasible region C, i.e., a ball of radius ρ centered at this point is contained in the set C. Note that this is a stronger assumption compared to item (ii) in the deﬁnition of In,d,R,ρ,M .  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  5  
   
  Results for n = 0 (continuous case with no integer variables). 1. When the separation and subgradient oracles can only be accessed through (all) binary queries (i.e., Hsep and Hsub consist of all possible binary functions on Rd ), we show that strictly more queries are needed compared to the classic setting of  full oracle access.  More precisely, compared to the MR classic bound of Θ d log min{ρ,1}ε , we show that one needs at least     MR ˜ hides polylogarith˜ max d 87 , d log binary queries (where Ω Ω min{ρ,1}ε mic factors in d). This is obtained using recent lower bounds on “memoryconstrained” algorithms for convex optimization from [6].  2   MR 2. We establish an upper bound of O d2 log min{ρ,1}ε for binary queries using ﬁrst-order oracles. This is an extension of a result from [11] that considered the unconstrained optimization setting.    MR for any ﬁnite 3. We establish an upper bound of O log |I| + d log min{ρ,1}ε subclass of instances I ⊆ In,d,R,ρ,M . Note that this can beat the lower bound from Item 1 above, e.g., if |I| = 2O(d) . 1.2  
   
  Formal Definitions and Statement of Results  
   
  For any set X, we will use X ∗ to denote the set of all ﬁnite sequences of elements from X (e.g., {0, 1}∗ denotes the set of all ﬁnite binary strings). Definition 3. Given an oracle using ﬁrst-order information (G, H), let Q be the set of possible queries that can be made under this oracle (i.e., pairs (z, h) where z ∈ Rn+d is a query point and h ∈ H). Let H denote the response set of the functions in H (e.g., vectors for standard ﬁrst-order oracles, or {0, 1} for binary queries). A query strategy is a function D : (Q × H)∗ → Q. The transcript Π(D, I) of a strategy D on an instance I = (f, C) is the sequence of query and response pairs (qi , qi (I)), i = 1, 2, . . . obtained when one applies D on I, i.e., q1 = D(∅) and qi = D((q1 , q1 (I)), . . . , (qi−1 , qi−1 (I))) for i ≥ 2. The ε-information complexity icomp ε (D, I, G, H) of an instance I for a query strategy D, with access to an oracle using ﬁrst-order information (G, H), is deﬁned as the minimum natural number k such that the set of all instances which return the same responses as the instance I to the ﬁrst k queries of D have a common ε-approximate solution. The ε-information complexity of the problem class In,d,R,ρ,M , with access to an oracle using ﬁrst-order information (G, H), is deﬁned as icomp ε (n, d, R, ρ, M, G, H) := inf D supI∈In,d,R,ρ,M icomp ε (D, I, G, H) where the inﬁmum is taken over all query strategies. We can now formally state our main results. Let Hbit be the set of binary queries that return a desired bit (of a desired coordinate) of a subgradient/separating hyperplane/function value. Let Hdir be the set of binary queries that returns  
   
  6  
   
  A. Basu et al.  
   
  the sign of the inner product of the subgradient/separating hyperplane with a desired direction, or a desired bit of the function value. Results for n ≥ 1 (allowing integer variables). Theorem 1. There exists a complete ﬁrst-order chart G such that for the standard ﬁrst-order oracle based on G (i.e., H consists of the identity functions), we have     MR . icomp ε (n, d, R, ρ, M, G, H) = Ω 2n 1 + d log min{ρ,1}ε Theorem 2. Assume d ≥ 1. For U > 0, consider the subclass of instances of In,d,R,ρ,M whose objective function values lie in [−U, U ], and the ﬁber over the optimal solution contains a z such that the (n + d)-dim ρ-radius ball centered at z is contained in C. There exists a query strategy for this subclass that uses (G, H), where G is any complete ﬁrst-order chart and H is either Hbit or Hdir , that reports an ε-approximate solution by making at most  

  dM R (n + d)M R U O 2n d (n + d) log · (n + d) log + log min{ρ, 1}ε ε ε queries. Prescribing an a priori range for objective function values is not a serious restriction for two reasons: i) The diﬀerence between the maximum and the minimum values of an objective function in In,d,R,ρ,M is at most 2M R, and ii) All optimization problems whose objective functions diﬀer by a constant are equivalent. We also comment that while we assume d ≥ 1 in Theorem 2, similar bounds can be established for the d = 0 case. We omit this here because a uniﬁed expression for the d = 0 and d ≥ 1 cases becomes unwieldy and diﬃcult to parse. We remark that we can obtain the same result when the objective function can only be accessed through comparisons of the form “Is f (z) ≤ f (z )?”, i.e., no access to the subgradients ∂f . Such algorithms are particularly useful in learning from users’ behaviors, since while a user typically cannot accurately report its (dis)utility value f (z) for an option z, it can more reliably compare the values f (z) and f (z ) of two options; see [5,10] and references therein for discussions and algorithms in the continuous case. To the best of our knowledge, no such algorithm for the mixed-integer case has appeared explicitly in the literature. We also remark that the additional assumption that a (n + d)-dim ρ-radius is contained in C can be weakened by using a Lenstra-style algorithm, but this yields a much worse dependence in d and n. Results for n = 0 (continuous case with no integer variables). Theorem 3. There exists a complete ﬁrst-order chart G such that for the general binary oracle based on G (i.e., H consists of all possible binary functions on Rd ), we have     MR ˜ max d 87 , d log icomp ε (d, R, ρ, M, G, H) = Ω , min{ρ,1}ε ˜ hides polylogarithmic factors in d. where Ω  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  7  
   
  Theorem 4. For U > 0, consider the subclass of instances of Id,R,ρ,M whose objective function values lie in [−U, U ]. There exists a query strategy for this subclass that uses (G, H), where G is any complete ﬁrst-order chart and H is either Hbit or Hdir , that reports an ε-approximate solution by making at most  

  dM R dM R U O d log · d log + log min{ρ, 1}ε ε ε queries. Theorem 5. Given any subclass of ﬁnitely many instances I ⊂ In,d,R,ρ,M and any complete ﬁrst-order chart G, there exists a query strategy for this subclass using the general binary on G that reports an ε-approximate solution  oracle based   MR by making at most O log |I| + d log min{ρ,1}ε queries.  
   
  1.3  
   
  Discussion and Future Avenues  
   
  The concept of information complexity in continuous convex optimization and its study go back several decades, and it is considered a fundamental question in convex optimization. In comparison, much less work on information complexity has been carried out in the presence of integer constrained variables. Nevertheless, we believe there are important and challenging questions that come up in that domain that are worth studying. Further, even within the context of continuous convex optimization, the notion of information complexity has almost exclusively focused on the number of ﬁrst-order queries. As we hope to illustrate with the results of this paper, considering other kinds of oracles lead to very interesting questions at the intersection of mathematical optimization and information theory. In particular, the study of binary oracles promises to give a more reﬁned understanding of the fundamental question “How much information about an optimization instance do we need to be able to solve it with provable guarantees?”. For instance, establishing any superlinear (in the dimension) lower bound for the continuous problem with binary oracles, like the one in Theorem 3, seems to be nontrivial. In fact, the results from [6], on which Theorem 3 is based, were considered a breakthrough in establishing superlinear lower bounds on space complexity of convex optimization. Even so, the right bound is conjectured to be quadratic in the dimension (see Theorem 4) and our Theorem 3 is far from that at this point. We thus view the results of this paper as expanding our understanding of information complexity of optimization in two diﬀerent dimensions: what role does the presence of integer variables play and what role does the nature of the oracle play (with or without integer variables)? For integer variables, our ﬁrst result brings the lower bound closer to the best  
   
  8  
   
  A. Basu et al.  
   
  known upper bound on information complexity based on the classical subgradient oracle. The remaining gap is now simply a factor linear in the dimension. A conjecture in convex geometry ﬁrst articulated in [9, Conjecture 4.1.20] and elaborated upon in [2,3] would resolve this and would show that the right upper bound is essentially equal to the lower bound we prove in this paper. Therefore, we have reasons to believe that the right bound is the one we obtain in this paper. Beyond this, we believe the following additional conjectures to be good catalysts for future research, especially in regard to understanding the interplay of integer variables and other oracles. Conjecture 1. Given an oracle (G, H) based on ﬁrst-order information, suppose there is a family of instances that establishes a lower bound (d, R, ρ, M, G, H) for the n = 0 (continuous) case. Then there exists a family of instances that establishes a lower bound of 2n · (d, R, ρ, M, G, H) for the n ≥ 1 case, i.e., the general mixed-integer case. Conjecture 2. If there exists a query strategy with worst case information complexity u(n, d, R, ρ, M, G) under the standard ﬁrst-order oracle based on a complete ﬁrst-order chart G, then there existsa query strategy with  worst case infor under the general mation complexity u(n, d, R, ρ, M, G) · O (n + d) log MρεR binary oracle based G. Both of the above results, if true, would be useful “transfer” theorems: the ﬁrst one for lower bounds, the second one for upper bounds. Conjecture 1 takes a lower bound result for the continuous problem and lifts it to the general mixedinteger case with a factor of 2n . This would be a general tool that can then give Theorem 1 as a special case and also give a mixed-integer version of Theorem 3 as a corollary. Further, if future research on the information complexity of continuous convex optimization results in better/diﬀerent lower bounds, these would immediately imply new lower bounds for the mixed-integer case as well. For instance, we believe the following conjecture to be true for the continuous convex optimization problem. Conjecture 3. There exists a complete ﬁrst-order chart G such that the general 2    . binary oracle based on G has information complexity Ω d2 log MρεR Another version of Conjecture 3 is also stated in the language of “memoryconstrained” algorithms (see Sect. 2.2 below) in [6,11]. Conjecture 2 can be used to take upper bound results proved in the standard ﬁrst-order oracle setting and get upper bound results in the general binary oracle setting. For instance, if the upper bound for the general mixed-integer problem is improved by resolving the convex geometry conjecture mentioned above (and we believe the lower bound is correct and the upper bound is indeed loose), then this would also give better upper bounds for the general binary oracle setting.  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  2 2.1  
   
  9  
   
  Proof Sketches Proof Sketch of Theorem 1  
   
  The general strategy to prove Theorem 1 is the following: Given any query strategy D, we will construct two instances (f1 , C1 ), (f2 , C2 ) ∈ In,d,R,ρ,M such that the transcripts Π(D, (f1 , C1 )) and Π(D, (f2 , C2 )) are equal for the ﬁrst k C2 ), ε) = ∅. terms if k is less than the lower bound, but S((f1 , C 1 ), ε) ∩ S((f  2 , was estabThe lower bound icomp ε (n, d, R, ρ, M, G, H) ≥ 2n · d log 2R 3ρ lished 4.2]. Thus, it suﬃces to show icomp ε (n, d, R, ρ, M, G, H) ≥ in [2,  Theorem  d2n log8 M2εR . The idea is to use a family F of convex functions over [−R, R]d  M R deﬁned  subgradient queries described in [7,8] such that one needs at least d log8 2ε to report an ε-approximate solution. In fact, for any query strategy in Rd , one construct subgradient responses such that if less than  can adversarially d log8 M2εR are made, one can report two functions from F that would have provided the same responses as given by the adversary and yet have disjoint sets of ε-approximate solutions. We now mimic this by putting the family F over the ﬁbers {x} × [−R, R]d for x ∈ {0, 1}n . Our constraint set C is going to be simply [0, 1]n ×[−R, R]d ; thus, the separation oracle queries will provide no information. We will create a nested sequence of polyhedra Y0 ⊇ Y1 ⊇ . . . ⊇ Yk contained in [0, 1]n × [−R, R]d × R, where Yi corresponds to query i. This sequence will depend on the queries made and will determine our responses. The set Yk will be used to construct the epigraphs of two functions f1 and f2 , whose ε-approximate minimizers in Zn × Rd will be disjoint. We now enumerate diﬀerent cases:  
   
  1. If the query point is outside [0, 1]n × [−R, R]d , then the function value is reported to be +∞ and a separating hyperplane is reported. Yi is not updated. 2. If the query point z = (x, y) is inside [0, 1]n × [−R, R]d , but x ∈ {0, 1}n , then we simply report the function value from the current Yi set interpreted as an epigraph and any subgradient at this point on Yi . Yi is not updated. 3. If the query point z = (x, y) ∈ {0, 1}n × [−R, R]d , we look at what the response from the adversary would have been for the family F at the query point y, and we rotate the corresponding subgradient hyperplane so that it is valid for all other ﬁbers {x } × [−R, R]d for x ∈ {0, 1}n \ {x}, as well as all points queried inside the hypercube, but not the ﬁbers. This can be done because the ﬁbers are compact, and only a ﬁnite number of queries have been made. We then update Yi by intersecting with this rotated halfspace, and report this rotated halfspace as the response for this query.   queries have been made, there must exist a ﬁber – If k < 2n d log8 M2εR    corresponding to say x ∈ {0, 1}n – on which less than d log8 M2εR queries were made. We now take the two functions f˜1 , f˜2 from F that would have given the same responses on that ﬁber, with disjoint ε-approximate solutions. On the other ﬁbers corresponding to x = x , we consider any function f˜x from F that would have returned the same responses on that ﬁber (this can be ensured to  
   
  10  
   
  A. Basu et al.  
   
  exist given the structure of the family F), and deﬁne Y˜ x := {x} × epi(f˜x ). For query points z not on the ﬁbers, we consider the sets Y˜ z := Yk ∩ ({z} × R). For i = 1, 2, we deﬁne Ei as the convex hull of {x } × epi(f˜i ) and all the Y˜ x , x = x and Y˜ z for query points z not on the ﬁbers. These convex hulls are the epigraphs of two functions f1 , f2 whose ε-approximate minimizers can be shown to be exactly the points of the form (x , y), where y is an ε-approximate minimizer of f˜1 , f˜2 , respectively. These are disjoint sets and we are done. 2.2  
   
  Proof of Theorem 3  
   
  We need to introduce the idea of information memory of any query strategy/algorithm. Definition 4. A ﬁrst-order query strategy with information memory comprises three functions: 1. φquery : {0, 1}∗ → [−R, R]n × [−R, R]d . n d ∗ ∗ 2. φsep update : (R × R ) × {0, 1} → {0, 1} . sub n d ∗ 3. φupdate : (R × (R × R )) × {0, 1} → {0, 1}∗ . Given access to a (complete) ﬁrst-order chart G, the query strategy maintains an information memory, which is a ﬁnite length binary string in {0, 1}∗ , initialized as the empty string. At every iteration k = 1, 2, . . ., the query φquery (rk−1 ) andupdates its memory using either strategy computes zk :=    sep sep sep  sub   is the gz (C), rk−1 or rk = φ gz (f ), rk−1 , where (f, C) rk = φ update  
   
  k  
   
  update  
   
  k  
   
  unknown true instance. After ﬁnitely many iterations, the query strategy does a ﬁnal computation based on its information memory and reports an ε-approximate solution, i.e., there is a ﬁnal function φfin : {0, 1}∗ → Zn × Rd . The information memory complexity of an algorithm for an instance is the maximum length of its information memory rk over all iterations k during the processing of this instance. Proposition 6. Let G be a (complete) ﬁrst-order chart. For any ﬁrst-order query strategy A with information memory that uses G, there exists a query strategy A using the general binary oracle based on G, such that for any instance (f, C), if A stops after T iterations with information memory complexity Q, A stops after making at most Q · T oracle queries. Conversely, for any query strategy A using the general binary oracle based on G, there exists a ﬁrst-order query strategy A with information memory such that for any instance (f, C), if A stops after T iterations, A stops after making at most T iterations with information memory complexity at most T . Proof. Let A be a ﬁrst-order query strategy with information memory. We can simulate A by the query strategy whose queries are precisely the bits of the information memory state rk at each iteration k of A. More formally, the query  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  11  
   
  sub is z = φquery (rk−1 ) and h(·) = (φsep update (·, rk−1 ))i or h(·) = (φupdate (·, rk−1 ))i , depending on which type of query was made. Conversely, given a query strategy A based on the general binary oracle, we can simulate it with a ﬁrst-order query strategy with information memory where in each iteration, we simply append the new bit queried by A to the current state of the memory.    
   
  The following is (a rephrasing of) a result from [6]. Theorem 7. [6, Theorem 1] For every δ ∈ [0, 1/4], there is a class of instances I ⊆ In,d,R,ρ,M and a (complete) ﬁrst-order chart G such that any ﬁrst-order query strategy with information memory must have either d1.25−δ information ˜ 1+ 43 δ ) iterations (in memory complexity (in the worst case) or make at least Ω(d the worst case). 3 in Theorem 7, we obtain that any ﬁrst-order Proof of Theorem 3. Setting δ = 28 8/7 ˜ 8/7 ) query strategy uses either d information memory or makes at least Ω(d iterations. Using the second part of Proposition 6, we obtain the desired lower ˜ 8/7 ) on the number of queries made by any query strategy using bound of Ω(d the general binary oracle based on G.    
   
  2.3  
   
  Proof Sketch of Theorem 5  
   
  We will sketch the proof for solving the feasibility problem, optimization being handled in a similar way by incorporating subgradients. Thus, we have a ﬁnite set of instance I ⊆ Id,R,ρ with only continuous variables, a true (unknown) instance C ∈ I, and our goal is to report a point in C using few binary queries to a separation oracle. For that, we design a procedure that maintains a family U ⊆ I of the instances that are still possible (which always includes the true instance C), along with a polyhedron P containing C. We start with U = I and P = [−R, R]d . We will show that we can always either reduce |U| or vol(P ) by a constant fraction with each query. For that, while |U| > 1 do the following: – Set p equal to be the centroid of P . If the separation oracle at p reports that p ∈ C, then we return p. Otherwise: – Case 1: For every possible answer v ∈ Rd to the separation oracle, at most half of the sets C  in U give that answer for the point p, namely gpsep (C  ) = v. Then, there is a set of answers V ⊆ Rd such that the number of sets C  ∈ U with gpsep (C  ) ∈ V is between 14 |U| and 34 |U|. Then querying whether the true instance has gpsep (C) ∈ V (using the binary query h where h(v) = 1 iﬀ v ∈ V ) we can eliminate at least a quarter of the instances of U as not possible. So update U by deleting those instances from it. ¯ ∈ Rd such that more than half of the instances C  – Case 2: There exists v sep  ¯ . Query whether the true instance has gpsep (C) = v ¯ in U have gp (C ) = v ¯ and 0 everywhere else). If (using the binary query h that takes value 1 at v ¯ , then remove from U all instances C  such that gpsep (C  ) = v ¯, gpsep (C) = v  
   
  12  
   
  A. Basu et al.  
   
  reducing the size of U by at least half. Otherwise, we then know the exact ¯ , and so separating hyperplane for the true instance C, namely gpsep (C) = v d v, x ≤ ¯ v, p }. employ it to update the relaxation as P ← P ∩ {x ∈ R : ¯ In each step, either the size of U decreases by at least 1/4, or the volume of P decreases by a factor of at least 1e (by Gr¨ unbaum’s Theorem [4]). The former can only happen O(log |I|) times until U becomes a singleton (in which case we know    times, the true instance), whereas the latter can happen at most O d log R ρ since C is always a subset of P and C contains an  -ball of radius ρ; thus, ∞    R d queries. vol(P ) ≥ (2ρ) . So the procedure succeeds in O log |I| + d log ρ 2.4  
   
  Proof Sketch of Theorems 2 and 4  
   
  Here we consider all instances In,d,R,ρ,M and again the goal is to solve convex mixed-integer (Theorem 2) and continuous (Theorem 4) instances using few binary queries (more speciﬁcally, bit queries or inner product sign queries) to the separation and subgradient oracles. Our strategy is to: 1) solve the the problems using approximate subgradients/separating hyperplanes; 2) use binary queries to construct such approximations. For the ﬁrst item, we use the algorithm of [3] based on the centerpoint: this is a point in the convex set where every halfspace supported on it cuts oﬀ a signiﬁcant (mixed-integer) volume of the set. Similar to the previous section, the algorithm keeps an outer relaxation P of the feasible region C, and repeatedly applies separation or subgradient-based cuts through the centerpoint of P ; the assumption that the feasible region contains a ball (in the optimal ﬁber) establishes a volume lower bound that essentially limits the number of iterations of the algorithm. While the original algorithm of [3] uses exact separation/subgradient oracles, we show, not surprisingly, that approximate ones suﬃce. The next item is to construct approximate separation/subgradient oracles by using few binary queries to the exact ones. In case of bit queries Hbit this is can be easily done by querying enough bits of the latter. The case of inner product sign queries Hdir , namely that given a vector g we can pick a direction a and ask “Is a, g ≥ 0?”, is more interesting. It boils down to approximating the vector g (subgradient/separating hyperplane) using few such queries.2 Lemma 1. For any vector g ∈ Rd , using O(d log εd ) inner product sign queries  
   
  g ˆ − g ˆ ∈ Rd such that g ≤ ε . we can obtain a unit-length vector g Proof. sketch. We prove by induction on d that with d log 8δ queries we can obtain  
   
  g ε ˆ − g ˆ with g ≤ 2dδ; the lemma follows by setting δ = 2d a unit-length vector g . 8 In the 2-dimensional case can use log δ queries to perform binary search and ˆ obtain a cone of angle δπ 4 that contains g; any unit-length vector g in this cone g  ≤ δ ≤ 4δ as desired. has ˆ g − g 2  
   
  This is related to (actively) learning the linear classiﬁer whose normal is given by g [1]. These methods can perhaps be adapted to our setting, but we present a diﬀerent and self-contained statement and proof.  
   
  Information Complexity of Mixed-Integer Convex Optimization  
   
  13  
   
  For the general case d > 2, we consider any 2-dim subspace A of Rd and ˜ ∈ A to the apply the previous case to obtain in log dδ queries an approximation g ˜ − ΠA g ≤ δΠA g ≤ projection ΠA g of g onto A with guarantee ΠA g · g δg. Then we consider the (d − 1)-dim subspace B := span{˜ g, A⊥ } and by 8 ˆ ∈ B that approximates induction, with 2(d−1) log δ queries we obtain a vector g ˆ − ΠB g ≤ 2(d − the projection ΠB g of g onto B with guarantee ΠB g · g 1)δΠB g ≤ 2(d − 1)δg (a total of less than 2d log 8δ queries was then used). ˆ is the desired approximation of g, namely (letting One can then show that g λA := ΠA g and λB := ΠB g)  

  g − g · g ˆ ≤ g − ΠB g + ΠB g − λB · g ˆ  + λB · g ˆ − g · g ˆ ≤ 2dδg, the upper bound on the ﬁrst and third terms in the middle inequality following ˜ ) and the upper bound from the fact dist(g, B) ≤ δg (by the guarantee of g ˆ. on the second term following from the approximation guarantee of g    
   
  References 1. Balcan, M.-F., Long, P.: Active and passive learning of linear separators under log-concave distributions. In: Shalev-Shwartz, S., Steinwart, I., (eds.) Proceedings of the 26th Annual Conference on Learning Theory, volume 30 of Proceedings of Machine Learning Research, pp. 288–316. Princeton, NJ, USA, 12–14 June 2013. PMLR (2013) 2. Basu, A.: Complexity of optimizing over the integers. to appear in Mathematical Programming, Series A (2022) 3. Basu, A., Oertel, T.: Centerpoints: a link between optimization and convex geometry. SIAM J. Optim. 27(2), 866–889 (2017) 4. Gr¨ unbaum, B.: Partitions of mass-distributions and of convex bodies by hyperplanes. Paciﬁc J. Math. 10, 1257–1261 (1960) 5. Jamieson, K.G., Nowak, R.D., Recht, B.: Query complexity of derivative-free optimization. In: Proceedings of the 25th International Conference on Neural Information Processing Systems - Volume 2, NIPS2012, pp. 2672–2680, Red Hook, NY, USA. Curran Associates Inc. (2012) 6. Marsden, A., Sharan, V., Sidford, A., Valiant, G.: Eﬃcient convex optimization requires superlinear memory. arXiv preprint arXiv:2203.15260 (2022) 7. Nemirovski, A.: Eﬃcient methods in convex programming. Lecture Notes (1994) 8. Nemirovski, A.S., Yudin, D,B.: Problem complexity and method eﬃciency in optimization. John Wiley (1983) 9. Oertel, T.: Integer convex minimization in low dimensions, Ph. D. thesis, Diss., Eidgen¨ ossische Technische Hochschule ETH Z¨ urich, Nr. 22288 (2014) 10. Protasov, V.Y.: Algorithms for approximate calculation of the minimum of a convex function from its values. Math. Notes 59(1), 69–74 (1996) 11. Woodworth, B., Srebro, N.: Open problem: the oracle complexity of convex optimization with limited memory. In: Conference on Learning Theory, pp. 3202–3210. PMLR (2019)  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products Ksenia Bestuzheva1(B) , Ambros Gleixner1,2 , and Tobias Achterberg3 1  
   
  3  
   
  Zuse Institute Berlin, Berlin, Germany {bestuzheva,gleixner}@zib.de 2 HTW Berlin, Berlin, Germany Gurobi GmbH, Frankfurt am Main, Germany [email protected]   
   
  Abstract. The reformulation-linearization technique (RLT) is a prominent approach to constructing tight linear relaxations of non-convex continuous and mixed-integer optimization problems. The goal of this paper is to extend the applicability and improve the performance of RLT for bilinear product relations. First, a method for detecting bilinear product relations implicitly contained in mixed-integer linear programs is developed based on analyzing linear constraints with binary variables, thus enabling the application of bilinear RLT to a new class of problems. Our second contribution addresses the high computational cost of RLT cut separation, which presents one of the major diﬃculties in applying RLT eﬃciently in practice. We propose a new RLT cutting plane separation algorithm which identiﬁes combinations of linear constraints and bound factors that are expected to yield an inequality that is violated by the current relaxation solution. A detailed computational study based on implementations in two solvers evaluates the performance impact of the proposed methods. Keywords: Reformulation-linearization technique · Bilinear products · Cutting planes · Mixed-integer programming  
   
  1  
   
  Introduction  
   
  The reformulation-linearization technique (RLT) was ﬁrst proposed by Adams and Sherali [1–3] for bilinear problems with binary variables, and has been applied to mixed-integer [18–20], general bilinear [21] and polynomial [24] problems. RLT constructs valid polynomial constraints, then linearizes these constraints by using nonlinear relations given in the problem and applying relaxations when such relations are not available. If relations used in the linearization step are violated by a relaxation solution, this procedure may yield violated cuts. By increasing the degree of derived polynomial constraints, hierarchies of c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 14–28, 2023. https://doi.org/10.1007/978-3-031-32726-1_2  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  15  
   
  relaxations can be constructed, which were shown to converge to the convex hull representation of MILPs and mixed-integer polynomial problems where continuous variables appear linearly [18–20]. RLT has been shown to provide strong relaxations [21,23], but this comes at the cost of excessive numbers of cuts. To address this, Sherali and Tuncbilek [25] proposed a technique to add a subset of RLT cuts, depending on signs of coefﬁcients of monomial terms in the original constraints and the RLT constraints. Furthermore, the reduced RLT technique [12–14,22] yields equivalent representations with fewer nonlinear terms for polynomial problems containing linear equality constraints. We focus on RLT for bilinear products, which is of particular interest due to the numerous applications whose models involve nonconvex quadratic nonlinearities [3,5,7–9,17]. Even in the bilinear case, large numbers of factors to be multiplied and of RLT cuts that are generated as a result remain an issue that can lead to considerable slowdowns, both due to the cost of cut separation and the large sizes of resulting LP relaxations. The ﬁrst contribution of this paper is a new approach to applying RLT to MILPs. Unlike the approaches that only introduce multilinear relations via multiplication [18,19], this approach detects and enforces bilinear relations that are already implicitly present in the model. A bilinear product relation where one multiplier is a binary variable and the other multiplier is a variable with ﬁnite bounds can be equivalently written as two linear constraints. We identify such pairs of linear constraints that implicitly encode a bilinear product relation, then utilize this relation in the generation of RLT cuts. The second contribution of this paper addresses the major bottleneck for applying RLT successfully in practice, which stems from prohibitive costs of separating RLT cuts, by proposing an eﬃcient separation algorithm. This algorithm considers the signs of bilinear relation violations in a current LP relaxation solution and the signs of coeﬃcients in linear constraints in order to ignore combinations of factors that will not produce a violated inequality. Furthermore, we propose a technique which projects the linear constraints onto a reduced space and constructs RLT cuts based on the resulting much smaller system. The rest of the paper is organized as follows. In Sect. 2, RLT for bilinear products is explained. In Sect. 3, we describe the technique for deriving bilinear product relations from MILP constraints. Section 4 presents the new cut separation algorithm, and computational results are presented in Sect. 5.  
   
  2  
   
  RLT for Bilinear Products  
   
  We consider mixed-integer (nonlinear) programs (MI(N)LPs) of the extended form where auxiliary variables w are introduced for all bilinear products:  
   
  16  
   
  K. Bestuzheva et al.  
   
  min cT x s.t. Ax ď b, g(x, w) ď 0,  
   
  (1a) (1b) (1c)  
   
  xi xj ĳ wij for all (i, j) P I w , x ď x ď x, w ď w ď w,  
   
  (1d) (1e)  
   
  xj P R for all j P I c , xj P {0, 1} for all j P I b ,  
   
  (1f)  
   
  with I “ I c YI b being a disjoint partition of variables x and x having dimension n |I w | (R “ RY{´∞, `∞}), |I| “ n. In the above formulation, x, x P R , w, w P R (l) (l) c P Rn and b P Rm are constant vectors and A P Rm ×n is a coeﬃcient matrix, and the function g deﬁnes the nonlinear constraints. Constraint (1d) deﬁnes the bilinear product relations in the problem and allows for inequalities and equations. Let I p denote the set of indices of all variables that participate in bilinear product relations (1d). Solvers typically employ McCormick inequalities [16] to construct an LP relaxation of constraints (1d). These inequalities describe the convex hull of the set given by the relation xi xj ĳ wij : xi xj ` xi xj ´ xi xj ď wij ,  
   
  xi xj ` xi xj ´ xi xj ď wij ,  
   
  (2a)  
   
  xi xj ` xi xj ´ xi xj ě wij ,  
   
  xi xj ` xi xj ´ xi xj ě wij ,  
   
  (2b)  
   
  where (2a) is a relaxation of xi xj ď wij and (2b) is a relaxation of xi xj ě wij . In the presence of linear constraints (1b), this relaxation can be strengthened n by adding RLT cuts. Consider a linear constraint: k“1 a1k xk ď b1 . Multiplying this constraint by nonnegative bound factors (xj ´ xj ) and (xj ´ xj ), where xj and xj are ﬁnite, yields valid nonlinear inequalities. We will derive the RLT cut using the lower bound factor. The derivation is analogous for the upper bound factor. The multiplication, referred to as the reformulation step, yields: n   
   
  a1k xk (xj ´ xj ) ď b1 (xj ´ xj ).  
   
  k“1  
   
  This nonlinear inequality is then linearized in order to obtain a valid linear inequality. The following linearizations are applied to each nonlinear term xk xj : – xk xj is replaced by wkj if the relation xk xj ď wkj exists in the problem and a1k ď 0, or if the relation xk xj ě wkj exists and a1k ě 0, or if the relation xk xj “ wkj exists in the problem, – if k “ j P I b , then xk xj “ x2j “ xj , – if k “ j R I b , then xk xj “ x2j is outer approximated by a secant from above or by a tangent from below, depending on the sign of the coeﬃcient, – if k ‰ j, k, j P I b and one of the four clique constraints is implied by the linear constraints (1b), then: xk ` xj ď 1 ⇒ xk xj “ 0; xk ´ xj ď 0 ⇒ xk xj “ xk ; ´xk ` xj ď 0 ⇒ xk xj “ xj ; ´xk ´ xj ď ´1 ⇒ xk xj “ xj ` xj ´ 1, – otherwise, xk xj is replaced by its McCormick relaxation.  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  17  
   
  The key step is the replacing of products xk xj with the variables wkj . When a bilinear product relation xk xj ĳ wkj does not hold for the current relaxation solution, this substitution may lead to an increase in the violation of the inequality, thus possibly producing a cut that is violated by the relaxation solution. n In the case that we have a linear equation constraint k“1 a1k xk “ b1 and all nonlinear terms can be replaced using equality relations, then RLT produces an n the equation constraint is treated as two inequalities nequation cut. Otherwise, a x ď b and 1 k“1 1k k k“1 a1k xk ě b1 to produce inequality cuts.  
   
  3  
   
  Detection of Implicit Products  
   
  Consider a product relation wij “ xi xj , where xi is binary. It can be equivalently rewritten as two implications: xi “ 0 ⇒ wij “ 0 and xi “ 1 ⇒ wij “ xj . With the use of the big-M technique, these implications can be represented as linear constraints, provided that the bounds of xj are ﬁnite: wij ´ xj xi ď 0, wij ´ xj ´ xj xi ď ´xj  
   
  (3a)  
   
  ´wij ` xj xi ď 0, ´ wij ` xj ` xj xi ď xj .  
   
  (3b)  
   
  Linear constraints with binary variables can be analyzed in order to detect constraint pairs of the forms (3). The method can be generalized to allow for bilinear relations of the following form, with A, B, C, D P R: Axi ` Bwij ` Cxj ` D ĳ xi xj  
   
  (4)  
   
  Theorem 1. Consider two linear constraints depending on the same three variables xi , xj and wij , where xi is binary: a1 xi ` b1 wij ` c1 xj ď d1 , a2 xi ` b2 wij ` c2 xj ď d2 .  
   
  (5a) (5b)  
   
  If b1 b2 ą 0 and γ “ c2 b1 ´ b2 c1 ‰ 0, then these constraints imply the following product relation: (1/γ)((b2 (a1 ´ d1 ) ` b1 d2 )xi ` b1 b2 wij ` b1 c2 xj ´ b1 d2 ) ď xi xj if b1 /γ ě 0, (1/γ)((b2 (a1 ´ d1 ) ` b1 d2 )xi ` b2 b2 wij ` b1 c2 xj ´ b1 d2 ) ě xi xj if b1 /γ ď 0. Proof. We begin by writing the bilinear relation (4), treating its coeﬃcients and inequality sign as unknown, and reformulating it as two implications: xi “ 1 xi “ 0  
   
  ⇒ Bwij ` (C ´ 1)xj ĳ ´D ´ A, ⇒ Bwij ` Cxj ĳ ´D,  
   
  (6a) (6b)  
   
  18  
   
  K. Bestuzheva et al.  
   
  where the inequality sign must be identical in both implied inequalities. Similarly, we rewrite constraints (5) with scaling parameters α and β: xi “ 1  
   
  ⇒ αb1 wij ` αc1 xj ĳ α(d1 ´ a1 ),  
   
  (7a)  
   
  xi “ 0  
   
  ⇒ βb2 wij ` βc2 xj ĳ βd2 ,  
   
  (7b)  
   
  where the inequality signs depend on the signs of α and β. The goal is to ﬁnd the coeﬃcients A, B, C and D and the inequality sign. We require that coeﬃcients and inequality signs in implications (6) and (7) match. Solving the resulting system yields: b1 b2 ą 0, A “ (1/γ)(b2 (a1 ´ d1 ) ` b1 d2 ) B “ b1 b2 /γ, C “ b1 c2 /γ, D “ ´b1 d2 /γ, γ ‰ 0, where γ “ c2 b1 ´ b2 c1 and the inequality sign is ‘ď‘ if b1/γ ě 0, and ‘ě‘ if b1/γ ď 0. Thus, the bilinear relation stated in this theorem is obtained.   Although the conditions of the theorem are suﬃcient for the bilinear product relation to be implied by the linear constraints, in practice more conditions are checked before deriving such a relation. In particular: – At least one of the coeﬃcients a1 and a2 must be nonzero. Otherwise, the product relation is always implied by the linear constraints, including when 0 ă xi ă 1. – The signs of the coeﬃcients of the binary variable xi must be diﬀerent, that is, one linear relation is more restrictive when xi “ 1 and the other when xi “ 0. While this is not necessary for the non-redundancy of the derived product relation, by requiring this we focus on stronger implications (for instance, for a linear relation a1 xi ` b1 wij ` c1 xj ď d1 with a1 ą 0, we use the more restrictive implication xi “ 1 ⇒ b1 wij ` c1 xj ď d1 ´ a1 rather than the less restrictive implication xi “ 0 ⇒ b1 wij ` c1 xj ď d1 ). In separation, the product relation (4) is treated similarly to product relations wij ĳ xi xj , with the linear left-hand side Axi ` Bwij ` Cxj ` D being used instead of the individual auxiliary variable wij . The detection algorithm searches for suitable pairs of linear relations and derives product relations from them. Let xi , as before, be a binary variable. The following relation types are considered as candidates for the ﬁrst relation in such a pair: implied relations of the form xi “ ξ ⇒ ˜b1 wij ` c˜1 xj ď d˜1 , where ξ “ 0 or ξ “ 1; and implied bounds of the form xi “ ξ ⇒ wij ď d˜1 . The second relation in a pair can be: an implied relation of the form xi “ ξ ⇒ ˜b2 wij ` c˜2 xj ď d˜2 , where ξ is the complement of ξ; if wij is non-binary, an implied bound of the form xi “ ξ ⇒ wij ď d˜2 ; if wij is binary, a clique containing the complement of xi if ξ “ 1 or xi if ξ “ 0, and wij or its complement; a constraint wij ; or a global bound on wij . Cliques are constraints of  on xj and the form: kPJ xk ` kPJ (1 ´ xk ) ď 1, where J Ď I b , J Ď I b and J X J “ H.  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  4  
   
  19  
   
  Separation Algorithm  
   
  We present a new algorithm for separating RLT cuts within an LP-based branchand-bound solver. The branch-and-bound algorithm builds LP relaxations of problem (1) by constructing linear underestimators of functions g in the constraint g(x, w) ď 0 and McCormick inequalities for constraints (1d). Let (x∗ , w∗ ) be the solution of an LP relaxation at a node of the branchand-bound tree, and suppose that (x∗ , w∗ ) violates the relation xi xj ĳ wij for some i, j P I w . Separation algorithms generate cuts that separate (x∗ , w∗ ) from the feasible region, and add those cuts to the solver’s cut storage. The standard separation algorithm, which will serve as a baseline for comparisons, iterates over all linear constraints. For each constraint, it iterates over all variables xj that participate in bilinear relations and generates RLT cuts using bound factors of xj . Violated cuts are added to the MINLP solver’s cut storage. 4.1  
   
  Row Marking ()  
   
  (u)  
   
  Let the bound factors be denoted as fj (x) “ xj ´ xj and fj (x) “ xj ´ xj . Consider a linear constraint multiplied by a bound factor: (.)  
   
  (.)  
   
  fj (x)ar x ď fj (x)br .  
   
  (8)  
   
  The ith nonlinear term is ari xi xj , where ari “ ari when multiplying by (xj ´ xj ) and ari “ ´ari when multiplying by (xj ´ xj ). Following the procedure described in Sect. 2, RLT may replace the product xi xj with wij . The product can also be replaced with a linear expression, but this does not change the reasoning, and we will only use wij in this section. ∗ ‰ x∗i x∗j , then such a replacement will change the violation of (8). The If wij terms whose replacement will increase the violation are of interest, that is, the terms where: ∗ . ari x∗i x∗j ď ari wij This determines the choice of bound factors to multiply with: ∗ x∗i x∗j ă wij ⇒  
   
  multiply by (xj ´ xj ) if ari ą 0, multiply by (xj ´ xj ) if ari ă 0,  
   
  ∗ x∗i x∗j ą wij ⇒  
   
  multiply by (xj ´ xj ) if ari ą 0, multiply by (xj ´ xj ) if ari ă 0.  
   
  The separation algorithm is initialized by creating data structures to enable eﬃcient access to 1) all variables appearing in bilinear products together with a given variable and 2) the bilinear product relation involving two given variables. For each variable xi , linear rows are marked in order to inform the separation algorithms which bound factors of xi they should be multiplied with, if any. The algorithm can work with inequality rows in both ‘ď’ and ‘ě’ forms as well as equation rows. For each bilinear product xi xj , the row marking algorithm iterates over all linear rows that contain xj with a nonzero coeﬃcient. These rows are stored in a sparse array and have one of the following marks:  
   
  20  
   
  K. Bestuzheva et al.  
   
  ∗ – MARK LT: the row contains a term arj xj such that arj x∗i x∗j ă arj wij ; ∗ ; – MARK GT: the row contains a term arj xj such that arj x∗i x∗j ą arj wij – MARK BOTH: the row contains terms ﬁtting both cases above.  
   
  Row marks are represented by integer values 1, 2 and 3, respectively, and are stored in two sparse arrays, row idcs and row marks, the ﬁrst storing sorted row indices and the second storing the corresponding marks. In the algorithm below, we use the notation mark(r) to denote accessing the mark of row r by performing a search in row idcs and retrieving the corresponding entry in row marks. We also deﬁne a sparse matrix W with entries wij .  
   
  1 2 3 4 5 6 7 8 9 10  
   
  Input: x∗ , w∗ , W marks :“ H for i P I p , j P nnz(wi ) do for r such that j P nnz(ar ) do if r R marks then marks ← r mark(r) :“ 0 ∗ if arj x∗i x∗j ă arj wij then mark(r) |“ MARK LT else mark(r) |“ MARK GT  
   
  The algorithm iterates over the sparse array of marked rows and generates RLT cuts for the following combinations of linear rows and bound factors: – If mark “ MARK LT, then “ď” constraints are multiplied with the lower bound factor and “ě” constraints are multiplied with the upper bound factor; – If mark “ MARK GT, then “ď” constraints are multiplied with the upper bound factor and “ě” constraints are multiplied with the lower bound factor; – If mark “ MARK BOTH, then both “ď” and “ě” constraints are multiplied with both the lower and the upper bound factors; – Marked equality constraints are always multiplied with xi itself. 4.2  
   
  Projection Filtering  
   
  If at least one of the variables xi and xj has a value equal to one of its bounds, then the McCormick relaxation (2) is tight for the relation wij “ xi xj . Therefore, if xi or xj is at a bound and the McCormick inequalities are satisﬁed, then the product relation is also satisﬁed. We describe the equality case here, and the reasoning is analogous for the inequality case of xi xj ĳ wij .  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  21  
   
  Consider the linear system Ax ď b projected onto the set of variables whose values are not equal to either of their bounds.   ark xk ď br ´ ark x∗k , ∀r P 1, . . . , m(l) , kPJ 1  
   
  kPJ 2  
   
  where J 1 Ď I is the set of all problem variables whose values in the solution x∗ of the current LP relaxation are not equal to one of their bounds, and J 2 “ I \ J 1 . Violation is then ﬁrst checked for RLT cuts generated based on the projected linear system. Only if such a cut, which we will refer to as a projected RLT cut, is violated, then the RLT cut for the same bound factor and the corresponding constraint in the original linear system will be constructed. Since x∗ is a basic LP solution, in practice either x∗k “ xk or x∗k “ xk holds for many of the variables, and the projected system often has a considerably smaller size than the original system. (.) In the projected system multiplied with a bound factor fj (x): (.)  
   
  fj (x) ·  
   
    
   
  (.)  
   
  ark xk ď fj (x)(br ´  
   
  kPJ 1  
   
    
   
  ark x∗k ), ∀r P 1, . . . , m(l) ,  
   
  kPJ 2  
   
  the only nonlinear terms are xj xk with k P J 1 , and therefore, no substitution xi xk → wik is performed for k P J 2 . If the McCormick inequalities for xi , xk and ∗ for k P J 2 , and checking the violation of a projected wik hold, then x∗i x∗k “ wik RLT cut is equivalent to checking the violation of a full RLT cut. Depending on the solver, McCormick inequalities may not be satisﬁed at ∗ for some k P J 2 , but these vio(x∗ , w∗ ). Thus, it is possible that x∗i x∗k ‰ wik lations will not contribute to the violation of the projected RLT cut. In this case, projection ﬁltering has an additional eﬀect: for violated bilinear products involving variables whose values in x∗ are at bound, the violation of the product will be disregarded when checking the violation of RLT cuts. Thus, adding McCormick cuts will be prioritized over adding RLT cuts.  
   
  5  
   
  Computational Results  
   
  5.1  
   
  Setup  
   
  We tested the proposed methods on the MINLPLib1 [6] test set and a test set comprised of instances from MIPLIB3, MIPLIB 2003, 2010 and 2017 [10], and Cor@l [15]. These test sets consist of 1846 MINLP instances and 666 MILP instances, respectively. After structure detection experiments, only those instances were chosen for performance evaluations that either contain bilinear products in the problem formulation, or where our algorithm derived bilinear products. This resulted in test sets of 1357 MINLP instances and 195 MILP instances. 1  
   
  https://www.minlplib.org.  
   
  22  
   
  K. Bestuzheva et al.  
   
  The algorithms were implemented in the MINLP solver SCIP [4]. We used a development branch of SCIP (githash dd6c54a9d7) compiled with SoPlex 5.0.2.4, CppAD 20180000.0, PaPILO 1.0.0.1, bliss 0.73p and Ipopt 3.12.11. The experiments were carried out on a cluster of Dell Poweredge M620 blades with 2.50GHz Intel Xeon CPU E5-2670 v2 CPUs, with 2 CPUs and 64GB memory per node. The time limit was set to one hour, the optimality gap tolerance to 10´4 for MINLP instances and to 10´6 for MILP instances, and the following settings were used for all runs, where applicable: – The maximum number of unknown bilinear terms that a product of a row and a bound factor can have in order to be used was 20. Unknown bilinear terms are those terms xi xj for which no wij variable exists in the problem, or its extended formulation which SCIP constructs for the purposes of creating an LP relaxation of an MINLP. – RLT cut separation was called every 10 nodes of the branch-and-bound tree. – In every non-root node where separation was called, 1 round of separation was performed. In the root node, 10 separation rounds were performed. – Unless speciﬁed otherwise, implicit product detection and projection ﬁltering were enabled and the new separation algorithm was used. 5.2  
   
  Impact of RLT Cuts  
   
  In this subsection we evaluate the performance impact of RLT cuts. The following settings were used: Oﬀ - RLT cuts are disabled; ERLT - RLT cuts are added for products that exist explicitly in the problem; IERLT - RLT cuts are added for both implicit and explicit products. The setting ERLT was used for the MINLP test set only, since MILP instances contain no explicitly deﬁned bilinear products. We report overall numbers of instances, numbers of solved instances, shifted geometric means of the runtime (shift 1 s), and the number of nodes in the branch-and-bound tree (shift 100 nodes), and relative diﬀerences between settings. Additionally, we report results on subsets of instances. Aﬀected instances are instances where a change of setting leads to a diﬀerence in the solving process, indicated by a diﬀerence in the number of LP iterations. [x,timelim] denotes the subset of instances which took the solver at least x seconds to solve with at least one setting, and were solved to optimality with at least one setting. All-optimal is the subset of instances which were solved to optimality with both settings. Table 1 shows the impact of RLT cuts on MILP performance. We observe a slight increase in time when RLT cuts are enabled, and a slight decrease in number of nodes. The diﬀerence is more pronounced on ‘diﬃcult’ instances: a 9% decrease in number of nodes on subset [100,timelim] and 28% on subset [1000,timelim], and a decrease of 21% in the mean time on subset [1000,timelim]. Table 2 reports the impact of RLT cuts derived from explicitly deﬁned bilinear products. A substantial decrease in running times and tree sizes is observed across all subsets, with a 15% decrease in the mean time and a 19% decrease in  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  23  
   
  Table 1. Impact of RLT cuts: MILP instances  
   
  Subset  
   
  Oﬀ instances solved time  
   
  IERLT nodes solved time  
   
  IERLT /Oﬀ nodes time nodes  
   
  All Aﬀected [0,tilim] [1,tilim] [10,tilim] [100,tilim] [1000,tilim] All-optimal  
   
  971 581 915 832 590 329 96 899  
   
  1339 1936 1127 1451 3604 9121 43060 1033  
   
  1310 1877 1104 1420 3495 8333 31104 1053  
   
  905 571 905 822 580 319 88 899  
   
  45.2 48.8 34.4 47.2 126.8 439.1 1436.7 31.9  
   
  909 575 909 826 584 323 92 899  
   
  46.7 51.2 35.6 49.0 133.9 430.7 1140.9 34.1  
   
  1.03 1.05 1.04 1.04 1.06 0.98 0.79 1.07  
   
  0.98 0.97 0.98 0.98 0.97 0.91 0.72 1.02  
   
  the number of nodes on all instances, and a 87% decrease in the mean time and a 88% decrease in the number of nodes on the subset [1000,timelim]. 223 more instances are solved with ERLT than with Oﬀ. Table 3 evaluates the impact of RLT cuts derived from implicit bilinear products. Similarly to MILP instances, the mean time slightly increases and the mean number of nodes slightly decreases when additional RLT cuts are enabled, but on MINLP instances, the increase in the mean time persists across diﬀerent instance subsets and is most pronounced (9%) on the subset [100,timelim], and the number of nodes increases by 6 ´ 7% on subsets [100,timelim] and [1000,timelim]. Table 2. Impact of RLT cuts derived from explicit products: MINLP instances  
   
  Subset  
   
  Oﬀ instances solved time  
   
  nodes  
   
  ERLT solved time  
   
  ERLT /Oﬀ nodes time nodes  
   
  All Aﬀected [0,timelim] [1,timelim] [10,timelim] [100,tilim] [1000,tilim] All-optimal  
   
  6622 2018 4568 3124 1871 861 284 4423  
   
  3375 1534 778 2081 6729 35991 196466 627  
   
  4557 2007 4557 3113 1860 850 273 4423  
   
  2719 3375 569 1383 3745 12873 23541 518  
   
  4434 1884 4434 2990 1737 727 150 4423  
   
  67.5 18.5 10.5 28.3 108.3 519.7 2354.8 8.6  
   
  57.5 10.6 8.2 20.0 63.6 196.1 297.6 7.5  
   
  0.85 0.57 0.78 0.71 0.59 0.38 0.13 0.87  
   
  0.81 0.51 0.73 0.67 0.56 0.36 0.12 0.83  
   
  24  
   
  K. Bestuzheva et al. Table 3. Impact of RLT cuts derived from implicit products: MINLP instances  
   
  Subset  
   
  ERLT instances solved time  
   
  IERLT nodes solved time  
   
  nodes  
   
  ERLT /IERLT time nodes  
   
  All Aﬀected [0,timelim] [1,timelim] [10,timelim] [100,tilim] [1000,tilim] All-optimal  
   
  6622 1738 4601 3141 1828 706 192 4532  
   
  2686 1567 587 1436 4157 22875 99996 540  
   
  2638 1494 576 1398 4012 24339 107006 529  
   
  1.01 1.02 1.01 1.01 1.02 1.09 1.03 1.02  
   
  4565 1702 4565 3105 1792 670 156 4532  
   
  57.0 24.2 8.5 21.1 74.1 359.9 1493.3 7.7  
   
  4568 1705 4568 3108 1795 673 159 4532  
   
  57.4 24.8 8.6 21.4 75.4 390.4 1544.7 7.8  
   
  0.98 0.95 0.98 0.97 0.97 1.06 1.07 0.98  
   
  Table 4 reports numbers of instances for which a change in the root node dual 1 , where bound was observed, where the relative diﬀerence is quantiﬁed as γ2γ´γ 1 γ1 and γ2 are root node dual bounds obtained with the ﬁrst and second settings, respectively. The range of the change is speciﬁed in the column ‘Diﬀerence’, and each column shows numbers of instances for which one or the other setting provided a better dual bound, within given range. The results of comparisons Oﬀ /IERLT for MILP instances and Oﬀ /ERLT for MINLP instances are consistent with the eﬀect of RLT cuts on performance observed in Tables 1 and 2. Interestingly, IERLT performs better than ERLT in terms of root node dual bound quality. Thus, RLT cuts derived from implicit products in MINLP instances tend to improve root node relaxations. 5.3  
   
  Separation  
   
  In Table 5, the setting Marking-oﬀ employs the standard separation algorithm, and Marking-on enables the row marking and projection ﬁltering algorithms described in Sect. 4. Row marking reduces the running time by 63% on MILP instances, by 70% on aﬀected MILP instances, by 12% on MINLP instances and by 22% on aﬀected MINLP instances. The number of nodes increases when row marking is enabled because, due to the decreased separation time, the solver can Table 4. Root node dual bound diﬀerences MILP MINLP Diﬀerence Oﬀ / IERLT Oﬀ / ERLT ERLT / IERLT 0.01-0.2 0.2-0.5 0.5-1.0 ą1.0  
   
  54 / 62 2/4 0/3 0/2  
   
  224 / 505 23 / 114 40 / 150 4 / 182  
   
  379 / 441 44 / 48 19 / 30 4 / 23  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  25  
   
  explore more nodes before reaching the time limit: this is conﬁrmed by the fact that on the subset All-optimal, the number of nodes remains nearly unchanged. Table 5. Separation algorithm comparison  
   
  Test set subset MILP  
   
  All Aﬀected All-optimal MINLP All Aﬀected All-optimal  
   
  Marking-oﬀ instances solved time  
   
  Marking-on M-on/M-oﬀ nodes solved time nodes time nodes  
   
  949 728 774 6546 3031 4448  
   
  952 1118 823 2317 1062 494  
   
  780 612 774 4491 2949 4448  
   
  124.0 156.6 58.4 64.5 18.5 9.1  
   
  890 722 774 4530 2988 4448  
   
  45.2 46.4 21.2 56.4 14.3 7.4  
   
  1297 1467 829 2589 1116 502  
   
  0.37 0.30 0.36 0.88 0.78 0.81  
   
  1.37 1.31 1.01 1.12 1.05 1.02  
   
  Table 6 analyzes the percentage of time that RLT cut separation takes out of overall running time, showing the arithmetic mean and maximum over all instances, numbers of instances for which the percentage was within a given interval, and numbers of failures. The average percentage is reduced from 54.2% to 2.8% for MILP instances and from 15.1% to 2.4% for MINLP instances, and the maximum percentage is reduced from 99.6% to 71.6% for MILP instances, but remains at 100% for MINLP instances. The numbers of failures are reduced with Marking-on, mainly due to avoiding failures that occur when the solver runs out of memory. Table 6. Separation times Test set Setting  
   
  avg % max % N(ă 5%) N(5-20%) N(20-50%) N(50-100%) fail  
   
  Marking-oﬀ Marking-on MINLP Marking-oﬀ Marking-on  
   
  54.2 2.8 15.1 2.4  
   
  MILP  
   
  99.6 71.6 100.0 100.0  
   
  121 853 3647 6140  
   
  117 87 1265 376  
   
  169 31 1111 204  
   
  552 4 685 49  
   
  16 0 77 16  
   
  Projection ﬁltering has a minor impact on performance. When comparing the runs where projection ﬁltering is disabled and enabled, the relative diﬀerence in time and nodes does not exceed 1% on both MILP and MINLP instances, except for aﬀected MILP instances where projection ﬁltering decreases the number of nodes by 4%. This is possibly occurring due to the eﬀect of prioritizing McCormick inequalities to RLT cuts when enforcing derived product relations. The number of solved instances remains almost unchanged, with one less instance being solved on both MILP and MINLP test sets when projection ﬁltering is enabled.  
   
  26  
   
  5.4  
   
  K. Bestuzheva et al.  
   
  Experiments with Gurobi  
   
  In this subsection we present results obtained by running the mixed-integer quadratically-constrained programming solver Gurobi 10.0 beta [11]. The algorithms for implicit product detection and RLT cut separation are the same as in SCIP, although implementation details may diﬀer between the solvers. The internal Gurobi test set was used, comprised of models sent by Gurobi customers and models from public benchmarks, chosen in a way that avoids overrepresenting any particular problem class. Whenever RLT cuts were enabled, so was implicit product detection, row marking and projection ﬁltering. The time limit was set to 10000 s. Table 7 shows, for both MILP and MINLP test sets, the numbers of instances in the test sets and their subsets, and the ratios of shifted geometric means of running time and number of nodes of the runs with RLT cuts enabled, to the same means obtained with RLT cuts disabled. The last row shows the numbers of instances solved with one setting and unsolved with the other, that is, for example, “RLT oﬀ: +41” means that 41 instances were solved with the setting “oﬀ” that were not solved with the setting “on”. While the results cannot be directly compared to those obtained with SCIP due to the diﬀerences in the experimental setup, we observe the same tendencies. In particular, RLT cuts yield small improvements on MILP instances which become more pronounced on subsets [100,timelim] and [1000,timelim], and larger improvements are observed on MINLP instances both in terms of geometric means and numbers of solved instances. Relative diﬀerences are comparable to those observed with SCIP, but the impact of RLT cuts is larger in Gurobi, and no slowdown is observed with Gurobi on any subset of MILP instances. Table 7. Results obtained with Gurobi 10.0 beta  
   
  5.5  
   
  Subset  
   
  MILP instances timeR nodeR  
   
  MINLP instances timeR nodeR  
   
  All [0,timelim] [1,timelim] [10,timelim] [100,timelim] [1000,timelim]  
   
  5011 4830 3332 2410 1391 512  
   
  806 505 280 188 114 79  
   
  Solved  
   
  RLT oﬀ: +41; RLT on: +37 RLT oﬀ: +2; RLT on: +35  
   
  0.99 0.99 0.98 0.97 0.95 0.89  
   
  0.97 0.96 0.96 0.93 0.91 0.83  
   
  0.73 0.57 0.40 0.29 0.17 0.12  
   
  0.57 0.44 0.29 0.20 0.11 0.08  
   
  Summary  
   
  RLT cuts yield a considerable performance improvement for MINLP problems and a small performance improvement for MILP problems which becomes more  
   
  Eﬃcient Separation of RLT Cuts for Implicit and Explicit Bilinear Products  
   
  27  
   
  pronounced for challenging instances. The new separation algorithm drastically reduces the computational burden of RLT cut separation and is essential to an eﬃcient implementation of RLT cuts, enabling the speedups we observed when activating RLT. Acknowledgements. The work for this article has been conducted within the Research Campus Modal funded by the German Federal Ministry of Education and Research (BMBF grant numbers 05M14ZAM, 05M20ZBM).  
   
  References 1. Adams, W.P., Sherali, H.D.: A tight linearization and an algorithm for zero-one quadratic programming problems. Manage. Sci. 32(10), 1274–1290 (1986) 2. Adams, W.P., Sherali, H.D.: Linearization strategies for a class of zero-one mixed integer programming problems. Oper. Res. 38(2), 217–226 (1990) 3. Adams, W.P., Sherali, H.D.: Mixed-integer bilinear programming problems. Math. Program. 59(1), 279–305 (1993) 4. Bestuzheva, K., et al.: Enabling research through the SCIP optimization suite 8.0. ACM Trans. Math. Softw. (2023). https://doi.org/10.1145/3585516 5. Buchheim, C., Wiegele, A., Zheng, L.: Exact algorithms for the quadratic linear ordering problem. INFORMS J. Comput. 22(1), 168–177 (2010) 6. Bussieck, M.R., Drud, A.S., Meeraus, A.: MINLPLib - a collection of test models for mixed-integer nonlinear programming. INFORMS J. Comput. 15(1), 114–119 (2003). https://doi.org/10.1287/ijoc.15.1.114.15159 7. Castillo, I., Westerlund, J., Emet, S., Westerlund, T.: Optimization of block layout design problems with unequal areas: a comparison of MILP and MINLP optimization methods. Comput. Chem. Eng. 30(1), 54–69 (2005) 8. Frank, S., Steponavice, I., Rebennack, S.: Optimal power ﬂow: a bibliographic survey I. Energy syst. 3(3), 221–258 (2012) 9. Frank, S., Steponavice, I., Rebennack, S.: Optimal power ﬂow: a bibliographic survey II. Energy Syst. 3(3), 259–289 (2012) 10. Gleixner, A., et al.: MIPLIB 2017: data-driven compilation of the 6th mixed-integer programming library. Math. Program. Comput. 13(3), 443–490 (2021). https://doi. org/10.1007/s12532-020-00194-3 11. Gurobi Optimization, LLC: Gurobi Optimizer Reference Manual (2022). https:// www.gurobi.com 12. Liberti, L.: Reduction constraints for the global optimization of NLPs. Int. Trans. Oper. Res. 11(1), 33–41 (2004) 13. Liberti, L.: Reformulation and convex relaxation techniques for global optimization. Ph.D. thesis. Springer (2004) 14. Liberti, L.: Linearity embedded in nonconvex programs. J. Global Optim. 33(2), 157–196 (2005) 15. Linderoth, J.T., Ralphs, T.K.: Noncommercial software for mixed-integer linear programming. Integer Programm. Theory Practice 3, 253–303 (2005) 16. McCormick, G.P.: Computability of global solutions to factorable nonconvex programs: Part I - convex underestimating problems. Math. Program. 10(1), 147–175 (1976) 17. Misener, R., Floudas, C.A.: Advances for the pooling problem: modeling, global optimization, and computational studies. Appl. Comput. Math. 8(1), 3–22 (2009)  
   
  28  
   
  K. Bestuzheva et al.  
   
  18. Sherali, H.D., Adams, W.P.: A hierarchy of relaxations between the continuous and convex hull representations for zero-one programming problems. SIAM J. Discret. Math. 3(3), 411–430 (1990) 19. Sherali, H.D., Adams, W.P.: A hierarchy of relaxations and convex hull characterizations for mixed-integer zero-one programming problems. Discret. Appl. Math. 52(1), 83–106 (1994) 20. Sherali, H.D., Adams, W.P.: A reformulation-linearization technique (RLT) for semi-inﬁnite and convex programs under mixed 0–1 and general discrete restrictions. Discret. Appl. Math. 157(6), 1319–1333 (2009) 21. Sherali, H.D., Alameddine, A.: A new reformulation-linearization technique for bilinear programming problems. J. Global Optim. 2(4), 379–410 (1992) 22. Sherali, H.D., Dalkiran, E., Liberti, L.: Reduced RLT representations for nonconvex polynomial programming problems. J. Global Optim. 52(3), 447–469 (2012) 23. Sherali, H.D., Smith, J.C., Adams, W.P.: Reduced ﬁrst-level representations via the reformulation-linearization technique: results, counterexamples, and computations. Discret. Appl. Math. 101(1–3), 247–267 (2000) 24. Sherali, H.D., Tuncbilek, C.H.: A global optimization algorithm for polynomial programming problems using a reformulation-linearization technique. J. Global Optim. 2(1), 101–112 (1992) 25. Sherali, H.D., Tuncbilek, C.H.: New reformulation linearization/convexiﬁcation relaxations for univariate and multivariate polynomial programming problems. Oper. Res. Lett. 21(1), 1–9 (1997)  
   
  A Nearly Optimal Randomized Algorithm for Explorable Heap Selection Sander Borst1(B) , Daniel Dadush1(B) , Sophie Huiberts2(B) , and Danish Kashaev1(B) 1  
   
  Centrum Wiskunde & Informatica (CWI), Amsterdam, The Netherlands {sander.borst,dadush,danish.kashaev}@cwi.nl 2 Columbia University, New York, USA [email protected]   
   
  Abstract. Explorable heap selection is the problem of selecting the nth smallest value in a binary heap. The key values can only be accessed by traversing through the underlying inﬁnite binary tree, and the complexity of the algorithm is measured by the total distance traveled in the tree (each edge has unit cost). This problem was originally proposed as a model to study search strategies for the branch-and-bound algorithm with storage restrictions by Karp, Saks and Widgerson (FOCS ’86), who √ log n)) time algorithms gave deterministic and randomized n · exp(O( √ using O(log(n)2.5 ) and O( log n) space respectively. We present a new randomized algorithm with running time O(n log(n)3 ) against an oblivious adversary using O(log n) space, substantially improving the previous best randomized running time at the expense of slightly increased space usage. We also show an Ω(log(n)n/ log(log(n))) lower bound for any algorithm that solves the problem in the same amount of space, indicating that our algorithm is nearly optimal.  
   
  1  
   
  Introduction  
   
  Many important problems in theoretical computer science are fundamentally search problems. The objective of these problems is to ﬁnd a certain solution from the search space. In this paper we analyze a search problem that we call explorable heap selection. The problem is related to the famous branch-andbound algorithm and was originally proposed by Karp, Widgerson and Saks [13] to model node selection for branch-and-bound with low space-complexity. Furthermore, as we will explain later, the problem remains practically relevant to branch-and-bound even in the full space setting.  
   
  Due to space limitations, we have omitted several proofs. These can be found in [7]. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement QIP–805241). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 29–43, 2023. https://doi.org/10.1007/978-3-031-32726-1_3  
   
  30  
   
  S. Borst et al.  
   
  The explorable heap selection problem1 is an online graph exploration problem for an agent on a rooted (possibly inﬁnite) binary tree. The nodes of the tree are labeled by distinct real numbers (the key values) that increase along every path starting from the root. The tree can thus be thought of as a min-heap. Starting at the root, the agent’s objective is to select the nth smallest value in the tree while minimizing the distance traveled, where each edge of the tree has unit travel cost. The key value of a node is only revealed when the agent visits it, and the problem thus has an online nature. When the agent learns the key value of a node, it still does not know the rank of this value. A simple selection strategy is to use the best-ﬁrst rule, which repeatedly explores the unexplored node whose parent has the smallest key value. While this rule is optimal in terms of the number of nodes that it explores, namely Θ(n), the distance traveled by the agent can be far from optimal. In the worstcase, an agent using this rule will need to travel a distance of Θ(n2 ) to ﬁnd the nth smallest value. A simple bad example for this rule is to consider a rooted tree consisting of two paths (which one can extend to a binary tree), where the two paths are consecutively labeled by all positive even and odd integers respectively. Improving on the best-ﬁrst strategy, Karp, Saksand Wigderson [13]  gave a randomized algorithm with expected cost n·exp(O( log(n))) using O( log(n)) working space. They also showed how to make the algorithm deterministic using O(log(n)2.5 ) space. In this work, our main contribution is an improved randomized algorithm with expected cost O(n log(n)3 ) using O(log(n)) space. Given the Ω(n) lower bound, our travel cost is optimal up to logarithmic factors. Furthermore we show that any algorithm for explorable heap selection that only uses s units of memory, must take at least n · logs (n) time in expectation. An interesting open problem is the question whether a superlinear lower bound also holds without any restriction on the memory usage. To clarify the memory model, it is assumed that any key value and O(log n) bit integer can be stored using O(1) space. We also assume that maintaining the current position in the tree does not take up memory. Furthermore, we assume that key value comparisons and moving across an edge of the tree require O(1) time. Under these assumptions, the running times of the above algorithms are in fact proportional to their travel cost. Throughout the paper, we will thus use travel cost and running time interchangeably. Motivation. The motivation to look at this problem comes from the branchand-bound algorithm. This is a well-known algorithm that can be used for solving many types of problems. In particular, it is often used to solve integer linear programs (ILP), which are of the form arg min{c x : x ∈ Zn , Ax ≤ b}. In that setting, branch-and-bound works by ﬁrst solving the linear programming (LP) relaxation, which does not have integrality constraints. The value of the solution to the relaxation forms a lower bound on the objective value of the original problem. Moreover, if this solution only has integral components, it is also optimal for the original problem. Otherwise, the algorithm chooses a ˆi is not integral. It then creates two component xi for which the solution value x xi  or xi ≥ ˆ xi . This new subproblems, by either adding the constraint xi ≤ ˆ 1  
   
  [13] did not name the problem, so we have given a descriptive name here.  
   
  A Nearly Optimal Randomized Algorithm  
   
  31  
   
  operation is called branching. The tree of subproblems, in which the children of a problem are created by the branching operation, is called the branch-andbound tree. Because a subproblem contains more constraints than its parent, its objective value is greater or equal to the one of its parent. At the core, the algorithm consists of two important components: the branching rule and the node selection rule. The branching rule determines how to split up a problem into subproblems, by choosing a variable to branch on. Substantial research has been done on branching rules, see, e.g., [2,4,14,15]. The node selection rule decides which subproblem to solve next. Not much theoretical research has been done on the choice of the node selection rule. Traditionally, the best-ﬁrst strategy is thought to be optimal from a theoretical perspective because this rule minimizes the number of nodes that need to be visited. However, to eﬃciently implement this rule the solver needs space proportional to the number of explored nodes, because all of them need to be kept in memory. In contrast to this, a simple strategy like depth-ﬁrst search only needs to store the current solution. Unfortunately, performing a depth-ﬁrst search can lead to an arbitrarily bad running time. This was the original motivation for introducing the explorable heap selection problem [13]. By guessing the number N of branch-and-bound nodes whose LP values are at most that of the optimal IP solution (which can be done via successive doubling), a search strategy for this problem can be directly interpreted as a node selection rule. The algorithm that they introduced be used to implement branch-and-bound eﬃ  can therefore log(N ) space. ciently in only O In practice, computers are usually able to store all explored nodes of the branch-and-bound tree in memory. However, many MIP-solvers still make use of a hybrid method that consists of both depth-ﬁrst and best-ﬁrst searches. This is not only done because depth-ﬁrst search uses less memory, but also because it is often faster. Experimental studies have conﬁrmed that the depth-ﬁrst strategy is in many cases faster than best-ﬁrst one [8]. This seems contradictory, because the running time of best-ﬁrst search is often thought to be theoretically optimal. In part, this contradiction can be explained by the fact that actual IP-solvers often employ complementary techniques and heuristics on top of branch-andbound, which might beneﬁt from depth-ﬁrst searches. Additionally, a best-ﬁrst search can hop between diﬀerent parts of the tree, while a depth ﬁrst search subsequently explores nodes that are very close to each other. In the latter case, the LP-solver can start from a very similar state, which is known as warm starting. This is faster for a variety of technical reasons [1]. For example, this can be the case when the LP-solver makes use of the LU-factorization of the optimal basis matrix [16]. Through the use of dynamic algorithms, computing this can be done faster if a factorization for a similar LP-basis is known [19]. Because of its large size, MIP-solvers will often not store the LU-factorization for all nodes in the tree. This makes it beneﬁcial to move between similar nodes in the branch-and-bound tree. Furthermore, moving from one part of the tree to another means that the solver needs to undo and redo many bound changes, which also takes up time. Hence, the amount of distance traveled between nodes  
   
  32  
   
  S. Borst et al.  
   
  in the tree is a metric that inﬂuences the running time. This can also be observed when running the academic MIP-solver SCIP [12]. The explorable heap selection problem captures these beneﬁts of locality by measuring the running time in terms of the amount of travel through the tree. Therefore, we argue that this problem is still relevant for the choice of a node selection rule, even if all nodes can be stored in memory. Related Work. The explorable heap selection problem was ﬁrst introduced in [13]. Their result was later applied to prove an upper bound on the parallel running time of branch-and-bound [18]. When random access to the heap is provided at constant cost, selecting the nth value in the heap can be done by a deterministic algorithm in O(n) time by using an additional O(n) memory for auxilliary data structures [11]. The explorable heap selection problem can be thought of as a search game [3] and bears some similarity to the cow path problem. In the cow path problem, an agent explores an unweighted unlabeled graph in search of a target node. The location of the target node is unknown, but when the agent visits a node they are told whether or not that node is the target. The performance of an algorithm is judged by the ratio of the number of visited nodes to the distance of the target from the agent’s starting point. In both the cow path problem and the explorable heap selection problem, the cost of backtracking and retracing paths is an important consideration. The cow path problem on inﬁnite b-ary trees was studied in [9] under the assumption that when present at a node the agent can obtain an estimate on that node’s distance to the target. Other explorable graph problems exist without a target, where typically the graph itself is unknown at the outset. There is an extensive literature on exploration both in graphs and in the plane. Models have been studied, in which one tried to minimize either the distance traveled or the amount of used memory. For more information we refer to [6,20] and the references therein. Outline. In Sect. 2 we formally introduce the explorable heap selection problem and any notation we will use. In Sect. 3 we introduce a new algorithm for solving this problem and provide a running time analysis. In Sect. 4 we give a lower bound on the complexity of solving explorable heap selection using a limited amount of memory.  
   
  2  
   
  The Explorable Heap Selection Problem  
   
  In this section we introduce the formal model for the explorable heap selection problem. The input to the algorithm is an inﬁnite binary tree T = (V, E), where each node v ∈ V has an associated real value, denoted by val(v) ∈ R. We assume that all the values are distinct and that for each node in the tree, the values of its children are larger than its own value. The binary tree T is thus a heap. We want to ﬁnd the nth smallest value in this tree. This may be seen as an online graph exploration problem where an agent can move in the tree and learns the value of a node each time he explores it. At each time step, the agent resides  
   
  A Nearly Optimal Randomized Algorithm  
   
  33  
   
  at a vertex v ∈ V and may decide to move to either the left child, the right child or the parent of v (if it exists, i.e. if v is not the root of the tree). Each traversal of an edge costs one unit of time, and the complexity of an algorithm for this problem is thus measured by the total traveled distance in the binary tree. The algorithm is also allowed to store values in memory. For a node v ∈ V , also per abuse of notation written v ∈ T , we denote by T (v) the subtree of T rooted at v. For a tree T and a value L ∈ R, we deﬁne the subtree TL := {v ∈ T | val(v) ≤ L}. We denote the nth smallest value in T by SELECTT (n). This is the quantity that we are interested in ﬁnding algorithmically. We say that a value V ∈ R is good for a tree T if V ≤ SELECTT (n) and bad otherwise. Similarly, we call a node v ∈ T good if val(v) ≤ SELECTT (n) and bad otherwise. We use [k] to refer to the set {1, . . . , k}. When we write log(n), we assume the base of the logarithm to be 2. We will often instruct the agent to move to an already discovered good vertex v ∈ V . The way this is done algorithmically is by saving val(v) in memory and starting a depth ﬁrst search at the root, turning back every time a value strictly bigger than val(v) is encountered until ﬁnally ﬁnding val(v). This takes at most O(n) time, since we assume v to be a good node. If we instruct the agent to go back to the root from a certain vertex v ∈ V , this is simply done by traveling back in the tree, choosing to go to the parent of the current node at each step. In later sections, we will often say that a subroutine takes a subtree T (v) as input. This implicitly means that we in fact pass it val(v) as input, make the agent travel to v ∈ T using the previously described procedure, call the subroutine from that position in the tree, and travel back to the original position at the end of the execution. Because the subroutine knows the value val(v) of the root of T (v) , it can ensure it never leaves the subtree T (v) , thus making it possible to recurse on a subtree as if it were a rooted tree by itself. We will sometimes want to pick a value uniformly at random from a set of values {V1 , . . . , Vk } of unknown size that arrives in a streaming fashion, for instance when we traverse a part of the tree T by doing a depth ﬁrst search. That is, we see the value Vi at the ith time step, but do not longer have access to it in memory once we move on to Vi+1 . This can be done by generating random values {X1 , . . . , Xk } where, at the ith time step, Xi = Vi with probability 1/i, and Xi = Xi−1 otherwise. It is easy to check that Xk is a uniformly distributed sample from {V1 , . . . , Vk }.  
   
  3  
   
  A New Algorithm  
   
  The authors of [13] presented a deterministic algorithm that solves  the explorable  heap selection problem in n · exp(O( log(n))) time and O(n log(n)) space. By replacing the binary search that is used in the algorithm by a randomized variant, they can decrease the space requirements. This  way, they get a randomized log(n))) and space complexity algorithm with expected running time n·exp(O(  O( log(n)). Alternatively, the binary search can be implemented in a deterministic way by [17] to get the same running time with O(log(n)2.5 ) space.  
   
  34  
   
  S. Borst et al.  
   
  We present a randomized algorithm with a running time O(n log(n)3 ) and space complexity O(log(n)). Unlike the algorithms mentioned before, our algorithm fundamentally relies on randomness to bound its running time. This bound only holds when the algorithm is run on a tree with labels that are ﬁxed before the execution of the algorithm. That is, the tree must be generated by an adversary that is oblivious to the choices made by the algorithm. This is a stronger assumption than is needed for the algorithm that is given in [13], which also works against adaptive adversaries. An adaptive adversary is able to defer the decision of the node label to the time that the node is explored. Note that this distinction does not really matter for the application of the algorithm as a node selection rule in branch-and-bound, since there the node labels are ﬁxed because they are derived from the integer program. Theorem 1. There exists a randomized algorithm that solves the explorable heap selection problem, with expected running time O(n log(n)3 ) and O(log(n)) space. The explorable heap selection problem can be seen as the problem of ﬁnding all n good nodes. Both our method and that of [13] function by ﬁrst identifying a subtree consisting of only good nodes. The children of the leaves of this subtree are called “roots” and the subtree is extended by ﬁnding a number of new good nodes under these roots in multiple rounds. √ In [13] this is done by running O(c 2 log(n) ) diﬀerent √ rounds, for some constant c > 1. In each round, the algorithm ﬁnds n/c 2 log(n) new good nodes. These nodes are found by recursively exploring each active root and using binary search on the observed values to discover which of these values are good. Which active roots are recursively explored furtherdepends on which values are good. The recursion in the algorithm is at most O( log(n)) levels deep, which is where the space complexity bound comes from. In our algorithm, we take a diﬀerent approach. We will call our algorithm consecutively with n = 1, 2, 4, 8, . . . . Hence, for a call to the algorithm, we can assume that we have already found at least n/2 good nodes. These nodes form a subtree of the original tree T . In each round, our algorithm chooses a random root under this subtree and ﬁnds every good node under it. It does so by doing recursive subcalls to the main algorithm on this root with values n = 1, 2, 4, 8, . . .. As soon as the recursively obtained node is a bad node, the algorithm stops searching the subtree of this root, since it is guaranteed that all the good nodes there have been found. The largest good value that is found can then be used to ﬁnd additional good nodes under the other roots without recursive calls, through a simple depth-ﬁrst search. Assuming that the node values were ﬁxed in advance, we expect this largest good value to be greater than half of the other roots’ largest good values. Similarly, we expect its smallest bad value to be smaller than half of the other roots’ smallest bad values. By this principle, a sizeable fraction of the roots can, in expectation, be ruled out from getting a recursive call. Each round a new random root is selected until all good nodes have been found. This algorithm allows us to eﬀectively perform binary search  
   
  A Nearly Optimal Randomized Algorithm  
   
  35  
   
  on the list of roots, ordered by the largest good value contained in each of their subtrees in O(log n) rounds, and the same list ordered by the smallest bad values (Lemma 2). Bounding the expected number of good nodes found using recursive subcalls requires a subtle induction on two parameters (Lemma 1): both n and the number of good nodes that have been identiﬁed so far. 3.1  
   
  The Algorithm  
   
  The Extend procedure is the core of our algorithm. It ﬁnds the nth smallest value in the tree, under the condition that the kth smallest value L0 is provided to the algorithm for some k ≥ n/2. Using this procedure, SELECT(n) can be solved by consecutively calling Extend(T , ni , ki , Li ) with parameters (ni , ki ) = (2i , 2i−1 ) for i ∈ {1, . . . , log(n)}. Algorithm 1. The Extend procedure 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25:  
   
  Input: T : tree which is to be explored. n ∈ N: total number of good values to be found in the tree T , satisfying n ≥ 2. k ∈ N: number of good values already found in the tree T , satisfying k ≥ n/2. L0 ∈ R: value satisfying DFS(T, L0 , n) = k. Output: the nth smallest value in T . procedure Extend(T , n, k, L0 ) L ← L0 , U ← ∞ while k < n do r ← random element from Roots(T , L0 , L, U) L ← max(L, val(r)) k ← DFS(T , L , n) // count the number of values ≤ L in T c ← DFS(T (r) , L , n) // count the number of values ≤ L in T (r) c ← min(n−k +c, 2c) // increase the number of values to be found in T (r) while k < n do // loop until it is certiﬁed that SELECTT (n) ≤ L L ← Extend(T (r) , c , c, L ) k ← DFS(T , L , n) c ← c c ← min(n − k + c, 2c) end while ˜ U˜ ← GoodValues(T, T (r) , L , n) // ﬁnd the good values in T (r) L, ˜ ˜ L ← max(L, L), U ← min(U, U) k ← DFS(T , L, n) // compute the number of good values found in T end while return L end procedure  
   
  Let us describe a few invariants from the Extend procedure. – L and U are respectively lower and upper bounds on SELECTT (n) during the whole execution of the procedure. – The integer k counts the number of values ≤ L in the full tree T . – After an iteration of the inner while loop, L is set to the cth smallest value in T (r) . The variable c then corresponds to the next value we would like to ﬁnd  
   
  36  
   
  S. Borst et al.  
   
  in T (r) if we were to continue the search. Note that c ≤ 2c, enforcing that the recursive call to Extend satisﬁes its precondition, and that c ≤ n − (k  − c) implies that (k  − c) + c ≤ n, which implies that the recursive subcall will not spend time searching for a value that is known in advance to be bad. – k  always counts the number of values ≤ L in the full tree T . It is important to observe that this is a global parameter, and does not only count values below the current root. Moreover, k  ≥ n implies that we can stop searching below the current root, since it is guaranteed that all good values in T (r) have been found, i.e., L is larger than all the good values in T (r) . We now describe the subroutines used in the Extend procedure. The Procedure DFS. The procedure DFS is a variant of depth ﬁrst search. The input to the procedure is T , a cutoﬀ value L ∈ R and an integer n ∈ N. The procedure returns the number of vertices in T whose value is at most L. It achieves that by exploring the tree T in a depth ﬁrst search manner, starting at the root and turning back as soon as a node w ∈ T such that val(w) > L is encountered. Moreover, if the number of nodes whose value is at most L exceeds n during the search, the algorithm stops and returns n + 1. The algorithm output is the following integer. whose value is at most L:    DFS(T, L, n) := min TL , n + 1 . Observe that the DFS procedure allows us to check whether a node w ∈ T is a good node, i.e. whether val(w) ≤ SELECTT (n). Indeed, w is good if and only if DFS(T, val(w), n) ≤ n. This procedure visits only nodes in TL or its direct descendants and its running time is thus O(n). The space complexity is O(1), since the only values needed to be stored in memory are L, val(v), where v is the root of the tree T , and a counter for the number of good values found so far. The Procedure Roots. The procedure Roots takes as input a tree T as well as a lower bound L0 ∈ R on the value of SELECTT (n). We assume that the main algorithm has already found all the nodes w ∈ T satisfying val(w) ≤ L0 . This means that the remaining values the main algorithm needs to ﬁnd in T are all lying in the subtrees of the following nodes, that we call the L0 -roots of T (Fig. 1):    R(T, L0 ) := r ∈ T \ TL0  r is a child of a node in TL0 In words, these are all the vertices in T one level deeper in the tree than TL0 . In addition to that, the procedure takes two other parameters L, U ∈ R as input, which correspond to (another) lower and upper bound on the value of SELECTT (n). These lower and upper bounds will be updated during the execution of the main algorithm. A key observation is that these bounds can allow us to remove certain roots in R(T, L0 ) from consideration, in the sense that all the good values in that root’s subtree will be certiﬁed to have already been found (Fig. 2):  Roots(T, L0 , L, U) := r ∈ R(T, L0 ) | ∃w ∈ T (r) with val(w) ∈ (L, U)  
   
  A Nearly Optimal Randomized Algorithm  
   
  37  
   
  1 2  
   
  4  
   
  3 5  
   
  5.5  
   
  3.5 11  
   
  13  
   
  4.5  
   
  17  
   
  Fig. 1. An illustration of R(T, L0 ) with L0 = 4. The number above each vertex is its value, the blue nodes are R(T, L0 ), whereas the subtree above is TL0 . (Color ﬁgure online)  
   
  5.5 5  
   
  9.5  
   
  11  
   
  7.5  
   
  13  
   
  17  
   
  6.5  
   
  8.5  
   
  4.5 8  
   
  9  
   
  12  
   
  6  
   
  15  
   
  10  
   
  7  
   
  16  
   
  19  
   
  18  
   
  Fig. 2. An illustration of the Roots procedure with L0 = 4, L = 7 and U = 10. Only two active roots remain, and are both colored in blue. The other roots are considered killed since all the good values have been found in their subtrees. (Color ﬁgure online)  
   
  This subroutine can be implemented by running a depth ﬁrst search starting at the root of T and exploring TL with its direct descendants. Since L is known to be good, the running time is bounded by O(|TL |) = O(n). In the main algorithm, we will only need this procedure in order to select a root from Roots(T, L0 , L, U) uniformly at random, without having to store the whole list in memory. This can then be achieved in O(1) space, since one then only needs to store val(v), L0 , L and U in memory, where v is the root of the tree T . The Procedure GoodValues. The procedure GoodValues takes as input a  tree T , a subtree T (r) , a value an integer n  ∈ N. The procedure  L ∈ R≥0 and then analyzes the set S := val(w)  w ∈ T (r) , val(w) ≤ L and outputs both the largest good value and the smallest bad value in that set, that we respectively call L and U. If no bad values exist in S, the algorithm sets U = ∞. The procedure can be implemented using a randomized binary search on the values in S, where the procedure DFS is used to check whether a value is good. This makes the procedure have a running time of O(n log n). The procedure only needs O(1) space, since the only values necessary to be kept in memory are val(v) (where v is the root of the tree T ), val(r), L, U and L , as well as the fact that every call to DFS also requires O(1) space.  
   
  38  
   
  3.2  
   
  S. Borst et al.  
   
  Proof of Correctness  
   
  Theorem 2. At the end of the execution of Algorithm 1, L is set to the nth smallest value in T . Moreover, the algorithm is guaranteed to terminate. Proof sketch. The variable L is always set to the ﬁrst output of the procedure GoodValues, which is always the value of a good node, implying L ≤ SELECTT (n). The other inequality follows since the outer while loop ends when at least n good nodes have been found in T . 3.3  
   
  Running Time Analysis  
   
  The main challenge in analyzing the running time of the algorithm is dealing with the cost of the recursive subcalls in the Extend procedure. For this we rely on two important ideas. Firstly, note that n is the index of the node value that we want to ﬁnd, while k is the index of the node value that is passed to the procedure. So, the procedure needs to only ﬁnd n − k new good nodes. Our runtime bound for the recursive subcalls that are performed does not just depend on n, but also on n − k. We will show that the amount of travel done in the non-recursive part of a call of Extend with parameters n and k is bounded by O(n log(n)2 ). We will charge this travel to the parent call that makes these recursive calls. Hence, a parent call that does z recursive calls with parameters (n1 , k1 ), . . . , (nz , kz ) will z be charged a cost of i=1 ni log(ni )2 . In our analysis, we will show that this sum can be upper bounded by (n − k) log(n)2 . So, for every recursive call with parameters n and k, a cost of at most (n − k) log(n)2 is incurred by the caller. Now we just need to bound the sum over (n − k) log(n)2 for all calls with parameters n and k that are done. We do this by ﬁrst considering a single algorithm call with parameters n and k that makes z recursive subcalls with parameters (n1 , k1 ), . . . , (nz , kz ). For such a subcall, we would like to bound the  
   
  z sum i=1 (ni −ki ) log(ni )2 by (n−k) log(n)2 . However, this bound does not hold deterministically. Instead, we show that this bound does hold in expectation. Now we know that every layer of recursion incurs an expected cost of at most (n−k) log(n)2 . Because the parameter n will decrease by at least a constant factor in each layer of recursion, there can be at most O(log(n)) layers. An upper bound of O((n − k) log(n)3 ) on the expected running time of the Extend then follows for the recursive part. Combining this with the upper bound of O(n log(n)2 ) on the non-recursive part, we get a total running time of O(n log(n)2 ) + O((n − k) log(n)3 ) for the Extend procedure, which then implies a running time of O(n log(n)3 ) for the SELECT procedure.  
   
  z Let us now prove these claims. We ﬁrst show that the expectation of i=1 (ni − ki ) is bounded. Lemma 1. Let z be the number of recursive calls that are done in the main loop of Extend(T , n , k  , L) with parameter k ≥ 1. For i ∈ [z], let ni and ki be the  
   
  A Nearly Optimal Randomized Algorithm  
   
  39  
   
  values of n and k that are given as parameters to the ith such subcall. Then: E  
   
  z  
   
  ni − ki ≤ n − k  .  
   
  i=1  
   
  Proof. Assume we have m roots, whose order is ﬁxed. For i ∈ [z], let ri ∈ [m] be such that  
   
  the ith recursive subcall is done on the root with index ri . For t ∈ [m], z let st = i=1 1ri =t (ni − ki ). From the algorithm we see that when ri = t, all successive recursive calls will also be on root t, until all good nodes under this root have been found. The updated values of L and U ensure this root is never selected again after this, hence all iterations i with ri = t are consecutive. Now let at , bt be variables that respectively denote the ﬁrst and last indices i with ri = t. When there is no iteration i with ri = t, then at = bt = ∞. For two calls i and i+1 with ri = t = ri+1 , observe that after call i already ni good nodes under root t have been found. On line 15, c corresponds to ni and c corresponds to ki , hence ki+1 = ni . Therefore, the deﬁnition of st is a telescoping series and can be rewritten as st = nbt − kat , when we deﬁne k∞ = n∞ = 0. Let p = n − k  and let W = {w1 , . . . , wp } denote the p smallest values under T that are larger than L0 , in increasing order. Now each of these values in W will be part of a subtree generated by one of the roots. For the j ∈ [p], let dj ∈ [m] be such that value wj is part of the subtree of root dj . Let St = {j ∈ [p] : dj = t}. We will  
   
  now show that  
   
  for each root  
   
  rt , we have E[st ] ≤ |St |. This will imply z m m that E [ i=1 ni − ki ] = t=1 E[st ] ≤ t=1 |St | = n − k  . First, consider a root t with t = dp . On line 9, each iteration a random root is chosen. In every iteration root dp will be among the active roots. So the probability that this root is chosen before root t is at least a half. In that case, after the iteration of root dp , L will be set to wp . Then DFS(T , L, n) returns n, and the algorithm terminates. Since no subcalls are done on root t, si = 0. If the algorithm does do subcalls i with ri = t, then consider iteration bt , the last iteration i that has ri = t. Before this iteration, already kbt good nodes under the root have been found by the algorithm. It can be seen in the algorithm on lines 13 and 18 that nbt ≤ 2kbt . Hence st = nbt − kat ≤ nbt ≤ 2kbt ≤ 2|St |. We therefore have E[st ] ≤ 12 · 0 + 12 · 2|St | = |St |. Now consider the root dp . If Sdp = [p], then sp = nbdp −kadp ≤ n −k  = |Sdp |, because nbdp ≤ n and kadp ≥ k  . If Sdp  [p], then there exists a j with dj = dp . Thus, we can deﬁne j ∗ = max{j ∈ [p] : dj = dp }. With probability a half, root dj ∗ is considered before root dp . If this happens, L will be equal to wj ∗ when root dp is selected by the algorithm. In particular, this means that kadp will be equal to j ∗ . Recall the stated invariant that c ≤ n − k  = p, and hence nbdp = c ≤ p. Now we can see that sdp = nbdp − kadp ≤ p − j ∗ . If root dp is chosen before root dj ∗ , then consider the last recursive call bdp to Extend that we do on root dp . Deﬁne A = [k  − k  ] ∩ Sdp , i.e. the set of all good values under root dp that have been found so far. We distinguish two cases. If k  − k  ≥ j ∗ , i.e., when all good values under dj ∗ have been found, then by deﬁnition of j  , [p] \ [k  − k  ] ⊆ [p] \ [j  ] ⊆ Sdp . Because A and [p] \ [k  − k  ]  
   
  40  
   
  S. Borst et al.  
   
  are disjoint, we have |A| + (n − k  ) = |A| + |[p] \ [k  − k  ]| ≤ |Sdp |. Hence, we have c ≤ n − k  + c = n − k  + |A| ≤ |Sdp |. Therefore, sdp ≤ nbdp = c ≤ |Sdp |. If k  − k  < j ∗ at the time of subcall bdp , then the last good value under dj ∗ has yet to be found, implying that A ⊆ [j ∗ ]. From the deﬁnition of j  we get [p] \ [j  ] ⊆ Sdp . Hence, |A| ≤ |Sdp | − |[p] \ [j  ]| = |Sdp | − (p − j  ). Thus c ≤ 2c = 2|A| ≤ 2(|Sdp | − (p − j ∗ )). So, in this case we have sdp ≤ nbdp = c ≤ 2(|Sdp | − (p − j ∗ )). Collecting the three cases above, we ﬁnd that   1 1 · (p − j ∗ ) + · max |Sdp |, 2(|Sdp | − (p − j ∗ )) 2  2  1 1 1 ∗ ∗ |Sd | + (p − j ), |Sdp | − (p − j ) . ≤ max 2 p 2 2  
   
  E[sdp ] ≤  
   
  Lastly, by deﬁnition of j ∗ we have [p] \ [j ∗ ] ⊆ Sdp , from which it follows that p − j ∗ ≤ |Sdp |. We ﬁnish the proof by observing that this implies   1 1 1 ∗ ∗ |Sd | + (p − j ), |Sdp | − (p − j ) ≤ |Sdp |, max 2 p 2 2 which ﬁnishes the proof. Lemma 2. The expected number of times that the outermost while-loop (at line 8) is executed by the procedure Extend is at most O(log(n)). Proof sketch. Let A (L) := {rj : j > L} and Au (U) := {rj : uj < U}. Observe that Roots(T, L0 , L, U) = A (L) ∪ Au (U) for any L ≤ U. One can show that in each iteration the size of either A (L) or Au (U) halves in expectation. Hence, in expectation at most O(log R) iterations are needed, where log R is the initial number of roots. Since R ≤ n, the lemma follows. By an elementary analysis of the algorithm and applying Lemma 2 we can prove the following lemma. Lemma 3. The expected running time of the non-recursive part of every call to Extend is O(n log(n)2 ). Finally we are able to prove the running time bound. Lemma 4. Let R(T, n, k) denote the running time of a call to Extend(T , n, k, L0 ). Then there exists C > 0 such that E[R(T, n, k)] ≤ 5C(n − k) log(n)3 + Cn log(n)2 . Proof. We will prove this with induction on r := log(n). For r = 1, we have n ≤ 2. In this case R is constant, proving our induction base. Now consider a call Extend(T , n, k, L0 ) and assume the induction claim is true when log(n) ≤ r − 1. By Lemma 3, we can choose C such that this running time is bounded by C · n log(n).  
   
  A Nearly Optimal Randomized Algorithm  
   
  41  
   
  Now we move on to the recursive part of the algorithm. All calls to Extend(T , n, k, L0 ) with k = 0 will have n = 1, so each of these calls takes only O(1) time. Hence we can safely ignore these calls. Let z be the number of recursive calls to Extend(T , n, k, L0 ) that are done from the base call with k ≥ 1. Let Ti , ki , ni for i ∈ [z] be the arguments of these function calls. Note that n/2 ≥ ni ≥ 2 for all i. By the induction hypothesis the expectation of the recursive part of the running time is:   z   z R(Ti , ni , ki ) ≤ E 5C log(ni )(ni − ki ) log(ni )2 + Cni log(ni )2 E i=1  
   
  i=1  
   
  ≤ 5C log(n/2) E  
   
    
   
  r  
   
   ni − ki log(n)2 + C log(n)2  
   
  i=1  
   
  r  
   
  ni  
   
  i=1  
   
  ≤ 5C(log(n) − 1)(n − k) log(n)2 + 5C log(n)2 (n − k) ≤ 5C(n − k) log(n)3 .  
   
  r Here we used Lemma 1 as well as the fact that i=1 ni ≤ 4(n − k). To see this, z consider an arbitrary root q with s good values under it. Now i=1 1Ti =T (q) ni ≤  
   
  log(s+1) i 2 ≤ 2log(s+1) +1 ≤ 4s. In total there are n − k good values under i=2  
   
  z the roots, and hence i=1 ni ≤ 4(n − k). Adding the expected running time of the recursive and the non-recursive part, we see that E[R(T, n, k)] ≤ 5C(n − k) log(n)3 + Cn log(n)2 . 3.4  
   
  Space Complexity Analysis  
   
  We prove in this section the space complexity of our algorithm. Theorem 3. The procedure Extend runs in O(log(n)) space. Proof. Observe that the subroutines DFS, Roots and GoodValues all require O(1) memory, as argued in their respective analyses. Hence the space complexity of the non-recursive part of the Extend is O(1). Any recursive subcall Extend(Ti , ni , ki , Li ) resulting from a call to Extend(T , n, k, L), will have ni ≤ n/2. Hence, the depth of recursion is at most O(log(n)), which implies that the same is true for the space complexity.  
   
  4  
   
  Lower Bound  
   
  In general, no lower bound is known for the running time of the selection problem. However, we will show that any algorithm with space complexity at most s, has a running time of at least Ω(n logs (n)). The tree that is used for the lower bound construction is very simple: a root with two trails of length O(n) attached to it. We will make use of a variant of the communication complexity model. In this model there are two agents A and B, that both have access to their own  
   
  42  
   
  S. Borst et al.  
   
  sets of values in SA and SB respectively. These sets are the input. We have |SA | = n + 1 and |SB | = n. Assume that all values SA and SB are diﬀerent. Now consider the problem where player A wants to compute the median of SA ∪ SB . Because the players only have access to their own values, they need to communicate. They use a protocol, that can consist of multiple rounds. In every odd round, player A can do computations and send units of information to player B. In every even round, player B does computations and sends information to player A. We assume that sending one value from SA or SB takes up one unit of information. Furthermore, we assume that, except for comparisons, no operations can be performed on the values. We can reduce median computation to the explorable heap selection problem. Lemma 5. If there is a algorithm that solves SELECT(3n) in f (n)n time and g space, then there is a protocol for median computation that uses f (n)/2 rounds in each of which at most g units of information are sent. By showing a lower bound on the number of necessary rounds for median computation we can now prove the lower bound. Theorem 4. The time complexity of any randomized algorithm for SELECT(n) with at most g units of storage is Ω(n logg+1 (n)).  
   
  References 1. Achterberg, T.: Constraint Integer Programming. Ph.D. thesis, TU Berlin (2009) 2. Achterberg, T., Koch, T., Martin, A.: Branching rules revisited. Oper. Res. Lett. 33(1), 42–54 (2005). https://doi.org/10.1016/j.orl.2004.04.002 3. Alpern, S., Gal, S.: The Theory of Search Games and Rendezvous, vol. 55. Springer, New York (2006). https://doi.org/10.1007/b100809 4. Balcan, M.F., Dick, T., Sandholm, T., Vitercik, E.: Learning to branch. In: ICML (2018) 5. Banerjee, S., Cohen-Addad, V., Gupta, A., Li, Z.: Graph searching with predictions, December 2022 6. Berman, P.: On-line searching and navigation. In: Fiat, A., Woeginger, G.J. (eds.) Online Algorithms. LNCS, vol. 1442, pp. 232–241. Springer, Heidelberg (1998). https://doi.org/10.1007/BFb0029571 7. Borst, S., Dadush, D., Huiberts, S., Kashaev, D.: A nearly optimal randomized algorithm for explorable heap selection, October 2022. https://doi.org/10.48550/ arXiv.2210.05982 8. Clausen, J., Perregaard, M.: On the best search strategy in parallel branch-andbound: best-ﬁrst search versus lazy depth-ﬁrst search. Ann. Oper. Res. 90, 1–17 (1999) 9. Dasgupta, P., Chakrabarti, P.P., DeSarkar, S.C.: A near optimal algorithm for the extended cow-path problem in the presence of relative errors. In: Thiagarajan, P.S. (ed.) FSTTCS 1995. LNCS, vol. 1026, pp. 22–36. Springer, Heidelberg (1995). https://doi.org/10.1007/3-540-60692-0 38 10. Diks, K., Fraigniaud, P., Kranakis, E., Pelc, A.: Tree exploration with little memory. J. Algorithms 51(1), 38–63 (2004). https://doi.org/10.1016/j.jalgor.2003.10. 002  
   
  A Nearly Optimal Randomized Algorithm  
   
  43  
   
  11. Frederickson, G.: An optimal algorithm for selection in a min-heap. Inf. Comput. 104(2), 197–214 (1993). https://doi.org/10.1006/inco.1993.1030 12. Gleixner, A.M.: Personal communication, November 2022 13. Karp, R.M., Saks, M.E., Wigderson, A.: On a search problem related to branchand-bound procedures. In: FOCS, pp. 19–28 (1986) 14. Linderoth, J.T., Savelsbergh, M.W.P.: A computational study of search strategies for mixed integer programming. INFORMS J. Comput. 11(2), 173–187 (1999). https://doi.org/10.1287/ijoc.11.2.173 15. Lodi, A., Zarpellon, G.: On learning and branching: a survey. TOP 25(2), 207–236 (2017). https://doi.org/10.1007/s11750-017-0451-6 16. Morrison, D.R., Jacobson, S.H., Sauppe, J.J., Sewell, E.C.: Branch-and-bound algorithms: a survey of recent advances in searching, branching, and pruning. Discret. Optim. 19, 79–102 (2016). https://doi.org/10.1016/j.disopt.2016.01.005 17. Munro, J., Paterson, M.: Selection and sorting with limited storage. Theoret. Comput. Sci. 12(3), 315–323 (1980). https://doi.org/10.1016/0304-3975(80)90061-4 18. Pietracaprina, A., Pucci, G., Silvestri, F., Vandin, F.: Space-eﬃcient parallel algorithms for combinatorial search problems. J. Parallel Distrib. Comput. 76, 58–65 (2015) 19. Suhl, L.M., Suhl, U.H.: A fast LU update for linear programming. Ann. Oper. Res. 43(1), 33–47 (1993). https://doi.org/10.1007/BF02025534 20. Kamphans, T.: Models and algorithms for online exploration and search. Ph.D. thesis, Rheinische Friedrich-Wilhelms-Universit¨ at Bonn (2006). https://hdl.handle. net/20.500.11811/2622  
   
  Sparse Approximation over the Cube Sabrina Bruckmeier1(B) , Christoph Hunkenschr¨ oder2 , and Robert Weismantel1 1 ETH Z¨ urich, Z¨ urich, Switzerland {sabrina.bruckmeier,robert.weismantel}@ifor.math.ethz.ch 2 TU Berlin, Berlin, Germany [email protected]   
   
  Abstract. This paper presents an analysis of the NP-hard minimization problem min{b − Ax2 : x ∈ [0, 1]n , |supp(x)| ≤ σ}, where supp(x) := of investigation {i ∈ [n] : xi = 0} and σ is a positive integer. The object  is a natural relaxation where we replace |supp(x)| ≤ σ by i xi ≤ σ. Our analysis includes a probabilistic view on when the relaxation is exact. We also consider the problem from a deterministic point of view and provide a bound on the distance between the images of optimal solutions of the original problem and its relaxation under A. This leads to an algorithm for generic matrices A ∈ Zm×n and achieves a polynomial running time provided that m and A∞ are ﬁxed. Keywords: Sparse Approximation Recovery  
   
  1  
   
  · Subset Selection · Signal  
   
  Introduction and Literature Review  
   
  Due to the recent development of machine learning, data science and signal processing, more and more data is generated, but only a part of it might be necessary in order to already make predictions in a suﬃciently good manner. Therefore, the question arises to best approximate a signal b by linear combinations of no   more than σ vectors Ai from a suitable dictionary A = A1 , . . . , An ∈ Rm×n : min Ax − b2 subject to x0 ≤ σ,  
   
  (1)  
   
  where x0 := |{i ∈ [n] : xi = 0}|. Additionally, many areas of application – as for example portfolio selection theory, sparse linear discriminant analysis, general linear complementarity problems or pattern recognition – require the solution x to satisfy certain polyhedral constraints. For instance motivated by computer tomography, lower and upper bounds on the variables are considered in [31]. While there exists a large variety of ideas how to tackle this problem, the majority of them relies on the matrix A satisfying conditions such as being sampled in a speciﬁc way or being close to behaving like an orthogonal system, that might be hard to verify. Additionally, these algorithms commonly yield results only with a certain probability or within an approximation factor that again highly depends on the properties of A. A discussion of these ideas and c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 44–57, 2023. https://doi.org/10.1007/978-3-031-32726-1_4  
   
  Sparse Approximation Over the Cube  
   
  45  
   
  diﬀerent names and variants of this problem is postponed to the end of the introduction. In this work, we develop an exact algorithm that, without these limitations on A, solves the Sparse Approximation problem in [0, 1]-variables, min Ax − b2 subject to x ∈ [0, 1]n and x0 ≤ σ. x  
   
  (P0 )  
   
  Theorem 1. Given A ∈ Zm×n , b ∈ Zm and σ ∈ Z≥1 , we can ﬁnd an opti2 mal solution x to Problem (P0 ) in (mA∞ )O(m ) · poly(n, ln(b1 )) arithmetic operations. Relaxing the pseudonorm  · 0 by  · 1 is a commonly used technique in the literature. In contrast to previous results we are able to bound the distance between the images of these solutions under A without any further assumptions on the input data and therefore derive a proximity result that – to the best of our knowledge – has not been known before. Theorem 2. Let x ˆ be an optimal solution to the following relaxation of (P0 ): min Ax − b2 subject to x ∈ [0, 1]n and x1 ≤ σ. x  
   
  Every optimal solution x of (P0 ) satisﬁes x2 ≤ 2ˆ x − ˆ x1 max Ai 2 ≤ 2 m3/2 A∞ , Ax − Aˆ i=1,...,n  
   
  where ˆ x denotes the vector x ˆ rounded down component-wise. We also illuminate our approach from a probabilistic point of view. Speciﬁcally, the hard instances are those where b is relatively close to the boundary of the polytope Q := {Ax : x ∈ [0, 1]n , x1 ≤ σ}. Conversely, if b is deep inside Q or far outside of Q, then with high probability, an optimal solution to the relaxation solves the initial problem (P0 ). The paper is organized as follows. We conclude the introduction by providing an overview on related literature. Section 2 discusses preliminaries. The probabilistic analysis of a target vector b is carried out in Sect. 3. We then discuss a worst-case proximity bound between optimal solutions of (P0 ) and a natural relaxation in Sect. 4. This will allow us to formalize a deterministic algorithm in Sect. 5. In the literature, Problem (1) can be found under various modiﬁcations and names, see e.g. [4,5,8,27]. A common variant in the context of random measurements is often called Sparse Recovery, cf. [20], or Subset Selection for (linear) regression, cf. [10], while the name (Best) Subset Selection is generally used without further interpretation cf. [8,11,34], in contrast to Signal Recovery or Signal Reconstruction as in [3]. If the vector b can be represented exactly, the problem is called Exact Sparse Approximation or Atomic Decomposition, cf. [7,21,32,35]. Since the diﬀerences are marginal and the names in the literature not welldeﬁned, we restrain ourselves to the name Sparse Approximation for simplicity.  
   
  46  
   
  S. Bruckmeier et al.  
   
  In general, there are two common strategies used to tackle Sparse Approximation: Greedy algorithms and algorithms based on relaxations. A detailed discussion of those is beyond the scope of this paper. Let us rather put these approaches into context below. The algorithms either recover the optimal support only under certain conditions (compare [1,8,9,32]), recover it with high probability (see for example [13,34]) or approximate the solution (for instance [10,14,21]). Unfortunately, because of their high computational cost most common greedy algorithms are not suﬃcient for large systems, though experiments suggest that there still exist applicable greedy approaches, such as the Dropping Forward-Backward Scheme, introduced by Nguyen [26]. While the idea of relaxing the pseudonorm ·0 by the norm ·1 , as done for example in Basis Pursuit by Chen, Donoho and Saunders [7], might seem intuitive, for a long time the success of this method was not quite understood. This changed as Candes, Romberg and Tao [4,6] discovered and improved the Uniform Uncertainty Principle. For the usually problematic case of having not enough data points, the Dantzig Selector presented by Candes and Tao [5] yields a sophisticated estimator with high probability. Similarly, LASSO based methods, see for instance [27], either recover the support with high probability exactly under certain conditions, or fail with high probability if the conditions are not met, cf. [33]. Finally, Garmanik and Zadik [17] revealed interesting structural results, that explain the above mentioned all-or-nothing behavior. There also exists a series of papers in a similar line of thought that relaxes  · 0 by smooth, non-decreasing, concave functions, see [12,15,16,19,22,24,29,30]. It can be shown that these relaxations converge ¸ ivril [35] proved that, towards the optimal solution of (P0 ). Qian et al. [28] and C unless P = N P , for a general matrix A Pareto Optimization and the two greedy algorithms, Forward Selection and Orthogonal Matching Pursuit, are almost the best we can hope for. This motivated a search for more eﬃciently solvable classes of A, cf. [3,11,18,20]. Finally, it should be mentioned that there exists a variety of Branch-and-Bound algorithms whose success though is in general only tested experimentally, see [2,23].  
   
  2  
   
  Preliminaries  
   
  Let A ∈ Zm×n and b ∈ Zm . Moreover, let supp(x) denote the support of x, i.e. supp(x) := {i ∈ [n] : xi = 0} and set x0 := |supp(x)|. For the rest of the paper, x denotes an optimal solution for (P0 ) for a given integer σ ∈ Z≥1 . A natural convex relaxation of (P0 ) is given by min Ax − b2 subject to x ∈ [0, 1]n and x1 ≤ σ. x  
   
  (P1 )  
   
  An optimal solution to (P1 ) will be denoted by x ˆ throughout the paper. When m = 1, there exists an optimal solution x ˆ for (P1 ) that has at most one fractional variable (see Lemma 4). This solution is also feasible for (P0 ), and hence optimal. The idea of our approach is to establish a proximity result for Aˆ x and Ax respectively, that we can exploit algorithmically. This proximity bound depends on m which comes as no surprise, given that the problem is NP-hard even for  
   
  Sparse Approximation Over the Cube  
   
  47  
   
  ﬁxed values of m. The latter statement can be veriﬁed by reducing the NP-hard partition problem to an instance of (P0 ). Theorem 3. The problem (P0 ) is NP-hard, even if m = 2. A simple but important ingredient of our proximity theorem is the following fact that can be derived from elementary linear programming theory. Lemma 4 (Few fractional entries). 1. Let x be a feasible point for (P0 ). There exists a solution x such that Ax = Ax with at most m fractional entries. 2. Let x be a feasible point for (P1 ). There exists a solution x such that Ax = Ax with at most m fractional entries. Proof. 1. Let x be a solution of (P0 ) and denote S = supp(x). Let AS denote the submatrix of A comprising the columns with indices in S. The set PS (x) := {y ∈ R|S| : Ax = AS y, 0 ≤ y ≤ 1} is a polytope. It is non-empty since x ∈ P , hence it has at least one vertex v. By standard LP theory, at least |S| − m inequalities of the form 0 ≤ y ≤ 1 are tight at v. It follows that v has at most m fractional entries. The vertex v can easily be extended to a solution x of (P0 ) by adding zero-entries. 2. Given the solution x to (P1 ), consider the optimization problem n  min{ yi : y ∈ P{1,...,n} (x)}. i=1  
   
  Let v be an optimal vertex solution. From Part 1.  v has at most nm fractional n entries. Since x is feasible for the above problem, i=1 vi ≤ i=1 xi ≤ σ.   
   
  3  
   
  The 1 -Relaxation for Random Targets b  
   
  In order to shed some light on Problem (P0 ) and its natural convex relaxation (P1 ) we ﬁrst provide a probabilistic analysis to what extend optimal solutions of (P1 ) already solve (P0 ). Let Q := {Ax ∈ Rm : x ∈ [0, 1]n , x1 ≤ σ} be the set of all points we can represent with the 1 -relaxation. This section deals with the question which vectors b are “easy” target vectors. It turns out that if b is “deep” inside Q or far outside of Q, then the corresponding instances of (P0 ) are easy with very high probability. In fact, there almost always exist optimal solutions of (P1 ) that are already feasible for (P0 ) and hence optimal. Conversely, if b is close to the boundary of Q, then the probability that an optimal solution of (P1 ) solves (P0 ) is almost 0. Theorem 5. Let A ∈ Rm×n and σ ≥ m be an integer. If b ∈ there exists x ∈ [0, 1]n with x 0 ≤ σ and Ax = b.  
   
  σ−m+1 Q, σ  
   
  then  
   
  48  
   
  S. Bruckmeier et al.  
   
  Proof. If b ∈ σ−m+1 Q, there exists a vector x ˆ ∈ [0, σ−m+1 ]n such that b = Aˆ x σ σ and ˆ x1 ≤ σ−m+1. Let v be a vertex of {x ∈ [0, 1]n : Ax = b, x1 ≤ σ−m+1}, which contains x ˆ. According to the constraint x1 ≤ σ − m + 1, v has at most σ − m + 1 integral non-zero entries. By Lemma 4, v has at most m fractional entries. However, if there are fractional entries present, we can only have σ − m  integral entries, thus, v0 ≤ σ. Intuitively, the following theorem states that if b is sampled far away from Q, then (P1 ) provides a solution to (P0 ) as well. Here B := {x ∈ Rm : x2 ≤ 1} denotes the Euclidean unit ball. Theorem 6. Let A ∈ Rm×n , λ ≥ 0 and σ ≥ 1 be an integer. If b is sampled uniformly at random from the convex set Q + λB, then with probability at least  m λ √ λ + σ mA∞ there exists x ∈ {0, 1}n that is optimal for (P1 ) and (P0 ). Proof. Deﬁne P := {x ∈ [0, 1]n : x1 ≤ σ}, hence we have Q = {Ax : x ∈ P }. Observe that all vertices of P are in {0, 1}n , and as a consequence any vertex v of Q can be written as v = Ax with x a vertex in P that is integral.  
   
  (2)  
   
  Hence, whenever an optimal solution to min{b − x2 : x ∈ Q} is attained by a vertex of Q, the problem (P1 ) has an optimal integral vertex solution v. Since an integral solution to (P1 ) is also feasible for (P0 ), the vector v is also optimal for (P0 ). Let V be the vertex set of Q. For v ∈ V , denote the normal cone of v by Cv := {c ∈ Rm : c (w − v) ≤ 0 ∀w ∈ Q}. Fix a vertex v and assume b ∈ v +Cv . We next show that v is an optimal solution to min{b − x22 : x ∈ Q}. Since b = v + c with c (v − w) ≥ 0 for all w ∈ Q, we obtain b − w22 = v − w + c22 = v − w22 + c22 + 2c (v − w) ≥ c22 = b − v22 , showing that v is optimal. By Eq. (2) there exists an integral x ∈ P such that v = Ax and hence x is optimal for (P0 ). It remains to calculate the probability that b ∈ v + Cv for some vertex v of Q. We obtain   
   
    
   
  vol (v + Cv ) ∩ (Q + λB) = vol Cv ∩ λB v∈V  
   
  v∈V  
   
   = vol  

  Cv  
   
  ∩ λB  
   
  v∈V  
   
  = vol(λB) = λm vol(B).  
   
  Sparse Approximation Over the Cube  
   
  49  
   
  In the second to last equality we used that the normal cones Cv tile the space Rm . √ Let μ > 0 be a constant s.t. Q ⊆ μB, e.g. μ = σ mA∞ . We have the containment Q + λB ⊆ μB + λB = (μ + λ)B that allows us to estimate vol(Q + λB) ≤ (λ + μ)m vol(B). The probability that b is sampled in one of the normal cones is therefore  m λ λm vol(λB) √ ≥ ≥ . vol(Q + λB) (λ + μ)m λ + σ mA∞  √ Let us brieﬂy comment on the probability quantity ρ := (λ/(λ + σ mA∞ ))m . If we choose λ = 2m3/2 σA∞ in Theorem 6, then ρ ≥ 1/2, as one can verify with Bernoulli’s inequality. Figure 1 depicts the geometry underlying the proof of Theorem 6. The vector b1 is sampled from the dotted area and hence, an optimal solution of (P1 ) may use 2 fractional entries, and thus have support σ + 1. On the other hand, the vector b2 is sampled from the dashed area, which leads to the solution of (P1 ) corresponding to a vertex of Q. In the second case (P1 ) has an integral solution, which automatically solves (P0 ).  
   
  Fig. 1. The sampling of the vector b from Q + λB  
   
  4  
   
  Proximity Between Optimal Solutions of (P0 ) and (P1 )  
   
  In this section we illuminate the Problems (P0 ) and (P1 ) from a deterministic point of view and develop worst-case bounds for the distance of the images of corresponding optimal solutions under A. Our point of departure is an optimal solution x ˆ of (P1 ). The target is to show that there exists an optimal solution x − x )2 ≤ 2m3/2 A∞ . Our strategy is to deﬁne a x of (P0 ) satisfying A(ˆ hyperplane containing Aˆ x in the space of target vectors b that separates b from  
   
  50  
   
  S. Bruckmeier et al.  
   
  all vectors Ax with x feasible for (P0 ). The next step is to show that if we perturb x ˆ along the fractional variables, we will remain in this hyperplane. This has the side-eﬀect that we can ﬁnd a feasible solution for (P0 ) whose image is in the vicinity of Aˆ x. The triangle inequality and basic geometry then come into play to establish the claimed bound. x, We introduce the hyperplane tangent to the ball B(b, b − Aˆ x2 ) in Aˆ x) y = (b − Aˆ x) Aˆ x}. H := {y ∈ Rm : (b − Aˆ Lemma 7. We have (b − Aˆ x) (Ax − Aˆ x) ≤ 0 for any point x feasible for (P1 ). Proof. Assume that there exists a point x feasible for (P1 ) for which the x) > 0 holds. As a convex combination the point inequality (b − Aˆ x) (Ax − Aˆ p := A(ˆ x + ε(x − x ˆ)) is feasible for (P1 ) for each ε ∈ [0, 1], and we can estimate the objective value as x22 + ε2 A(x − x ˆ)22 − 2ε(b − Aˆ x) (Ax − Aˆ x) < b − Aˆ x22 b − p22 = b − Aˆ for ε small enough. This contradicts the optimality of x ˆ. We illustrate the argument geometrically in Fig. 2.   
   
  b  
   
  Aˆ x p  
   
  Ax  
   
  H  
   
  Fig. 2. If H does not separate b from Ax, there is a point p closer to b than Aˆ x.  
   
  An important property is that H contains many points that we can easily generate from x ˆ. This is made precise below. (Recall that Ai denotes the i-th column of A). / Z} where x ˆ is an optimal solution Lemma 8. Deﬁne F := {i ∈ [n] : x ˆi ∈ to (P1 ). We have   Aˆ x+ λi Ai : λi = 0 ⊆ H. i∈F  
   
  i∈F  
   
  Sparse Approximation Over the Cube  
   
  51  
   
  Proof. Let v := b − Aˆ x ∈ Rm be the normal vector of H and let   y= λi ei for some λi ∈ R with λi = 0. i∈F  
   
  i∈F  
   
  Since x ˆi ∈ (0, 1) for all i ∈ F, there exists ε > 0 such that both points x ˆ + εy x + εy − x ˆ) = and x ˆ − εy are feasible for (P1 ). By Lemma 7, we must have v  A(ˆ x + y) ∈ H.  v  Aεy ≤ 0 and −v  Aεy ≤ 0, resulting in v  Ay = 0. Thus, A(ˆ With these results we are now able to show a proximity result (Theorem 2) between Aˆ x and Ax . Here, ˆ x denotes the vector x ˆ rounded down componentwise. Proof (Theorem 2). Given an optimal solution x ˆ of (P1 ), let F = {i ∈ [n] : generality, we may assume that |F| ≤ m and x ˆi ∈ (0, 1)}. Without loss of  ˆi , and construct a feasible solution y for (P0 ) F = {1, 2, . . . , |F|}. Let k := i∈F x from x ˆ as follows: ⎧ 1, 1 ≤ i ≤ k ⎪ ⎪ ⎪ ⎨k − k, i = k yi := ⎪ 0, k + 1 ≤ i ≤ |F| ⎪ ⎪ ⎩ x ˆi , i∈ / F. The point y satisﬁes 0 ≤ yi ≤ 1 for all i ∈ [n] and y0 = ˆ x1  ≤ σ. Since   yi = x ˆi , (3) i∈F  
   
  i∈F  
   
  Lemma 8 implies that Ay ∈ H and hence b − Ay22 = b − Aˆ x22 + Aˆ x − Ay22 . Assume Ax − Aˆ x2 > Ay − Aˆ x2 holds for some optimal solution x for (P0 ). Since y is feasible for (P0 ), we also know b − Ay2 ≥ b − Ax 2 . We are now prepared to estimate (using Lemma 7 in the third line) x + Aˆ x − Ax 22 b − Ax 22 = b − Aˆ = b − Aˆ x22 + Aˆ x − Ax 22 + 2(b − Aˆ x) (Aˆ x − Ax ) x − Ax 22 ≥ b − Aˆ x22 + Aˆ > b − Aˆ x22 + Aˆ x − Ay22 = b − Ay22 , showing that x is not optimal. The proof is ﬁnished by observing that Eq. (3) x − ˆ x1 , and consequently also implies ˆ x − y1 ≤ 2ˆ Ay − Aˆ x2 ≤ 2ˆ x − ˆ x1 max Ai 2 ≤ 2m3/2 A∞ . i=1,...,n  
   
    
   
  52  
   
  5  
   
  S. Bruckmeier et al.  
   
  A Deterministic Algorithm  
   
  The results presented so far give rise to a conceptually simple algorithm. Compute an optimal solution x ˆ to (P1 ). According to the proximity Theorem 2, we can limit our search for an optimal right-hand side vector b = Ax in the vicinity of Aˆ x. Since b might be fractional, we cannot enumerate all possible right-hand sides. Instead, we reﬁne our approach by decomposing x = z  + f  into its integral part z  and its fractional part f  . We ﬁrst guess the support F of the fractional entries, which satisﬁes |F| ≤ m by Lemma 4. For the remaining variables, we next establish a candidate set Z  comprising the potential vectors z  in the decomposition of x . It will be essential to determine a bound on |Z  |. This is where the proximity theorem comes into play. We now enumerate the elements of Z  and extend each of them by a vector f  whose support is in the index set F that we guessed upfront. A composition of these two solutions will provide x . This section is devoted to analyze this conceptually simple algorithm and this way shed some light on some of the details required. Before we describe the decomposition x = z  + f  in more detail, we discuss the standard obstacle in convex optimization that x ˆ can only be approximated. To be more precise, we call a solution x ¯ to (P1 ) ε-close, if x22 ≤ ε2 . b − A¯ x22 − b − Aˆ  
   
  (4)  
   
  We obtain a canonical corollary from the proximity Theorem 2. Corollary 9. Let x ¯ be an ε-close solution of (P1 ). 1. Every optimal solution x of (P0 ) satisﬁes x∞ ≤ 2 m3/2 A∞ + ε. Ax − A¯ 2. The integral part z  of x satisﬁes x∞ ≤ 3 m3/2 A∞ + ε. Az  − A¯ Proof. We start by estimating the distance from A¯ x to Aˆ x for an optimal solution x ˆ of (P1 ). We have x + Aˆ x − A¯ x22 b − A¯ x22 = b − Aˆ = b − Aˆ x22 + Aˆ x − A¯ x22 + 2(b − Aˆ x) (Aˆ x − A¯ x), where the last term is non-negative by Lemma 7. Rearranging terms, we obtain x22 − b − Aˆ x22 − 2(b − Aˆ x) (Aˆ x − A¯ x) ≤ ε2 . Aˆ x − A¯ x22 = b − A¯ Applying the triangle inequality and combining the above estimate with Theorem 2, we have x∞ ≤ Ax − A¯ x2 ≤ Ax − Aˆ x2 + Aˆ x − A¯ x2 Ax − A¯ ≤ 2 m3/2 A∞ + ε.  
   
  Sparse Approximation Over the Cube  
   
  53  
   
  For Part 2, recall that x − z  = f  with f  0 ≤ m, implying the inequality A(x − z  )∞ ≤ mA∞ . We obtain Az  − A¯ x∞ = Az  − Ax + Ax − A¯ x∞ ≤ A(z  − x )∞ + Ax − A¯ x∞ ≤ mA∞ + 2 m3/2 A∞ + ε ≤ 3 m3/2 A∞ + ε.  We next outline the decomposition x = z  + f  . As a ﬁrst step, we guess the support of a minimal index set of fractional entries. 2  
   
  Lemma 10. There are (2A∞ +1)m potentially diﬀerent index sets supp(f  ). Proof. We notice that a minimal index set of fractional entries uses distinct columns from the matrix A. There are at most (2A∞ + 1)m distinct columns of A. Since the cardinality of a minimal index set of fractional entries is bounded 2 by m, there are at most ((2A∞ +1)m )m = (2A∞ +1)m potentially diﬀerent index sets.  A canonical approach would be to search for the vector f  . Then we run into the problem that our objective is nonlinear, and hence f  depends on z  . This requires us to ﬁrst search for an optimal z  and then use continuous optimization techniques to compute f  . In order to avoid to determine a minimal index set of fractional entries, we also allow entries with index in F to be integral. Then we need to guess only sets F ⊆ [n] with |F| = m. We denote by A\f  the matrix A without the columns with index in supp(f  ). The next theorem shows that we can compute a small set Z  of possible vectors for z  . Theorem 11. Let x ¯ be an ε-close solution to (P1 ). If supp(f  ) is ﬁxed, we can  compute a set Z ⊆ {0, 1}n of candidate vectors such that x = z  + f  with z  ∈ Z  . This requires us to solve at most (6m3/2 A∞ + 2ε + 1)m linear integer programming problems. Proof. We have Az  ∈ A¯ x + [−Dε , Dε ]m ∩ Zm , where Dε = 3m3/2 A∞ + ε by  x + [−Dε , Dε ]m ∩ Zm we solve the integer feasibility Corollary 9. For every b ∈ A¯ problem n−m  yi ≤ σ − m, y ∈ {0, 1}n−m . A\f  y = b , i=1  
   
  If it has a feasible solution y, we can insert zero entries according to supp(f  ) and obtain a vector z ∈ {0, 1}n that qualiﬁes as the vector z  . The set Z  is the set of all extended vectors z.  It remains to compose each z  ∈ Z  with a vector f  . This is accomplished by solving a series of least-square problems. The reason why we proceed in this way is that it allows us to compute the exact vector f  as opposed to an ε-close solution.  
   
  54  
   
  S. Bruckmeier et al.  
   
  Lemma 12 (Extension lemma). For each z ∈ Z  an optimal solution f to min{b − Az − Af 2 : supp(f ) ⊆ supp(f  ), 0 ≤ f ≤ 1} can be computed in O(3m m3 ) arithmetic operations. Proof. As fi = 0 for i ∈ / supp(f  ), we can restrict to the matrix Af  ∈ Zm×m and solve the equivalent problem min{b −Af  g2 : g ∈ [0, 1]m } for b := b−Az. Without the variable bounds this is a least-square problem that can be solved in O(m3 ) arithmetic operations. Let g  be an optimal solution. We guess the sets S0 := {i : gi = 0} and S1 := {i : gi = 1}, and afterwards solve the modiﬁed least-square problem min{b − Af  g2 : gi = 0 ∀i ∈ S0 , gi = 1 ∀i ∈ S1 }. If the solution g is in [0, 1]n , its extension f ∈ [0, 1]n qualiﬁes as f  . In the end, we pick the best among all feasible extensions. As there are 3m guesses, this ﬁnishes the proof.  This completes the presentation of the main steps to prove Theorem 1. In fact, in order to obtain an optimal solution to (P0 ) one proceeds as follows. We ﬁrst guess the set supp(f  ), determine the set Z  and compute for every z  ∈ Z  an optimal vector f  . The best of all those solutions solves (P0 ). As a last technicality, we have to show how to ﬁnd an ε-close solution x ¯ for which we fall back on [25, Chap. 8]. √ Lemma Chap. 8]). We can ﬁnd a mA∞ -close solution for (P1 )   7/213 ([25, in O n ln n2 σb1 arithmetic operations. Proof. We apply the results presented in [25, Chap. 8] that depend on several parameters. Let P := {x ∈ [0, 1]n : x1 ≤ σ} denote the feasible region of (P1 ) and x ˆ an optimal solution. We ﬁrst need to estimate D := max{b − Ay22 − b − Aˆ x22 : y ∈ P }. For any y ∈ P we can estimate b − Ay22 − b − Aˆ x22 = Ay22 − Aˆ x22 + 2b A(ˆ x − y) ≤ σ 2 mA2∞ + 4b1 σA∞ ≤ 4σ 2 mA2∞ (b1 + 1), resulting in D ≤ 4σ 2 mA2∞ (b1 + 1). As the initial point in the interior of P σ · 1 where 1 denotes the that is required in [25, Chap. 8] we choose w := n+σ all-ones vector. Next we estimate the asymmetry coeﬃcient α(P : w) := max{t : w + t(w − P ) ⊆ P }. Since [0, nσ ]n ⊆ P ⊆ [0, 1]n , for t =  
   
  σ n  
   
  we obtain  
   
  n  w + t(w − P ) ⊆ w + t(w − [0, 1]n ) = 0, nσ ⊆ P,  
   
  thus α(P : w) ≥  
   
  σ n.  
   
  By [25, Chap. 8, Eq. 8.1.5] we can compute a feasible   solution  
   
  2n+1 x22 −b−Aˆ x22 ≤ δD in O(1)(2n+1)1.5 n2 ln α(P x ¯ of (P1 ) satisfying b−A¯ :w)δ √ 1 arithmetic operations. Finally, by choosing δ = 4σ2 (b ﬁnding a mA ∞1 +1)  7/2  2  close solution takes O n ln n σb1 arithmetic operations.   
   
  Sparse Approximation Over the Cube  
   
  6  
   
  55  
   
  Extension  
   
  A natural generalization of our problem is to consider arbitrary upper bounds ui > 0, i.e. min Ax − b2 subject to x0 ≤ σ and 0 ≤ xi ≤ ui for all i ∈ [n]. x  
   
  (P0 )  
   
  The natural convex relaxation of (P0 ) is given by: min Ax − b2 subject to x  
   
  n  xi i=1  
   
  ui  
   
  ≤ σ and 0 ≤ xi ≤ ui for all i ∈ [n].  
   
  (P1 )  
   
  The results of Sects. 4 and 5 extend to this generalization in a straight-forward manner. For the algorithm it implies that the number of arithmetic operations increases by an additional factor of um ∞ . The reason is the core of our approach: The proximity bound between optimal solutions for (P0 ) and (P1 ) respectively, increases by this factor. The proximity bound must however depend on u∞ as the following example shows: Let n and u be even, non-negative integers. Set A := 1, σ := n2 and b = u2 1 where 1 denotes the all-ones vector. It can easily be checked that x ˆ = u2 1 is  optimal for (P1 ) while u , i ∈ [σ]  xi = 2 0, i ∈ [n] \ [σ] is optimal for (P0 ). This shows that any approach aiming for a logarithmic dependency on u∞ requires techniques that are diﬀerent from the ideas presented in this paper. Acknowledgements. The second and third author acknowledge support by the Einstein Foundation Berlin.  
   
  References 1. Ament, S., Gomes, C.: On the optimality of backward regression: Sparse recovery and subset selection. In: ICASSP 2021–2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), June 2021. https://doi.org/ 10.1109/icassp39728.2021.9415082 2. Beale, E.M.L., Kendall, M.G., Mann, D.W.: The discarding of variables in multivariate analysis. Biometrika 54(3–4), 357–366 (1967). https://doi.org/10.1093/ biomet/54.3-4.357 3. Candes, E., Romberg, J., Tao, T.: Robust uncertainty principles: exact signal reconstruction from highly incomplete frequency information. IEEE Trans. Inf. Theory 52(2), 489–509 (2006). https://doi.org/10.1109/TIT.2005.862083  
   
  56  
   
  S. Bruckmeier et al.  
   
  4. Candes, E., Tao, T.: Decoding by linear programming. IEEE Trans. Inf. Theory 51(12), 4203–4215 (2005). https://doi.org/10.1109/TIT.2005.858979 5. Candes, E., Tao, T.: The Dantzig selector: statistical estimation when p is much larger than n. Ann. Stat. 35(6), 2313–2351 (2007). https://doi.org/10.1214/ 009053606000001523 6. Candes, E.J., Romberg, J.K., Tao, T.: Stable signal recovery from incomplete and inaccurate measurements. Commun. Pure Appl. Math. 59(8), 1207–1223 (2006). https://doi.org/10.1002/cpa.20124 7. Chen, S.S., Donoho, D.L., Saunders, M.A.: Atomic decomposition by basis pursuit. SIAM Rev. 43(1), 129–159 (2001). https://doi.org/10.1137/S1064827596304010 8. Couvreur, C., Bresler, Y.: On the optimality of the backward greedy algorithm for the subset selection problem. SIAM J. Matrix Anal. Appl. 21(3), 797–808 (2000). https://doi.org/10.1137/S0895479898332928 9. Das, A., Kempe, D.: Algorithms for subset selection in linear regression. In: Proceedings of the Fortieth Annual ACM Symposium on Theory of Computing. STOC 2008, pp. 45–54. Association for Computing Machinery, New York (2008). https:// doi.org/10.1145/1374376.1374384 10. Das, A., Kempe, D.: Submodular meets spectral: greedy algorithms for subset selection, sparse approximation and dictionary selection. In: Proceedings of the 28th International Conference on International Conference on Machine Learning. ICML 2011, pp. 1057–1064. Omnipress, Madison (2011). https://doi.org/10.5555/ 3104482.3104615 11. Del Pia, A., Dey, S.S., Weismantel, R.: Subset selection in sparse matrices. SIAM J. Optim. 30(2), 1173–1190 (2020). https://doi.org/10.1137/18M1219266 12. Di Lorenzo, D., Liuzzi, G., Rinaldi, F., Schoen, F., Sciandrone, M.: A concave optimization-based approach for sparse portfolio selection. Optim. Methods Softw. 27(6), 983–1000 (2012). https://doi.org/10.1080/10556788.2011.577773 13. Donoho, D.: Compressed sensing. IEEE Trans. Inf. Theory 52(4), 1289–1306 (2006). https://doi.org/10.1109/TIT.2006.871582 14. Elenberg, E.R., Khanna, R., Dimakis, A.G., Negahban, S.: Restricted strong convexity implies weak submodularity. Ann. Stat. 46(6B), 3539–3568 (2018). https:// doi.org/10.1214/17-AOS1679 15. Feng, M., Mitchell, J.J., Pang, J.S., Shen, X., Waechter, A.: Complementarity formulations of 0 -norm optimization. Pac. J. Optim. 14(2), 273–305 (2018) 16. Fung, G.M., Mangasarian, O.L.: Equivalence of minimal 0 - and 1 -norm solutions of linear equalities, inequalities and linear programs for suﬃciently small p. J. Optim. Theory Appl. 151(1), 1–10 (2011). https://doi.org/10.1007/s10957-0119871-x 17. Gamarnik, D., Zadik, I.: High dimensional regression with binary coeﬃcients. estimating squared error and a phase transition. In: Proceedings of the 2017 Conference on Learning Theory. Proceedings of Machine Learning Research, vol. 65, pp. 948–953. PMLR, 07–10 July 2017 18. Gao, J., Li, D.: A polynomial case of the cardinality-constrained quadratic optimization problem. J. Glob. Optim. 56(4), 1441–1455 (2013). https://doi.org/10. 1007/s10898-012-9853-z 19. Ge, D., Jiang, X., Ye, Y.: A note on the complexity of LP minimization. Math. Program. 129, 285–299 (2011). https://doi.org/10.1007/s10107-011-0470-2 20. Gilbert, A., Indyk, P.: Sparse recovery using sparse matrices. Proc. IEEE 98(6), 937–947 (2010). https://doi.org/10.1109/JPROC.2010.2045092  
   
  Sparse Approximation Over the Cube  
   
  57  
   
  21. Gilbert, A.C., Muthukrishnan, S., Strauss, M.J.: Approximation of functions over redundant dictionaries using coherence. In: SODA, pp. 243–252. Citeseer (2003). https://doi.org/10.5555/644108.644149 22. Migot, T., Haddou, M.: A smoothing method for sparse optimization over polyhedral sets. In: Le Thi, H.A., Pham Dinh, T., Nguyen, N.T. (eds.) Modelling, Computation and Optimization in Information Systems and Management Sciences. AISC, vol. 359, pp. 369–379. Springer, Cham (2015). https://doi.org/10.1007/978-3-31918161-5 31 23. Hocking, R.R., Leslie, R.N.: Selection of the best subset in regression analysis. Technometrics 9(4), 531–540 (1967). https://doi.org/10.1080/00401706.1967. 10490502 24. Mangasarian, O.: Minimum-support solutions of polyhedral concave programs. Optimization 45(1–4), 149–162 (1999). https://doi.org/10.1080/ 02331939908844431 25. Nesterov, Y., Nemirovski, A.: Interior-point polynomial algorithms in convex programming. In: SIAM Studies in Applied Mathematics (1994) 26. Nguyen, T.: Dropping forward-backward algorithms for feature selection. CoRR abs/1910.08007 (2019) 27. Oymak, S., Thrampoulidis, C., Hassibi, B.: The squared-error of generalized lasso: a precise analysis. In: 2013 51st Annual Allerton Conference on Communication, Control, and Computing (Allerton), pp. 1002–1009 (2013). https://doi.org/10. 1109/Allerton.2013.6736635 28. Qian, C., Yu, Y., Zhou, Z.H.: Subset Selection by Pareto Optimization. NIPS 2015, pp. 1774–1782. MIT Press, Cambridge (2015). https://doi.org/10.5555/2969239. 2969437 29. Rinaldi, F.: Concave programming for ﬁnding sparse solutions to problems with convex constraints. Optim. Methods Softw. 26(6), 971–992 (2011). https://doi. org/10.1080/10556788.2010.511668 30. Rinaldi, F., Schoen, F.: Concave programming for minimizing the zero-norm over polyhedral sets. Comput. Optim. Appl. 46, 467–486 (07 2010). https://doi.org/10. 1007/s10589-008-9202-9 31. Teng, Y., Qi, S., Xiao, D., Xu, L., Li, J., Kang, Y.: A general solution to least squares problems with box constraints and its applications. Math. Probl. Eng. 2016 (2016) 32. Tropp, J.: Greed is good: algorithmic results for sparse approximation. IEEE Trans. Inf. Theory 50(10), 2231–2242 (2004). https://doi.org/10.1109/TIT.2004.834793 33. Wainwright, M.J.: Sharp thresholds for high-dimensional and noisy sparsity recovery using 1 -constrained quadratic programming (lasso). IEEE Trans. Inf. Theor. 55(5), 2183–2202 (2009). https://doi.org/10.1109/TIT.2009.2016018 34. Zhu, J., Wen, C., Zhu, J., Zhang, H., Wang, X.: A polynomial algorithm for bestsubset selection problem. Proc. Natl. Acad. Sci. 117(52), 33117–33123 (2020). https://doi.org/10.1073/pnas.2014241117 35. C ¸ ivril, A.: A note on the hardness of sparse approximation. Inf. Process. Lett. 113(14), 543–545 (2013). https://doi.org/10.1016/j.ipl.2013.04.014  
   
  Recycling Inequalities for Robust Combinatorial Optimization with Budget Uncertainty Christina B¨ using1 , Timo Gersing1(B) , and Arie M.C.A. Koster2 1  
   
  Combinatorial Optimization, RWTH Aachen University, Aachen, Germany {buesing,gersing}@combi.rwth-aachen.de 2 Discrete Optimization, RWTH Aachen University, Aachen, Germany [email protected]   
   
  Abstract. Robust combinatorial optimization with budget uncertainty is one of the most popular approaches for integrating uncertainty in optimization problems. The existence of a compact reformulation for (mixed-integer) linear programs and positive complexity results give the impression that these problems are relatively easy to solve. However, the practical performance of the reformulation is actually quite poor when solving robust integer problems due to its weak linear relaxation. To overcome the problems arising from the weak formulation, we propose a procedure to derive new classes of valid inequalities for robust binary optimization problems. For this, we recycle valid inequalities of the underlying deterministic problem such that the additional variables from the robust formulation are incorporated. The valid inequalities to be recycled may either be readily available model constraints or actual cutting planes, where we can benefit from decades of research on valid inequalities for classical optimization problems. We first demonstrate the strength of the inequalities theoretically, by proving that recycling yields a facet-defining inequality in surprisingly many cases, even if the original valid inequality was not facetdefining. Afterwards, we show in a computational study that using recycled inequalities leads to a significant improvement of the computation time when solving robust optimization problems. Keywords: Robust Optimization · Combinatorial Optimization Integer Programming · Polyhedral Combinatorics  
   
  1  
   
  ·  
   
  Introduction  
   
  Robust optimization is a widely used approach for integrating uncertainties into optimization models. The concept of budgeted uncertainty by Bertsimas and Sim [6] has received particular attention. However, despite its popularity and the amount of research devoted to solving these kind of robust optimization problems, instances of practical size often still pose a considerable challenge for c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 58–71, 2023. https://doi.org/10.1007/978-3-031-32726-1_5  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  59  
   
  MILP solvers [7]. In this context, we propose a new class of valid inequalities for robust combinatorial optimization problems that are easy to compute and can lead to a signiﬁcant reduction of the computation time. Without uncertainties, the socalled nominal combinatorial optimization n problem NOM is deﬁned as min{ i∈[n] ci xi |Ax ≤ b, x ∈ {0, 1} }, with c ∈ Rn , A ∈ Rm×n , and b ∈ Rm . Here, [n] = {1, . . . , n}. In the case of uncertainty in the objective, the coeﬃcients ci are replaced by uncertain coeﬃcients ci from an interval [ci , ci + cˆi ]. We say that ci can deviate from its nominal value ci by up to the deviation cˆi . Since the worst-case, in which all coeﬃcients ci deviate to ci + cˆi , is unlikely, Bertsimas and Sim [6] deﬁne an uncertainty budget Γ ∈ [0, n] and only consider scenarios where at most Γ  coeﬃcients ci deviate to ci + cˆi and one coeﬃcient may deviate to ci + (Γ − Γ ) cˆi . The robust counterpart, in which we optimize against the worst-case, can be stated as     ci xi + max cˆi xi (Γ − Γ ) cˆt xt + min i∈[n]  
   
  S∪{t}⊆[n]: |S|≤Γ ,t∈S / n  
   
  i∈S  
   
  s.t. Ax ≤ b, x ∈ {0, 1} .  
   
  Dualizing the inner maximization problem [6] yields the compact robust problem  min Γ z + (ci xi + pi ) i∈[n] ROB n s.t. (x, p, z) ∈ P ROB , x ∈ {0, 1} with P ROB  
   
  ⎧  
   
  Ax ≤ b ⎪  
   
  ⎨  
   
  = (x, p, z) pi + z ≥ cˆi xi  
   
  ⎪ ⎩  
   
  x ∈ [0, 1]n , p ∈ Rn≥0 , z ∈ R≥0  
   
  ∀i ∈ [n]  
   
  ⎫ ⎪ ⎬ ⎪ ⎭  
   
  .  
   
  Unfortunately, the formulation P ROB is quite weak, often leading to much higher computation times for solving ROB compared to NOM. In fact, the relative integrality gap of the formulation P ROB may be arbitrarily large, even if the integrality gap of the corresponding nominal problem is zero. This is shown in the following example from [7]. Example the easy problem of  selecting the cheapest of n elements  1. Consider  n . The integrality gap is zero for all c x | x = 1, x ∈ {0, 1} min i∈[n] i i i∈[n] i n c ∈ R . However, if we consider an instance of the uncertain counterpart ROB with c ≡ 0, cˆ ≡ 1, and Γ = 1  
   
   ⎫ ⎧  
   
  ⎪ ⎪ xi = 1  
   
  ⎪ ⎪ ⎪ ⎪ ⎬ ⎨   
   
  i∈[n] pi  
   
  min z +  
   
  pi + z ≥ xi ⎪ ∀i ∈ [n]⎪ ⎪ ⎪ i∈[n]  
   
  ⎪ ⎪ ⎭ ⎩  
   
  x ∈ {0, 1}n , p ∈ Rn , z ∈ R ≥0  
   
  ≥0  
   
  60  
   
  C. B¨ using et al.  
   
    then (x, p, z) = n1 , . . . , n1 , 0, . . . , 0, n1 is the unique optimal fractional solution of value n1 , while the objective value of an optimal integer solution is 1. Hence, 1 = n, and thus unbounded. the integrality gap is 1/n The above example shows that optimal continuous solutions for ROB tend to be highly fractional, as small values of xi allow for covering all right-hand sides cˆi xi in the constraints pi + z ≥ cˆi xi with a small value of z, while choosing p ≡ 0. On the one hand, such solutions are exactly what we aim for when striving for robustness, as we distribute the risk as much as possible. On the other hand, highly fractional optimal solutions for the linear relaxation imply the need for much branching, and thus a high computational eﬀort when solving ROB. Bertsimas et al. [4] as well as Fischetti and Monaci [9] tested the practical performance of the compact reformulation P ROB compared to a separation approach using an alternative formulation with exponentially many inequalities, each one modeling a scenario from the uncertainty set. Unfortunately, the alternative formulation is, despite its size, as weak as P ROB and performs worse for robust integer problems (but better for continuous problems) [4,9]. Joung and Park [16] propose cuts that dominate the classic scenario inequalities and can be separated by considering the robustness term as a submodular function and greedily solving a maximization problem over the corresponding polymatroid. Atamt¨ urk [3] addresses this issue by proposing four diﬀerent strong formulations. The strongest of these preserves the integrality gap of the nominal problem, but all four formulations are very large and hence, are outperformed by P ROB [7]. The weak relaxation can be avoided by tentatively ﬁxing the variable z to diﬀerent values, resulting in a series of nominal problems NOM to be solved + 1 nominal instead [2,5,19]. Lee and Kwon [17] showed that at most n−Γ 2 problems have to be solved. However, the computational eﬀort is usually still higher compared to solving ROB directly if n is large [7]. Hansknecht et al. [14] improve on this with their divide & conquer approach, in which one prunes many non-optimal values for z. In [7], non-optimal values for z are pruned even more eﬃciently by exploiting structural insights and strong linearizations derived from the following bilinear formulation  
   
  ⎧ ⎫  
   
  Ax ≤ b ⎪ ⎪  
   
  ⎨ ⎬  
   
  BIL ∀i ∈ [n] . P = (x, p, z) pi + xi z ≥ cˆi xi  
   
  ⎪ ⎪ ⎩ ⎭  
   
  x ∈ [0, 1]n , p ∈ Rn≥0 , z ∈ R≥0 This bilinear formulation strengthens the robustness constraints pi + z ≥ cˆi xi by multiplying z with xi , which is valid due to xi ∈ {0, 1}. While the bilinearity is rather hindering for practical purposes, P BIL is theoretically very strong. In fact, there exists no polyhedral formulation P for ROB with P  P BIL . Contribution. In this paper, we use the bilinear formulation P BIL as a foundation for the new class of recycled inequalities. To obtain these, we combine the strength of the bilinear inequalities with the structural properties provided by inequalities for the nominal problem NOM. By doing so, we can use inequalities for NOM  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  61  
   
  a second time to improve the formulation P ROB . We show that in many cases they even deﬁne facets of the convex hull of integer-feasible solutions  
   
   n  . C ROB = conv (x, p, z) ∈ P ROB x ∈ {0, 1} A preliminary computational study reveals that separating recycled inequalities can lead to a drastic improvement of both integrality gap and solving times. First experiments with adapted MIPLIB [12] instances (to be presented in the journal version) conﬁrm these results for a broad set of robust problems. All implemented algorithms and generated test instances are published together with a package of algorithms for solving robust combinatorial optimization problems [10] and benchmark instances [11] for those very problems. Outline. In Sect. 2, we show how to derive recycled inequalities from valid inequalities for NOM. In Sect. 3, we characterize valid inequalities for which the respective recycled inequality is facet-deﬁning. We also provide examples indicating that this applies for many well-known valid inequalities for classical optimization problems. In Sect. 4, we test recycled inequalities in a computational study, highlighting their practical value.  
   
  2  
   
  Recycling Valid Inequalities  
   
  As already mentioned, the bilinear inequalities pi + xi z ≥ cˆi xi play a crucial role for our recycled inequalities. To understand their strength intuitively, we recall our observations from Example 1. There, we noticed that choosing fractional values for xi is tempting, as we are then able to meet the inequalities pi +z ≥ cˆi xi with a small value of z and p ≡ 0. However, this advantage vanishes for the bilinear inequalities pi + xi z ≥ cˆi xi , as we always have z ≥ cˆi for xi = 0 and pi = 0. To make use of this in practice, it would be beneﬁcial to carry over the strength of the bilinear inequalities to a linear formulation. Multiplying linear inequalities with variables as an intermediate step in order to achieve a stronger linear formulation is not a new approach. For the Reformulation-Linearization-Technique by Sherali and Adams [20], one multiplies constraints with variables and linearizes the resulting products afterwards via substitution with auxiliary variables. Our approach is diﬀerent in the sense that we don’t directly linearize the bilinear inequalities, and thus don’t create auxiliary variables. Instead, we combine several of the bilinear inequalities in order to estimate the non-linear terms against a linear term, using a valid inequality for the corresponding nominal problem. From now on, let n  
   
  C NOM = conv ({x ∈ {0, 1} |Ax ≤ b}) be the convex hull of all integer nominal solutions. Then we combine the bilinear inequalities and valid inequalities for C NOM as follows.  
   
  62  
   
  C. B¨ using et al.  
   
   Theorem 1. Let i∈[n] πi xi ≤ π0 be a valid inequality for C NOM with π ≥ 0. Then the inequality   π0 z + πi p i ≥ πi cˆi xi (1) i∈[n]  
   
  is valid for C  
   
  ROB  
   
  i∈[n]  
   
  .  
   
  Proof. Summing the bilinear constraints pi + xi z ≥ cˆi xi , each with a factor of πi , we obtain    πi p i + πi xi z ≥ πi cˆi xi , i∈[n]  
   
  i∈[n]  
   
  i∈[n]  
   
  whichis a valid inequality for C due to π ≥ 0. Now, since z ≥ 0 holds, we  
   
  have i∈[n] πi xi z ≤ π0 z, which proves the statement.  As we reuse the valid inequality i∈[n] πi xi ≤ π0 to strengthen the formula tion P ROB , we call (1) the recycled inequality of i∈[n] πi xi ≤ π0 . In accordance  with the requirements of Theorem 1, we call i∈[n] πi xi ≤ π0 recyclable if it is valid for C NOM and π ≥ 0. Note that we could also derive the concept of recycled inequalities on the basis of the even stronger bilinear inequalities xi (pi + z) ≥ cˆi xi , resulting from multiplying both pi and z with xi . However, after  summing the bilinear inequalities with factors πi , this would yield the term i∈[n] πi xi pi , which we can only  estimate against i∈[n] πi pi , yielding the same result as above. To get a better understanding for recycled inequalities, let us recognize how they compare to the bilinear inequalities over the course of their construction. First, note that the sum of the bilinear inequalities is weaker than the bilinear inequalities themselves. Hence, when separating a recycled inequality to cut-oﬀ a fractional solution (˜ x, p˜, z˜) ∈ P NOM , the inequality to be recycled should only xi z˜ ≥ cˆi x ˜i support indices i ∈ [n] with πi > 0 for which the bilinear inequality p˜i +˜ is violated  or tight. A second potential weakening occurs  when applying the estimation i∈[n] πi xi z ≤ π0 z. This implies that recycling i∈[n] πi xi ≤ π0 is especially interesting if it is binding for x ˜.  Revisit Example 1, where we can recycle the valid inequality i∈[n] xi ≤ 1  implied by the constraint i∈[n] xi = 1. The corresponding recycled inequality    z + i∈[n] pi ≥ i∈[n] xi yields z + i∈[n] pi ≥ 1, and thus the optimal objective value of the linear relaxation is now equal to the optimal integer objective value. This intuitively highlights the strength of the recycled inequalities in the case where both properties, a binding recyclable valid inequality and the violation of supported bilinear inequalities, coincide. ROB  
   
  3  
   
  Facet-Defining Recycled Inequalities  
   
  In this section, we show that recycled inequalities often deﬁne facets of the convex hull of the robust problem C ROB . To this end, we ﬁrst determine the dimension of C ROB and assume for the sake of simplicity that the sets of solutions to our problems are non-empty.  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  63  
   
      Lemma 1. We have dim C ROB = dim C NOM + n + 1. Proof. For a polytope P ⊆ Rn , the number n − dim (P ) equals the maximumnumber of linearly independent equations that are met by all x ∈ P . Let i∈[n] (ωi xi + ωn+i pi ) + ω2n+1 z = ω0 be an equation that is satisﬁed by all be raised arbitrarily and C ROB = ∅, we have (x, p, z) ∈ C ROB . Since p and z can  ωn+1 = · · · = ω2n+1 = 0 and thus i∈[n] ωi xi = ω0 . Hence, the equations that are met by all (x, p, z) ∈ C ROB are exactly the equations that are met by all x ∈ C NOM , which implies        dim C ROB = 2n + 1 − n − dim C NOM = dim C NOM + n + 1.  
   
  Knowing the dimension of C ROB , we are now able to study  facet-deﬁning recycled inequalities. For this, we only consider inequalities i∈[n] πi xi ≤ π0 consisting of variables with uncertain objective coeﬃcients, i.e., we have πi = 0 for all i ∈ [n] with cˆi = 0. We call inequalities with this property uncertaintyexclusive inequalities. Note that these are the only interesting inequalities for recycling, because we can always drop variables xi with cˆi = 0. This strengthens the corresponding recycled inequality by removing πi pi from the left-hand side, while the right-hand side doesn’t change due to πi cˆi xi = 0. The following theorem characterizes exactly under which conditions recyclable, uncertaintyexclusive inequalities i∈[n] πi x ≤ π0 yield facet-deﬁning recycled inequalities,  
   
      
   
  based on the face F (π) = x ∈ C NOM i∈[n] πi x = π0 . The statement may seem very technical at ﬁrst glance, but we will see afterwards that it is quite powerful and has some surprising implications.  Theorem 2. Let i∈[n] πi xi ≤ π0 be a recyclable, uncertainty-exclusive inequality and ej ∈ Rn+1 be the unit-vector for j ∈ S = {i ∈ [n]|πi = 0}. Then the recyROB exist vectors cled inequality (1) is facet-defining for if and  only  j C  if there  n−|S|   1 n−|S|  
   
  ˜1 , 1 , . . . , x ⊆ F (π) such that e j ∈ S ∪ x ˜ ˜ , 1 are x ˜ ,...,x linearly independent. Proof. First, note that the face of the recycled inequality is not equal to C ROB , since p and z can be raised arbitrarily.    Thus, it is facet-deﬁning if and only if there exist dim C ROB = dim C NOM + n + 1 aﬃnely independent vectors (x, p, z) ∈ C ROB that satisfy it with equality.   Regardless of π, there are dim C NOM + 1 + |S|   aﬃnely independent NOM ROB ) ⊆ (x, p, z) ∈ C satisfying (1) with equality. For this, let x0 , . . . , xdim(C  j  NOM j C be aﬃnely   NOM independent. j We choose x , cˆ  x , 0 for each j ∈ 0, . . . , dim C , where cˆ  x refers to the component-wise multiplication,     i.e., cˆ  xj i = cˆi xji . By deﬁnition, xj , cˆ  xj , 0 is within C ROB and satisﬁes   (1) with equality. Additionally, we choose x0 , cˆ  x0 + ej , 0 for each j ∈ S. Here, ej ∈ Rn with some abuse of notation. Again, this vector is within C ROB and satisﬁes (1) with equality due to πj = 0.  
   
  64  
   
  C. B¨ using et al.  
   
  Now, the recycled inequality (1) is facet-deﬁning if and only if there exists a suitable extension of the vectors above, consisting of additional vectors x ˜j , p˜j , z˜j j∈[n−|S|] that satisfy (1) with equality and are aﬃnely independent to the vectors above. Such vectors need to satisfy the property  j  ˜i for all i ∈ [n] \ S and j ∈ [n − |S|] , (2) p˜ji = cˆi − z˜j x as otherwise π0 z˜j +  
   
    
   
  πi p˜ji > π0 z˜j −  
   
  i∈[n]  
   
   i∈[n]  
   
  πi z˜j x ˜ji +  
   
   i∈[n]  
   
  πi cˆi x ˜ji ≥  
   
    
   
  πi cˆi x ˜ji .  
   
  i∈[n]  
   
   One can show that any vectors x ˜j , p˜j , z˜j j∈[n−|S|] with property (2) are   
   
  aﬃnely if  and only if z˜j > 0 for all j ∈ [n − |S|]  
   
    to1 the  ones above  j independent n−|S|  
   
  ˜ , 1 , . . . , x ˜ , 1 are linearly independent. To show and e j ∈ S ∪  x this, one subtracts x0 , cˆ  x0 , 0 from all other vectors, yielding vectors that are linearly independent if and only if the desired aﬃne independency holds. Writing the vectors in a matrix and performing basic column and row transformations implies the result. We omit this step here  j due to space limitations. ˜i , we also have With z˜j > 0 and πi p˜ji = πi cˆi − z˜j x     πi p˜ji = πi cˆi x ˜ji ⇔ π0 z˜j = πi z˜j x ˜ji ⇔ π0 = πi x ˜ji , π0 z˜j + i∈[n]  
   
  i∈[n]  
   
  i∈[n]  
   
  i∈[n]  
   
   1   j j j and thus x ˜ ,...,x ˜ , p˜ , z˜ j∈[n−|S|] fulﬁll the ˜n−|S| ⊆ F (π) if and only if x recycled inequality (1) with equality. This shows the necessity of the condition.   1 Now, let x ˜ ,...,x ˜n−|S| ⊆ F (π) be as speciﬁed in the theorem. To show suﬃciency of the condition, we only need to construct vectors x ˜j , p˜j , z˜j j∈[n−|S|]  
   
  j satisfying  (2) and z˜ > 0 for all j ∈ [n − |S|]. Forj each j ∈ [n − |S|], wej  jproperty j min ci |i ∈ [n] , cˆi > 0} and p˜i = max {0, cˆi − z˜} x ˜i choose x ˜ , p˜ , z˜ with  jz˜ =  {ˆ for all  i ∈ [n]. Then x ˜ , p˜j , z˜ is by deﬁnition within C ROB and satisﬁes z˜ > 0. Since i∈[n] πi xi ≤ π0 is uncertainty-exclusive, we have πi = 0 for all cˆi < z˜,  j j  ci − z˜) x ˜ji for all i ∈ [n] \ S. Therefore, x ˜ , p˜ , z˜ also satisﬁes and thus p˜ji = (ˆ property (2), which completes the proof.  
   
  A straightforward, but powerful implication of Theorem 2 is that recycling a uncertainty-exclusive inequality yields always a facet-deﬁning inequality if dim (F (π)) = n − 1 holds.  This is because there already exist n aﬃnely independent vectors satisfying i∈[n] πi x = π0 , which implies that there exist appro  − 1 holds if F (π) priate vectors x1 , . . . , xn−|S| . Note that dim (F (π)) = n  is either a facet of a full-dimensional polytope C NOM or if i∈[n] πi x ≤ π0 is   actually an equation with F (π) = C NOM and dim C NOM = n − 1. This is summarized in the following corollary.  Corollary 1. Let i∈[n] πi xi ≤ π0 be a recyclable, uncertainty-exclusive inequality. The recycled inequality (1) is facet-defining for C ROB if one of the following holds:  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  65  
   
  – C NOM and F (π) is a facet of C NOM ,   is full-dimensional – dim C NOM = n − 1 and F (π) = C NOM . Contrary to ﬁrst intuition, it is also possible to obtain facet-deﬁning inequalities by recycling weaker inequalities that are neither facet-deﬁning nor equations. This is because Theorem 2 suggests that an inequality deﬁning a low-dimensional face can also be recycled to a facet-deﬁning inequality if we have πi = 0 for many i ∈ [n]. For example, consider an independent set problem on a graph  with vertices V = [n] and let Q ⊆ Vbe a clique. Then the clique inequality i∈Q xi ≤ 1 dominates all inequalities i∈Q xi ≤ 1 with Q  Q and is facet-deﬁning if and only if Q is a maximal cliquewith respect to inclusion [8]. However, the recycled  inequality z + i∈Q pi ≥ i∈Q cˆi xi is facet-deﬁning for all cliques Q ⊆ Q.    
   
    1 This is because the set x ˜ ,...,x ˜n−|S| = ej j ∈ Q meets the criteria of Theorem 2 with S = V \ Q . Other examples include odd-hole inequalities for the independent set problem [18] and minimal cover inequalities for the knapsack problem [8]. These are in general not facet-deﬁning for their respective polytope, but yield facet-deﬁning recycled inequality for the robust counterpart. All these examples are covered by the following corollary. NOM Corollary 2. Let C NOM be a full-dimensional polyhedron such that x ∈ C   NOM and 0 ≤ x ≤ x implies x ∈ C . Furthermore, let i∈[n] πi xi ≤ π0 be a recyclable, uncertainty-exclusive inequality. The recycled inequality (1) is facet defining for C ROB if i∈[n] πi xi ≤ π0 is facet-defining for the restricted solution  
   
    space x ∈ C NOM xi = 0 for all πi = 0 .  
   
  Note that the additional requirements on C NOM imply that the restricted solutionspace is of dimension n − |S|, which guarantees that we ﬁnd appropriate  ˜n−|S| . vectors x ˜1 , . . . , x One now might raise the question whether inequalities recycled from dominated inequalities are actually of practical interest or whether they do not really matter due to the special structure of the objective function. The following example demonstrates that it can be beneﬁcial to weaken an inequality before it is recycled. Example 2. Consider the robust problem   
   
  ⎧  
   
  3x5 + xi ≤ 3 ⎪  
   
  ⎪ ⎪  
   
  ⎨  i∈[4]  
   
  min 2z + −xi + pi  
   
  z + pi ≥ xi ⎪ ⎪ i∈[5]  
   
  ⎪ ⎩  
   
  x ∈ {0, 1}5 , p ∈ R5 , z ∈ R ≥0 ≥0  
   
  ⎫ ⎪ ⎪ ⎪ ⎬ ∀i ∈ [5]⎪ ⎪ ⎪ ⎭  
   
  .  
   
    Choosing x = 34 , . . . , 34 , 0 , p ≡ 0, and z = 34 yields an optimal  solution for the linear relaxation of value − 23 . Recycling constraint 3x5 + i∈[4] xi ≤ 3 yields   3z + 3p5 + i∈[4] pi ≥ 3x5 + i∈[4] xi . After adding the recycled inequality,     an optimal choice is given by x = 34 , . . . , 34 , 0 , p = 0, . . . , 0, 14 , and z = 34 ,  
   
  66  
   
  C. B¨ using et al.  
   
  with an objective value of − 45 . Note that we now choose p5 > 0 even though x5 = 0 holds. This is because raising p5 has the same eﬀect on the recycled inequality as raising z, but is cheaper in the objective function. Since the bilinear inequality p5 + x5 z ≥ cˆ5 x5 now has a slack of 14 , our observation from the last section suggests that it may be beneﬁcial to drop x5 from the valid  inequality for recycling. In fact, when recycling the dominated inequality i∈[4] xi ≤ 3   instead, we obtain 3z + i∈[4] pi ≥ i∈[4] xi and an optimal choice is now given by x = (1, 1, 1, 0, 0), p ≡ 0, and z = 1, which yields an objective value of −1. We can beneﬁt from this insight on dominated inequalities when recycling within a separation procedure to cut-oﬀ a fractional x, p˜, z˜) ∈ P ROB .  solution (˜ ci x ˜i − p˜i ) − π0 z˜. In The violation of a recycled inequality is given by i∈[n] πi (ˆ order to maximize the violation, we can drop all variables xi from the recyclable  ˜i − p˜i < 0. We use this in our computational inequality i∈[n] πi xi ≤ π0 with cˆi x study in the next section, where we show that recycled inequalities are not only interesting from a theoretical point of view, but also computationally relevant.  
   
  4  
   
  Computational Study  
   
  Due to space limitations, we present a preliminary computational study, in which we test recycled inequalities for robust counterparts of two classical combinatorial problems, namely the weighted independent set problem and the weighted bipartite matching problem. In the following, we compare (i) computation times to asses an algorithm’s performance and (ii) integrality gaps to evaluate the strength of a formulation. Since displaying these for all algorithms and instances is impractical, we give aggregated values using the shifted geometric  mean, as proposed by Achter1/k k − s for values v1 , . . . , vk ∈ R≥0 berg [1]. This is deﬁned as Πi=1 (vi + s) and a shifting parameter s ∈ R≥0 . We always use s = 1 second for aggregating computation times and s = 1% for aggregating integrality gaps. Furthermore, we use a time limit of 3600 seconds for each algorithm and instance and set the computation time to this value if an algorithm reaches the limit. Note that this is a bias in favor of algorithms that reach the time limit for many instances. All experiments have been implemented in Java 11 and are performed on a R CoreTM i7-5930K CPU @ 3.50GHz, single core of a Linux machine with an Intel with 4 GB RAM reserved for each calculation. All LPs and MILPs are solved using Gurobi version 9.5.0 [13] in single thread mode and all other settings at default, if not stated otherwise. All implemented algorithms [10] and generated test instances [11] are freely available online. 4.1  
   
  Robust Independent Set  
   
  To show the eﬀect of recycling a class of well-known valid inequalities in a separation procedure, we consider the robust maximum weighted independent set problem on a graph with nodes V and edges E  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  max  
   
  ⎧ ⎪ ⎨ ⎪ ⎩v∈V  

  xv + xw ≤ 1   
   
  cv xv − Γ z − pv pv + z ≥ cˆv xv  
   
  v∈V  
   
  x ∈ {0, 1}V , p ∈ RV , z ∈ R ≥0 ≥0  
   
  67  
   
  ⎫ ∀ {v, w} ∈ E ⎪ ⎬ ∀v ∈ V  
   
  ⎪ ⎭  
   
  .  
   
   As seen in Sect. 3, recycling a clique inequality v∈Q xv ≤ 1 yields a facetdeﬁning inequality for all cliques Q ⊆ V . We compare the separation of recycled clique inequalities in the root node of the branching tree against the robust default formulation P ROB , which solely uses the constraints pi + z ≥ cˆi xi . For this, we use Gurobi’s callback to add the recycled inequalities as user cuts [13]. Every time Gurobi invokes the callback in the root node and reports a current ROB optimal fractional solution (˜ x, p˜, z˜) ∈ P to compute cliques Q ⊆ V  , we try for which the recycled inequality z + v∈Q pv ≥ v∈Q cˆv xv is violated. Since ˜v − p˜v > 0 holds, a node v ∈ V positively contributes to the violation if cˆv x we essentially need to solve a maximum weighted clique problem with weights ˜v − p˜v . To separate many recycled inequalities at once, we extend each node cˆv x ˜v − p˜v > 0 greedily to a clique Qv ⊆ V with v ∈ Qv . For v ∈ V with cˆv x this, we start with Qv = {v} and then iteratively add v  ∈ N (Qv ) such that ˜v − p˜v is maximal and non-negative. Finally, we return the corresponding cˆv x recycled inequality to Gurobi as a user cut if its violation is positive. As a basis for our test instances, we use the graphs of the second DIMACS implementation challenge on the clique problem [15]. Of the 66 DIMACS graphs, we choose the 46 graphs that have at most 500 nodes, as otherwise the nominal problem is already very hard. For each node v ∈ V , we generate independent and uniformly distributed values cv ∈ {900, . . . , 1000} and correlated deviations cˆv = ξv cv , with ξv ∈ [0.45, 0.55] being an independent and uniformly distributed random variable. Since robust problems tend to be hard for Γ being somewhere around half the number of variables with xi = 1 [7], we greedily compute an  
   
  independent set S ⊆ V and deﬁne Γ = |S| 2 . For this, we start with S = ∅ and then iteratively add nodes v ∈ V \ N [S] such that |V \ N [S ∪ {v}]| is maximal, with N [S  ] being the closed neighborhood of S  . Using this procedure, we randomly generate ﬁve robust independent set problems for each of the 46 DIMACS graphs, leaving us with 230 robust instances. We show computational results for the robust default formulation P ROB and the recycling of clique inequalities in Table 1. Here, we see that the shifted geometric mean of the integrality gaps is reduced absolutely by 220% from 1427.59% to 1207.59% when using recycled clique inequalities. For computing these gaps, we use the dual bound obtained by heuristically separating recycled clique inequalities for subsequent linear relaxations until no violated cuts are found. While the absolute reduction of the integrality gap is quite impressive, the relative reduction does not adequately reﬂect the strength of the recycled inequalities. This is due to the large integrality gap of the nominal problem, which constitutes a major part of the total gap. Therefore, we also test a stronger formulation for the nominal problem, in which we replace every  
   
  68  
   
  C. B¨ using et al.  
   
  Table 1. Computational results for 230 instances of the robust maximum weighted independent set problem. separate recycled robust default formulation clique inequalities nominal formulation Gurobi’s cuts tilim time int. gap tilim time int. gap edge  
   
  enabled disabled  
   
  24 40  
   
  clique  
   
  enabled disabled  
   
  61 78  
   
  26.15 1427.59% 51.01 133.62 187.21  
   
  135.30%  
   
  22 20 63 54  
   
  31.03 1207.59% 20.34 141.97 89.24  
   
  56.25%  
   
   constraint xv + xw ≤ 1 with v∈Q xv ≤ 1 for a clique Q ⊆ V with {v, w} ⊆ Q. This clique formulation has a much tighter linear relaxation compared to the previous edge formulation, and thus reduces the contribution of the nominal problem to the integrality gap. Indeed, Table 1 shows that separating recycled clique inequalities reduces the integrality gap by more than one half when using the clique formulation. Apart from this observation, the clique formulation is not of practical interest, as the solver performs better on the edge formulation. Using the edge formulation, we are able to solve 2 more instances when recycling clique inequalities, but observe an increase of the computation time. This seems to be due to some interference with Gurobi’s own cutting planes. When disabling Gurobi’s cutting planes, recycling is much better than using the default formulation. In fact, disabling Gurobi’s cuts and using recycled clique inequalities is the overall best performing approach, solving the most instances in the least amount of computation time. This is true for both nominal formulations and indicates that, given a careful implementation, recycling clique inequalities yields a signiﬁcant speedup compared to the robust default formulation. 4.2  
   
  Robust Bipartite Matching  
   
  We now consider the robust maximum weighted bipartite matching problem  
   
   ⎫ ⎧  
   
  ⎪ ⎪ x ≤ 1 ∀v ∈ V  
   
  ⎪ ⎪ e ⎪ ⎪ ⎪ ⎪ ⎬ ⎨   
   
  e∈δ(v)  
   
  ce xe − Γ z − pe  
   
  max ∀e ∈ E ⎪ ⎪  
   
  pe + z ≥ cˆe xe ⎪ ⎪ e∈E ⎪ ⎪e∈E  
   
  ⎪ ⎪ E ⎭ ⎩ E  
   
  x ∈ {0, 1} , p ∈ R≥0 , z ∈ R≥0 on a bipartite graph with nodes V and edges E. In contrast to the independent set problem, for which the standard nominal formulation is quite weak, we have P NOM = C NOM for the bipartite matching problem [8]. That is, the integrality gap of the robust counterpart is only due to the robust substructure, which allows us to test the strength of recycled inequalities to their limit. We randomly generate instances by ﬁrst dividing  n  a given set  of nodes V = [n]  n  and W = + 1, . . . , n . Afterwards, we into two partitions U = 2 2  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  69  
   
  Table 2. Computational results for the robust maximum weighted bipartite matching problem. recycle constraints robust default formulation recycle constraints and separate dominated nodes Gurobi’s cuts tilim time int. gap tilim time int. gap tilim time int. gap 50  
   
  enabled disabled  
   
  0 10  
   
  0.78 19.532% 3600.00  
   
  0 0  
   
  0.53 0.326% 0 0.25 0  
   
  0.64 0.319% 0.28  
   
  100  
   
  enabled disabled  
   
  5 10  
   
  603.37 22.82% 3600.00  
   
  0 0  
   
  4.76 0.319% 0 14.83 0  
   
  5.59 0.316% 15.62  
   
  150  
   
  enabled disabled  
   
  4 10  
   
  1405.15 23.66% 3600.00  
   
  0 6  
   
  122.11 0.269% 0 1809.62 7  
   
  158.81 0.265% 1873.43  
   
  sample for each node u ∈ U a random number φu ∈ [0, 1], modeling the probability with which an edge incident to u exists. Then for every w ∈ W , we add the edge {u, w} with probability φu . Analogously to the independent set problem, every weight is a random number ce ∈ {900, . . . , 1000} and the correlated deviations are cˆe = ξe ce  with ξe ∈ [0.45, 0.55]. Finally, as the number of edges in a solution will most likely be near to n2 , we set Γ = n4 . We use this procedure to generate ten instances for diﬀerent numbers of nodes n ∈ {50, 100, 150}. Table 2 shows computational results for the robust default formulation and two diﬀerent approaches  for using recycled inequalities. The ﬁrst approach recycles all constraints e∈δ(v) xe ≤ 1 for v ∈ V . The second approach additionally separates violated recycled inequalities corresponding to dominated inequalities  x ≤ 1 with E  ⊆ δ (v) for v ∈ V in the root node of the branching tree.  e e∈E It is evident that recycling inequalities is signiﬁcantly better than solely using the default formulation. We observe a signiﬁcant strengthening of the formulation, leading to a reduction of the integrality gap to nearly one-hundredth for n = 150 nodes. This strength also translates to a higher number of instances solved and much lower computation times. For n = 150, recycling constraints leads to a speedup of more than 1000% with Gurobi’s cuts enabled. The reduced integrality gap obtained by  recycling dominated constraints compared to the sole recycling of constraints e∈δ(v) xe ≤ 1 shows that recycling dominated inequalities can improve the strength of the linear relaxation in practice. However, as the recycled constraints already perform very well for these instances, the improvement in the linear relaxation is very small. In fact, the minor strengthening of the linear relaxation cannot compensate for the computational load imposed by the additional inequalities, which leads to higher computation times. In any case, recycling valid inequalities yields a signiﬁcant speed-up compared to the default formulation. First experiments with adapted MIPLIB [12] instances, which will be part of the full paper, conﬁrm that this is also true for a broad set of diﬀerent robust problems. Here, we even observe that recycling dominated inequalities can have a strong positive eﬀect on the strength of the linear relaxation.  
   
  70  
   
  5  
   
  C. B¨ using et al.  
   
  Conclusion  
   
  In this paper, we proposed and analyzed recycled inequalities for robust combinatorial optimization problems with budget uncertainty. These can be derived in linear time from valid inequalities for the nominal problem, which gives the possibility to easily reuse model constraints and well known classical valid inequalities in order to strengthen the linear relaxation of the robust problem. We highlighted the theoretical strength of recycled inequalities by proving that they often deﬁne facets of the convex hull of the robust problem, even when the underlying valid inequality is dominated. Our preliminary computational experiments reveal that recycled inequalities are not only interesting from a theoretical point of view, but can also yield a substantial speed-up in the optimization process. They thus extend the boundaries of computational tractability for one of the most popular approach for integrating uncertainties into optimization problems. Acknowledgements. This work was partially supported by the German Federal Ministry of Education and Research (grants no. 05M16PAA) within the project “HealthFaCT - Health: Facility Location, Covering and Transport”, the Freigeist-Fellowship of the Volkswagen Stiftung, and the German research council (DFG) Research Training Group 2236 UnRAVeL. Code Availability. All tested algorithms have been implemented in Java and are available on GitHub, see [10]. Data Availability. All test instances used in our computational study are published and available for download, sharing, and reuse, see [11].  
   
  References 1. Achterberg, T.: Constraint integer programming. Ph.D. Thesis, Technische Universitat Berlin (2007) ´ 2. Alvarez-Miranda, E., Ljubi´c, I., Toth, P.: A note on the Bertsimas & Sim algorithm for robust combinatorial optimization problems. 4OR 11(4), 349–360 (2013) 3. Atamt¨ urk, A.: Strong formulations of robust mixed 0–1 programming. Math. Program. 108(2–3), 235–250 (2006) 4. Bertsimas, D., Dunning, I., Lubin, M.: Reformulation versus cutting-planes for robust optimization. CMS 13(2), 195–217 (2016) 5. Bertsimas, D., Sim, M.: Robust discrete optimization and network flows. Math. Program. 98(1–3), 49–71 (2003) 6. Bertsimas, D., Sim, M.: The price of robustness. Oper. Res. 52(1), 35–53 (2004) 7. B¨ using, C., Gersing, T., Koster, A.M.: A branch and bound algorithm for robust binary optimization with budget uncertainty. Math. Program. Comput. (2023). https://doi.org/10.1007/s12532-022-00232-2 8. Conforti, M., Cornu´ejols, G., Zambelli, G., et al.: Integer Programming, vol. 271. Springer, Cham (2014). https://doi.org/10.1007/978-3-319-11008-0 9. Fischetti, M., Monaci, M.: Cutting plane versus compact formulations for uncertain (integer) linear programs. Math. Program. Comput. 4(3), 239–273 (2012)  
   
  Recycling Inequalities for Robust Combinatorial Optimization  
   
  71  
   
  10. Gersing, T.: Algorithms for robust binary optimization, December 2022. https:// doi.org/10.5281/zenodo.7463371 11. Gersing, T., B¨ using, C., Koster, A.: Benchmark Instances for Robust Combinatorial Optimization with Budgeted Uncertainty, December 2022. https://doi.org/10. 5281/zenodo.7419028 12. Gleixner, A., et al.: MIPLIB 2017: data-driven compilation of the 6th mixed-integer programming library. Math. Program. Comput. 13(3), 443–490 (2021). https://doi. org/10.1007/s12532-020-00194-3 13. Gurobi Optimization, LLC: Gurobi optimizer reference manual, version 9.5 (2022). http://www.gurobi.com 14. Hansknecht, C., Richter, A., Stiller, S.: Fast robust shortest path computations. In: 18th Workshop on Algorithmic Approaches for Transportation Modelling, Optimization, and Systems (ATMOS 2018). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik (2018) 15. Johnson, D.S., Trick, M.A.: Cliques, coloring, and satisfiability: second DIMACS implementation challenge, 11–13 October 1993, vol. 26. American Mathematical Society (1996) 16. Joung, S., Park, S.: Robust mixed 0–1 programming and submodularity. INFORMS J. Optim. 3(2), 183–199 (2021). https://doi.org/10.1287/ijoo.2019.0042 17. Lee, T., Kwon, C.: A short note on the robust combinatorial optimization problems with cardinality constrained uncertainty. 4OR 12(4), 373–378 (2014) 18. Padberg, M.W.: On the facial structure of set packing polyhedra. Math. Program. 5(1), 199–215 (1973) 19. Park, K., Lee, K.: A note on robust combinatorial optimization problem. Manag. Sci. Financ. Eng. 13(1), 115–119 (2007) 20. Sherali, H.D., Adams, W.P.: A Reformulation-Linearization Technique for Solving Discrete and Continuous Nonconvex Problems, vol. 31. Springer, New York (2013). https://doi.org/10.1007/978-1-4757-4388-3  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes Jean Cardinal1 1  
   
  and Raphael Steiner2(B)  
   
  Universit´e Libre de Bruxelles (ULB), Brussels, Belgium [email protected]  2 ETH Zurich, Z¨ urich, Switzerland [email protected]   
   
  Abstract. We consider the computational problem of ﬁnding short paths in the skeleton of the perfect matching polytope of a bipartite graph. We prove that unless P = NP, there is no polynomial-time algorithm that computes a path of constant length between two vertices at distance two of the perfect matching polytope of a bipartite graph. Conditioned on P = NP, this disproves a conjecture by Ito, Kakimura, Kamiyama, Kobayashi and Okamoto [SIAM Journal on Discrete Mathematics, 36(2), pp. 1102-1123 (2022)]. Assuming the Exponential Time Hypothesis we prove the stronger result that there exists   no polynomialtime algorithm computing a path of length at most 14 − o(1) logloglogNN between two vertices at distance two of the perfect matching polytope of an N -vertex bipartite graph. These results remain true if the bipartite graph is restricted to be of maximum degree three. The above has the following interesting implication for the performance of pivot rules for the simplex algorithm on simply-structured combinatorial polytopes: If P = NP, then for every simplex pivot rule executable in polynomial time and every constant k ∈ N there exists a linear program on a perfect matching polytope and a starting vertex of the polytope such that the optimal solution can be reached using only two monotone non-degenerate steps from the starting vertex, yet the pivot rule will require at least k non-degenerate steps to reach the optimal solution. This result remains true in the more general setting of pivot rules for so-called circuit-augmentation algorithms. Keywords: Perfect matching polytopes · Simplex method · Pivot rules · Circuit augmentations · Combinatorial reconﬁguration  
   
  1  
   
  Introduction  
   
  The history of linear programming is intimately intertwined with that of Dantzig’s simplex algorithm. While the simplex and its many variants are among R. Steiner–Supported by an ETH Postdoctoral Fellowship. A full version of this article can be found at https://arxiv.org/abs/2210.14608. Proofs of statements marked with  are deferred to the full version. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 72–86, 2023. https://doi.org/10.1007/978-3-031-32726-1_6  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  73  
   
  the most studied algorithms ever, a number of fundamental questions remain open. It is not known, for instance, whether there exists a pivot rule that makes the simplex method run in strongly polynomial time. Since the publication of the ﬁrst examples of linear programs that make the original simplex algorithm run in exponential time, many alternative pivot rules have been proposed, fostering a tremendous amount of work in the past 75 years, both from the combinatorial and complexity-theoretic point of views. The simplex algorithm follows a monotone path on the skeleton of the polytope deﬁning the linear program. The following natural question was recently raised by De Loera, Kafer, and Sanit` a [16]: “Can one hope to ﬁnd a pivot rule that makes the simplex method use a shortest monotone path?”. As an answer, they proved that given an initial solution to a linear program, it is NP-hard to ﬁnd a (2−ε)-approximate shortest monotone path to an optimal solution. It implies that unless P = NP, no polynomial-time pivot rule for the simplex can be guaranteed to reach an optimal solution in a minimum number of (non-degenerate) steps. A similar result can also be deduced from two independent contributions, by Aichholzer, Cardinal, Huynh, Knauer, M¨ utze, Steiner, and Vogtenhuber [2] on the one hand, and by Ito, Kakimura, Kamiyama, Kobayashi, and Okamoto [29] on the other hand. They proved that the above result holds for perfect matching polytopes of planar and bipartite graphs, albeit with a slightly weaker inapproximability factor of 3/2 instead of 2. Ito et al. [29] conjecture that there exists a constant-factor approximation algorithm for the problem of ﬁnding a shortest path between two perfect matchings on the perfect matching polytope. Our main result is a disproof of this conjecture under the P = NP assumption: Strengthening the previous inapproximability results mentioned above, we show that unless P = NP no C-approximation for a shortest path between two vertices at distance 2 of a bipartite perfect matching polytope can be found in polynomial time, for any (arbitrarily large) choice of C > 0. We also give an even stronger inapproximability result under the Exponential Time Hypothesis (ETH). The latter states that the 3-SAT problem cannot be solved in worst-case subexponential time, and is one of the main computational assumptions of the ﬁne-grained complexity program [39]. As a consequence, there is not much hope of ﬁnding a pivot rule for the simplex algorithm yielding good approximations of the shortest path towards an optimal solution, even when the linear program is integer and its associated matrix totally unimodular. 1.1  
   
  Our Result  
   
  We consider the complexity of computing short paths on the 0/1 polytope associated with perfect matchings of a bipartite graph. Given a balanced bipartite graph G = (V, E), where V is partitioned into two equal-size independent sets A and B, we deﬁne the perfect matching polytope PG ⊆ RE of G as the convex hull of the 0/1 incidence vectors of perfect matchings of G.  
   
  74  
   
  J. Cardinal and R. Steiner  
   
  It is well-known (see e.g. Chapter 18 in [38]) that for bipartite graphs G, there is a nice halfspace representation of PG . An edge-vector (xe )e∈E ∈ RE is in PG if and only if the following hold.   
   
  xe = 1,  
   
  (∀v ∈ V )  
   
  (1)  
   
  xe ≥ 0,  
   
  (∀e ∈ E).  
   
  (2)  
   
  ev  
   
  The above is a compact encoding of PG , with a number of constraints and variables of size polynomial in G. The assumption that G is bipartite is crucial here: For non-bipartite G the polytope deﬁned by the above constraints has non-integral vertices and is thus not a representation of PG [38]. The matrix of this representation of a perfect matching polytope of a bipartite graph G is simply the vertex-edge-incidence matrix of G, which is totally unimodular. The problem of maximizing a linear functional wT x subject to constraints (1) and (2) corresponds  exactly to the problem of ﬁnding a perfect matching M of G whose weight e∈M we is maximal. Given that the simplex algorithm moves along the edges of a polytope, it is crucial for our considerations to understand adjacency of vertices on PG . The following result is well-known [13,30]. Lemma 1. For a bipartite graph G, two vertices of PG corresponding to two perfect matchings M1 and M2 are adjacent in the skeleton of PG if and only if the symmetric diﬀerence M1 ΔM2 is a cycle in G. This cycle is said to be alternating in both matchings, and one matching can be obtained from the other by ﬂipping this alternating cycle. In general, we will say that two perfect matchings are at distance at most k from each other on PG , for some positive integer k, if one can be obtained from the other by successively ﬂipping at most k alternating cycles.  
   
  Fig. 1. Two perfect matchings at distance two on the perfect matching polytope, but whose symmetric diﬀerence consists of an arbitrarily large number of even cycles.  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  75  
   
  Note that given any two perfect matchings M1 and M2 of a bipartite graph G, it is always the case that M1 ΔM2 is a collection of vertex-disjoint even cycles that are alternating in both matchings. The number of such cycles is therefore an upper bound on the distance between M1 and M2 on PG . Interestingly, this upper bound can be arbitrarily larger than the actual distance. Figure 1 shows a construction of a graph G with two matchings at distance two on PG , whose symmetric diﬀerence consists of an arbitrary number of cycles. Our main result is the following. Theorem 1. Let k ≥ 2 be any ﬁxed integer. Unless P = NP, there does not exist any polynomial-time algorithm solving the following problem: Input: A bipartite graph G of maximum degree 3 and a pair of perfect matchings M1 , M2 of G at distance at most 2 on the polytope PG . Output: A path from M1 to M2 in the skeleton of PG , of length at most k. More strongly, for every absolute constant δ > 0, unless the Exponential Time Hypothesis fails, no polynomial-time algorithm can solve the above problem when k is allowed to grow with the number N of vertices of G as 1  log N  k(N ) = 4 − δ log log N . A path on the perfect matching polytope of a bipartite graph G is said to be monotone with respect to some weight vector w = (we )e∈E ∈ RE on the edges of G if the perfect matchings along the path have monotonically increasing total weights. Given two perfect matchings M1 and M2 at distance two on the perfect matching polytope, one can assign weights to edges so that (i) the path of length two between them is strictly monotone, and (ii) M2 is the unique matching of maximal weight (this will be formally proven later in Lemma 4). This allows us to formulate our result as one about the hardness of reaching an optimal solution from a given feasible solution of a linear program on the perfect matching polytope. Corollary 1. Unless P = NP, there does not exist any polynomial-time constant-factor approximation algorithm for the following optimization problem: Input: A bipartite graph G = (V, E) of maximum degree 3, a weight function E → R+ , and a perfect matching M of G. Output: A shortest monotone path on PG from M to a maximum-weight perfect matching of G. Furthermore, assuming ETH, for an arbitrary but ﬁxed δ > 0 no polynomial time algorithm can achieve an approximation ratio of less than 18 − δ logloglogNN , where N := |V (G)|. This corollary can be further interpreted as a statement on the existence of a polynomial-time pivot rule that would make the simplex method use an approximately shortest monotone path to a solution. Any such pivot rule could be used as an approximation algorithm for the above problem, contradicting  
   
  76  
   
  J. Cardinal and R. Steiner  
   
  the computational hypotheses. While making this statement, it is important to point out that here (and throughout this paper) we always measure the number of non-degenerate steps during an execution of a pivot rule for the simplex algorithm, and not the natural alternative, which would be the number of all steps (including both degenerate and non-degenerate steps). A degenerate step in a simplex algorithm here means a step that changes the basis of active variables, but not the value of the current feasible solution. 1.2  
   
  Pivot Rules for Circuit-Augmentation Algorithms  
   
  Our work on distances in the skeleton of PG for bipartite graphs G was originally motivated by questions regarding so-called circuit moves (or circuit augmentations), that have been recently studied in linear programming [11,15,16] as well as in the context of relaxations of the Hirsch conjecture concerning the diameter of polytopes [10,32]. A circuit move extends the simplex-paradigm of moving along an incident edge of the constraint-polyhedron, by additionally allowing to move along certain non-edge directions, called circuits. Given a linear program, the circuits in a well-deﬁned sense represent all possible edge-directions that could occur after changing the right-hand side of the LP. The following is a formal deﬁnition. Definition 1 (cf. Definition 1 in [16]). Given a polyhedron of the form P = {x ∈ Rn |Ax = b, Bx ≤ d}, a circuit is a vector g ∈ Rn \ {0} such that 1. Ag = 0, and 2. Bg is inclusion-wise support-minimal in the collection {By|Ay = 0, y = 0}. Given an LP {max cT x|x ∈ P} for a polyhedron P, a current feasible solution x ∈ P and a circuit g with cT g > 0, a circuit move then consists of moving to a new feasible solution x = x + t∗ g, where t∗ ≥ 0 is maximal w.r.t. x + t∗ g ∈ P. Note that in general, an optimization algorithm based on a pivot rule for circuit moves may traverse several non-vertices of the polyhedron before reaching an optimal solution. Our interest in the perfect matching polytope for understanding the complexity of circuit-pivot algorithms came from the following statement (see the full version for a proof). Lemma 2 (). Let G be a bipartite graph. Then if x is a vertex of PG , and x = x is obtained from x by a circuit move, then x is also a vertex of PG and adjacent to x on the skeleton of PG . This lemma implies that any sequence of circuit moves, applied starting from a vertex of PG , will follow a monotone path on the skeleton of PG from vertex to vertex. Consequently, Corollary 1 also yields an inapproximability result for polynomial pivot rules for circuit augmentation, as follows.  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  77  
   
  Corollary 2. Unless P = NP, there does not exist a polynomial-time constantfactor approximation algorithm for the following problem. Input: A bipartite graph G of maximum degree 3, a vertex x ∈ PG and a linear objective function. Output: A shortest sequence of circuit moves on PG from x to an optimal solution. Assuming ETH, no algorithm can achieve an approximation   polynomial-time ratio of less than 18 − δ logloglogNN , where N := |V (G)| and δ > 0 is a constant. A related inapproximability result (but for the largest improvement of the objective function via a single circuit step) was obtained by Borgwardt, Brand, Feldmann and Kouteck´ y [9]. 1.3  
   
  Related Works  
   
  Our work relates to two main threads of research in combinatorics and computer science: one obviously related to the complexity of the simplex method and linear programming in general, and another more recent one, aiming at building a thorough understanding of the computational complexity of so-called combinatorial reconﬁguration problems. Complexity of the Simplex Method. In 1972, Klee and Minty showed that the original simplex method had an exponential worst-case behavior on what came to be known as Klee-Minty cubes [34]. Since then, many other variants have been shown to have exponential or superpolynomial lower bounds [4,7,19,24,31], although subexponential rules are known [26]. More dramatic complexity results have been obtained recently [1,20]. In particular, it was shown by Fearney and Savani [21] that Dantzig’s original simplex method can solve PSPACE-complete problems: Given an initial vertex, deciding whether some variable will ever be chosen by the algorithm to enter the basis is PSPACE-complete. The simplex method is also a key motivation for studying the diameter of polytopes, in particular the Hirsch conjecture, refuted in 2012 by Santos [37]. The hardness result on approximating monotone paths given by De Loera, Kafer, and Sanit` a [16] is in fact a corollary of the NP-hardness of the following problem: Given a feasible extreme point solution of the bipartite matching polytope and an objective function, decide whether there is a neighbor extreme point that is optimal. A related result for circulation polytopes was proved by Barahona and Tardos [5]. These two results, as well as the hardness results from Aichholzer et al. [2] and Ito et al. [29] rely on the NP-hardness of the Hamiltonian cycle problem. In order to deal with the approximability of the shortest path, we have to resort to more recent inapproximability results on the longest cycle problem [6].  
   
  78  
   
  J. Cardinal and R. Steiner  
   
  Reconfiguration of Matchings. The ﬁeld of combinatorial reconﬁguration deals with the problems of transforming a given discrete structure, typically a feasible solution of a combinatorial optimization problem, into another one using elementary combinatorial moves [23,27,28,36]. The reachability problem, for instance, asks whether there exists such a transformation, while the shortest reconﬁguration path problem asks for the minimum number of elementary moves. A number of recent works in this vein deal with reconﬁguration of matchings in graphs [8,12,25,28,33]. Ito et al. [28] proved that the reachability problem between matchings of size at least some input number k and under single edge addition or removal was solvable in polynomial time. This was extended to an adjacency relation involving two edges by Kaminsk´ı, Medvedev and Milani´c [33]. The problem of ﬁnding the shortest reconﬁguration path under this model was shown to be NP-hard [12,25]. Another line of work involves ﬂip graphs on perfect matchings in which the adjacency relation corresponds to ﬂips of alternating cycles of length exactly four [8,14,17,18,35]. Note that for bipartite graphs, this ﬂip graph is precisely the subgraph of the skeleton of the perfect matching polytope that consists of edges of length two. Bonamy, Bousquet, Heinrich, Ito, Kobayashi, Mary, M¨ uhlentaler and Wasa [8] proved that the reachability problem in these ﬂip graphs is PSPACE-complete.  
   
  2 2.1  
   
  Proof of Theorem 1 Preliminaries  
   
  First note that perfect matchings of a bipartite graph G = (A ∪ B, E) with |A| = |B| can also be represented by orientations of G in which every vertex in A has outdegree one and every vertex in B has indegree one. The edges of the matching are those oriented from A to B. Alternating cycles in a perfect matching are one-to-one with directed cycles in this orientation, and ﬂipping the cycle amounts to reverting the orientations of all its arcs. We will switch from one representation to another when convenient. We prove Theorem 1 by reducing from the problem of approximating the longest directed cycle in a digraph. We rely on the following two results from Bj¨ orklund, Husfeldt, and Khanna given as Theorems 1 and 2 in [6]. Theorem 2 (Bj¨ orklund, Husfeldt, Khanna [6]). Consider the problem of computing a long directed cycle in a given Hamiltonian digraph D on n vertices. 1. For every ﬁxed 0 < ε < 1, unless P = NP, there does not exist any polynomialtime algorithm that returns a directed cycle of length at least nε in D. 2. For every polynomial-time computable increasing function f : N → N in ω(1), unless the Exponential Time Hypothesis fails, there does not exist any polynomial-time algorithm that returns a directed cycle of length at least f (n) log n in D.  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  79  
   
  Note that in the two problems, the input graph is guaranteed to be Hamiltonian, yet it remains hard to explicitly construct a directed cycle of some guaranteed length. Characterising the approximability of the longest cycle problem in undirected graphs is a longstanding open question [3,22]. The second ingredient of our proof is the following lemma, perhaps of independent interest, that bounds the increase in length of a longest directed cycle after a number of cycle ﬂips in a digraph. Lemma 3. Let G be an undirected graph, and let C1 , . . . , Ct be a sequence of (not necessarily distinct) cycles in G. Let D0 , D1 , . . . , Dt be a sequence of orientations of G such that for each i ∈ [t] the cycle Ci is directed in Di−1 and such that Di is obtained from Di−1 by ﬂipping Ci . There exists a polynomial-time algorithm that, given as input a number , the orientations D0 , . . . , Dt and a directed cycle C in Dt of length |C| > t+1 , computes a directed cycle in D0 of length at least . The bound of Lemma 3 can be shown to be essentially tight. We refer to the full version of this paper for an explicit description of a directed graph whose maximum directed cycle is of length , but after a sequence of at most t cycle ﬂips, it contains a directed cycle of length at least (/2)t+1 . 2.2  
   
  Reduction  
   
  Fig. 2. Illustration of the reduction in the proof of Theorem 1. Every vertex in the given Hamiltonian digraph D (left) is replaced by the depicted gadget (right), yielding a maximum degree-three bipartite graph with a perfect matching.  
   
  We now give a proof of Theorem 1, assuming Lemma 3. Proof (Theorem 1). We consider the ﬁrst problem in Theorem 2: For a ﬁxed ε > 0, given a Hamiltonian digraph D on n vertices, return a directed cycle of length at least nε . We ﬁrst construct a digraph D from D by replacing every vertex v of D by the gadget illustrated on Fig. 2. The gadgets are obtained by applying the following transformations1 to every vertex v of D: 1  
   
  We note that the sole prupose of splitting vertices into binary trees is to restrict the maximum degree of the graph, the remainder of the proof is only based on the 4-cycles in the middle of the gadgets.  
   
  80  
   
  J. Cardinal and R. Steiner  
   
  1. The set of incoming arcs of v is decomposed into a balanced binary tree with deg− D (v) leaves and a degree-one root identiﬁed to v. Each internal node of this binary tree (that is, all nodes except for the leaves and the roots of degree 1) is further split into an arc. All arcs of the tree are oriented towards the root. 2. The set of outgoing arcs are split into a tree with deg+ D (v) leaves in a similar fashion, with all arcs oriented away from the root. The roots of the in- and out-trees are both identiﬁed with v and thus equal to each other. 3. Finally, the vertex v itself is replaced by a directed 4-cycle, such that the single incoming arc from the ﬁrst tree and the single outgoing arc from the second tree have adjacent endpoints on the cycle.  
   
  Fig. 3. Flipping the 4-cycles of each gadget in D can be done with two successive cycle ﬂips, using the Hamiltonian cycle of D.  
   
  The digraph D thus obtained is bipartite and subcubic. Furthermore, it is easy to see by construction that for every vertex v ∈ V (D), the corresponding gadget in D has at most + 4deg− D (v) + 4 + 4degD (v) ≤ 8(n − 1) + 4 < 8n  
   
  vertices, such that N := |V (D )| < n · 8n = 8n2 , and D is of polynomial size. Furthermore, the orientation of D is such that every vertex in one side of the bipartition has outdegree one, and every vertex in the other has indegree one, hence it corresponds to a perfect matching M1 . By ﬂipping the alternating 4-cycle in each gadget, we obtain another perfect matching M2 . We observe that M2 can be obtained from M1 in two cycle ﬂips, by using the Hamiltonian cycle of D twice (see Fig. 3). Hence, while M1 ΔM2 consists of n disjoint 4-cycles, M2 is in fact at distance two from M1 on the perfect matching polytope of D . The underlying undirected graph of D together with the two perfect matchings M1 and M2 therefore constitute an instance of the problem described in Theorem 1. We now show that any sequence of length at most k of alternating cycle ﬂips  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  81  
   
  transforming M1 into M2 can be turned in polynomial time into a cycle of length at least nε in D, for some ε > 0 depending solely on k. Consider a sequence of k cycles C1 , C2 , . . . , Ck in the underlying graph of D , such that C1 is alternating with respect to the matching M1 in D (and thus a directed cycle in D ); for every i = 2, . . . , k the cycle Ci is alternating with respect to the perfect matching M1 ΔC1 Δ · · · ΔCi−1 (and thus a directed cycle  , in this in the digraph obtained from D after ﬂipping the cycles C1 , C2 , . . . , Ci−1 order); and such that ﬂipping all k alternating cycles in sequence transforms M1 into M2 . Observe that the sum of the lengths of the cycles in this sequence must be at least n, since all the orientations of the 4-cycles in the n diﬀerent gadgets in D have to be ﬂipped, and since every single cycle Ci can intersect at most |Ci | diﬀerent gadget-4-cycles. Let  = n1/(k+2) . We have k   
   
  |Ci | ≥ n = (1 − o(1))k+2 >  
   
  i=1  
   
  k   
   
  i+1 ,  
   
  i=1  
   
  hence from the pigeonhole principle, at least one cycle Ci in the sequence has length |Ci | > i+1 . From Lemma 3, applied with this value of i, we can now  compute in polynomial time a directed cycle in D of length at least nε for   ε = 1/(k + 2). Let us call this cycle C . Note that for every gadget in D corresponding to a vertex v of D, either C  is vertex-disjoint from this gadget, or it traverses it via exactly one directed path, consisting of a leaf-to-root path in the in-tree, a directed path of length 7 touching the 4-cycle of the gadget, and then a root-to-leaf path in the out-tree. From this it follows that by contracting the edges of the gadgets, the cycle C  in D can be mapped to a cycle C in D. Note that the in- and out-degree of a vertex in D is at most n − 1, thus all the in- and out-trees in D corresponding to the gadgets have depth at most 2 log2 n . Consequently, the length of C  can be shrinked by at most a factor of 4 log2 n + 7 by contracting the gadgets. In other words, we obtain a directed  cycle C in D of length at least nε /(4 log2 n + 7) = nε , for ε = ε − o(1). Hence if we can obtain in polynomial time a sequence of at most k = O(1) ﬂips transforming M1 into M2 , we can also ﬁnd a cycle of length at least nε in D for some ﬁxed ε > 0. This establishes the ﬁrst statement of Theorem 1. It remains to prove the second statement. We consider the second problem in Theorem 2, in which we seek a path of length at least f (n) log n, for some computable function f (n) = ω(1). Suppose that for some δ > 0 there is a polynomial-time algorithm that can ﬁnd a sequence of at most k = k(N ) =   log N  1 ﬂips transforming M1 into M2 . Note that for n large enough 4 − δ log log N  k+2≤  
   
  1 −δ 4  

  log 8n2 log n 1 . + 2 < (1 − δ) 2 log log 8n 2 log log n  
   
  82  
   
  J. Cardinal and R. Steiner  
   
  Now, from the same reasoning as above, we can turn such an algorithm into a polynomial-time algorithm that ﬁnds a directed cycle in D of length at least  
   
  n1/(k+2) n2·log log n/((1−δ) log n) log2/(1−δ) n > =Ω = f (n) log n, 4 log2 n + 7 O(log n) log n for a computable function f (n) = Ω(log2δ/(1−δ) n) = ω(1). This, from Theorem 2, is impossible unless the Exponential Time Hypothesis fails.  
   
  In order to deduce Corollary 1 from Theorem 1, we need the following lemma. Lemma 4 (). Given a bipartite graph G = (V, E), let M1 and M2 be two perfect matchings in G at distance two on the perfect matching polytope, hence such that M2 = (M1 ΔC1 )ΔC2 for some pair C1 , C2 of cycles in G, and such that M1 ΔC1 =: M  is also a perfect matching. Then there exists a weight function w : E → R+ such that 1. M2 is the unique maximum-weight perfect matching of G,  2. w(M1 ) < w(M  ) < w(M2 ) (where w(M ) = e∈M w(e)). In other words, there exists a linear program over the perfect matching polytope of G such that the path M1 , M1 ΔC1 = M  = M2 ΔC2 , M2 is a strictly monotone path and M2 is the unique optimum. 2.3  
   
  Proof of Lemma 3  
   
  Proof (Lemma 3). Let the orientations D0 , D1 , . . . , Dt of G be given as input, together with a directed cycle C in Dt and a number  ∈ N such that |C| > t+1 . Our algorithm starts by computing the sequence of cycles C1 , . . . , Ct by determining for each i ∈ [t] the set of edges with diﬀerent orientation in Di−1 and Di . Next we compute in polynomial time the subgraph H of G which is the union of the cycles C1 , . . . , Ct in G. We in particular compute a list of the vertex sets of its connected components, which we call Z1 , . . . , Zc for some number c ≥ 1. We need the following fact, proved in the full version: Claim ✢ (). For each r ∈ [c] the induced subdigraph D0 [Zr ] of D0 is strongly connected. Let (x0 , x1 , . . . , xk−1 , xk = x0 ) be the cyclic list of vertices on the directed cycle C in Dt , with edges oriented from xi to xi+1 for all i ∈ [k − 1]. By assumption on the input, we have k = |C| > t+1 . We ﬁrst check if C is vertex-disjoint from H, in which case we may return C, which is then also a directed cycle in D0 of length k > t+1 ≥ , as desired. Otherwise, C intersects some of the components of H. We then for each vertex xi ∈ V (C) compute a label lab(xi ) ∈ [c + 1], deﬁned as lab(xi ) := r if xi ∈ Zr lies in the r-th component of H, and lab(xi ) := c + 1 if xi is not a vertex of H. We next compute an auxiliary weighted directed multigraph M on the vertex set [c] as follows: For every maximal subsequence of C, of length at least  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  83  
   
  two, of the form xi , xi+1 , . . . , xj (addition to be understood modulo k) such that lab(xs ) = c + 1 for all s = i + 1, . . . , j − 1 (if any), we add an additional arc from lab(xi ) to lab(xj ) and give it weight j − i, the corresponding number of arcs in C. Note that the total arc weight in M is exactly |C|, while the total number of arcs is exactly |V (C) ∩ V (H)| ≤ |V (H)|. The construction of M is illustrated in Fig. 4.  
   
  Fig. 4. Construction of the auxiliary directed multigraph M in the proof of Lemma 3. The cycle C is shown on the left, together with the connected components of H that it intersects. The resulting weighted directed multigraph M is shown on the right.  
   
  Furthermore, by deﬁnition every vertex in M has the same number of incoming and outgoing arcs. Hence, we may compute in polynomial time an edgedisjoint decomposition of M into directed cycles (including possible loops) in M . Let W1 , . . . , Wp for some p ∈ N be the list of edge-disjoint directed cycles in this decomposition of M . We now create, for each Wi , a directed cycle Ki in D0 of length |Ki | ≥ weight(Wi ), where weight(Wi ) is the total arc weight of Wi , as follows: Let (l0 , l1 , . . . , ls = l0 ) be the cyclic vertex-sequence of Wi . For each arc (lj , lj+1 ) in Wi , we consider the corresponding subsequence P (lj , lj+1 ) of C which starts in Zlj , ends in Zlj+1 , and all whose internal vertices are not contained in H. We note that since arcs outside H have the same orientation in D0 and Dt , the subsequence P (lj , lj+1 ) is a directed path or a directed cycle also in D0 which starts in Zlj and ends in Zlj+1 . We ﬁrst check whether there exists an index j such that P (lj , lj+1 ) is a directed cycle. In this case, necessarily Wi is a loop (i.e. s = 0) and lj = lj+1 = l0 . We thus may simply put Ki := P (lj , lj+1 ), with weight(Wi ) = |Ki | satisﬁed by deﬁnition of the weights in M . Otherwise, each of the P (lj , lj+1 ) is a directed path in D0 . We now make use of Claim ✢, which tells us that D0 [Zlj ] is strongly connected for every j = 0, 1, . . . , s − 1. We may therefore compute in polynomial time for each j = 0, 1, . . . , s−1 a directed path Qj in D0 [Zlj ] (possibly consisting of a single vertex) which connects the endpoint of P (lj−1 , lj ) to the starting point of P (lj , lj+1 ) (index-addition modulo s). Crucially, note that any two directed paths in the collection {P (lj , lj+1 ), Qj |j = 0, 1, . . . , s−1} are vertex-disjoint except for shared common endpoints. We now compute the directed cycle Ki in D0 , which is the union of the directed paths P (lj , lj+1 ) and the directed paths Qj for j = 0, . . . , s − 1. It is clear that its length |Ki | is lower-bounded by the sum of the  
   
  84  
   
  J. Cardinal and R. Steiner  
   
  lengths of the P (lj , lj+1 ), which by deﬁnition of M equals the sum of arc-weights on Wi , i.e., we indeed have |Ki | ≥ weight(Wi ) also in this case. After having computed the directed cycles K1 , . . . , Kp in D0 , the algorithm checks whether one of the cycles has length |Ki | ≥ . If so, it returns the cycle Ki and the algorithm stops with the desired output. Otherwise, we have |Ki | <  for i = 1, . . . , p, which implies that t+1 < |C| = weight(M ) =  
   
  p   
   
  weight(Wi ) ≤  
   
  i=1  
   
  p   
   
  |Ki | ≤ p( − 1).  
   
  i=1  
   
  Note that p is at most as large as the number of arcs in M , which in turn is bounded by |V (H)|. We thus obtain t+1 < |V (H)| · ( − 1) ≤  
   
  t   
   
  |Ci | · ( − 1).  
   
  i=1  
   
  This yields that  
   
  t  i=1  
   
  t  
   
  |Ci | >  
   
   t+1 > i . −1 i=1  
   
  Therefore there exists i ∈ {1, . . . , t} such that |Ci | > i . The algorithm proceeds by ﬁnding one cycle Ci with this property. Note that Ci is a directed cycle in the orientation Di−1 of G. Hence a recursive call of the algorithm to the input D0 , D1 , . . . , Di−1 and the cycle Ci will yield a directed cycle of length at least  in D0 , as desired. This proves the correctness of the described algorithm. As all steps between two recursive calls are executable in polytime in the size of G and t, and since there will clearly be at most t − 1 recursive calls in any execution of the algorithm, the whole algorithm runs in polynomial time, as desired.  

  References 1. Adler, I., Papadimitriou, C., Rubinstein, A.: On simplex pivoting rules and complexity theory. In: Lee, J., Vygen, J. (eds.) IPCO 2014. LNCS, vol. 8494, pp. 13–24. Springer, Cham (2014). https://doi.org/10.1007/978-3-319-07557-0 2 2. Aichholzer, O., et al.: Flip distances between graph orientations. Algorithmica 83(1), 116–143 (2021) 3. Alon, N., Yuster, R., Zwick, U.: Color-coding. J. ACM 42(4), 844–856 (1995) 4. Avis, D., Friedmann, O.: An exponential lower bound for Cunningham’s rule. Math. Program. 161(1–2), 271–305 (2017) ´ Note on Weintraub’s minimum-cost circulation algo5. Barahona, F., Tardos, E.: rithm. SIAM J. Comput. 18(3), 579–583 (1989) 6. Bj¨ orklund, A., Husfeldt, T., Khanna, S.: Approximating longest directed paths and cycles. In: D´ıaz, J., Karhum¨ aki, J., Lepist¨ o, A., Sannella, D. (eds.) ICALP 2004. LNCS, vol. 3142, pp. 222–233. Springer, Heidelberg (2004). https://doi.org/ 10.1007/978-3-540-27836-8 21  
   
  Inapproximability of Shortest Paths on Perfect Matching Polytopes  
   
  85  
   
  7. Bland, R.G.: New ﬁnite pivoting rules for the simplex method. Math. Oper. Res. 2(2), 103–107 (1977) 8. Bonamy, M., et al.: The perfect matching reconﬁguration problem. In: Rossmanith, P., Heggernes, P., Katoen, J. (eds.) 44th International Symposium on Mathematical Foundations of Computer Science, MFCS 2019, August 26–30, 2019, Aachen, Germany. LIPIcs, vol. 138, pp. 80:1–80:14. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik (2019) 9. Borgwardt, S., Brand, C., Feldmann, A.E., Kouteck´ y, M.: A note on the approximability of deepest-descent circuit steps. Oper. Res. Lett. 49(3), 310–315 (2021) 10. Borgwardt, S., Finhold, E., Hemmecke, R.: On the circuit diameter of dual transportation polyhedra. SIAM J. Discrete Math. 29(1), 113–121 (2015) 11. Borgwardt, S., Viss, C.: A polyhedral model for enumeration and optimization over the set of circuits. Discret. Appl. Math. 308, 68–83 (2022) 12. Bousquet, N., Hatanaka, T., Ito, T., M¨ uhlenthaler, M.: Shortest reconﬁguration of matchings. In: Sau, I., Thilikos, D.M. (eds.) WG 2019. LNCS, vol. 11789, pp. 162–174. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-30786-8 13 13. Chv´ atal, V.: On certain polytopes associated with graphs. J. Comb. Theory, Ser. B 18(2), 138–154 (1975) 14. Cioab˘ a, S.M., Royle, G., Tan, Z.K.: On the ﬂip graphs on perfect matchings of complete graphs and signed reversal graphs. Australas. J. Comb. 81, 480–497 (2021) 15. De Loera, J.A., Hemmecke, R., Lee, J.: On augmentation algorithms for linear and integer-linear programming: from Edmonds-Karp to Bland and beyond. SIAM J. Optim. 25(4), 2494–2511 (2015) 16. De Loera, J.A., Kafer, S., Sanit` a, L.: Pivot rules for circuit-augmentation algorithms in linear optimization. SIAM J. Optim. 32(3), 2156–2179 (2022) 17. Diaconis, P.W., Holmes, S.P.: Matchings and phylogenetic trees. Proc. Natl. Acad. Sci. USA 95(25), 14600–14602 (1998) 18. Diaconis, P.W., Holmes, S.P.: Random walks on trees and matchings. Electron. J. Probab. 7(6), 1–17 (2002) 19. Disser, Y., Friedmann, O., Hopp, A.V.: An exponential lower bound for Zadeh’s pivot rule. CoRR abs/1911.01074 (2019). http://arxiv.org/abs/1911.01074 20. Disser, Y., Skutella, M.: The simplex algorithm is NP-mighty. ACM Trans. Algorithms 15(1), 5:1–5:19 (2019) 21. Fearnley, J., Savani, R.: The complexity of the simplex method. In: Servedio, R.A., Rubinfeld, R. (eds.) Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing, STOC 2015, Portland, OR, USA, June 14–17, 2015, pp. 201–208. ACM (2015) 22. Gabow, H.N., Nie, S.: Finding a long directed cycle. ACM Trans. Algorithms 4(1), 7:1–7:21 (2008) 23. Gima, T., Ito, T., Kobayashi, Y., Otachi, Y.: Algorithmic meta-theorems for combinatorial reconﬁguration revisited. In: Chechik, S., Navarro, G., Rotenberg, E., Herman, G. (eds.) 30th Annual European Symposium on Algorithms, ESA 2022, September 5–9, 2022, Berlin/Potsdam, Germany. LIPIcs, vol. 244, pp. 61:1–61:15. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik (2022) 24. Goldfarb, D., Sit, W.Y.: Worst case behavior of the steepest edge simplex method. Discret. Appl. Math. 1(4), 277–285 (1979) 25. Gupta, M., Kumar, H., Misra, N.: On the complexity of optimal matching reconﬁguration. In: Catania, B., Kr´ aloviˇc, R., Nawrocki, J., Pighizzini, G. (eds.) SOFSEM 2019. LNCS, vol. 11376, pp. 221–233. Springer, Cham (2019). https://doi.org/10. 1007/978-3-030-10801-4 18  
   
  86  
   
  J. Cardinal and R. Steiner  
   
  26. Hansen, T.D., Zwick, U.: An improved version of the random-facet pivoting rule for the simplex algorithm. In: Servedio, R.A., Rubinfeld, R. (eds.) Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing, STOC 2015, Portland, OR, USA, June 14–17, 2015, pp. 209–218. ACM (2015) 27. van den Heuvel, J.: The complexity of change. In: Blackburn, S.R., Gerke, S., Wildon, M. (eds.) Surveys in Combinatorics 2013, London Mathematical Society Lecture Note Series, vol. 409, pp. 127–160. Cambridge University Press (2013) 28. Ito, T., et al.: On the complexity of reconﬁguration problems. Theor. Comput. Sci. 412(12–14), 1054–1065 (2011) 29. Ito, T., Kakimura, N., Kamiyama, N., Kobayashi, Y., Okamoto, Y.: Shortest reconﬁguration of perfect matchings via alternating cycles. SIAM J. Discret. Math. 36(2), 1102–1123 (2022) 30. Iwata, S.: On matroid intersection adjacency. Discret. Math. 242(1–3), 277–281 (2002) 31. Jeroslow, R.G.: The simplex algorithm with the pivot rule of maximizing criterion improvement. Discret. Math. 4(4), 367–377 (1973) 32. Kafer, S., Pashkovich, K., Sanit` a, L.: On the circuit diameter of some combinatorial polytopes. SIAM J. Discret. Math. 33(1), 1–25 (2019) 33. Kaminski, M., Medvedev, P., Milanic, M.: Complexity of independent set reconﬁgurability problems. Theor. Comput. Sci. 439, 9–15 (2012) 34. Klee, V., Minty, G.J.: How good is the simplex algorithm? In: Inequalities, III (Proc. Third Sympos., Univ. California, Los Angeles, Calif., 1969; dedicated to the memory of Theodore S. Motzkin), pp. 159–175. Academic Press, New York (1972) 35. Monroy, R.F., Flores-Pe˜ naloza, D., Huemer, C., Hurtado, F., Wood, D.R., Urrutia, J.: On the chromatic number of some ﬂip graphs. Discret. Math. Theor. Comput. Sci. 11(2), 47–56 (2009) 36. Nishimura, N.: Introduction to reconﬁguration. Algorithms 11(4), 52 (2018) 37. Santos, F.: A counterexample to the Hirsch conjecture. Ann. Math. 176(1), 383– 412 (2012) 38. Schrijver, A.: Combinatorial Optimization: Polyhedra and Eﬃciency, Algorithms and Combinatorics, vol. 24. Springer (2003) 39. Williams, V.V.: On some ﬁne-grained questions in algorithms and complexity. In: Proceedings of the International Congress of Mathematicians (ICM 2018), pp. 3447–3487. World Scientiﬁc (2018)  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs Antonia Chmiela1 , Gonzalo Mu˜ noz2(B) , and Felipe Serrano3 1  
   
  2  
   
  Zuse Institute Berlin, Berlin, Germany [email protected]  Institute of Engineering Sciences, Universidad de O’Higgins, Rancagua, Chile [email protected]  3 I2DAMO GmbH, Berlin, Germany [email protected]   
   
  Abstract. Using the recently proposed maximal quadratic-free sets and the well-known monoidal strengthening procedure, we show how to improve intersection cuts for quadratically-constrained optimization problems by exploiting integrality requirements. We provide an explicit construction that allows an eﬃcient implementation of the strengthened cuts along with computational results showing their improvements over the standard intersection cuts. We also show that, in our setting, there is unique lifting which implies that our strengthening procedure is generating the best possible cut coeﬃcients for the integer variables.  
   
  Keywords: MIQCP  
   
  1  
   
  · monoidal strengthening · unique lifting  
   
  Introduction  
   
  In recent years, we have seen multiple eﬀorts in generating valid linear inequalities to quadratically constrained quadratic programs (QCQPs) which, using an epigraph formulation, we can assume have the form min{¯ cT s : s ∈ S ⊆ Rp }  
   
  (1)  
   
  where S = {s ∈ Rp : sT Qi s + bT i s + ci ≤ 0, i = 1, . . . , m}. One of the approaches to generate such valid inequalities has been the intersection cut paradigm [1,13, 19] which works as follows. We assume we have f ∈ S, a basic feasible solution of a linear programming (LP) relaxation of (1). Additionally, we assume we have a simplicial conic relaxation K ⊇ S with apex f , and an S-free set C—a convex set satisfying int(C) ∩ S = ∅—such that f ∈ int(C). Using these ingredients, we can ﬁnd a cutting plane separating f from S. In Fig. 1 we show a simple intersection cut in the case when all p rays of K intersect the boundary of the S-free set C. In such case, the intersection cut is simply deﬁned by the hyperplane containing all such intersection points. It is well known that one can assume C to be described as C = {s ∈ Rp : φ(s − f ) ≤ 1} where φ is a sublinear function. For instance, φ c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 87–99, 2023. https://doi.org/10.1007/978-3-031-32726-1_7  
   
  88  
   
  A. Chmiela et al.  
   
  Fig. 1. An intersection cut (red) separating f from S (blue). The cut is computed using the intersection points of an S-free set C (green) and the rays of a simplicial cone K ⊇ S (boundary in orange) with apex f ∈ S. Figure obtained from [8] (Color ﬁgure online).  
   
  can be chosen as the gauge of C − f [17]. Further assuming w.l.o.g that the LP p relaxation is in standard form, we consider the constraint f + i=1 ri si ∈ S with ri ∈ Rp (e.g. the extreme rays of K) and si ∈ R+ . Under these considerations, the intersection cut separating f is p   
   
  φ(ri )si ≥ 1.  
   
  (2)  
   
  i=1  
   
  In [8,16] a method for constructing maximal quadratic-free sets (which ensures separation of any basic feasible solution f ∈ S) and a computational implementation was developed, with positive results in a broad class of problems. One of the limitations of these cutting planes is that they do not use any integrality information: if we were to add integrality requirements to (1)—thus obtaining an MIQCP—the intersection cuts would be completely oblivious to this. In this work, we remedy this via the monoidal strengthening framework [2]; a strengthening of intersection cuts based on integrality information. Monoidal strengthening leverages the  fact that some of the si in (2) are integer. The idea p is to take the relation f + i=1 ri si ∈ S and modify it in the following way. Assume p to be integer. The above p relation implies that p that all si are restricted )s ∈ S + m s . The points f + i=1 (ri + m i i i i i=1 i=1 mi si form a monoid p is, M satisﬁes 0 ∈ M and M + M = M = {m : m = i=1 mi si , si ∈ Z+ }, that p M . Thus, we obtain the new relation: f + i=1 (ri + mi )si ∈ S + M . If it turns out that C is still S + M free, then we can use the function φ to generate a new cut. The above is summarized in the following result by Balas and Jeroslow. Theorem 1 ([2] Theorem 1). Let M be a monoid such that C is S + M -free and let I = {i ∈ [p] : si ∈ Z} be the index set of the integer variables. Then,   φ(ri )si + inf φ(ri + m)si ≥ 1 i∈I /  
   
  i∈I  
   
  m∈M  
   
  is valid and dominates the intersection cut.  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  89  
   
  There are two main challenges in this technique. Firstly, to ﬁnd a monoid M such that C stays S + M -free. Note that, equivalently, we can ﬁnd a monoid M such that C − M is (possibly non-convex) S-free1 . Secondly, to eﬃciently solve the problem ψ(r) := inf m∈M φ(r + m) for r the rays associated to integer non-basic variables and thus obtain a stronger cut coeﬃcients. In this work we tackle both tasks. In most of this article S is deﬁned using a single quadratic inequality. As noted in [16], using linear transformations (diagonalization and homogenization), one can shift the focus from a generic quadratic set, S = {s ∈ Rp : sT Qs + bT s + c ≤ 0}, to one of the following two sets: S h := {(x, y) ∈ Rn+m : x ≤ y }, g  
   
  n+m  
   
  S := {(x, y) ∈ R  
   
  (3) T  
   
  T  
   
  : x ≤ y , a x + d y = −1}.  
   
  (4)  
   
  where max{ a , d } = 1. Whether S gets mapped to S h or S g depends on whether the quadratic deﬁning S is homogeneous or not. Thus, one of the goals of this paper will be: using C as maximal S h - and S g -free sets of [16], to ﬁnd a monoid M such that C is S h + M - or S g + M -free and, subsequently, strengthen the corresponding intersection cut. Monoidal strengthening is also related to lifting [3,9–11]. A nice property of ψ is that it is subadditive2 . This implies that with ψ we obtain sequence independent lifting, i.e. we can apply the strengthening to all integer variables at the same time. However, the monoidal lifting function ψ is, in general, just one possible way of lifting. We can deﬁne the best possible coeﬃcient that a particular integer variable can achieve, with the so-called lifting function π [4,10].   1 − φ(s) : f + s + σr ∈ S, σ ∈ Z≥1 . (5) π(r) = sup σ In general, π is not subadditive so we do not have sequence independent lifting with it [4]. When it is subadditive, we say that there is unique lifting, because π dominates any other lifting. For the case S = Zn ∩ P it is well understood when we have unique lifting [3]. Our ﬁnal goal is to show that in our setting there is unique lifting; more speciﬁcally, we show that choosing φ to be a minimal representation 3 of C − f , we have that π = ψ. Contributions. Our main contributions are: (1) we show that the monoidal strengthening framework does not produce any strengthening when S is deﬁned using a homogeneous quadratic; (2) in the non-homogeneous case, we show a family of cases where monoidal strengthening can be applied and an explicit monoid construction based on a maximal S g -free set of [16] which can be used for this strengthening; (3) we show an explicit formula for how to eﬃciently 1 2 3  
   
  With a slight abuse of notation, we refer to a non-convex set C − M as S-free whenever the convex set C − m is S-free for every m ∈ M . A function ψ is subadditive if ψ(x + y) ≤ ψ(x) + ψ(y). This means that if ρ is such that C = {s ∈ Rp : ρ(s − f ) ≤ 1} then ρ(s) ≥ φ(s).  
   
  90  
   
  A. Chmiela et al.  
   
  compute ψ(r) in practice; (4) we show that in our setting there is unique lifting which, in particular, implies that ψ yields the best coeﬃcients in the strengthening of the intersection cut; and (5) we present extensive computational results that show the impact of this strengthening procedure. We remark that, even though our constructions are based on the structure of one quadratic, they can also be applied to MIQCPs with multiple quadratic inequalities: using our approach, it suﬃces to have one quadratic inequality being violated in order to ensure separation. In the interest of space, we do not present all details in this extended abstract. We refer the reader to our preprint available in [7].  
   
  2  
   
  Monoidal Strengthening in the Homogeneous Case  
   
  In this section, we analyze the case of S h and show that the monoidal strengthening framework does not produce any improvements when the cuts are created using maximal S h -free sets. The main reason behind this fact is that S h is a cone, and consequently every maximal S h -free set is a convex cone [6, Corollary 3]4 ; we show below why this is not a good setting for monoidal strengthening. In fact, the results in this section apply to a generic closed cone S and are stated with respect to such set. As mentioned before, for a given S-free set C, we are interested in ﬁnding a monoid M such that C − M is S-free. The following result shows that in this case C − M = M . We remark that cone(·) is the cone generated by a set, which may not be convex. Theorem 2. Let S, C ⊆ Rn where S is a closed cone and C is a convex maximal S-free set. Let M ⊆ Rn be a monoid such that C −M is S-free, then C −M = C. In particular, this implies that the cut obtained from monoidal strengthening would be the same as the standard intersection cut obtained through C. Proof (sketch). Since M is a monoid, 0 ∈ M and thus C ⊆ C − M . It can be shown that cl cone(M ) is a convex cone such that C − cl cone(M ) is S-free. Note that C − cl cone(M ) is convex, and thus the maximality of C implies that C − cl cone(M ) ⊆ C. Since C − M ⊆ C − cl cone(M ), we conclude C − M = C. This last result shows that in the presence of a maximal S-free set C, there is not much to be gained from the monoidal strengthening framework when S is a cone. This negative property, nonetheless, can be reinterpreted as a way of detecting “non-maximality” of an S-free set: if one could ﬁnd a monoid M such that C − M is S-free and C − M = C, then C is not maximal. We formalize this in the next result.  
   
  4  
   
  This citation deals with a particular set S, but the proof can be easily extended to any conic set S.  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  (a) Slices of S (blue) and Cθ (orange)  
   
  91  
   
  (b) Slices of S (blue) and Cθ (orange)  
   
  Fig. 2. Three-dimensional slices of S, Cθ and Cθ in Example 1 given by a = 1/10.  
   
  Proposition 1. Let S be a closed cone and let C be a full dimensional closed convex S-free cone. If there exists r ∈ / −C such that C is S + cone(r)-free, then C is not a maximal S-free set. Furthermore, C + cone(−r) is S-free and strictly contains C. The next example illustrates an application of the last proposition, in a connection with the work of [6]. Example 1. Consider the set S = {(a, b, c, d) ∈ R4 : ad = bc, a ≥ 0}. Although this set does not fall into either the forms S h or S g which are our main objects of interest, it is still a closed conic set to which the results of this section apply. The set S is studied in [6], and appears when using lifted variables Xi,j representing bilinear terms xi xj . Let Cθ = {(a, b, c, d) ∈ R4 : cos(θ)(a + d) + sin(θ)(b − c) ≥  (a − d)2 + (b + c)2 }. In [6, Theorem 7], the authors show that Cθ is maximal S-free for values of θ that satisfy cos(θ) = 0 or sin(θ) = 0. Using the results of this section, we can prove that if θ is such that cos(θ) = 0 and sin(θ) = 0, then / −Cθ and Cθ is not maximal S-free. More speciﬁcally, we can show that −e4 ∈ that Cθ is S + cone(−e4 )-free, where e4 = (0, 0, 0, 1). Using Proposition 1, this implies that Cθ = Cθ + cone(e4 ) is S-free and strictly contains Cθ . We leave out the details for the sake of brevity. In Fig. 2 we show a 3-dimensional slice of the 4-dimensional sets S and Cθ , for θ = π/4, showing how the S-free was enlarged. We remark that one can actually show that Cθ is maximal S-free using the maximality criteria of [15].  
   
  92  
   
  A. Chmiela et al.  
   
  (a) S (blue) with maximal S-free set C (orange). In this case the two inequalities of C intersect S.  
   
  (b) Set of points not in S and “to the left of the exposing points” (green). Note that the green region is not contained on the orange region: see the top left and bottom left.  
   
  Fig. 3. Constuction of the monoid for a maximal S-free set.  
   
  3  
   
  Monoidal Strengthening in the Non-homogeneous Case  
   
  In this case, the monoidal strengthening framework does produce improvements. The intuition for our construction is as follows. Consider the maximal S-free set C represented in Fig. 3a. The set is maximal, because all of its deﬁning inequalities αT s ≤ β have exposing points [16], that is, there exists s0 ∈ C ∩ S with αT s0 = β such that if γ T s ≤ δ is any other non-trivial valid inequality for C that is tight at s0 , then there exists a μ > 0 such that γ = μα and β = μδ. For example, if C is a polyhedron and s0 ∈ C ∩ S is an exposing point of an inequality, then that inequality is a facet and s0 is in its relative interior. Thus, in the example of Fig. 3a, the two exposing points of C are the points of the facets of C that are tangent to S. We see that a way of translate C such that the translation is S-free is by moving the apex of C to a point not in S and to the left of the exposing points (see Fig. 3b). This is the basic idea behind our monoid construction, and below we show how to formalize it. 3.1  
   
  A Technical Consideration for S g  
   
  Before motivating the construction the monoid, we need to provide some details on the construction of maximal S g -free presented in [16]. This construction starts from the maximal S h -free set Cλ = {(x, y) ∈ Rn+m : y ≤ λT x},  
   
  (6)  
   
  where λ is a vector in the unit sphere. Note that Cλ can be equivalently described as Cλ = {(x, y) ∈ Rn+m : β T y ≤ λT x ∀β ∈ D1 } where D1 is the unit sphere of appropriate dimension. The proof that Cλ is maximal S h -free boils down to ˆ the vector (λ, β) ˆ ∈ S h ∩ Cλ is tight for the inequality noting that for each β,  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  93  
   
  βˆT y ≤ λT x and for no other of Cλ . This means that each inequality of Cλ indexed by β has an exposing point in S h . Moving to the non-homogeneous case, since S g = S h ∩ H, where H = {(x, y) ∈ Rn+m : aT x + dT y = −1}, the set C = Cλ ∩ H is clearly S g -free5 , but it is not necessarily maximal. The maximal S g -free constructed in [16] ﬁrst identiﬁes the inequalities of Cλ for which an exposing point can be found in H, keeps them, and relaxes the rest. The inequalities given by β such that β = 1 and aT λ + dT β < 0 are the ones that have the desired exposing points; these exposing points are −  
   
  aT λ  
   
  1 (λ, β) + dT β  
   
  Maximality of the resulting set is shown using the exposing points above and, for relaxed inequalities, a diverging sequence in S g that approaches the inequality indeﬁnitely (an exposing sequence). This is due to the fact that these relaxed inequalities may have never intersect S g . In our current monoid construction, we require that all inequalities to have exposing points. This requirement translates to aT λ + dT β < 0 for all β with  
   
  β = 1. This, in turn, reduces to d < −aT λ. Note that this condition implies that C = Cλ ∩ H is maximal S g -free with respect to H [16]. Additionally, this implies that we can assume a = max{ a , d } = 1. We believe that when these assumptions are not fulﬁlled, monoidal strengthening cannot be applied. Proving this conjecture is part of future work. 3.2  
   
  Monoid Construction  
   
  Using the considerations of the previous section, we can formalize the notion of “left of the exposing points”: we ﬁrst consider the halfspace {(x, y) ∈ Rn+m : (a − λT aλ)T x ≥ 0} which contains the exposing points and the directions of lineality of Cλ ∩ H. Secondly, when translating Cλ by a vector m we can modify m by a vector in the lineality space of Cλ without changing the translation. Thus, we restrict to vectors m that live in a subspace that contains the exposing points and is orthogonal to the lineality space of Cλ ∩ H. This subspace is given by {λ, a} × Rm where {λ, a} denotes the span of {λ, a}. Thus, we have the following set representing the points “left of the exposing points”: L = {(x, y) ∈ {λ, a} × Rm : aT x + dT y = −1, x ≥ y , (a − λT aλ)T x ≥ 0}. To obtain the translation we ﬁnd the apex of Cλ ∩ H in the space {λ, a} × Rm . This point is given by   −1 λT a ν = (x0 , 0) := a+ λ, 0 . (7) 1 − (λT a)2 1 − (λT a)2 5  
   
  Note that S g is contained on a halfspace, so S g -freeness is with respect to the induced topology in H.  
   
  94  
   
  A. Chmiela et al.  
   
  Thus, L − ν is a candidate to represent the translations of C that would result in an S g -free set. Note that the assumptions d < −λT a and d ≤ 1 imply (λT a)2 < 1, thus ν is well-deﬁned. Recall that the translations we consider for C are given by “minus the monoid” and that a monoid must contain the origin, therefore our candidate for a monoid is M = {(x, y) ∈ {λ, a} × Rm : aT x + dT y = 0, x − x0 ≥ y , T  
   
  (8)  
   
  T  
   
  (a − λ aλ) x ≤ −1} ∪ {(0, 0)}. Theorem 3. Let M be deﬁned as in (8) with d < −λT a and a = λ = 1. The set M is a monoid. Proof (sketch). This proof is highly technical, so we just present the high-level strategy for obtaining the desired result. See [7] for the details. We equivalently show that −M is a monoid. Thus, we take two vector (xi , yi ) ∈ −M , i = 1, 2, and show that their sum is in −M . This is trivial whenever one of the vectors is (0, 0). The linear constraints in the deﬁnition of −M are satisﬁed trivially, hence the main argument is to show that  
   
  x1 + x2 + x0 ≥ y1 + y2 . This is equivalent to showing that the value of the following optimization problem is non-negative. min { x1 + x2 + x0 2 − y1 + y2 2 : (xi , yi ) ∈ −M \ {(0, 0)}, i = 1, 2}  
   
  xi ,yi  
   
  2 Using that xi + x0 ≥ yi and (a − λT aλ)T xi ≥ 1 ⇔ −xT 0 xi ≥ x0 , we 2 can lower bound the objective function by x1 + x2 + x0 − y1 + y2 2 ≥ T 2 2xT 1 x2 − 2y1 y2 − x0 . Hence, to show that T min {xT 1 x2 − y1 y2 : (xi , yi ) ∈ −M \ {(0, 0)}, i = 1, 2}  
   
  xi ,yi  
   
  (P )  
   
  is lower bounded by 21 x0 2 suﬃces. Note that we can decompose yi = ωi d + ρi where ρi is orthogonal to d. Furthermore, since xi ∈ {a, λ} , we can write xi = θi a + ηi λ. Using this together with the fact that λT x0 = 0 and aT x0 = −1, the hyperplane in −M becomes 0 = aT xi +dT yi = θi +ηi λT a+ωi d 2 . Furthermore, 2 2 we get −xT 0 xi ≥ x0 ⇔ θi ≥ x0 , and expanding the nonlinear constraint we reformulate problem (P ) as min  
   
  θi ,ηi ,ωi ,ρi  
   
  s.t.  
   
  θ1 θ2 + η1 η2 + θ1 η2 λT a + θ2 η1 λT a − w1 w2 d 2 − ρT 1 ρ2 0 ≤ θi2 + ηi2 + 2θi ηi λT a − 2θi + x0 2 − wi2 d 2 − ρi 2  
   
  x0 2 ≤ θi  
   
  (Pexp )  
   
  d 2 ωi = −θi + ηi λT a The remainder of the proof focuses on showing the desired lower bound for this problem. The key elements of the proof involve: ﬁrst showing that the problem is simply bounded, then showing that constraint x0 2 ≤ θi can be assumed to be tight. This is shown leveraging results from [18]. Using this we show the desired lower bound (Pexp ) ≥ 12 x0 2 .  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  95  
   
  The last required result for monoidal strengthening is the following. Theorem 4. Let S g and Cλ be deﬁned as in (4) and (6) respectively, and H = {(x, y) ∈ Rn+m : aT x+dT y = −1}. Let M be deﬁned as in (8) with d < −λT a and a = λ = 1. The set Cλ ∩ H − M is S g -free.  
   
  4  
   
  Solving the Monoidal Strengthening Problem  
   
  In order to strengthen the cut using Theorem 1 and the construction in Sect. 3, we need to solve ψ(r) = inf m∈M φ(r + m), where φ is such that Cλ ∩ H = {s : φ(s − f ) ≤ 1}. From now on, λ = ffxx  , where f is the point we want to separate, i.e., f ∈ / S g . Furthermore, we restrict Cλ ∩ H to {λ, a} × Rm because any representation of Cλ ∩ H is invariant in the directions of the lineality space of Cλ ∩ H, namely, {λ, a} ⊥ × {0}. Thus, we deﬁne C = Cλ ∩ H ∩ {λ, a} × Rm . Likewise, we restrict all rays to {λ, a} × Rm . We work with the minimal representation of C − f ; we can prove it is given by β T s −λT s supβ=1 λT fxy −β T fxy , if s ∈ H and sx ∈ {λ, a} φ(s) = (9) +∞, otherwise. The monoidal problem is equivalent to ψ(r) = inf{τ : φ(r + m) ≤ τ, m ∈ M }. In order to understand this problem better, we need to understand the set {s : φ(s) ≤ τ }. Lemma 1. Let φ be the minimal representation of C − f given in (9). Then {s : φ(s) ≤ τ } = C − ν − τ (f − ν), where ν is deﬁned in (7) (the apex of Cλ ∩ H in the space {λ, a} × Rm ). From this lemma, we can show that ψ(r) = inf {τ : r + ν + τ (f − ν) ∈ C − M } .  
   
  (10)  
   
  In other words, solving the monoidal strengthening problem reformulates to ﬁnding the ﬁrst intersection point between the line l(τ ) = r + ν + τ (f − ν), and the set C − M . It can be shown that C − M = L ∪ C, thus, ψ(r) = inf{τ : l(τ ) ∈ L ∪ C} = min{τ1 , τ2 }, where τ1 = inf{τ : l(τ ) ∈ L} and τ2 = inf{τ : l(τ ) ∈ C}. Note that τ2 corresponds to the normal intersection cut coeﬃcient φ(r). The following proposition shows how to evaluate ψ(r). Proposition 2. Let τ¯ be the largest root of the univariate quadratic equation τ ) ∈ L, then ψ(r) = τ¯. Otherwise,  
   
  lx (τ ) 2 = ly (τ ) 2 . If the root exists and l(¯ ψ(r) = φ(r). To ﬁnalize this section, we show how to use this result starting from a general quadratic constraint. Consider S to be deﬁned by a general quadratic constraint, i.e., S = {s ∈ Rp : sT Qs + bT s + c ≤ 0} with Q ∈ Rp×p , b ∈ Rp and c ∈ R. Let  
   
  96  
   
  A. Chmiela et al.  
   
  s¯ ∈ / S be the point we want to separate. In [8] the authors transform S using the eigenvalue decomposition Q = V ΘV T . Let θi , i ∈ [p], be the eigenvalues of Q, and let I+ = {i : θi > 0}, I− = {i : θi < 0} and I0 = {i : θi = 0}. Furthermore, denote by vi the i-th eigenvector of Q, that is, the i-th column of V . We avoid showing the full transformation here, but an important fact is that the conditions d < −λT a < 1 we need for applying monoidal strengthening in S g become 1  (viT b)2 >0 (11) (V T b)I0 = 0 ∧ c − 4 θi i∈I+ ∪I−  
   
  The following result summarizes the necessary computations. Proposition 3. Suppose conditions (11) are met. The computation of ψ(r) for a given ray r reduces to computing the largest root of Aτ 2 + Bτ + D = 0 where      

  2 b A= θi viT (¯ s − ν) , B = 2 θi viT (¯ s − ν) viT (r + ν + ) , 2θi i∈I+ ∪I− i∈I+ ∪I−   2  b D= θi viT (r + ν + ) +κ 2θi i∈I+ ∪I−  
   
  κ T s+ j∈I+ θj (vj (¯  
   
  ν = −  
   
  1 κ=c− 4  
   
   i∈I+ ∪I−  
   
   b 2 2θj )) j∈I+  
   
  vij (vjT (¯ s+  
   
  b )) − 2θj  
   
   j∈I+ ∪I−  
   
  vij  
   
  vjT b 2θj  
   
  (viT b)2 θi  
   
  We note that we also need to compute the cut coeﬃcient φ(r), but this can also be done eﬃciently as shown in [8]. The expressions on the previous proposition may not provide too much insight themselves, as they are accumulating a series of transformations to bring S to S g . However, we believe their value relies in that, given an eigenvalue decomposition for a general quadratic inequality, one can simply plug-in the desired parameters and obtain a univariate quadratic that yields the strengthened coeﬃcients of an intersection cut.  
   
  5  
   
  Unique Lifting  
   
  As mentioned in the introduction, monoidal strengthening is just one way of improving the cut coeﬃcients of integer variables. The best possible coeﬃcient that a particular integer variable can achieve is given by the lifting function π deﬁned in (5). If π is subadditive, then there is unique lifting [4]. This means that the lifting using π can be applied simultaneously to all rays ri corresponding to integer variables and dominates any other lifting. In this section, we show that if we use φ the minimal representation of C − f shown in (9), we have π = ψ;  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  (a) ψ(r) in (10) searches for the smallest step τ such that r + ν + τ (f − ν) ∈ C − M . The latter set is depicted in green.  
   
  97  
   
  (b) π1 (r) in (13) searches for the largest step τ such that r + ν + τ (f − ν) ∈ S g − rec(C). The latter set is depicted in green  
   
  Fig. 4. Comparison of the deﬁnitions of ψ and π1 showing why they are equal. In both ﬁgures, S g is depicted in blue and C in orange. (Color ﬁgure online)  
   
  since ψ is a subadditive function we obtain unique lifting and, moreover, that the procedure of Sect. 4 yields the best possible lifting coeﬃcients. Let π1 be the restriction of π to σ = 1. Slightly reformulating the optimization problem, we see that π1 (r) = sup {τ : f + s + r ∈ S g , φ(s) ≤ 1 − τ }  
   
  (12)  
   
  Using Lemma 1, we can show that f + s + r ∈ S g and φ(s) ≤ 1 − τ reformulate to r + ν + τ (f − ν) ∈ S g − (C − ν). Since C − ν = rec(C), (12) becomes π1 (r) = sup {τ : r + ν + τ (f − ν) ∈ S g − rec(C)} .  
   
  (13)  
   
  Notice that problem (13) is very similar to the monoidal problem (10). Moreover, we can use this—plus structural results we leave out for the sake of space—to show that ψ(r) = π1 (r). This is almost what we want. In Fig. 4 we illustrate the deﬁnitions of both π1 and ψ to provide some intuition on why this result holds. To make the connection with π we prove the following lemma. Lemma 2. Let M be a monoid such that C is S + M -free and π1 (r) = sup{1 − φ(s) : f + s + r ∈ S}. If π1 is subadditive, then π = π1 and we have unique lifting. Since ψ is subadditive and ψ = π1 , we directly obtain the following theorem. Theorem 5. Consider ψ the monoidal strengthening function and π the lifting function, both deﬁned using φ as in (9). Then π = ψ, in particular, there is unique lifting.  
   
  6  
   
  Computational Results  
   
  In this section, we show results of computational experiments testing the eﬃcacy of the monoidal strengthening procedure we propose. We embedded the  
   
  98  
   
  A. Chmiela et al.  
   
  Table 1. Summary of results for branch-and-bound experiments. Rows labeled [t, 7200] consider instances where one of the settings took at least t seconds. Columns labeled relative show the relative improvement of monoidal compared to icuts. subset  
   
  instances icuts solved time  
   
  all 189 [0, 7200] 115 83 [1, 7200] 81 [10, 7200] 23 [100, 7200] [1000, 7200] 10  
   
  113 113 81 79 21 8  
   
  221.87 22.81 67.62 72.54 724.66 2475.04  
   
  nodes 5282 936 2377 2574 186545 631764  
   
  monoidal solved time 115 115 83 81 23 10  
   
  214.63 21.56 62.40 66.56 565.24 1252.96  
   
  nodes 5321 883 2184 2341 144747 307639  
   
  relative time nodes 0.97 0.95 0.92 0.92 0.78 0.51  
   
  0.97 0.94 0.92 0.91 0.78 0.49  
   
  computation of the monoidal strengthening cut coeﬃcients in SCIP 8.0 [5] as a subroutine of the already implemented intersection cut generator. As the underlying LP solver, we used CPLEX 12.10.0.0. For testing, we used a Linux cluster of Intel Xeon CPU E5-2680 0 2.70 GHz with 20MB cache and 64GB main memory. The time limit in all experiments was set to two hours. The test set we consider consists of the publicly available instances of the MINLPLib [14] and QPLib [12]. We selected all non-convex instances with (mixed)-integer constriants and at least one quadratic constraint of the correct case, leaving us with 95 instances. Furthermore, we ﬁltered out all instances that are either infeasible, where no dual bound was found or where monoidal strengthening could not been applied. This leaves us with a heterogeneous test set of 63 instances with 8–23826 variables and 12–24971 constraints. All experiments are run with three diﬀerent permutations for each instance. We treat every instance-permutation pair as an individual instance, since permuting the constraints and variables of a problem formulation may considerably change the solving process. We consider two diﬀerent settings that are both based on SCIP’s default settings: icuts additionally generates the original intersection cuts, whereas monoidal uses the strengthened cutting planes if possible. Furthermore, we restrict icuts and monoidal to add at most 20 intersection cuts per quadratic constraint. We found this to be the best performing setting compared to default SCIP. Summarized results can be found in Table 1. monoidal consistently outperforms icuts with respect to solving time as well as number of nodes needed. On the whole test set, the strengthened intersection cuts reduce both metrics by around 3% while solving two more instances. This improvement increases when looking at harder instances: On the hardest test set [1000, 7200] containing only instances for which at least one setting needs 1000 seconds or more, monoidal uses 49% less time and 51% less nodes. These results show that the proposed monoidal strengthening procedure signiﬁcantly improves the standard intersection cuts, which highlights the importance of exploiting integrality whenever possible. Nonetheless, our cuts are currently not able to improve the overall performance of default SCIP. One of the main reasons is that our cuts, while helping in obtaining better dual bounds, are  
   
  Monoidal Strengthening and Unique Lifting in MIQCPs  
   
  99  
   
  negatively aﬀecting the performance of SCIP’s primal heuristics. Improving this behavior is subject of ongoing work.  
   
  References 1. Balas, E.: Intersection cuts–a new type of cutting planes for integer programming. Oper. Res. 19(1), 19–39 (1971) 2. Balas, E., Jeroslow, R.G.: Strengthening cuts for mixed integer programs. Eur. J. Oper. Res. 4(4), 224–234 (1980) 3. Basu, A., Campelo, M., Conforti, M., Cornu´ejols, G., Zambelli, G.: Unique lifting of integer variables in minimal inequalities. Math. Program. 141(1–2), 561–576 (2012) 4. Basu, A., Dey, S.S., Paat, J.: Nonunique lifting of integer variables in minimal inequalities. SIAM J. Discret. Math. 33(2), 755–783 (2019) 5. Bestuzheva, K., et al.: The SCIP Optimization Suite 8.0. ZIB-Report 21–41, Zuse Institute Berlin, December 2021 6. Bienstock, D., Chen, C., Munoz, G.: Outer-product-free sets for polynomial optimization and oracle-based cuts. Math. Program. 1–44 (2020) 7. Chmiela, A., Mu˜ noz, G., Serrano, F.: Monoidal strengthening and unique lifting in MIQCPs (2022). https://www.gonzalomunoz.org/publications/ 8. Chmiela, A., Mu˜ noz, G., Serrano, F.: On the implementation and strengthening of intersection cuts for QCQPs. Math. Program. pp. 1–38 (2022) 9. Conforti, M., Cornu´ejols, G., Zambelli, G.: A geometric perspective on lifting. Oper. Res. 59(3), 569–577 (2011) 10. Dey, S.S., Wolsey, L.A.: Two row mixed-integer cuts via lifting. Math. Program. 124(1–2), 143–174 (2010) ´ 11. Fukasawa, R., Poirrier, L., Xavier, A.S.: The (not so) trivial lifting in two dimensions. Math. Program. Comput. 11(2), 211–235 (2018). https://doi.org/10.1007/ s12532-018-0146-5 12. Furini, F., et al.: A library of quadratic programming instances. Programming Computation, QPLIB (2018) 13. Glover, F.: Convexity cuts and cut search. Oper. Res. 21(1), 123–134 (1973) 14. MINLP library (2010). http://www.minlplib.org/ 15. Mu˜ noz, G., Serrano, F.: Maximal quadratic-free sets. In: Bienstock, D., Zambelli, G. (eds.) IPCO 2020. LNCS, vol. 12125, pp. 307–321. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-45771-6 24 16. Mu˜ noz, G., Serrano, F.: Maximal quadratic-free sets. Math. Program. 1–42 (2021) 17. Rockafellar, R.T.: Convex Analysis. Princeton University Press, Princeton (1970) 18. Santana, A., Dey, S.S.: The convex hull of a quadratic constraint over a polytope. SIAM J. Optim. 30(4), 2983–2997 (2020) 19. Tuy, H.: Concave programming with linear constraints. In: Doklady Akademii Nauk, vol. 159, pp. 32–35. Russian Academy of Sciences (1964)  
   
  From Approximate to Exact Integer Programming Daniel Dadush1 , Friedrich Eisenbrand2 , and Thomas Rothvoss3(B) 1 CWI, Amsterdam, The Netherlands  
   
  [email protected]   
   
  2 EPFL, Lausanne, Switzerland  
   
  [email protected]   
   
  3 University of Washington, Seattle, USA  
   
  [email protected]   
   
  Abstract. Approximate integer programming is the following: For a given convex body K ⊆ Rn , either determine whether K ∩ Zn is empty, or find an integer point in the convex body 2 · (K − c) + c which is K , scaled by 2 from its center of gravity c. Approximate integer programming can be solved in time 2O(n) while the fastest known methods for exact integer programming run in time 2O(n) · n n . So far, there are no efficient methods for integer programming known that are based on approximate integer programming. Our main contribution are two such methods, each yielding novel complexity results. First, we show that an integer point x ∗ ∈ (K ∩Zn ) can be found in time 2O(n) , provided that the remainders of each component x i∗ mod  for some arbitrarily fixed  ≥ 5(n + 1) of x ∗ are given. The algorithm is based on a cutting-plane technique, iteratively halving the volume of the feasible set. The cutting planes are determined via approximate integer programming. Enumeration of the possible remainders gives a 2O(n) n n algorithm for general integer programming. This matches the current best bound of an algorithm by Dadush (2012) that is considerably more involved. Our algorithm also relies on a new asymmetric approximate Carathéodory theorem that might be of interest on its own. Our second method concerns integer programming problems in standard equation form Ax = b, 0 ≤ x ≤ u, x ∈ Zn . Such a problem can be reduced to  the solution of i O(log u i + 1) approximate integer programming problems. This implies, for example that knapsack or subset-sum problems with polynomial variable range 0 ≤ x i ≤ p(n) can be solved in time (log n)O(n) . For these problems, the best running time so far was n n · 2O(n) .  
   
  A full version of this paper can be found under https://arxiv.org/abs/2211.03859. D. Dadush—Supported by ERC Starting Grant no. 805241-QIP. F. Eisenbrand—Supported by the Swiss National Science Foundation (SNSF) grant 185030 and 207365. T. Rothvoss—Supported by NSF CAREER grant 1651861 and a David & Lucile Packard Foundation Fellowship. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 100–114, 2023. https://doi.org/10.1007/978-3-031-32726-1_8  
   
  From Approximate to Exact Integer Programming  
   
  101  
   
  1 Introduction Many combinatorial optimization problems as well as many problems from the algorithmic geometry of numbers can be formulated as an integer linear program max{〈c, x〉 | Ax ≤ b, x ∈ Zn }  
   
  (1)  
   
  where A ∈ Zm×n , b ∈ Zm and c ∈ Zn , see, e.g. [16,27,30]. Lenstra [23] has shown that integer programming can be solved in polynomial time, if the number of variables 2 is fixed. A careful analysis of his algorithm yields a running time of 2O(n ) times a polynomial in the binary encoding length of the input of the integer program. Kannan [19] has improved this to n O(n) , where, from now on we ignore the extra factor that depends polynomially on the input length. The current best algorithm is the one of Dadush [10] with a running time of 2O(n) · n n . The question whether there exists a singly exponential time, i.e., a 2O(n) -algorithm for integer programming is one of the most prominent open problems in the area of algorithms and complexity. Integer programming can be described in the following more general form. Here, a convex body is synonymous for a full-dimensional compact and convex set. Integer Programming (IP) Given a convex body K ⊆ Rn , find an integer solution x ∗ ∈ K ∩ Zn or assert that K ∩ Zn = . The convex body K must be well described in the sense that there is access to a separation oracle, see [16]. Furthermore, one assumes that K contains a ball of radius r > 0 and that it is contained in some ball of radius R. In this setting, the current best running times hold as well. The additional polynomial factor in the input encoding length becomes a polynomial factor in log(R/r ) and the dimension n. Central to this paper is Approximate integer programming which is as follows. Approximate Integer Programming (Approx-IP) Given a convex body K ⊆ Rn , let c ∈ Rn be its center of gravity. Either find an integer vector x ∗ ∈ (2 · (K − c) + c) ∩ Zn , or assert that K ∩ Zn = . The convex body 2 · (K − c) + c is K scaled by a factor of 2 from its center of gravity. The algorithm of Dadush [11] solves approximate integer programming in singly exponential time 2O(n) . Despite its clear relation to exact integer programming, there is no reduction from exact to approximate known so far. Our guiding question is the following: Can approximate integer programming be used to solve the exact version of (specific) integer programming problems? 1.1 Contributions of This Paper We present two different algorithms to reduce the exact integer programming problem (IP) to the approximate version (A PPROX -IP).  
   
  102  
   
  D. Dadush et al.  
   
  a) Our first method is a randomized cutting-plane algorithm that, in time 2O(n) and for any  ≥ 5(n + 1) finds a point in K ∩ (Zn /) with high probability, if K contains an integer point. This algorithm uses an oracle for (A PPROX -IP) on K intersected with one side of a hyperplane that is close to the center of gravity. Thereby, the algorithm collects  integer points close to K . The collection is such that the convex combination with uniform weights 1/ of these points lies in K . If, during an iteration, no point is found, the volume of K is roughly halved and eventually K lies on a lower-dimensional subspace on which one can recurse. b) If equipped with the component-wise remainders v ≡ x ∗ (mod ) of a solution x ∗ of (IP), one can use the algorithm to find a point in (K − v) ∩ Zn and combine it with the remainders to a full solution of (IP), using that (K − v) ∩ Zn = . This runs in singly exponential randomized time 2O(n) . Via enumeration of all remainders, one obtains an algorithm for (IP) that runs in time 2O(n) · n n . This matches the best-known running time for general integer programming [11], which is considerably involved. c) Our analysis depends on a new approximate Carathéodory theorem that we develop in Sect. 4. While approximate Carathéodory theorems are known for centrally symmetric convex bodies [4,26,28], our version is for general convex sets and might be of interest on its own. d) Our second method is for integer programming problems Ax = b, x ∈ Zn , 0 ≤ x ≤ u in equation standard form. We show that such a problem can be reduced  to 2O(n) · ( i log(u i + 1)) instances of (A PPROX -IP). This yields a running time of (log n)O(n) for such IPs, in which the variables are bounded by a polynomial in the dimension. The so-far best running time for such instances 2O(n) ·n n . Well known benchmark problems in this setting are knapsack and subset-sum with polynomial upper bounds on the variables, see Sect. 5. 1.2 Related Work If the convex body K is an ellipsoid, then the integer programming problem (IP) is the well known closest vector problem (CVP) which can be solved in time 2O(n) with an algorithm by Micciancio and Voulgaris [25]. Blömer and Naewe [7] previously observed that the sampling technique of Ajtai et al. [1] can be modified in such a way as to solve the closest vector approximately. More precisely, they showed that a (1 + )-approximation of the closest vector problem can be found in time O(2 + 1/)n time. This was later generalized to arbitrary convex sets by Dadush [11]. This algorithm either asserts that the convex body K does not contain any integer points, or it finds an integer point in the body stemming from K is scaled by (1+) from its center of gravity. Also the running time of this randomized algorithm is O(2 + 1/)n . In our paper, we restrict to the case  = 1 which can be solved in singly exponential time. The technique of reflection sets was also used by Eisenbrand et al. [13] to solve (CVP) in the ∞ -norm approximately in time O(2 + log(1/))n . In the setting in which integer programming can be attacked with dynamic programming, tight upper and lower bounds on the complexity are known [14,17,20]. Our n n · 2O(n) algorithm could be made more efficient by constraining the possible remainders of a solution (mod ) efficiently. This barrier is different than the one in  
   
  From Approximate to Exact Integer Programming  
   
  103  
   
  classical integer-programming methods that are based on branching on flat directions [16,23] as they result in a branching tree of size n O(n) . The subset-sum problem is as follows. Given a set Z ⊆ N of n positive integers and  a target value t ∈ N, determine whether there exists a subset S ⊆ Z with s∈S s = t . Subset sum is a classical NP-complete problem that serves as a benchmark in algorithm design. The problem can be solved in pseudopolynomial time [5] by dynamic programming. The current fastest pseudopolynomial-time algorithm is the one of Bringmann [8] that runs in time O(n + t ) up to polylogarithmic factors. There exist instances of subset-sum whose set of feasible solutions, interpreted as 0/1 incidence vectors, require numbers of value n n in the input, see [2]. Lagarias and Odlyzko [21] have shown that instances of subset sum in which each number of the input Z is 2 drawn uniformly at random from {1, . . . , 2O(n ) } can be solved in polynomial time with high probability. The algorithm of Lagarias and Odlyzko is based on the LLLalgorithm [22] for lattice basis reduction.  
   
  2 Preliminaries A lattice Λ is the set of integer combinations of linearly independent vectors, i.e. Λ := Λ(B ) := {B x | x ∈ Zr } where B ∈ Rn×r has linearly independent columns. The determinant is the volume of the r -dimensional parallelepiped spanned by the columns of the basis B , i.e. det(Λ) := detr (B T B ). We say that Λ has full rank if n = r . In that case the determinant is simply det(Λ)  = | detn (B )|. For a full rank lattice Λ, we denote the dual lattice by Λ∗ = {y ∈ Rn | x, y ∈ Z ∀x ∈ Λ}. Note that det(Λ∗ ) · det(Λ) = 1. For an introduction to lattices, we refer to [24]. A set Q ⊆ Rn is called a convex body if it is convex, compact and has a non-empty interior. A set Q is symmetric if Q = −Q. Recall that any symmetric convex body Q naturally induces a norm  · Q of the form xQ = min{s ≥ 0 | x ∈ sQ}. For a full rank lattice Λ ⊆ Rn and a symmetric convex body Q ⊆ Rn we denote λ1 (Λ,Q) := min{xQ | x ∈ Λ \ {0}} as the length of the shortest vector with respect to the norm induced by n Q. We denote the Euclidean ball by B 2n := {x ∈ Rn | x2 ≤ 1} and the ∞ -ball by B ∞ := n n n [−1, 1] . An (origin centered) ellipsoid is of the form E = A(B 2 ) where A : R → Rn is an invertible linear map. For any  such ellipsoid E there is a unique positive definite matrix M ∈ Rn×n so that x = x T M x. The barycenter (or centroid) of a convex  E 1 body Q is the point Voln (Q) Q x d x. We will use the following version of (A PPROX -IP) that runs in time 2O(n) , provided that the symmetrizer for the used center c is large enough. This is the case for c being the center of gravity, see Theorem 3. Note that the center of gravity of a convex body can be (approximately) computed in randomized polynomial time [6,12].  
   
  Theorem 1 (Dadush [11]). There is a 2O(n) -time algorithm A PX IP(K , c, Λ) that takes as input a convex set K ⊆ Rn , a point c ∈ K and a lattice Λ ⊆ Rn . Assuming that Voln ((K − c) ∩ (c − K )) ≥ 2−Θ(n) Voln (K ) the algorithm either returns a point x ∈ (c + 2(K − c)) ∩ Λ or returns EMPTY if K ∩ Λ = . One of the classical results in the geometry of numbers is Minkowski’s Theorem which we will use in the following form:  
   
  104  
   
  D. Dadush et al.  
   
  Theorem 2 (Minkowski’s Theorem). For a full rank lattice Λ ⊆ Rn and a symmetric convex body Q ⊆ Rn one has  det(Λ) 1/n λ1 (Λ,Q) ≤ 2 · Voln (Q) We will use the following bound on the density of sublattices which is an immediate consequence of Minkowski’s Second Theorem. Here we abbreviate λ1 (Λ) := λ1 (Λ, B 2n ). Lemma 1. Let Λ ⊆ Rn be a full rank lattice. Then for any k-dimensional sublattice 1 (Λ) k ˜ ⊆ Λ one has det(Λ) ˜ ≥ ( λ Λ ) . k  
   
  Finally, we revisit a few facts from convex geometry. Details and proofs can be found in the excellent textbook by Artstein-Avidan, Giannopoulos and Milman [3]. Lemma 2 (Grünbaum’s Lemma). Let K ⊆ Rn be any convex body and let 〈a, x〉 = β be any hyperplane through the barycenter of K . Then 1e Voln (K ) ≤ Voln ({x ∈ K | 〈a, x〉 ≤ β}) ≤ (1 − 1e )Voln (K ). For a convex body K , there are two natural symmetric convex bodies that approximate K in many ways: the “inner symmetrizer” K ∩ (−K ) (provided 0 ∈ K ) and the “outer symmetrizer” in form of the difference body K − K . The following is a consequence of a more general inequality of Milman and Pajor. Theorem 3. Let K ⊆ Rn be any convex body with barycenter 0. Then Voln (K ∩(−K )) ≥ 2−n Voln (K ). In particular Theorem 3 implies that choosing c as the barycenter of K in Theorem 1 results in a 2O(n) running time—however this will not be the choice that we will later make for c. Also the size of the difference body can be bounded: Theorem 4 (Inequality of Rogers and Shephard). For any convex body K ⊆ Rn one has Voln (K − K ) ≤ 4n Voln (K ).   Recall that for a convex body Q with 0 ∈ int(Q), the polar is Q ◦ = {y ∈ Rn | x, y ≤ 1 ∀x ∈ Q}. We will use the following relation between volume of a symmetric convex body and the volume of the polar; to be precise we will use the lower bound (which is due to Bourgain and Milman). Theorem 5 (Blaschke-Santaló-Bourgain-Milman). For any symmetric convex body Q ⊆ Rn one has Voln (Q) · Voln (Q ◦ ) Cn ≤ ≤1 Voln (B 2n )2 where C > 0 is a universal constant. We will also rely on the result of Frank and Tardos to reduce the bit complexity of constraints: Theorem 6 (Frank, Tardos [15]). There is a polynomial time algorithm that takes ˜ ∈ Zn+1 with a ˜ ≤ ˜ b) ˜ ∞ , |b| (a, b) ∈ Qn+1 and Δ ∈ N+ as input and produces a pair (a, O(n 3 ) O(n 2 ) ˜ x〉 = b˜ and 〈a, x〉 ≤ b ⇔ 〈a, ˜ x〉 ≤ b˜ for all ·Δ so that 〈a, x〉 = b ⇔ 〈a, 2 x ∈ {−Δ, . . . , Δ}n .  
   
  From Approximate to Exact Integer Programming  
   
  105  
   
  3 The Cut-Or-Average Algorithm First, we discuss our C UT-O R-AVERAGE algorithm that on input of a convex set K , a lattice Λ and integer  ≥ 5(n +1), either finds a point x ∈ Λ  ∩K or decides that K ∩Λ = O(n) n  
   
  in time 2 . Note that for any polyhedron K = {x ∈ R | Ax ≤ b} with rational A, b and lattice Λ with basis B one can compute a value of Δ so that log(Δ) is polynomial in the encoding length of A, b and B and K ∩Λ = if and only if K ∩[−Δ, Δ]n ∩Λ = . See Schrijver [31] for details. In other words, w.l.o.g. we may assume that our convex set is bounded. The pseudo code of the algorithm can be found in Fig. 1. An intuitive description of the algorithm is as follows: we compute the barycenter c of K and an ellipsoid E that approximates K up to a factor of R = n + 1. Then we iteratively use the oracle for approximate integer programming from Theorem 1 to find a convex combination z of lattice points in a 3-scaling of K until z is close to the barycenter c. If this succeeds, then we can directly use an asymmetric version of the Approximate Carathéodory Theorem (Lemma 9) to find an unweighted average of  lattice points that lies in K ; this would be a vector of the form x ∈ Λ  ∩ K . If the algorithm fails to approximately express c as a convex combination of lattice points, then we will have found a hyperplane H going almost through the barycenter c so that K ∩ H≥ does not contain a lattice point. Then the algorithm continues searching in K ∩ H≤ (Fig. 2). This case might happen repeatedly, but after polynomial number of times, the volume of K will have dropped below a threshold so that we may recurse on a single (n − 1)-dimensional subproblem. We will now give the detailed analysis. Note that in order to obtain a clean exposition we did not aim to optimize any constant. However by merely tweaking the parameters one could make the choice of  = (1 + ε)n work for any constant ε > 0. 3.1 Bounding the Number of Iterations We begin the analysis with a few estimates that will help us to bound the number of iterations. Lemma 3. Any point x found in line (7) lies in a 3-scaling of K around c, i.e. x ∈ c + 3(K − c) assuming 0 < ρ ≤ 1. Proof. We verify that x ∈ (c − ρd ) + 2(K − (c − ρd )) = c + 2(K − c) + ρd ⊆ c + 3(K − c) using that ρd E = ρ ≤ 1. Next we bound the distance of z to the barycenter: Lemma 4. At the beginning of the kth iterations of the WHILE loop on line (5), one 2 has c − z2E ≤ 9Rk . Proof. We prove the statement by induction on k. At k = 1, by construction on line (4), z ∈ c + 2(K − c) ⊆ c + 2R E . Thus c − z2E ≤ (2R)2 ≤ 9R 2 , as needed.  
   
  106  
   
  D. Dadush et al.  
   
  Fig. 1. The Cut-Or-Average algorithm.  
   
  ρ Fig. 2. Visualization of the inner WHILE loop where Q := K ∩ {x ∈ Rn | 〈a, x〉 ≥ a, c + 2 d }.  
   
  Now assume k ≥ 2. Let z, z  denote the values of z during iteration k − 1 before and after the execution of line (9) respectively, and let x be the vector found on line (7) during iteration k −1. Note that z  = (1− k1 )z + k1 x. By the induction hypothesis, we have that z − c2E ≤ 9R 2 /(k − 1). Our goal is to show that z  − c2E ≤ 9R 2 /k. Letting d denote the normalized version of z − c, we see that d E = 1 and hence d ∈ K − c. By construction 〈a, x − c〉 ≥ 0 and from Lemma 3 we have x ∈ c + 3(K − c) which implies  
   
  From Approximate to Exact Integer Programming  
   
  107  
   
  x − cE ≤ 3R. The desired bound on the E -norm of z  − c follows from the following calculation: 2  1 1 z  − c2E = 1 − (z − c) + (x − c) E k k   1 1 2 1 1 2 〈a, x − c〉 + 2 x − c2E = 1− z − cE − 2 1 − k k k k  1 2 1 ≤ 1− z − c2E + 2 x − c2E k k  1 1 2 1 9R 2 + 2 · 9R 2 = . ≤ 1− k k −1 k k In particular Lemma 4 implies an upper bound on the number of iterations of the inner WHILE loop: Corollary 1. The WHILE loop on line (5) never takes more than 36R 2 iterations. Proof. By Lemma 4, for k := 36R 2 one has c − z2E ≤  
   
  9R 2 k  
   
  ≤ 14 .  
   
  Next, we prove that every time we replace K by K  ⊂ K in line (8), its volume drops by a constant factor. ρ  
   
  Lemma 5. In step (8) one has Voln (K  ) ≤ (1 − 1e ) · (1 + 2 )n · Voln (K ) for any ρ ≥ 0. In 1 one has Voln (K  ) ≤ 34 Voln (K ). particular for 0 ≤ ρ ≤ 4n Proof. The claim is invariant under affine linear transformations, hence we may assume w.l.o.g. that E = B 2n , M = I n and c = 0. Note that then B 2n ⊆ K ⊆ RB 2n . Let us abbreviate K ≤t := {x ∈ K | 〈d , x〉 ≤ t }. In this notation K  = K ≤ρ/2 . Recall that Grünbaum’s Lemma (Lemma 2) guarantees that  
   
  1 e  
   
  ≤  
   
  Voln (K ≤0 ) Voln (K )  
   
  ≤ 1 − 1e . Moreover, it is well  
   
  known that the function t → Voln (K ≤t )1/n is concave on its support, see again [3]. Then Voln (K ≤0 )1/n ≥  
   
    
   
   ρ/2 1 · Voln (K ≤ρ/2 )1/n + · Voln (K ≤−1 )1/n   1 + ρ/2 1 + ρ/2  
   
  1 · Voln (K ≤ρ/2 )1/n ≥ 1 + ρ/2   
   
  and so  
   
    
   
  1−  
   
  ≥0  
   
   1 n 1 · Voln (K ) ≥ Voln (K ≤0 ) ≥ · Voln (K ≤ρ/2 ) e 1 + ρ/2 ρ  
   
  Rearranging gives the first claim in the form Voln (K ≤ρ/2 ) ≤ (1 − 1e ) · (1 + 2 )n · Voln (K ). ρ ρ 1 For the 2nd part we verify that for ρ ≤ 4n one has (1− 1e )·(1+ 2 )n ≤ (1− 1e )·exp( 2 ) ≤ 34 . Lemma 6. Consider a call of C UT-O R-AVERAGE on (K , Λ) where K ⊆ r B 2n for some r > 0. Then the total number of iterations of the outer WHILE loop over all recursion levels is bounded by O(n 2 log( λ1nr(Λ) )).  
   
  108  
   
  D. Dadush et al.  
   
  Proof. Consider any recursive run of the algorithm. The convex set will be of the ˜ := Λ ∩ U where U is a subform K˜ := K ∩ U and the lattice will be of the form Λ ˜ as n-dimensional ˜ space and we denote n˜ := dim(U ). We think of K˜ and Λ objects. Let K˜ t ⊆ K˜ be the convex body after t iterations of the outer WHILE loop. Recall that Voln˜ (K˜ t ) ≤ ( 34 )t · Voln˜ (K˜ ) by Lemma 5 and Voln˜ (K˜ ) ≤ r n˜ Voln˜ (B 2n˜ ). Our goal is to show ˜ ∗ with y ˜ ˜ ◦ ≤ 1 that for t large enough, there is a non-zero lattice vector y ∈ Λ (K t −K t )  
   
  2  
   
  which then causes the algorithm to recurse. To prove existence of such a vector y, we use Minkowski’s Theorem (Theorem 2) followed by the Blaschke-Santaló-BourgainMilman Theorem (Theorem 5) to obtain ˜ ∗ , (K˜ t − K˜ t )◦ ) λ1 (Λ  
   
  1/n˜ ˜ ∗) det(Λ ◦ Voln˜ ((K˜ t − K˜ t ) )  Vol (K˜ − K˜ ) 1/n˜ Thm 5 t t n˜ ≤ 2C · ˜ · Voln˜ (B n˜ )2 det(Λ) 2  1/n˜ Thm 4 Voln˜ (K˜ t ) n˜  ·C ≤ 2·4· ˜ · Voln˜ (B n˜ ) 2 det(Λ) 2  
   
  Thm 2  
   
    
   
  ≤  
   
  2·  
   
  ≤  
   
   n˜ · r (3/4)t /n˜ · (3/4)t /n˜ 4C n˜ · r · ≤ 4C · ˜ 1/n˜ λ1 (Λ) det(Λ)  
   
  n˜ Here we use the convenient estimate of Voln˜ (B 2n˜ ) ≥ Voln˜ ( 1 B ∞ ) = ( 2 )n˜ . Moreover, n˜  
   
  n˜  
   
  ˜ 1 (Λ) n ˜ ≥ ( λ we have used that by Lemma 1 one has det(Λ) ) ˜ . Then t = Θ(n˜ log( λ1nr (Λ) )) n˜ 1 ˜ ∗ , (K˜ t − K˜ t )◦ ) ≤ and the algorithm recurses. Hence the iterations suffice until λ1 (Λ 2  
   
  total number of iterations of the outer WHILE loop over all recursion levels can be bounded by O(n 2 log( λ1nr(Λ) )). The iteration bound of Lemma 6 can be improved by amortizing the volume reduction over the different recursion levels following the approach of Jiang [18]. We refrain from that to keep our approach simple. 3.2 Correctness and Efficiency of Subroutines Next, we verify that the subroutines are used correctly. The proofs in this section are deferred to the full version of this paper. Lemma 7. For any convex body K ⊆ Rn one can compute the barycenter c and a 0centered ellipsoid E in randomized polynomial time so that c + E ⊆ K ⊆ c + (n + 1)E . In order for the call of A PX IP in step (7) to be efficient, we need that the symmetrizer of the set is large enough volume-wise, see Theorem 1. In particular for any ˜ ∩ (c˜ − Q)) ≥ parameters 2−Θ(n) ≤ ρ ≤ 0.99 and R ≤ 2O(n) we will have Voln ((Q − c) −Θ(n) 2 Voln (Q) which suffices for our purpose.  ρ  Lemma 8. In step (7), the set Q := {x ∈ K | 〈a, x〉 ≥ a, c + 2 d } and the point c˜ := c+ρd ρ ˜ ∩ (c˜ −Q)) ≥ (1 − ρ)n · 2R · 2−n · Voln (Q). satisfy Voln ((Q − c)  
   
  From Approximate to Exact Integer Programming  
   
  109  
   
  3.3 Conclusion on the Cut-Or-Average Algorithm From the discussion above, we can summarize the performance of the algorithm in Fig. 1 as follows: Theorem 7. Given a full rank matrix B ∈ Qn×n and parameters r > 0 and  ≥ 5(n + 1) with  ∈ N and a separation oracle for a closed convex set K ⊆ r B 2n , there is a randomized algorithm that with high probability finds a point x ∈ K ∩ 1 Λ(B ) or decides that K ∩Λ(B ) = . Here the running time is 2O(n) times a polynomial in log(r ) and the encoding length of B . This can be easily turned into an algorithm to solve integer linear programming: Theorem 8. Given a full rank matrix B ∈ Qn×n , a parameter r > 0 and a separation oracle for a closed convex set K ⊆ r B 2n , there is a randomized algorithm that with high probability finds a point x ∈ K ∩ Λ(B ) or decides that there is none. The running time is 2O(n) n n times a polynomial in log(r ) and the encoding length of B . Proof. Suppose that K ∩ Λ = and fix an (unknown) solution x ∗ ∈ K ∩ Λ. We set  := 5(n + 1). We iterate through all v ∈ {0, . . . ,  − 1}n and run Theorem 7 on the set K and the shifted lattice v + Λ. For the outcome of v with x ∗ ≡ v mod  one has K ∩ (v + Λ) = and so the algorithm will discover a point x ∈ K ∩ (v + Λ).  
   
  4 An Asymmetric Approximate Carathéodory Theorem The Approximate Carathéodory Theorem states the following. Given any point-set X ⊆ B 2n in the unit ball with 0 ∈ conv(X ) and a parameter k ∈ N, there exist u 1 , . . . , u k ∈ X (possibly with repetition) such that 1    k u i ≤ O 1/ k . k i =1 2  
   
  The theorem is proved, for example, by Novikoff [28] in the context of the perceptron algorithm. An p -version was provided by Barman [4] to find Nash equilibria. Deterministic and nearly-linear time methods to find the convex combination were recently described in [26]. In the following, we provide a generalization to asymmetric convex bodies and the dependence on k will be weaker but sufficient for our analysis of our C UT- OR-AVERAGE algorithm from Sect. 3. Recall that with a symmetric convex body K , we one can associate the Minkowski norm  · K with xK = inf{s ≥ 0 | x ∈ sK }. In the following we will use the same definition also for an arbitrary convex set K with 0 ∈ K . Symmetry is not given but one still has x + yK ≤ xK + yK for all x, y ∈ Rn and αxK = αxK for α ∈ R≥0 . Using this notation we can prove the main result of this section. Lemma 9. Given a point-set X ⊆ K contained in a convex set K ⊆ Rn with 0 ∈ conv(X ) and a parameter k ∈ N, there exist u 1 , . . . , u k ∈ X (possibly with repetition) so that 1  k u i ≤ min{|X |, n + 1}/k. k i =1 K  
   
  110  
   
  D. Dadush et al.  
   
  Moreover, given X as input, the points u 1 , . . . , u k can be found in time polynomial in |X |, k and n. Proof. Let  = min{|X |, n + 1}. The claim is true whenever k ≤  since then we may simply pick an arbitrary point in X . Hence from now on we assume k > . By Carathéodory’s theorem, there exists a convex combination of zero, using    elements of X . We write 0 = i =1 λi v i where v i ∈X , λi ≥ 0 for i ∈ [] and i =1 λi = 1.  Consider the numbers L i = (k − )λi + 1. Clearly, i =1 L i = k. This implies that there  exists an integer vector μ ∈ N with μ ≥ (k − )λ and i =1 μi = k. It remains to show that we have 1   μi v i ≤ /k. k i =1 K  
   
  In fact, one has       μi v i = (μi − (k − )λi ) v i + (k − ) λi v i    
   
  K K    
   
  i =1 i =1 i =1 ≥0  
   
  ≤  
   
  ≥0  
   
    (μi − (k − )λi ) v i K +(k − ) λi v i ≤ .  
   
    K i =1 i =1  
   
    ≤1    
   
  =0  
   
  For the moreover part, note that the coefficients λ1 , . . . , λ are the extreme points of a linear program which can be found in polynomial time. Finally, the linear system  μ ≥ (k − )λ, i =1 μi = k has a totally unimodular constraint matrix and the right hand side is integral, hence any extreme point solution is integral as well, see e.g. [31]. Lemma 10. For any integer  ≥ 5(n + 1), the convex combination μ computed in line  (10) satisfies x∈X μx x ∈ K . Proof. We may translate the sets X and K so that c = 0 without affecting the claim. Recall that z ∈ conv(X ). By Carathéodory’s Theorem there are v 1 , . . . , v m ∈ X with m ≤ n + 1 so that z ∈ conv{v 1 , . . . , v m } and so 0 ∈ conv{v 1 − z, . . . , v m − z}. We have v i ∈ 3K by Lemma 3 and −z ∈ 14 E ⊆ 14 K as well as z ∈ 14 K . Hence v i − zK ≤ v i K +− zK ≤ m Zm 13 ≥0 4 . We apply Lemma 9 and obtain a convex combination μ ∈  with  i =1 μi (v i − m z) 13 K ≤  . Then 4  
   
    m m 13 m 1 + ≤1 μi v i ≤ μi (v i − z) + zK ≤  
   
    K K 4  4 i =1 i =1 ≤1/4  
   
  if  ≥  
   
  13 3 m. This is satisfies if  ≥ 5(n + 1).  
   
  5 IPs with Polynomial Variable Range Now we come to our second method that reduces (IP) to (A PPROX -IP) that applies to integer programming in standard equation form Ax = b, x ∈ Zn , 0 ≤ x i ≤ u i , i = 1, . . . , n,  
   
  (2)  
   
  From Approximate to Exact Integer Programming  
   
  111  
   
  Here, A ∈ Zm×n , b ∈ Zm , and the u i ∈ N+ are positive integers that bound the variables from above. Our main goal is to prove the following theorem. Theorem 9. The integer feasibility problem in standard equation form (see (2)) can  be solved in time 2O(n) ni=1 log2 (u i + 1). We now describe the algorithm. It is again based on the approximate integer programming technique of Dadush [11]. We exploit it to solve integer programming exactly via the technique of reflection sets developed by Cook et al. [9]. For each i = 1, . . . , n we consider the two families of hyperplanes that slice the feasible region with the shifted lower and upper bounds respectively x i = 2 j −1 and x i = u i − 2 j −1 , 0 ≤ j ≤ log2 (u i ).  
   
  (3)  
   
  Following [9], we consider two points w, v that lie in the region between two consecutive planes x i = 2 j −1 and x i = 2 j for some j . Suppose that w i ≤ v i holds. Let s be the point such that w = 1/2(s + v). The line-segment s, v is the line segment w, v scaled by a factor of 2 from v. Let us consider what can be said about the i -th component of s. Clearly s i ≥ 2 j −1 − (2 j − 2 j −1 ) = 0. Similarly, if w and v lie in the region in-between x i = 0 and x i = 1/2, then s i ≥ −1/2. We conclude with the following observation. Lemma 11. Consider the hyperplane arrangement defined by the equations (3) as well as by x i = 0 and x i = u i for 1 ≤ i ≤ n. Let K ⊆ Rn a cell of this hyperplane arrangement and v ∈ K . If K  is the result of scaling K by a factor of 2 from v, i.e. K  = {v + 2(w − v) | w ∈ K }, then K  satisfies the inequalities −1/2 ≤ x i ≤ u i + 1/2 for all 1 ≤ i ≤ n. We use this observation to prove Theorem 9: Proof (Proof of Theorem 9). The task of (2) is to find an integer point in the affine subspace defined by the system of equations Ax = b that satisfies the bound constraints 0 ≤ x i ≤ u i . We first partition the feasible region with the hyperplanes (3) as well as x i = 0 and x i = u i for each i . We then apply the approximate integer programming algorithm with approximation factor 2 on each convex set P K = {x ∈ Rn | Ax = b} ∩ K where K ranges over all cells of the arrangement. In 2O(n) time, the algorithm either finds an integer point in the convex set C K that results from P K by scaling it with a factor of 2 from its center of gravity, or it asserts that P K does not contain an integer point. Clearly, C K ⊆ {x ∈ Rn | Ax = b} and if the algorithm returns an integer point x ∗ , then, by Lemma 11, this integer point also satisfies the bounds 0 ≤ x i ≤ u i . The running time of the algorithm is equal to the number of cells times 2O(n) which is  2O(n) ni=1 log2 (u i + 1). IPs in Inequality Form We can also use Theorem 9 to solve integer linear programs in inequality form. Here the efficiency is strongly dependent on the number of inequalities.  
   
  112  
   
  D. Dadush et al.  
   
  Theorem 10. Let A ∈ Qm×n , b ∈ Qm , c ∈ Qn and u ∈ Nn+ . Then the integer linear program   max 〈c, x〉 | Ax ≤ b, 0 ≤ x ≤ u, x ∈ Zn can be solved in time n O(m) · (2 log(1 + Δ))O(n+m) where Δ := max{u i | i = 1, . . . , n}. Proof. Via binary search it suffices to solve the feasibility problem 〈c, x〉 ≥ γ, Ax ≤ b, 0 ≤ x ≤ u, x ∈ Zn  
   
  (4)  
   
  in the same claimed running time. We apply the result of Frank and Tardos (Theorem 6) and replace c, γ, A, b by integer-valued objects of bounded ·∞ -norm so that the feasible region of (4) remains the same. Hence we may indeed assume that c ∈ Zn , 3 2 γ ∈ Z, A ∈ Zm×n and b ∈ Zm with c∞ , |γ|, A∞ , b∞ ≤ 2O(n ) · ΔO(n ) . Any feasible solution x to (4) has a slack bounded by γ−〈c, x〉 ≤ |γ|+c∞ ·n ·Δ ≤ N where we may 3 2 choose N := 2O(n ) ΔO(n ) . Similarly b i − A i x ≤ N for all i ∈ [n]. We can then introduce slack variables y ∈ Z≥0 and z ∈ Zm ≥0 and consider the system 〈c, x〉 + y = γ, Ax + z = b, 0 ≤ x ≤ u, 0 ≤ y ≤ N , 0 ≤ z j ≤ N ∀ j ∈ [m], (x, y, z) ∈ Zn+1+m  
   
  (5)  
   
  in equality form which is feasible if and only if (4) is feasible. Then Theorem 9 shows that such an integer linear program can be solved in time 2O(n+m) ·  
   
   n i =1  
   
  ln(1 + u i ) · (ln(1 + N ))m+1 ≤ n O(m) · (2 log(1 + Δ))O(n+m) .  
   
  Subset Sum and Knapsack The subset-sum problem (with multiplicities) is an integer program of the form (2) with one linear constraint. Polak and Rohwedder [29] have shown that subset-sum  with multiplicities—that means ni=1 x i z i = t , 0 ≤ x i ≤ u i ∀i ∈ [n], x ∈ Zn —can be 5/3 solved in time O(n+z max ) times a polylogarithmic factor where z max := maxi =1,...,n z i . The algorithm of Frank and Tardos [15] (Theorem 6) finds an equivalent instance in 3  
   
  2  
   
  O(n ) . All-together, if each multiplicity is bounded which z max is bounded by 2O(n ) u max by a polynomial p(n), then the state-of-the-art for subset-sum with multiplicities is straightforward enumeration resulting in a running time n O(n) which is the current best running time for integer programming. We can significantly improve the running time in this regime. This is a direct consequence of Theorem 10.  Corollary 2. The subset sum problem with multiplicities of the form ni=1 x i z i = t , 0 ≤ x ≤ u, x ∈ Zn can be solved in time 2O(n) · (log(1 + u∞ ))n . In particular if each multiplicity is bounded by a polynomial p(n), then it can be solved in time (log n)O(n) .  
   
  Knapsack with multiplicities is the following integer programming problem   max 〈c, x〉 | x ∈ Zn≥0 , 〈a, x〉 ≤ β, 0 ≤ x ≤ u ,  
   
  (6)  
   
  From Approximate to Exact Integer Programming  
   
  113  
   
  where c, a, u ∈ Zn≥0 are integer vectors. Again, via the preprocessing algorithm of Frank and Tardos [15] (Theorem 6) one can assume that c∞ as well as a∞ are 3 O(n 2 ) . If each u i is bounded by a polynomial in the dimenbounded by 2O(n ) u max sion, then the state-of-the-art for this problem is again straightforward enumeration which leads to a running time of n O(n) . Also in this regime, we can significantly improve the running time which is an immediate consequence of Theorem 10. Corollary 3. A knapsack problem (6) can be solved in time 2O(n) · (log(1 + u∞ ))n . In particular if u∞ is bounded by a polynomial p(n) in the dimension, it can be solved in time (log n)O(n) .  
   
  References 1. Miklós Ajtai, R.K., Sivakumar, D.: A sieve algorithm for the shortest lattice vector problem. In: Proceedings of the Thirty-Third Annual ACM Symposium on Theory of Computing, pp. 601–610 (2001) ˜ V.H.: Anti-hadamard matrices, coin weighing, threshold gates, and indecom2. Alon, N., Vu, posable hypergraphs. J. Comb. Theory Ser. A 79(1), 133–160 (1997) 3. Artstein-Avidan, S., Giannopoulos, A., Milman, V.D.: Asymptotic geometric analysis. Part I, Volume 202 of Mathematical Surveys and Monographs. American Mathematical Society, Providence, RI (2015) 4. Barman, S.: Approximating nash equilibria and dense bipartite subgraphs via an approximate version of Caratheodory’s theorem. In: Proceedings of the Forty-Seventh Annual ACM Symposium on Theory of Computing, pp. 361–369 (2015) 5. Bellman, R.: Dynamic programming. Science 153(3731), 34–37 (1966) 6. Bertsimas, D., Vempala, S.: Solving convex programs by random walks. J. ACM (JACM) 51(4), 540–556 (2004) 7. Blömer, J., Naewe, S.: Sampling methods for shortest vectors, closest vectors and successive minima. Theor. Comput. Sci. 410(18), 1648–1665 (2009) 8. Bringmann, K.: A near-linear pseudopolynomial time algorithm for subset sum. In: Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 1073–1084. SIAM (2017) 9. Cook, W., Hartmann, M., Kannan, R., McDiarmid, C.: On integer points in polyhedra. Combinatorica 12(1), 27–37 (1992) 10. Dadush, D.: Integer Programming, Lattice Algorithms, and Deterministic Volume Estimation. Georgia Institute of Technology (2012) 11. Dadush, D.: A randomized sieving algorithm for approximate integer programming. Algorithmica 70(2), 208–244 (2014) 12. Dyer, M., Frieze, A., Kannan, R.: A random polynomial-time algorithm for approximating the volume of convex bodies. J. ACM 38(1), 1–17 (1991) 13. Eisenbrand, F., Hähnle, N., Niemeier, M.: Covering cubes and the closest vector problem. In: Proceedings of the Twenty-Seventh Annual Symposium on Computational Geometry, pp. 417–423 (2011) 14. Eisenbrand, F., Weismantel, R.: Proximity results and faster algorithms for integer programming using the Steinitz lemma. ACM Trans. Algorithms (TALG) 16(1), 1–14 (2019) 15. Frank, A., Tardos, É.: An application of simultaneous diophantine approximation in combinatorial optimization. Combinatorica 7(1), 49–65 (1987) 16. Grötschel, M., Lovász, L., Schrijver, A.: Geometric Algorithms and Combinatorial Optimization. Algorithms and Combinatorics, vol. 2. Springer, Heidelberg (1988). https://doi. org/10.1007/978-3-642-78240-4  
   
  114  
   
  D. Dadush et al.  
   
  17. Jansen, K., Rohwedder, L.: On integer programming and convolution. In: 10th Innovations in Theoretical Computer Science Conference (ITCS 2019). Schloss Dagstuhl-LeibnizZentrum fuer Informatik (2018) 18. Jiang, H.: Minimizing convex functions with integral minimizers. In: SODA, pp. 976–985. SIAM (2021) 19. Kannan, R.: Minkowski’s convex body theorem and integer programming. Math. Oper. Res. 12(3), 415–440 (1987) 20. Knop, D., Pilipczuk, M., Wrochna, M.: Tight complexity lower bounds for integer linear programming with few constraints. ACM Trans. Comput. Theory (TOCT) 12(3), 1–19 (2020) 21. Lagarias, J.C., Odlyzko, A.M.: Solving low-density subset sum problems. J. ACM (JACM) 32(1):229–246 (1985) 22. Lenstra, A.K., Lenstra, H.W., Lovász, L.: Factoring polynomials with rational coefficients. Mathematische annalen 261(ARTICLE), 515–534 (1982) 23. Lenstra Jr., H.W.: Integer programming with a fixed number of variables. Math. Oper. Res. 8(4), 538–548 (1983) 24. Micciancio, D., Goldwasser, S.: Complexity of lattice problems - a cryptograhic perspective. The Kluwer International Series in Engineering and Computer Science, vol. 671. Springer, New York (2002). https://doi.org/10.1007/978-1-4615-0897-7 25. Micciancio, D., Voulgaris, P.: A deterministic single exponential time algorithm for most lattice problems based on voronoi cell computations. In: Proceedings of the Forty-Second ACM Symposium on Theory of Computing, pp. 351–358 (2010) 26. Mirrokni, V., Leme, R.P., Vladu, A., Wong, S.C.: Tight bounds for approximate Carathéodory and beyond. In: International Conference on Machine Learning, pp. 2440–2448. PMLR (2017) 27. Nemhauser, G.L., Wolsey, L.A.: Integer programming. In: Nemhauser, G.L., et al. (eds.) Optimization. Handbooks in Operations Research and Management Science, chapter VI, vol. 1, pp. 447–527. Elsevier (1989) 28. Novikoff, A.B.: On convergence proofs for perceptrons. Technical report, Office of Naval Research, Washington, D.C. (1963) 29. Polak, A., Rohwedder, L., W˛egrzycki, K.: Knapsack and subset sum with small items. In: 48th International Colloquium on Automata, Languages, and Programming (ICALP 2021), number CONF, pp. 106–1. Schloss Dagstuhl-Leibniz-Zentrum für Informatik (2021) 30. Schrijver, A.: Polyhedral combinatorics. In: Graham, R., Grötschel, M., Lovász, L. (eds.) Handbook of Combinatorics, chapter 30, vol. 2, pp. 1649–1704. Elsevier (1995) 31. Schrijver, A.: Theory of Linear and Integer Programming. Wiley-Interscience Series in Discrete Mathematics and Optimization. Wiley, Hoboken (1999)  
   
  Optimizing Low Dimensional Functions over the Integers Daniel Dadush1 , Arthur L´eonard2 , Lars Rohwedder3(B) , and Jos´e Verschae4 1  
   
  4  
   
  CWI, Amsterdam, Netherlands [email protected]  2 ENS, Paris, France [email protected]  3 Maastricht University, Maastricht, Netherlands [email protected]  Pontiﬁcia Universidad Cat´ olica de Chile, Santiago, Chile [email protected]   
   
  Abstract. We consider box-constrained integer programs with objective g(W x) + cT x, where g is a “complicated” function with an m dimensional domain. Here we assume we have n  m variables and that W ∈ Zm×n is an integer matrix with coeﬃcients of absolute value at most Δ. We design an algorithm for this problem using only the mild assumption that the objective can be optimized eﬃciently when all but m variables are ﬁxed, 2 yielding a running time of nm (mΔ)O(m ) . Moreover, we can avoid the term m n in several special cases, in particular when c = 0. Our approach can be applied in a variety of settings, generalizing several recent results. An important application are convex objectives of low domain dimension, where we imply a recent result by Hunkenschr¨ oder et al. [SIOPT’22] for the 0-1-hypercube and sharp or separable convex g, assuming W is given explicitly. By avoiding the direct use of proximity results, which only holds when g is separable or sharp, we match their running time and generalize it for arbitrary convex functions. In the case where the objective is only accessible by an oracle and W is unknown, we further show that their proximity framework can be implemented in 2 3 n(mΔ)O(m ) -time instead of n(mΔ)O(m ) . Lastly, we extend the result by Eisenbrand and Weismantel [SODA’17, TALG’20] for integer programs with few constraints to a mixed-integer linear program setting where integer variables appear in only a small number of diﬀerent constraints.  
   
  1  
   
  Introduction  
   
  Integer programming has played a crucial role in many areas of computer science, operations research, and more recently, data science. Its modelling power allows The ﬁrst author has received funding from the European Research Council (ERC) under the European Unions Horizon 2020 research and innovation programme: grant agreement QIP805241. The fourth author was partially funded by Fondecyt grant Nr. 1221460 and Centro de Modelamiento Matem´ atico (CMM), FB210005, BASAL funds, ANID-Chile. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 115–126, 2023. https://doi.org/10.1007/978-3-031-32726-1_9  
   
  116  
   
  D. Dadush et al.  
   
  to capture a large diversity of settings. However, its general intractability makes it challenging to derive a general algorithmic theory, and hence the focus has been to consider meaningful special cases. The main theoretical result in this area has been the algorithm by Lenstra [10], and the improvement by Kannan [7], which show that integer programs are tractable as long as the dimension is constant. In recent years, a surge of interest appeared regarding eﬃcient algorithms for integer programs under other assumptions. More recently, the seminal work by Eisenbrand and Weismantel [4] for integer programs with a constant number of constraints and bounded matrix coeﬃcients sparked a new trend of improved algorithms and lower bounds; see, e.g., [2,6,9]. In this paper, we study a new general framework that encompasses and further extends many of the settings found in the literature. Consider the problem of optimizing a low dimensional objective function over a high dimensional space Zn . Formally, the problem is deﬁned as min cT x + g(W x) i ≤ xi ≤ ui  
   
  for all i ∈ {1, 2, . . . , n},  
   
  (1)  
   
  n  
   
  x∈Z . We assume that W ∈ Zm×n has entries of absolute value at most Δ. Here, W can be interpreted as a projection matrix to a space of low dimension m  n, where then the function g : Rm → R ∪ {∞} is applied to the projection. We can think of W as extracting a relatively small set of features from x. The vectors  ∈ (Z ∪ {−∞})n and u ∈ (Z ∪ {∞})n are arbitrary variable bounds and c represents a linear cost function. Crucially, we only make a very mild assumption on g, namely that we can ˙ = [n] with solve (1) when all but m of the variables are ﬁxed: given any I ∪J J |I| = m and any ﬁxing z ∈ Z of the J-variables, we require that min  
   
  cI x + g(WI x + WJ z)  
   
  s.t.  
   
  i ≤ xi ≤ ui  
   
  for all i ∈ I,  
   
  (2)  
   
  I  
   
  x∈Z , can be solved eﬃciently. Here cI = (ci )i∈I is the vector c restricted to indices in I and similarly WI (resp. WJ ) is the matrix W restricted to columns indexed by I (resp. J). The requirement is intuitively necessary, because the only plausible approach to eﬃciently solve the very general setting (1) is to exploit that the function g is low dimensional. If we cannot even optimize over it in a low dimensional coordinate subspace of Zn , then there is no hope to optimize over it on all of Zn . Perhaps the most natural such setting is when g is convex and can be accessed through gradient and function evaluation queries. Then (2) can be solved in time that is exponential only in m, but polynomial in the other input parameters, by the Lenstra-Kannan algorithm [7,10]. If g is indeed convex, the Lenstra-Kannan algorithm can also be used to O(m) ·input O(1) , where input denotes the encoding directly solve (1) in time ΔΔ size of the input. Indeed, we can merge variables with the same columns in  
   
  Optimizing Low Dimensional Functions  
   
  117  
   
  W , which reduces the dimension of the problem to n = (2Δ + 1)m . Notice that the linear part of the objective may not remain linear, but it does remain convex. Thus, we can apply Lenstra-Kannan to solve the problem in the claimed running time. This indicates that the problem is tractable for small values of Δ and m. Our main result is an algorithm that avoids the double exponential running time. Theorem 1. For any function g, problem (1) can be solved in time 2  
   
  nm · (mΔ)O(m ) · Q , where Q is the query time of the oracle for (2). In particular, for a convex function g, the term Q can be replaced by input O(1) . We notice that in this theorem the bound of Q for the convex case follows by using the Lenstra-Kannan algorithm to solve the small dimensional subproblem (2). In this case, the mO(m) factor in the running time of the Lenstra-Kannan 2 algorithm can be omitted as it is upper bounded by (mΔ)O(m ) . Regarding the nm term, as we explain below, it can be made lower order in interesting concrete settings. We also remark that a term of the form Δm cannot be avoided due to reductions from integer linear programming (see Sect. 1.1) and lower bounds for that problem [6]. 1.1  
   
  Applications  
   
  Low dimensional convex functions. The main inspiration for this work is a recent study by Hunkenschr¨ oder, Pokutta, and Weismantel [5], who consider the problem (3) min n g(W x) , x∈{0,1}  
   
  m×n  
   
  where W ∈ Z with entries of absolute value at most Δ, g : Rm → R is a “nice” sharp or separable convex function, and the algorithm can make function and gradient evaluations to the objective g(W x). They further distinguish between the case where W is given explicitly and where W is unknown to the 2 algorithm. Assuming g is separable, they provide an n(mΔ)O(m ) -time algorithm 3 when W is known, and an n(mLΔ)O(m ) -time algorithm when W is unknown and g is assumed to have L-Lipschitz gradients1 . They show similar results when g is suitably “sharp”, though we omit the statements for concision. As a direct application of Theorem 1, we extend the result of [5] to arbitrary convex functions when W is known. Corollary 1. When W is known and g is an arbitrary convex function, problem (3) can be solved in time O(nm) + (mΔ)O(m 1  
   
  2  
   
  )  
   
  .  
   
  They further require g to have an integer valued gradient on integer inputs.  
   
  118  
   
  D. Dadush et al.  
   
  The reduction to Theorem 1 is as follows: we ﬁrst abandon the restriction of x ∈ {0, 1}n in favor of the general bounded integer variables. Then, since any two variables with the same column in the projection matrix W can be merged to one (by adapting the box-constraints), we may assume without loss of generality that n ≤ (2Δ + 1)m . One of the main motivations in the work by Hunkenschr¨ oder et al. [5] is to solve certain types of regression problems. For example, they examine an integer compressed sensing problem, where one receives a small number m of linear measurements of a high dimensional integral signal x∗ ∈ {0, 1}n which one would like to (approximately) reconstruct. The received measurements are of the form b = W x∗ , where W ∈ Zm×n is an unknown matrix with coeﬃcients of size at most Δ. As an approximation to x∗ , they compute the minimizer of min{ b − W x 2 : x ∈ {0, 1}n }, under the assumption that one can only access W indirectly via gradient and function evaluation queries to f (x) = b − W x 2 . As we will explain later, in the compressed sensing and related settings, one can essentially avoid any overhead from not knowing W . While we focus above on the case where W is known, using orthogonal techniques, we can also improve the running times in the unknown W setting by modifying the Hunkenschr¨ oder et al. framework. We defer further discussion of their framework and our related improvements to Sect. 4. Mixed-Integer Linear Programming. Eisenbrand and Weismantel [4] studied the complexity of integer programs of the form min cT x s.t. Ax = b, i ≤ xi ≤ ui x ∈ Zn .  
   
  (4) for all i ∈ {1, . . . , n},  
   
  Speciﬁcally, they considered the setting where A has few rows and then used 2 the Steinitz Lemma to obtain an algorithm with running time (mΔ)O(m ) · n, where Δ is the maximum absolute value in A. This has inspired a line of work for similar settings, see for example [3,6,8,9]. Our setting is a generalization of theirs: take A = W and let  0 if Ax = b, g(Ax) = ∞ otherwise. Here subproblem (2) corresponds to solving integer programming in m dimensions, which can be done using Lenstra-Kannan. Alternatively, one could model the problem as minimizing the convex function g(Ax) = Ax − b for some suitable norm. Moreover, our model generalizes beyond the scope of Eisenbrand and  
   
  Optimizing Low Dimensional Functions  
   
  119  
   
  Weismantel’s work to mixed-integer linear programming. Consider the problem min cT x + dT y s.t. Ax + By = b, i ≤ xi ≤ ui , x ∈ Zn ,  
   
  for all i ∈ {1, . . . , n}  
   
  (5)  
   
  y ∈ P ⊆ Rh . Here P is some polytope that can impose additional constraints on the continuous variables. We can encode this problem in (1) by setting W = A and  min{dT y : By = b − Ax, y ∈ P } if this minimum exists, g(Ax) = ∞ otherwise. Notice that the oracle problem (2) in this case forms a mixed-integer linear program itself, but with only m many integer variables; hence it can be solved eﬃciently with the algorithm by Lenstra-Kannan. Corollary 2. Assuming P can be eﬃciently separated over, problem (5) can be solved in time 2 nm · (mΔ)O(m ) · input O(1) . We emphasize here that Δ is only a bound on the entries of A, but not necessarily on those of B. Compared to the algorithm for the pure integer setting in [4], our running time has an extra factor of nm , which however vanishes in some settings: for example, when c = 0 or ui = ∞ for all i. In those cases we can again merge variables that share the same column in W . The only other example we are aware of that extends Eisenbrand and Weismantel’s setting to mixed-integer linear programming is the work by Brand, Kouteck´ y, and Ordyniak [2]. Their setting can be considered orthogonal to ours. On the one hand, they study a much more general structure of bounded treedepth programs, of which integer programs with a bounded number of constraints are the simplest special case. On the other hand, they impose these structural restrictions also on the continuous variables (and additionally bounds on their coeﬃcients), whereas we impose essentially no restrictions on the structure of continuous variables or their coeﬃcients. To appreciate this, let us remark a pleasing aspect of the (straight-forward) extension of Lenstra-Kannan to mixed-integer linear programs: it combines the tractability of integer programs in ﬁxed dimension with the tractability of linear programs in any dimension, achieving essentially a generalization of both. Eisenbrand and Weismantel’s algorithm, on the other hand, concerns the tractability of integer programs with a ﬁxed number of constraints (adding the necessary assumption that Δ is bounded). In a similar spirit to the aforementioned generalization, our algorithm combines this with the tractability of (arbitrary) linear programs.  
   
  120  
   
  D. Dadush et al.  
   
  Integer linear programming with few complex variables. Recall the integer programming setting (4) studied by Eisenbrand and Weismantel, for which they 2 gave an algorithm with running time (mΔ)O(m ) · n (with Δ being the maximum absolute value in A). The interesting parameter regime for this algorithm is therefore when m and Δ are very small. Already for m = 1 this formulation easily captures the Knapsack problem, which is weakly NP-hard and therefore we cannot hope to reduce the dependency on Δ to, say, log(Δ) while still maintaining polynomial dependency on n. In Lenstra-Kannan, on the other hand, the dependency on the coeﬃcients of the matrix is polynomial in the encoding size, i.e., in log(Δ), but the dependency on n is exponential. These two rather orthogonal results can be combined using Theorem 1. Corollary 3. Consider the integer programming problem in (4) and partition the columns of A into “simple” columns where the entries are bounded by Δ in absolute value and “complex” columns where they are arbitrary. Suppose that there are only k many complex columns. Then we can solve (4) in time 2  
   
  nm · (mΔ)m · k O(k) · input O(1) . For this we proceed as follows. Let S and C be the index sets of the simple and complex columns and accordingly let AS and AC be the matrix A restricted to these column sets. We deﬁne Problem (1) only on xS , the variables for the simple columns. Then let  min{cTC xC : AC xC = b − AS xS } g(AS xS ) = ∞  
   
  if this minimum exists, otherwise.  
   
  The resulting subproblem (2) is then an integer program with m + k variables that can be solved using Lenstra-Kannan. We note that one could even add to (4) arbitrary additional constraints on the complex columns and still solve the problem in the same way. Variable-sized Knapsack. Antoniadis et al. [1] introduce a variant of the Knapsack problem with a non-linear cost function associated with the used capacity. They show that the case where this function is concave is polynomial time solvable and describe an FPTAS for the convex case. Our result can be used to devise a pseudopolynomial time algorithm for the convex case: the problem can be expressed as   n   n  pi xi − g wi xi : xi ∈ {0, 1, . . . , ui } for all i . (6) max i=1  
   
  i=1  
   
  where pi is the proﬁt of item i, wi the weight, and ui ∈ Z≥0 ∪ {∞} is a bound on the number of items of this type. Straightforward generalizations to multidimensional knapsack follow in a similar way.  
   
  Optimizing Low Dimensional Functions  
   
  121  
   
  Corollary 4. For a convex function g, problem (6) can be solved in time (n + wmax )O(1) . Here, the oracle problem (2) reduces to a simple binary search. In general our result ﬁts well to problems with a similar spirit, where the constraints are not hard, but they induce some penalty. 1.2  
   
  Overview of Techniques  
   
  The related results for more restrictive cases in [4] and [5] are based on proximity: the continuous relaxation of the problem, where the integer requirement is omitted, is solved and if one can show that the solution for the relaxation and the actual solution diﬀer only slightly, then this can be exploited in reducing the search space. The precise proximity theorem in [4] is as follows. Theorem 2 (Eisenbrand and Weismantel [4]). Let z be an optimal vertex solution to the linear program   max cT x : Ax = b and i ≤ xi ≤ ui for all i , where A ∈ Zm×n has entries of size at most Δ. If there exists an integer solution, then there is also an optimal integer solution x∗ with  
   
  x∗ − z 1 ≤ m(2mΔ + 1)m . Hunkenschr¨ oder et al. [5] consider the optimal solution to the continuous relaxation of (3). In the special cases of separable convex and strict convex functions they show that a similar proximity holds, which is a crucial ingredient in their algorithm. Already for general convex functions, however, the proximity bound can be very large, as shown in an example in [5]. This forms a serious obstacle towards our main result. We manage to circumvent this and still rely on proximity by applying it in a diﬀerent way. Consider for sake of illustration that we were able to determine the value of b∗ = W x∗ , where x∗ is the optimal solution of (1). Then it would be easy to recover x∗ (solving our problem) by applying the integer linear programming algorithm by Eisenbrand and Weismantel [4]. The algorithm works by computing the continuous solution z to W x = b∗ and then using that z − x∗ 1 is bounded by Theorem 2. Indeed, this bound still holds in our case when ﬁxing b∗ . However, it is not clear how to compute or guess b∗ , nor how to compute z without knowing b∗ . Let us now consider the case that the domain of each variable is Z≥0 , which is slightly simpler than the bounded case. Here we may assume that z has only m non-zero components, which we can guess from nm candidates. We still do not know b∗ or z, but we trivially know z on the n − m zero components. Intuitively, this is enough to apply proximity to recover x∗ on the zero components of z. Moreover, recovering x∗ on the non-zero components of z is only an mdimensional problem, where we can apply the oracle problem (2).  
   
  122  
   
  D. Dadush et al.  
   
  For our general result with arbitrarily bounded variable domains, there is another obstacle: if we try to generalize the previous line of arguments, it is still true that there are only m “special” variables in z, namely variables that are not tight on either of their bounds. For the remaining variables, however, it is not immediately obvious whether they equal the lower bound or the upper bound and if we do not know this, it is unclear how to determine x∗ on these tight variables. We overcome this by guessing enough information about the dual so that we can use complementary slackness to infer which bound that the tight variables attain.  
   
  2  
   
  Non-negative Variables  
   
  For simplicity, in this section we ﬁrst prove our main result for the variable domain Z≥0 , that is, i = 0 and ui = ∞ for all i. Consider the optimal solution x∗ to (1) and deﬁne b∗ = W x∗ . Furthermore, let z be an optimal vertex solution to min{cT x : W x = b∗ , x ∈ Rn≥0 }. We emphasize that z is not necessarily integral. By Theorem 2 there is an optimal integer solution x to min{cT x : W x = b∗ , x ∈ Zn≥0 } with x − z 1 ≤ O(mΔ)m . We can assume without loss of generality that x = x∗ . Since z is a vertex solution, it has at least n − m zero components T . It follows that  
   
  x∗T 1 = x∗T − zT 1 ≤ x∗ − z 1 ≤ O(mΔ)m . Thus,  
   
  WT x∗T 1 ≤ mΔ · x∗T 1 ≤ O(mΔ)m+1 .  
   
  We now guess the indices of variables in T from the nm many candidates and we guess the value of b(T ) := WT x∗T from the O(mΔ)(m+1)m many candidates. It is now easy to recover x∗T (or an equivalent solution) by solving  
   
  min cTT xT : WT xT = b(T ) and xi ∈ Z≥0 for all i ∈ T . Here we use the algorithm by Eisenbrand and Weismantel [4] or the improvement in [6]. This requires time (mΔ)O(m) · n, which is insigniﬁcant compared to the number of guesses above. The algorithm assumes a solution to the LP relaxation is given, which, however, only serves the purpose of having a vector close to the optimal solution (in 1 -norm). For this purpose we can also simply take zT (the zero vector). Let L be the set of indices not in T . To recover x∗L we need to solve   min cTL x∗L + g(WL x∗L + WT x∗T ) : x∗i ∈ Z≥0 for all i ∈ L . This corresponds to an oracle query of the form (2). For each guess of T and b(T ) we compute a solution in this way and return the best among them. The running time, which is dominated by the number of guesses, is therefore 2  
   
  nm · (mΔ)O(m ) · Q .  
   
  (7)  
   
  In fact, the nm term here can be omitted, since one may assume without loss of generality that no two columns of W are equal and therefore n ≤ (2Δ + 1)m .  
   
  Optimizing Low Dimensional Functions  
   
  3  
   
  123  
   
  Bounded Variables  
   
  Let again x∗ denote an optimal solution to (1) and b∗ = W x∗ . Let z be an optimal solution to   min cT x : W x = b∗ and i ≤ xi ≤ ui for all i . We assume that c is augmented slightly by adding εi to the ith component for all i for some very small ε, which essentially implements a lexicographic tiebreaking rule between solutions. Here ε can be treated symbolically. We note that the dual of this linear program is  
   
  max b∗T y + T s − uT su : c − W T y = s − su and si , sui ∈ Rn≥0 , y ∈ Rm . Let y, s , su be an optimal vertex solution to the dual. Then there are m linearly independent rows (W T )i with si = sui = 0 (otherwise it would not be a vertex solution). We guess these rows among the nm candidates, which fully determines y and in particular c − W T y. We may assume that (c − W T y)i = 0 for the other n − m rows, which follows from the perturbation with ε. If (c − W T y)i > 0 for some i we know that sui > 0 and likewise if (c − W T y)i < 0, then si > 0. By complementary slackness we can determine for these rows that zi = ui (respectively, zi = i ). It follows that for n − m variables T we now determined its value in z. Let L denote the m other variables. We now proceed similar to the previous section. We again have that  
   
  x∗T − zT 1 ≤ O(mΔ)m . This implies that  
   
  WT x∗T − WT zT 1 ≤ mΔ · x∗T ≤ O(mΔ)m+1 . Since we know the value of WT zT , we can guess b(T ) = WT x∗T among the O(mΔ)(m+1)m many candidates. Then we recover x∗T using the algorithm by Eisenbrand and Weismantel [4] (where we can use zT instead of an LP solution) and x∗L by applying (2) to min{cTL x∗L + g(WL x∗L + WT x∗T ) : x∗i ∈ {i , i + 1, . . . , ui } for all i ∈ L}. Finally, we return the best solution computed for any guess.  
   
  4  
   
  Overview of Hunkenschr¨ oder Et Al. [5] and Related Improvements  
   
  We now explain the high-level algorithm of Hunkenschr¨ oder et al. [5] in more detail, as well as some improvements to their framework in the unknown W case. Their algorithm starts with an optimal solution z to the continuous relaxation min{g(W x) : x ∈ [0, 1]n } having at most m fractional components (which is  
   
  124  
   
  D. Dadush et al.  
   
  easy to show to always exists). Here, z is assumed to be given by an oracle. For the cases they consider, e.g., the separable case, they prove that there is a “nearby” optimal integral solution x∗ satisfying x∗ −z 1 ≤ (mΔ)O(m) . Function g being separable means that it can be decomposed into a sum of functions each depending only on a single dimension, that is, g(W x) = g1 ((W x)1 ) + . . . + gm ((W x)m ). Using the proximity result, they guess b∗ = W x∗ ∈ Zm , where the 2 number of guesses is bounded by (mΔ)O(m ) (modulo an n factor, this is the dominant term in the complexity), noting that W (x∗ − z) ∞ ≤ (mΔ) x∗ − z 1 . They then recover an optimal solution by solving the integer program W x = b∗ , x ∈ {0, 1}n . Note that this version of the algorithm requires W to be known. When W is unknown, they show that one can replace W by a proxy matrix W  , whose rows correspond to linearly independent gradients of f (x) := g(W x) seen so far by the algorithm. Their ﬁrst observation is that the gradients of ∇f (x) = W T ∇g(W x) are linear combinations of the rows of W . Their second crucial observation is that for b∗ = W  x∗ , any integer solution to W  x = b∗ , x ∈ {0, 1}n , is either optimal or has a gradient ∇f (x) outside the row span of W  , in which case we can add an extra row to W  . Thus, one can iterate the guessing procedure with W replaced by W  at most m times before ﬁnding an optimal solution. The blowup in complexity in this setting comes from a lack of control over the coeﬃcients appearing in W  . Indeed, this is precisely why they require that g has an L-Lipschitz gradient and integral gradients on integral inputs. We remark that this idea can be implemented more eﬃciently without suffering from the worse parameters of W  . First, we observe that the cardinality of the set BN = {W  x : x ∈ {0, 1}n , z − x 1 ≤ N } can be bounded solely in N and the parameters of W . This is because each row of W  is a linear combination of rows of W . Hence, W x = W x implies W  x = W  x and therefore |BN | ≤ O(N Δ)m . Next, notice that BN can be enumerated in time polynomial in n and |BN |: this follows from an induction over n. To this end, for all n ≤ n + 1 we deﬁne (n )  
   
  BN  
   
  = {W  x : x ∈ {0, 1}n , z − x 1 ≤ N, and xi = zi  for all i ≥ n } , (n+1)  
   
  (n )  
   
  1 = BN . We now iteratively generate the sets BN  by using BN where BN  =  {W z} and the recurrence  (n ) (n ) BN  ∪ (BN  −1 + Wn  ) if zn  = 0, (n +1) BN  =  (n ) (n ) BN  ∪ (BN  −1 − Wn  ) if zn  = 1. (n )  
   
  Here Wn  is the n th column of W  . We note that every vector in BN  −1 is generated from some x with xn = 0 iﬀ zn  = 0. Hence, when adding (resp. removing) Wn  there is again a legal x generating this vector (where z − x 1 has increased by one). As in the algorithm of Hunkenschr¨ oder et al., we now start with W  having only the single row ∇f (z). Then for every element of BN we consider a  
   
  Optimizing Low Dimensional Functions  
   
  125  
   
  corresponding integer solution x (note that such an x can easily be recovered in the above recurrence) and check if ∇f (x) and the rows of W  are linearly independent. If so, we add the gradient as a new row to W  . We repeat for at most m iterations until no new row is added. Then we return the best solution x∗ seen during this process. Theorem 3. Let g : Rm → R be a convex function, let f (x) := g(W x) be accessible via a function value and gradient oracle, where W ∈ Zm×n is an unknown matrix with entries of absolute value at most Δ. Then given an optimal solution z to the continuous relaxation min{f (x) : x ∈ [0, 1]n } with at most m fractional entries, one can compute an optimal integral solution in time n(N Δ)O(m) . Here N is the minimum z − x∗ 1 over all optimal integer solutions x∗ . In particular, 2 when g is separable convex, the running time becomes n(mΔ)O(m ) .  
   
  5  
   
  Conclusion and Open Questions  
   
  In this paper we have demonstrated that the task of optimizing low dimensional functions over a projection as introduced by Hunkenschr¨ oder et al. [5] remains tractable even in much more general settings than originally considered. This creates a bridge also to other lines of work in integer optimization, such as integer programs with few constraints [4]. Our main result leaves open a few questions about the complexity of algorithms for problem (1) or the central case of g being a convex function. As mentioned before, one cannot hope to avoid a term of Δm in the running time because of known conditional lower bounds. The necessity of the nm term or the m2 exponent, however, appears less clear. The algorithm for integer programming by Eisenbrand and Weismantel [4], a special case of our setting (see applications), does not require the nm term and in many cases we can avoid it as well by merging duplicate columns of W . It would be nice if this term could be removed in general, or at least in the convex case. Related to the m2 exponent, there is already a notorious question arising from [4]. There, Eisenbrand and Weismantel gave an improved algorithm with exponent O(m) instead of O(m2 ) for the case that there are no upper variable bounds, but with bounds they require O(m2 ). It remains unclear whether this is necessary. In our case even without upper bounds our algorithm need the exponent O(m2 ). In fact, this exponent arises in several places: when guessing the support (assuming n ≈ Δm ) and when guessing the projection of the tight variables b(T ) .  
   
  References 1. Antoniadis, A., Huang, C.-C., Ott, S., Verschae, J.: How to pack your items when you have to buy your knapsack. In: Proceedings of MFCS, pp. 62–73 (2013) 2. Brand, C., Kouteck´ y, M., Ordyniak, S.: Parameterized algorithms for MILPs with small treedepth. In: Proceedings of AAAI, pp. 12249–12257 (2021)  
   
  126  
   
  D. Dadush et al.  
   
  3. Cslovjecsek, J., Eisenbrand, F., Hunkenschr¨ oder, C., Rohwedder, L., Weismantel, R.: Block-structured integer and linear programming in strongly polynomial and near linear time. In: Proceedings of SODA, pp. 1666–1681 (2021) 4. Eisenbrand, F., Weismantel, R.: Proximity results and faster algorithms for integer programming using the Steinitz lemma. ACM Trans. Algorithms 16(1), 5:1-5:14 (2020) 5. Hunkenschr¨ oder, C., Pokutta, S., Weismantel, R.: Optimizing a low-dimensional convex function over a high-dimensional cube. SIAM J. Optim. 2022, to appear 6. Jansen, K., Rohwedder, L.: On integer programming, discrepancy, and convolution. Math. Oper. Res. (2022, to appear) 7. Kannan, R.: Improved algorithms for integer programming and related lattice problems. In: Proceedings of STOC, pp. 193–206 (1983) 8. Klein, K.-M.: About the complexity of two-stage stochastic IPs. Math. Program. 192(1), 319–337 (2022) 9. Knop, D., Pilipczuk, M., Wrochna, M.: Tight complexity lower bounds for integer linear programming with few constraints. ACM Trans. Comput. Theory 12(3), 191–1919 (2020) 10. Lenstra, H.W., Jr.: Integer programming with a ﬁxed number of variables. Math. Oper. Res. 8(4), 538–548 (1983)  
   
  Configuration Balancing for Stochastic Requests Franziska Eberle1(B) , Anupam Gupta2(B) , Nicole Megow3(B) , Benjamin Moseley2(B) , and Rudy Zhou2(B) 1  
   
  London School of Economics and Political Science, London, UK [email protected]  2 Carnegie Mellon University, Pittsburgh, PA, USA [email protected]  , {moseleyb,rbz}@andrew.cmu.edu 3 University of Bremen, Bremen, Germany [email protected]   
   
  Abstract. The conﬁguration balancing problem with stochastic requests generalizes well-studied resource allocation problems such as load balancing and virtual circuit routing. There are given m resources and n requests; each request has multiple possible configurations, each of which increases the load of each resource by some amount. The goal is to select one conﬁguration for each request to minimize the makespan: the load of the most-loaded resource. In the stochastic setting, the amount by which a conﬁguration increases the resource load is uncertain until the conﬁguration is chosen, but we are given a probability distribution. We develop both oﬄine and online algorithms for conﬁguration balancing with stochastic requests. When the requests are known oﬄine, we give a non-adaptive policy for conﬁguration balancing with stochastic requests that O( logloglogmm )-approximates the optimal adaptive policy, which matches a known lower bound for the special case of load balancing on identical machines. When requests arrive online in a list, we give a non-adaptive policy that is O(log m) competitive. Again, this result is asymptotically tight due to information-theoretic lower bounds for special cases (e.g., for load balancing on unrelated machines). Finally, we show how to leverage adaptivity in the special case of load balancing on related machines to obtain a constant-factor approximation oﬄine and an O(log log m)-approximation online. A crucial technical ingredient in all of our results is a new structural characterization of the optimal adaptive policy that allows us to limit the correlations between its decisions. Keywords: stochastic scheduling  
   
  1  
   
  · stochastic routing · load balancing  
   
  Introduction  
   
  This paper considers the conﬁguration balancing problem: there are m resources and n requests. Request j has qj conﬁgurations xj (1), . . . , xj (qj ) ∈ Rm ≥0 . We F. Eberle—Supported by the Dutch Research Council (NWO), Netherlands Vidi grant 016.Vidi.189.087. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 127–141, 2023. https://doi.org/10.1007/978-3-031-32726-1_10  
   
  128  
   
  F. Eberle et al.  
   
  must choose one conﬁguration cj ∈ [qj ] per request, which adds xj (cj ) to the load vector on the resources. The goal is to minimize the makespan, i.e., the load of the most-loaded resource. Conﬁguration balancing captures many natural resource allocation problems where requests compete for a ﬁnite pool of resources and the task is to ﬁnd a “fair” allocation in which no resource is over-burdened. Two well-studied problems of this form arise in scheduling and routing. (i) In load balancing a.k.a. makespan minimization, there are m (unrelated) machines and n jobs. Scheduling job j on machine i increases the load of i by pij ≥ 0. The goal is to schedule each job on some machine to minimize the makespan, i.e., the load of the most-loaded machine. (ii) In virtual circuit routing or congestion minimization, there is a directed graph G = (V, E) on m edges with edge capacities ce > 0 for e ∈ E, and n requests, each request consisting of a source-sink pair (sj , tj ) in G and a demand dj ≥ 0. The goal is to route each request j from sj to tj via some directed path, increasing the load/congestion of each edge e on the path by dj/ce , while the objective is to minimize the load of the most-loaded edge. Conﬁguration balancing captures both problems by taking the m resources to be the m machines or edges, respectively; each conﬁguration now corresponds to assigning a job to some machine or routing a request along some path. Typically, job sizes or request demands are not known exactly when solving resource allocation problems in practice. This motivates the study of algorithms under uncertainty, where an algorithm must make decisions given only partial/uncertain information about the input. Uncertainty can be modeled in diﬀerent ways. In exceptional cases, a non-clairvoyant algorithm that has no knowledge about the loads of requests may perform surprisingly well; an example is Graham’s greedy list scheduling for load balancing on identical machines [15]. In general, a non-clairvoyant algorithm cannot perform well. Hence, we consider a stochastic model, where the unknown input follows some known distribution but the actual realization is a priori unknown. Such a model is natural when there is historical data available from which such distributions can be deduced. In the conﬁguration balancing with stochastic requests problem, we assume that each conﬁguration c of request j is a random vector Xj (c) with known distribution Dj (c) supported on Rm ≥0 such that the Xj (c)’s are independent across diﬀerent requests j. The actual realized vector of a conﬁguration c of request j is only observed after irrevocably selecting this particular conﬁguration for request objective is to minimize the expected maximum load  j. The n (makespan) E maxi j=1 Xij (cj ) , where cj is the conﬁguration chosen for request j. We assume that we have oracle access to the Dj (c)’s; in particular we assume that in constant time, we can compute any needed statistic of the distribution Dj (c). Further, we distinguish whether there is an additional dimension of uncertainty or not, namely the knowledge about the request set. In the oﬄine setting, the set of requests and the distributions of the conﬁgurations of each request are known up-front, and they can be selected and assigned to the resources irre-  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  129  
   
  vocably in any order. In the online setting, requests are not known in advance and they are revealed one-by-one (online-list model). The algorithm learns the stochastic information on conﬁgurations of a request upon its arrival, and must select one of them without knowledge of future arrivals. After a conﬁguration is chosen irrevocably, the next request arrives. In general, we allow an algorithm to base the next decision on knowledge about the realized vectors of all previously selected request conﬁgurations. We call such policies adaptive. Conversely, a non-adaptive policy is one that ﬁxes the particular conﬁguration chosen for a request without using any knowledge of the realized conﬁguration vectors. The goal of this paper is to investigate the power of adaptive and nonadaptive policies for online and oﬄine conﬁguration balancing with stochastic requests. We quantify the performance of an algorithm by bounding the worst-case ratio of the achieved expected makespan and the minimal expected makespan achieved by an optimal oﬄine adaptive policy. We say that an algorithm Alg α-approximates an algorithm Alg’ if, for any input instance, the expected makespan of Alg is at most a factor α larger than the expected makespan of Alg’; we refer to α also as approximation ratio. For online algorithms, the term competitive ratio refers to their approximation ratio. 1.1  
   
  Our Results  
   
  Main Result. As our ﬁrst main result, we present non-adaptive algorithms for oﬄine and online conﬁguration balancing with stochastic requests. Theorem 1. For conﬁguration balancing with stochastic requests there is a randomized  oﬄine algorithm that computes a non-adaptive policy that is a  Θ logloglogmm -approximation and an eﬃcient deterministic online algorithm that is a Θ(log m)-approximation when comparing to the optimal oﬄine adaptive policy. Both algorithms run in polynomial time in the number of resources and the total number of conﬁgurations over all requests. The oﬄine analysis relies on a linear programming (LP)relaxation  of conﬁguration balancing, which has a known integrality gap of Θ logloglogmm , even for virtual circuit routing [25], implying that the analysis is tight. In the online setting, our analysis employs a potential function to greedily determine which conﬁguration to choose for each request. In particular, we generalize the idea by [3] to the setting of conﬁguration balancing with stochastic requests and match a known lower bound for online deterministic load balancing on unrelated machines by [5]. If the conﬁgurations are not given explicitly as part of the input or the number of conﬁgurations is large, then eﬃciently solving the problem requires us to be able to optimize over conﬁgurations in polynomial time. Applications. These results would hold for both load balancing on unrelated machines and virtual circuit routing if we could guarantee that either the con-  
   
  130  
   
  F. Eberle et al.  
   
  ﬁgurations are given explicitly or the respective subproblems can be solved eﬃciently. We can ensure this in both cases. For stochastic load balancing on unrelated machines, the resources are the m machines, and each job has m possible conﬁgurations – one corresponding to assigning that job to each machine. Thus, we can eﬃciently represent all conﬁgurations. Further, here the LP relaxation of conﬁguration balancing used in Theorem 1 is equivalent to the LP relaxation of the generalized assignment problem (GAP) solved in [33], which gives a deterministic rounding algorithm. Hence, Theorem 1 implies the following theorem. We omit the proof in this extended abstract; see [14] for proof. Theorem 2. There exist eﬃcient deterministic algorithms that compute a nonadaptive policy for loadbalancing on unrelated machines with stochastic jobs that achieve an Θ logloglogmm -approximation oﬄine and an Θ(log m)-approximation online when comparing to the optimal oﬄine adaptive policy.   These results are asymptotically tight due to the lower bound of Ω logloglogmm on the adaptivity gap [17] and the lower bound of Ω(log m) on the competitive ratio of any deterministic online algorithm, even for deterministic requests [5].   This implies that the adaptivity gap for stochastic load balancing is Θ logloglogmm . For virtual circuit routing, the resources are the m edges and each request has a conﬁguration for each possible routing path. Thus, eﬃciently solving the subproblems requires more work as the conﬁgurations are only given implicitly and there can be exponentially many. For the oﬄine setting, since the LP relaxation has (possibly) exponentially many variables, we design an eﬃcient separation oracle for the dual LP in order to eﬃciently solve the primal. For the online setting, we carefully select a subset of polynomially many conﬁgurations that contain the conﬁguration chosen by the greedy algorithm, even when presented with all conﬁgurations. Thus, Theorem 1 implies that stochastic requests are not harder to approximate than deterministic requests. We omit the proof in this extended abstract; see [14] for proof. Theorem 3. For routing with stochastic requests, there exist an eﬃcient ran  domized oﬄine algorithm computing a non-adaptive policy that is a Θ logloglogmm approximation and an eﬃcient deterministic online algorithm that computes an Θ(log m)-approximation when comparing to the optimal oﬄine adaptive policy. Adaptive Policies for Related Machines. When each request j has m conﬁguraX tions and conﬁguration c ∈ [m] can be written as Xj (c) = sij ec , where ec ∈ Rm is the cth standard unit vector, the problem is also known as load balancing on related machines. We say that Xj is the size of request (or job) j and si is the speed of resource (or machine) i. In this  special case, we show how to leverage adaptivity to overcome the Ω logloglogmm lower bound on the adaptivity gap. Interestingly, our adaptive algorithms begin with a similar non-adaptive assignment of jobs to machines, but we deviate from the assignment adaptively to obtain our improved algorithms.  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  131  
   
  Theorem 4. For load balancing on related machines with stochastic jobs, there exist eﬃcient deterministic algorithms that compute an adaptive oﬄine O(1)approximation and an adaptive online O(log log m)-approximation when comparing to the optimal oﬄine adaptive policy. It remains an interesting open question whether the online setting admits an O(1)-competitive algorithm. 1.2  
   
  Technical Overview  
   
  We illustrate the main idea behind our non-adaptive policies, which compare to the optimal oﬄine adaptive policy. Throughout this paper, we let Opt denote the optimal adaptive policy as well as its makespan. As in many other stochastic optimization problems, our goal is to give a good deterministic proxy for the makespan of a policy. Then, our algorithm will optimize over this deterministic proxy to obtain a good solution. First, we observe that if all conﬁgurations were bounded with respect to E[Opt] in every entry, then selecting conﬁgurations such   that each resource has expected load O(E[Opt]) gives the desired O logloglogmm approximation by standard concentration inequalities for independent sums with bounded increments. Thus, in this case the expected load on each resource is a good proxy. However, in general, we have no upper bound on Xij (c), so we cannot argue as above. We turn these unbounded random variables (RVs) into bounded ones in a standard way by splitting each request into truncated and exceptional parts. Deﬁnition 1 (Truncated and Exceptional Parts). Fix τ ≥ 0 as threshold. For a RV X, its truncated part (w.r.t. threshold τ ) is X T := X · 1X 0 is the truncationthresh old. There are m jobs: a stochastic one with processing time Xj ∼ τ ·Ber τ1 and 1 m − 1 deterministic jobs with processing time Xj ≡ m . The optimal adaptive policy ﬁrst schedules the stochastic job on the fast machine. If its realized size is 0, then it schedules all deterministic jobs on the fast machine as well. Otherwise the realized size is τ and it schedules deterministic job on each slow machine,   one 1 + · implying E[Opt] = 1 − τ1 m−1 m  However, the total expected τ Eτ = Θ(1).  · 1j→i = τ1 (mτ ) = m, where j → i exceptional load (w.r.t. τ ) is i,j E Xij denotes that job j is assigned to machine i, i.e., conﬁguration i is chosen for j. In the example, the optimal adaptive policy accrues a lot of exceptional load, but this does not have a large eﬀect on the makespan. Concretely, (1) can be loose by a Ω(m)-factor for adaptive policies. Thus, it seems that the total exceptional load is a bad proxy in terms of lower-bounding Opt. However, we show that, by comparing our algorithm to a near-optimal adaptive policy rather than the optimal one, the total exceptional load becomes a good proxy in the following sense. This is the main technical contribution of our work, and it underlies all of our algorithmic techniques. Theorem 5. For conﬁguration balancing with stochastic requests, there exists an adaptive policy with expected maximum load and total expected exceptional load at most 2 · E[Opt] with respect to any truncation threshold   τ ≥ 2 · E[Opt]. Further, any conﬁguration c selected by this policy satisﬁes E maxi Xi (c) ≤ τ . The proof of the above relies on carefully modifying the “decision tree” representing the optimal adaptive policy; see [14] for proof. In light of Theorem 5, the deterministic proxies we consider are the expected truncated load on each resource and the total expected exceptional load. All of our algorithms then proceed by ensuring that both quantities are bounded with respect to E[Opt]. In the oﬄine case, we round a natural assignment-type linear program (LP), and in the online case, we use a potential-function argument. All of these algorithms actually output non-adaptive policies. For the special case of related-machines load balancing, we also compute a non-adaptive assignment but instead of following it exactly, we deviate using adaptivity and give improved solutions. 1.3  
   
  Related Work  
   
  While stochastic optimization problems have long been studied [6,11], approximation algorithms for them are more recent [13,29]. By now, multi-stage stochastic problems (where uncertain information is revealed in stages) are well-understood [9,19,34]. In contrast, more dynamic models, where the exact value of an unknown parameter becomes known at times depending on the algorithms  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  133  
   
  decisions (serving a request) still remain poorly understood. Some exceptions come from stochastic knapsack [8,12,16,28] as well as stochastic scheduling and routing which we discuss below. Scheduling. For load balancing with deterministic sizes, a 2-approximation in the most general unrelated-machines oﬄine setting [26] is known. For identical machines (pij = pj for all jobs j), the greedy algorithm (called list scheduling)  1 -approximation algorithm [15]. This guarantee holds even when the is a 2 − m   1 jobs arrive online and nothing is known about job sizes. This implies a 2 − m approximate adaptive policy for stochastic load balancing on identical machines. Apart from this, prior work on stochastic scheduling has focused on approximating the optimal non-adaptive policy. There are non-adaptive O(1)approximations known for identical machines [24], unrelated machines [17], the q -norm objective [30], and monotone, symmetric norms [21]. In contrast, our work focuses on approximating the stronger optimal adaptive policy. The adaptivity gap (the ratio between the expected makespan of  the optimal adaptive and non-adaptive policies) can be Ω logloglogmm even for the simplest case of identical machines [17]. Thus, previous work on approximating the optimal non-adaptive policy does not immediately give any non-trivial approximation guarantees for our setting. The only previous work on adaptive stochastic policies for load-balancing (beyond the highly-adaptive list scheduling) is by [32]. They propose scheduling policies whose degree of adaptivity can be controlled by parameters and show an approximation factor of O(log log m) for scheduling on identical machines. Online load balancing with deterministic jobs is also well studied [4]. On identical machines, the aforementioned list scheduling algorithm [15] is 2 −  1 -competitive. For unrelated machines, there is a deterministic O(log m)m competitive algorithm [3] and this is best possible [5]. When the machines are uniformly related, [7] design an O(1)-competitive algorithm for minimizing the makespan. [22,23] study the multi-dimensional generalization to vector scheduling under the makespan and the q -norm objective. To the best of our knowledge, conﬁguration balancing has not been explicitly deﬁned before. The techniques of [3] give an O(log m)-competitive algorithm for deterministic requests. It is also studied for packing integer programs [1,2,18]. Routing. For oblivious routing with stochastic demands, [20] give an algorithm which is an O(log2 n)-approximation with high probability. Here, “oblivious” refers to the requirement that the chosen path between a source-sink pair must not depend on the current congestion of the network. In particular, after specifying a set of paths for each possible source-sink pair, a demand matrix is drawn from an a-priori known distribution and each demand needs to be routed along one of the predeﬁned paths. The obliviousness requirement is very diﬀerent from our setting and makes the two models essentially incomparable.   When dj = 1 for each source-sink pair, there is an O logloglogmm -approximation algorithm by [31], which is best possible, unless NP ⊆ ZPTIME(nlog log n ) [10].  
   
  134  
   
  F. Eberle et al.  
   
  In the online setting, when the source-sink pairs arrive online in a list and have to be routed before the next pair arrives, [3] give a lower bound of Ω(log n) on the competitive ratio of any deterministic online algorithm in directed graphs, where n is the number of vertices. They also give a matching upper bound. For more details on online routing we refer to the survey [27].  
   
  2  
   
  Configuration Balancing with Stochastic Requests  
   
  In this section, we prove our main results for the most  general problem we consider: conﬁguration balancing. We give an O logloglogmm -approximation oﬄine and an O(log m)-approximation online; both algorithms are non-adaptive. Before describing the algorithms, we give our main structural theorem that enables all of our results. Roughly, we show that instead of comparing to the optimal adaptive policy, by losing only a constant factor in the approximation ratio, we can compare to a near-optimal policy that behaves like a non-adaptive one (w.r.t. the proxy objectives we consider, namely, the total expected exceptional load). 2.1  
   
  Structural Theorem  
   
  In this section, we show that there exists a near-optimal policy as guaranteed by Theorem 5. To this end, we modify the optimal policy by “restarting” whenever an exceptional request is encountered. Additionally, we ensure   that this modiﬁed policy never selects a conﬁguration c for a request j with E maxi Xij (c) > τ . We let J denote the set of requests. For any subset J  ⊆ J, we let Opt(J  ) denote the optimal adaptive policy (and its maximum load) on the set of requests J  . Note that Opt(∅) = 0. Our (existential) algorithm to construct such a policy will begin by running the optimal policy Opt(J) on all requests. However, once an exceptional request is encountered or the next decision will choose a conﬁguration with too large expected maximum, we cancel Opt(J) and instead recurse on all remaining requests, ignoring all previously-accrued loads; see Algorithm 1. The idea of our analysis is that we recurse with small probability; see [14]. Theorem 5. For conﬁguration balancing with stochastic requests, there exists an adaptive policy with expected maximum load and total expected exceptional load at most 2 · E[Opt] with respect to any truncation threshold   τ ≥ 2 · E[Opt]. Further, any conﬁguration c selected by this policy satisﬁes E maxi Xi (c) ≤ τ . Having this near-optimal policy at hand, the upshot is that we can bound our subsequent algorithms with respect to the following LP relaxation (LPC ) for conﬁguration balancing with stochastic requests. The variable ycj denotes selecting conﬁguration c for request j. We take our threshold between the truncated and exceptional parts to be τ . Using the natural setting of the y-variables as the probabilities of the policy from Theorem 5, it is straight-forward to show that  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  135  
   
  Algorithm 1: Policy S(J) R←J if R = ∅ then return empty policy  
   
  1  
   
  2  
   
  // remaining requests // ﬁnish  
   
  while R = ∅ do j ← ﬁrst / next request considered by Opt(J) cj ←conﬁguration chosen for request j by Opt(J) if E maxi Xij (cj ) > τ then // maximum too large break else choose cj for request j // S(J) follows Opt(J) R ← R \ {j} // update remaining requests if maxi Xij (cj ) ≥ τ then // exceptional conﬁguration observed break run S(R)  
   
  // recurse with remaining requests  
   
  the following LP relaxation has a feasible solution, formalized in Lemma 1. qj ∀ j ∈ [n] c=1 ycj = 1 n qj T E[X (c)] · y ≤ τ ∀ i ∈ [m] cj ij c=1 n j=1 qj E E[max X (c)] · y ≤ τ i cj ij c=1 j=1 ycj = 0 ∀ j ∈ [n], ∀ c ∈ [qj ] : E[maxi Xij (c)] > τ ycj ≥ 0 ∀ j ∈ [n], ∀ c ∈ [qj ] (LPC ) Lemma 1. (LPC ) has a feasible solution for any τ ≥ 2 · E[Opt]. 2.2  
   
  Oﬄine Setting  
   
  Our oﬄine algorithm is the natural randomized rounding of (LPC ). For the truncated parts, the following inequality bounds their contribution to the makespan. Lemma 2. Let S1 , . . . , Sm be sums of independent RVs bounded in  [0, τ ] for some τ > 0 such that E[Si ] ≤ τ for all i ∈ [m]. Then, E[maxi Si ] = O logloglogmm τ . To bound the contribution of the exceptional parts, we use (1), i.e., the total expected exceptional load. Using binary search for the correct choice of τ and re-scaling the instance down by the current value of τ , it suﬃces to give an eﬃcient algorithm that either   – outputs a non-adaptive policy with expected makespan O logloglogmm , or – certiﬁes that E[Opt] > 1.   This is because for τ ∈ E[Opt], 2 · E[Opt] , the re-scaling guarantees E[Opt] ∈ [ 12 , 1) on the scaled instance, in which case the algorithm achieves     expected makespan O logloglogmm = O logloglogmm · E[Opt].  
   
  136  
   
  F. Eberle et al.  
   
  Algorithm 2: Oﬄine Conﬁguration Balancing with Stochastic Requests try to solve (LPC ) with τ = 2 if (LPC ) is feasible then let y ∗ be the outputted feasible solution for each request j do ∗ independently sample c ∈ [qj ] with probability ycj choose sampled c as cj else return “E[Opt] > 1”  
   
  To that end, we use the natural independent randomized rounding of (LPC ). That is, if (LPC ) has a feasible solution y ∗ , for request j, we choose conﬁguration c ∗ ; see Algorithm 2. as conﬁguration cj independently with probability ycj If the conﬁgurations are given explicitly as part of the input, then (LPC ) can be solved in polynomial  time and, thus, Algorithm 2 runs in polynomial  time. Hence, the O logloglogmm -approximate non-adaptive policy for conﬁguration balancing with stochastic requests (Theorem 1) follows from the next lemma. Lemma 3. If (LPC ) can be solved in polynomial time, Algorithm 2 is a polynomial-time randomized algorithm  that either outputs a non-adaptive pol icy with expected makespan O logloglogmm , or certiﬁes correctly that E[Opt] > 1. 2.3  
   
  Online Setting  
   
  We now consider online conﬁguration balancing where n stochastic requests arrive online one-by-one, and for each request, one conﬁguration has to be irrevocably selected before the next request appears. We present a non-adaptive online algorithm that achieves a competitive ratio of O(log m), which is best possible due to the lower bound of Ω(log m) [5]. By a standard guess-and-double scheme, we may assume that we have a good guess of E[Opt]. We omit the proof, which is analogous to its virtual-circuitrouting counterpart in [3]. Lemma 4. Given an instance of online conﬁguration balancing with stochastic requests, suppose there exists an online algorithm that, given parameter λ > 0, never creates an expected makespan more than α · λ, possibly terminating before handling all requests. Further, if the algorithm terminates prematurely, then it certiﬁes that E[Opt] > λ. Then, there exists an O(α)-competitive algorithm for online conﬁguration balancing with stochastic requests. Further, the resulting algorithm preserves non-adaptivity. We will build on the same technical tools as in the oﬄine case. In particular, we wish to compute a non-adaptive assignment online with small expected truncated load on each resource and small total expected exceptional load. To achieve this, we generalize the greedy potential function approach of [3]. Our two new ingredients are to treat the exceptional parts of a request’s conﬁguration as a  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  137  
   
  resource requirement for an additional, artiﬁcial resource and to compare the potential of our solution directly with a fractional solution to (LPC ). Now we describe our potential function, which is based on an exponential/soft-max function. Let λ denote the current guess of the optimum as required by Lemma 4. We take τ = 2λ as our truncation threshold. Given load vector L ∈ Rm+1 , our potential function is φ(L) =  
   
  m  
   
  (3/2)Li /τ .  
   
  i=0  
   
  For i ∈ [m], we ensure the ith entry of L is the expected truncated load on resource i and use the 0th entry as a virtual resource that is the total expected exceptional load. For any request j, let Lj be the expected load vector after handling the ﬁrst j requests, with Lij denoting its ith entry. Let Li0 := 0 for all i. Upon arrival of request j, our algorithm tries to choose the conﬁguration cj ∈ [qj ] that minimizes the increase in potential; see Algorithm 3. Algorithm 3: Online Conﬁguration Balancing with Stochastic Requests  ← log3/2 (2m + 2) λ ← current guess of E[Opt] τ ← 2λ truncation threshold upon arrival of requestj do 1  
   
  E  
   
  cj ← arg minc∈[qj ] (3/2)(L0j−1 +E[maxi∈[m] Xij (c)])/τ +  m T 3/2)(Lij−1 +E[Xij (c)])/τ − φ(L ( j−1 ) i=1  
   
  T E if Lij−1 + E[Xij (cj )] ≤ τ for all i ∈ [m] and L0j−1 + E[maxi∈[m] Xij (cj )] ≤ τ then choose cj for j T (cj )] for all i ∈ [m] Lij ← Lij−1 + E[Xij E (cj )] L0j ← L0j−1 + E[maxi∈[m] Xij else return “E[Opt] > λ”  
   
  To analyze this algorithm, we compare its makespan with a solution to (LPC ).   This LP has an integrality gap of Ω logloglogmm , which follows immediately from the path assignment LP for virtual circuit routing [25]. Hence, a straightforward analysis of Algorithm 3 comparing to a rounded solution to (LPC ) gives an assignment with  expected truncated load per machine and total expected exceptional load O log m · logloglogmm ) · E[Opt]. To get a tight competitive ratio of O(log m), we avoid the integrality gap by comparing to a fractional solution to (LPC ), and we use a slightly diﬀerent inequality than Lemma 2 for the regime where the mean of the sums is larger than the increments by at most a O(log m)-factor. Lemma 5. Let S1 , . . . , Sm be sums of independent RVs bounded in [0, τ ] for τ > 0 such that E[Si ] ≤ O(log m)τ for all 1 ≤ i ≤ m. Then, E[maxi Si ] ≤ O(log m)τ .  
   
  138  
   
  F. Eberle et al.  
   
  We give the guarantee for Algorithm 3, which implies the O(log m)competitive algorithm for online conﬁguration balancing with stochastic requests. Lemma 6. Suppose the minimizing conﬁguration in Line 1 can be found in polynomial time. Then Algorithm 3 runs in polynomial time; it is deterministic, non-adaptive and correctly solves the subproblem of Lemma 4 for α = O(log m).  
   
  3  
   
  Load Balancing on Related Machines  
   
  In this section, we improve on Theorem 2 in the special case of related machines, where each machine i has a speed parameter si > 0 and each job j an indeX pendent size Xj such that Xij = sij . Recall that we gave a non-adaptive  log m  O log log m -approximation for unrelated machines. However, the adaptivity gap   is Ω logloglogmm even for load balancing on identical machines where every machine has the same speed. Thus, to improve on Theorem 2, we need to use adaptivity. The starting point of our improved algorithms is the same non-adaptive assignment for unrelated-machines load balancing. However, instead of nonadaptively assigning job j to the speciﬁed machine i, we adaptively assign j to the least loaded machine with similar speed to i. We formalize this idea and brieﬂy explain the algorithms for oﬄine and online load balancing on related machines. Machine Smoothing. In this part, we deﬁne a notion of smoothed machines. We show that by losing a constant factor in the approximation ratio, we may assume that the machines are partitioned into at most O(log m) groups such that machines within a group have the same speed and the size of the groups shrinks geometrically. Thus, by “machines with similar speed to i,” we mean machines in the same group. Formally, we transform an instance I of load balancing on m related machines with stochastic jobs into an instance Is with so-called “smoothed machines” and the same set of jobs with the following three properties: (i) The machines are partitioned into m = O(log m) groups such that group k consists of mk machines with speed exactly sk such that s1 < s2 < · · · < sm . (ii) For all groups 1 ≤ k < m , we have mk ≥ 32 mk+1 . (iii) Opt(Is ) = O(Opt(I)). To this end, we suitably decrease machine speeds and delete machines from the original instance I; see [14] for the algorithm and the technical details. Lemma 7. There is an eﬃcient algorithm that, given an instance I of load balancing with m related machines and stochastic jobs, computes an instance Is of smoothed machines with the same set of jobs satisfying Properties (i) to (iii).  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  139  
   
  A similar idea for machine smoothing has been employed by Im et al. [23] for deterministic load balancing on related machines. In their approach, they ensure that the total processing power of the machines in a group decreases geometrically rather than the number of machines. Oﬄine Setting. We run Algorithm 2 on the conﬁguration balancing instance deﬁned by the load balancing instance with smoothed machines. Given a job-tomachine assignment, we list schedule the jobs assigned to a particular group on the machines of this group. In the proof of Theorem 4, we rely on the following strong bound on the expected maximum of the truncated load; see [14]. Lemma 8. Let c1 , . . . , cm ∈ N≥1 be constants such that ci ≥ 32 ci+1 for all 1 ≤ variables bounded in [0, τ ] i ≤ m. Let S1 , . . . , Sm be sums of independent random   such that E[Si ] ≤ ci τ for all 1 ≤ i ≤ m. Then, E maxi Scii ≤ O(τ ). Online Setting. We apply a similar framework as above. Note that our online conﬁguration balancing algorithm loses a logarithmic factor in the number of resources, so to obtain a O(log log m)-approximation, we aggregate each group (in the smoothed-machines instance) as a single resource. Intuitively, this deﬁnition captures the fact that we will average all jobs assigned to a group over the machines in this group. Thus, our conﬁguration balancing instance will have only O(log m) resources and applying Theorem 1 proves Theorem 4; see [14].  
   
  Conclusion We considered the conﬁguration balancing problem under uncertainty. In contrast to the (often overly optimistic) clairvoyant settings and the (often overly pessimistic) non-clairvoyant settings, we consider the stochastic setting where each request j presents a set of random vectors, and we need to (adaptively) pick one of these vectors, to minimize the expected maximum load over the m resources. We give logarithmic bounds for several general settings (which are existentially tight), and a much better O(1) oﬄine and O(log log m) online bound for the related machines setting. Closing the gap for online related-machines load balancing remains an intriguing open problem. More generally, getting a better understanding of both adaptive and non-adaptive algorithms for stochastic packing and scheduling problems remains an exciting direction for research.  
   
  References 1. Agrawal, S., Devanur, N.R.: Fast algorithms for online stochastic convex programming. In: Proceedings of SODA, pp. 1405–1424 (2015) 2. Agrawal, S., Wang, Z., Ye, Y.: A dynamic near-optimal algorithm for online linear programming. Oper. Res. 62(4), 876–890 (2014) 3. Aspnes, J., Azar, Y., Fiat, A., Plotkin, S.A., Waarts, O.: On-line routing of virtual circuits with applications to load balancing and machine scheduling. J. ACM 44(3), 486–504 (1997)  
   
  140  
   
  F. Eberle et al.  
   
  4. Azar, Y.: On-line load balancing. In: Fiat, A., Woeginger, G.J. (eds.) Online Algorithms. LNCS, vol. 1442, pp. 178–195. Springer, Heidelberg (1998). https://doi. org/10.1007/BFb0029569 5. Azar, Y., Naor, J., Rom, R.: The competitiveness of on-line assignments. J. Algorithms 18(2), 221–237 (1995) 6. Beale, E.M.L.: On minimizing a convex function subject to linear inequalities. J. Roy. Stat. Soc. Ser. B. Methodol. 17, 173–184; discussion, 194–203 (1955) 7. Berman, P., Charikar, M., Karpinski, M.: On-line load balancing for related machines. J. Algorithms 35(1), 108–121 (2000) 8. Bhalgat, A., Goel, A., Khanna, S.: Improved approximation results for stochastic knapsack problems. In: Proceedings of SODA, pp. 1647–1665. SIAM (2011) 9. Charikar, M., Chekuri, C., P´ al, M.: Sampling bounds for stochastic optimization. In: Chekuri, C., Jansen, K., Rolim, J.D.P., Trevisan, L. (eds.) APPROX/RANDOM -2005. LNCS, vol. 3624, pp. 257–269. Springer, Heidelberg (2005). https://doi.org/10.1007/11538462 22 10. Chuzhoy, J., Guruswami, V., Khanna, S., Talwar, K.: Hardness of routing with congestion in directed graphs. In: Proceedings of STOC, pp. 165–178. ACM (2007) 11. Dantzig, G.B.: Linear programming under uncertainty. Manag. Sci. 1, 197–206 (1955) 12. Dean, B.C., Goemans, M.X., Vondr´ ak, J.: Approximating the stochastic knapsack problem: the beneﬁt of adaptivity. Math. Oper. Res. 33(4), 945–964 (2008) 13. Dye, S., Stougie, L., Tomasgard, A.: The stochastic single resource service-provision problem. Naval Res. Logist. 50(8), 869–887 (2003) 14. Eberle, F., Gupta, A., Megow, N., Moseley, B., Zhou, R.: Conﬁguration balancing for stochastic requests. CoRR, abs/2208.13702 (2022) 15. Graham, R.L.: Bounds on multiprocessing timing anomalies. SIAM J. Appl. Math. 17(2), 416–429 (1969) 16. Gupta, A., Krishnaswamy, R., Molinaro, M., Ravi, R.: Approximation algorithms for correlated knapsacks and non-martingale bandits. In: Ostrovsky, R. (ed.) Proceedings of FOCS, pp. 827–836. IEEE Computer Society (2011) 17. Gupta, A., Kumar, A., Nagarajan, V., Shen, X.: Stochastic load balancing on unrelated machines. Math. Oper. Res. 46(1), 115–133 (2021) 18. Gupta, A., Molinaro, M.: How the experts algorithm can help solve LPS online. Math. Oper. Res. 41(4), 1404–1431 (2016) 19. Gupta, A., P´ al, M., Ravi, R., Sinha, A.: Sampling and cost-sharing: approximation algorithms for stochastic optimization problems. SIAM J. Comput. 40(5), 1361– 1401 (2011) 20. Hajiaghayi, M.T., Kim, J.H., Leighton, T., R¨ acke, H.: Oblivious routing in directed graphs with random demands. In: Proceedings of STOC, pp. 193–201. ACM (2005) 21. Ibrahimpur, S., Swamy, C.: Approximation algorithms for stochastic minimumnorm combinatorial optimization. In: Proceedings of FOCS, pp. 966–977. IEEE (2020) 22. Im, S., Kell, N., Kulkarni, J., Panigrahi, D.: Tight bounds for online vector scheduling. SIAM J. Comput. 48(1), 93–121 (2019) 23. Im, S., Kell, N., Panigrahi, D., Shadloo, M.: Online load balancing on related machines. In: Proceedings of STOC, pp. 30–43. ACM (2018) ´ Allocating bandwidth for bursty connec24. Kleinberg, J.M., Rabani, Y., Tardos, E.: tions. SIAM J. Comput. 30(1), 191–217 (2000) 25. Leighton, T., Rao, S., Srinivasan, A.: Multicommodity ﬂow and circuit switching. In: HICSS (7), pp. 459–465. IEEE Computer Society (1998)  
   
  Conﬁguration Balancing for Stochastic Requests  
   
  141  
   
  ´ Approximation algorithms for scheduling 26. Lenstra, J.K., Shmoys, D.B., Tardos, E.: unrelated parallel machines. Math. Program. 46, 259–271 (1990) 27. Leonardi, S.: On-line network routing. In: Fiat, A., Woeginger, G.J. (eds.) Online Algorithms. LNCS, vol. 1442, pp. 242–267. Springer, Heidelberg (1998). https:// doi.org/10.1007/BFb0029572 28. Ma, W.: Improvements and generalizations of stochastic knapsack and Markovian bandits approximation algorithms. Math. Oper. Res. 43(3), 789–812 (2018) 29. M¨ ohring, R.H., Schulz, A.S., Uetz, M.: Approximation in stochastic scheduling: the power of LP-based priority policies. J. ACM 46(6), 924–942 (1999) 30. Molinaro, M.: Stochastic p load balancing and moment problems via the l-function method. In: Proceedings of SODA, pp. 343–354. SIAM (2019) 31. Raghavan, P., Thompson, C.D.: Randomized rounding: a technique for provably good algorithms and algorithmic proofs. Combinatorica 7(4), 365–374 (1987) 32. Sagnol, G., Schmidt, D., Waldschmidt, G.: Restricted adaptivity in stochastic scheduling. In: Proceedings of ESA. LIPIcs, vol. 204, pp. 79:1–79:14. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik (2021) ´ An approximation algorithm for the generalized assign33. Shmoys, D.B., Tardos, E.: ment problem. Math. Program. 62, 461–474 (1993) 34. Swamy, C., Shmoys, D.B.: Sampling-based approximation algorithms for multistage stochastic optimization. SIAM J. Comput. 41(4), 975–1004 (2012)  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem Satoru Fujishige1 , Tomonari Kitahara2 , and László A. Végh3(B) 1  
   
  3  
   
  Research Institute for Mathematical Sciences, Kyoto University, Kyoto 606-8502, Japan [email protected]  2 Faculty of Economics, Kyushu University, Fukuoka 819-0395, Japan [email protected]  Department of Mathematics, London School of Economics and Political Science, London WC2A 2AE, UK [email protected]   
   
  Abstract. We consider the minimum-norm-point (MNP) problem of polyhedra, a well-studied problem that encompasses linear programming. Inspired by Wolfe’s classical MNP algorithm, we present a general algorithmic framework that performs ﬁrst order update steps, combined with iterations that aim to ‘stabilize’ the current iterate with additional projections, i.e., ﬁnding a locally optimal solution whilst keeping the current tight inequalities. We bound the number of iterations polynomially in the dimension and in the associated circuit imbalance measure. In particular, the algorithm is strongly polynomial for network ﬂow instances. The conic version of Wolfe’s algorithm is a special instantiation of our framework; as a consequence, we obtain convergence bounds for this algorithm. Our preliminary computational experiments show a signiﬁcant improvement over standard ﬁrst-order methods.  
   
  1  
   
  Introduction  
   
  We study the minimum-norm-point (MNP) problem Minimize 12 ||Ax − b||2 subject to 0 ≤ x ≤ u , x ∈ RN ,  
   
  (P)  
   
  where m and n are positive integers, M = {1, · · · , m} and N = {1, · · · , n}, A ∈ RM ×N is a matrix with rank rk(A) = m, b ∈ RM , and u ∈ (R ∪ {∞})N . This is an extended abstract. The full version including all omitted proofs is available on arXiv:2211.02560. SF’s research is supported by JSPS KAKENHI Grant Numbers JP19K11839 and 22K11922 and by the Research Institute for Mathematical Sciences, an International Joint Usage/Research Center located in Kyoto University. TK is supported by JSPS KAKENHI Grant Number JP19K11830. LAV’s research is supported by the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement no. 757481–ScaleOpt). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 142–156, 2023. https://doi.org/10.1007/978-3-031-32726-1_11  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  143  
   
  We will use the notation B(u) := {x ∈ RN | 0 ≤ x ≤ u} for the feasible set. The problem (P) generalizes the linear programming (LP) feasibility problem: the optimum value is 0 if and only if Ax = b, x ∈ B(u) is feasible. We say that (P) is an uncapacitated instance if u(i) = ∞ for all i ∈ N . The formulation (P) belongs to a family of problems for which Necoara, Nesterov, and Glineur [16] showed linear convergence bounds of ﬁrst order methods. That is, the number of iterations needed to ﬁnd an ε-approximate solution depends linearly on log(1/ε). Such convergence has been known for strongly convex functions, but this property does not hold for (P). However, [16] shows that restricted variants of strong convexity also suﬃce. For problems of the form (P), the required property follows using Hoﬀman-proximity bounds [13]; see [19] and the references therein for recent results on Hoﬀman-proximity. We propose a new algorithmic framework for the minimum-norm-point problem (P) that uses stabilizing steps between ﬁrst order updates. Our algorithm terminates with an exact optimal solution in a ﬁnite number of iterations. Moreover, we show poly(n, κ) running time bounds for multiple instantiations of the framework, where κ is the circuit imbalance measure associated with the matrix (A | Im ) (see Sect. 2). This gives strongly polynomial bounds whenever κ is constant; in particular, κ = 1 for network ﬂow feasibility. We note that if A ∈ ZM ×N , then κ ≤ Δ(A) for the maximum subdeterminant Δ(A). Still, κ can be exponential in the encoding length of the matrix. The stabilizing step is inspired by Wolfe’s classical minimum-norm-point algorithm [24]. This considers the variant of (P) where the box constraint  x ∈ B(u) is replaced by i∈N xi = 1, x ≥ 0. Wolfe’s algorithm is reminiscent of the simplex method. It comprises major and minor cycles, and at the end of every major cycle, the algorithm maintains a corral solution: for a linearly independent set of columns, the current point is the nearest point to b in the aﬃne hull of these columns, while it also falls inside their convex hull. Wolfe’s algorithm has been successfully employed as a subroutine in various optimization problems, e.g., submodular function minimization [11], see also [1,8,10]. Beyond the trivial 2n bound, the convergence analysis remained elusive; the ﬁrst bound with 1/ε-dependence was given by Chakrabarty et al. [2] in 2014. Lacoste-Julien and Jaggi [14] gave a log(1/ε) bound, parametrized by the pyramidal width of the polyhedron. Recently, De Loera et al. [5] showed an example of exponential time behaviour of Wolfe’s algorithm for the min-norm insertion rule (the analogue of a pivot rule); no exponential example for other insertion rules such as the linopt rule used in the application for submodular minimization. Wolfe’s algorithm works with a polytope in V -representation. Concurrently with Wolfe’s work, Wilhelmsen [23] proposed an equivalent algorithm for uncapacitated (conic) instances of (P), i.e., for a polytope in H-representation. This algorithm can be seen as a special instantiation of our framework, and we show an O(n4 κ2 A2 log(n + κ)) iteration bound. A signiﬁcant diﬀerence compared to the Wolfe and Wolfe–Wilhelmsen algorithms is that the supports of our iterates are not required to be independent. This provides much additional ﬂexibility: our algorithm can be combined with  
   
  144  
   
  S. Fujishige et al.  
   
  a variety of ﬁrst order methods. This feature also yields a signiﬁcant advantage in our computational experiments. Overview of the Algorithm. A key concept in our algorithm is the centroid mapping, deﬁned as follows. For disjoint subsets I0 , I1 ⊆ N , we let L(I0 , I1 ) denote the aﬃne subspace of RN where x(i) = 0 for i ∈ I0 and x(i) = u(i) for i ∈ I1 . For x ∈ B(u), let I0 (x) and I1 (x) denote the subsets of coordinates i with x(i) = 0 and x(i) = u(i), respectively. A centroid mapping Ψ : B(u) → RN is a mapping with the property that Ψ (x) ∈ arg miny { 12 Ay − b2 | y ∈ L(I0 (x), I1 (x))}. This mapping may not be unique, since the columns of A corresponding to {i ∈ N | 0 < x(i) < u(i)} = N \ (I0 (x) ∪ I1 (x)) may not be independent: the optimal centroid set is itself an aﬃne subspace. The point x ∈ B(u) is stable if Ψ (x) = x. Stable points can be seen as the analogues of corral solutions in Wolfe’s algorithm. Every major cycle starts with an update step and ends with a stable point. The update step could be any ﬁrst-order step satisfying some natural requirements, such as variants of Frank–Wolfe, projected gradient, or Wolfe updates. As long as the current iterate is not optimal, this update strictly improves the objective. Finite convergence follows by the fact that there can be at most 3n stable points. After the update step, we start a sequence of minor cycles. From the current iterate x ∈ B(u), we move to Ψ (x) in case Ψ (x) ∈ B(u), or to the intersection of the boundary of B(u) and the line segment [x, Ψ (x)] otherwise. The minor cycles ﬁnish once x = Ψ (x) is a stable point. The objective 12 Ax − b2 is decreasing in every minor cycle, and at least one new coordinate i ∈ N is set to 0 or to u(i). Thus, the number of minor cycles in any major cycle is at most n. One can use various centroid mappings, with only a mild requirement on Ψ (see Sect. 2.2). We present a poly(n, κ) convergence analysis in the uncapacitated case for projected gradient and Wolfe updates. We expect that similar arguments extend to the capacitated case. The proof has two key ingredients. First, we show linear convergence of the ﬁrst-order update steps (Theorem 3). Such a bound follows already from [16]; we present a simple self-contained proof exploiting properties of stable points and the uncapacitated setting. The second step of the analysis shows that in every poly(n, κ) iterations, we can identify a new variable that will never become zero in subsequent iterations (Theorem 2). The proof relies on proximity arguments: we show that for any iterate x and any subsequent iterate x , the distance x − x  can be upper bounded in terms of n, κ, and the optimality gap at x. In Sect. 5, we present preliminary computational experiments using randomly generated problem instances of various sizes. We compare the performance of diﬀerent variants of our algorithm to standard gradient methods. The algorithm performs much better with projected gradient updates than with Wolfe updates. We compare an ‘oblivious’ centroid mapping and one that chooses Ψ (x) as the a nearest point to x in the centroid set in the ‘local norm’ (see Sect. 2.2). The latter one appears to be signiﬁcantly better. For choices of parameters n ≥ 2m, our method with projected gradient updates and local norm mapping outperforms  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  145  
   
  the accelerated gradient method—the best among classical methods—by a factor 10 or more in computational time. Related Work. Arguments that show strongly polynomial convergence by gradually revealing the support of an optimal solution are prevalent in combinatorial optimization. These date back to Tardos’s [21] groundbreaking work giving the ﬁrst strongly polynomial algorithm for minimum-cost ﬂows. Our proof is closer to the dual ‘abundant arc’ algorithms in [9,17]. Tardos generalized the above result for general LP’s, giving a running time dependence poly(n, log Δ(A)), where Δ(A) is the largest subdeterminant of A. This framework was recently strengthened in [4] to poly(n, log κ(A)) running time for the circuit imbalance measure κ(A). We note that the above algorithms—along with many other strongly polynomial algorithms in combinatorial optimization—modify the problem directly once new information is learned about the optimal support. In contrast, our algorithm does not require any such modiﬁcations, nor a knowledge or estimate on the condition number κ. Strongly polynomial algorithms with poly(n, log κ(A)) running time bounds can also be obtained using layered least squares interior point methods. This line of work was initiated by Vavasis and Ye [22] using a related condition measure χ(A). ¯ An improved version that also established the relation between χ(A) ¯ and κ(A) was recently given by Dadush et al. [3]. We refer the reader to the survey [6] for properties and further applications of circuit imbalances. Further Related Work. There are similarities between our algorithm and the Iteratively Reweighted Least Squares (IRLS) method that has been intensively studied since the 1960’s [15,18]. For some p ∈ [0, ∞], A ∈ RM ×N , b ∈ RM , the goal is to approximately solve  p : Ax = b}. At each iteration, a weighted  min{x minimum-norm point min{ w(t) , x : Ax = b} is solved, where the weights w(t) are iteratively updated. The LP-feasibility problem Ax = b, 0 ≤ x ≤ 1 for ﬁnite upper bounds u = 1 can be phrased as an ∞ -minimization problem min{x∞ : Ax = b − A1/2}. Ene and Vladu [7] gave an eﬃcient variant of IRLS for 1 and ∞ -minimization; see their paper for further references. Some variants of our algorithm solve a weighted least squares problem with changing weights in the stabilizing steps. There are however signiﬁcant diﬀerences between IRLS and our method. The underlying optimization problems are diﬀerent, and IRLS does not ﬁnd an exact optimal solution in ﬁnite time. Applied to LP in the ∞ formulation, IRLS satisﬁes Ax = b throughout while violating the box constraints 0 ≤ x ≤ u. In contrast, iterates of our algorithm violate Ax = b but maintain 0 ≤ x ≤ u. The role of the least squares subroutines is also rather diﬀerent in the two settings.  
   
  2  
   
  Preliminaries  
   
  Notation. We use N ⊕ M for disjoint union (or direct sum) of the copies of the two sets. For a matrix A ∈ RM ×N , i ∈ M and j ∈ N , we denote the ith row  
   
  146  
   
  S. Fujishige et al.  
   
  of A by Ai and jth column by Aj . Also for any matrix X denote by X  the matrix transpose of X. We let  · p denote the p vector norm; we use  ·  to denote the Euclidean norm  · 2 . For a matrix A ∈ RM ×N , we let A denote norm. the spectral norm, that is, the 2 → 2 operator  For any x, y ∈ RM we deﬁne x, y = i∈M x(i)y(i). We will use this notation also in other dimensions. We let [x, y] := {λx + (1 − λ)y | λ ∈ [0, 1]} denote the line segment between the vectors x and y. Elementary Vectors and Circuits. For a linear space W  RN , g ∈ W is an elementary vector if g is a support minimal nonzero vector in W , that is, no h ∈ W \{0} exists such that supp(h)  supp(g), where supp denotes the support of a vector. We let F(W ) ⊆ W denote the set of elementary vectors. A circuit in W is the support of some elementary vector; these are precisely the circuits in the associated linear matroid M(W ). The subspaces W = {0} and W = RN are called trivial subspaces, all other subspaces are nontrivial. We deﬁne the circuit imbalance measure     g(j)    | g ∈ F(W ), i, j ∈ supp(g) κ(W ) := max  g(i)  for nontrivial subspaces and κ(W ) = 1 for trivial subspaces. For a matrix A ∈ RM ×N , we use κ(A) to denote κ(ker(A)). Recall that a matrix is totally unimodular (TU) if the determinant of every square submatrix is 0, +1, or −1. A result by Cederbaum from 1957 shows that κ(W ) = 1 if and only if there exists a TU matrix A ∈ RM ×N such that W = ker(A). We also note that if A ∈ ZM ×N , then κ(A) ≤ Δ(A). We say that the vector y ∈ RN conforms to x ∈ RN if x(i)y(i) > 0 whenever y(i) = 0. Given a subspace W ⊆ RN , a conformal circuit decomposition of a vector v ∈ W is a decomposition v=  
   
     
   
  hk ,  
   
  k=1  
   
  where  ≤ n and h1 , h2 , . . . , h ∈ F(W ) are elementary vectors that conform to v. A fundamental result on elementary vectors asserts that for every subspace W ⊆ RN , every v ∈ W admits a conformal circuit decomposition, see e.g. [12,20]. Note that there may be multiple conformal circuit decompositions of a vector. Given A ∈ RM ×N , we deﬁne the extended subspace XA ⊂ RN ⊕M as XA := ker(A | −IM ). Hence, for every v ∈ RN , (v, Av) ∈ XA . For v ∈ RN , the generalized  path-circuit decomposition of v with respect to A is a decomposition v = k=1 hk , where  ≤ n, and for each 1 ≤ k ≤ , (hk , Ahk ) ∈ RN ⊕M is an elementary vector in XA that conforms to (v, Av). Moreover, hk is an inner vector in the decomposition if Ahk = 0 and an outer vector otherwise. We say that v ∈ RN is cycle-free with respect to A, if all generalized pathcircuit decompositions of v contain outer vectors only. The following lemma will play a key role in analyzing our algorithms.  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  147  
   
  Lemma 1. For any A ∈ RM ×N , let v ∈ RN be cycle-free with respect to A. Then, v∞ ≤ κ(XA )Av1 and v2 ≤ nκ(XA )Av2 . Remark 1. We note that a similar argument shows that A ≤ min{nκ(XA ), √ nτ (A)κ(XA )}, where τ (A) is the maximum size of supp(Ah) for an elementary vector (h, Ah) ∈ XA . Example 1. If A ∈ RM ×N is the node-arc incidence matrix of a directed graph D = (M, N ). The system Ax = b, x ∈ B(u) corresponds to a network ﬂow feasibility problem. Here, b(i) is the demand of node i ∈ M , i.e., the inﬂow minus the outﬂow at i is required to be b(i). Recall that A is a TU matrix; consequently, (A| − IM ) is also TU, and κ(XA ) = 1. Our algorithm is strongly polynomial in this setting. Note that inner vectors correspond to cycles and outer vectors to paths; this motivates the term ‘generalized path-circuit decomposition’. We also √ note τ (A) = 2, and thus A ≤ 2 n in this case. 2.1  
   
  Optimal Solutions and Proximity  
   
  We deﬁne the set Z(A, u) := {Ax | x ∈ B(u)} . Thus, Problem (P) is to ﬁnd the point in Z(A, u) that is nearest to b with respect to the Euclidean norm. We note that if the upper bounds u are ﬁnite, Z(A, u) is called a zonotope. Throughout, we let p∗ denote the optimum value of (P). Note that whereas the optimal solution x∗ may not be unique, the vector b∗ := Ax∗ is unique by strong convexity; we have p∗ = 12 b − b∗ 2 . We use η(x) := 12 Ax − b2 − p∗ to denote the optimality gap for x ∈ B(u). The point x ∈ B(u) is an εapproximate solution if η(x) ≤ ε. For a point x ∈ B(u), let I0 (x) := {i ∈ N : x(i) = 0}, I1 (x) := {i ∈ N : x(i) = u(i)}, and J(x) := N \ (I0 (x) ∪ I1 (x)). The gradient of the objective 1 2 2 Ax − b in (P) can be written as g x := A (Ax − b) . We recall the ﬁrst order optimality conditions: x ∈ B(u) is an optimal solution to (P) if and only if g x (i) = 0 for all i ∈ J(x), g x (i) ≥ 0 for all i ∈ I0 (x), and g x (i) ≤ 0 for all i ∈ I1 (x). Using Lemma 1, we can show: Lemma 2. For any x ∈ B(u), there exists an optimal solution x∗ to (P) such that x − x∗ ∞ ≤ κ(XA )Ax − b∗ 1 , and hence, x − x∗ 2 ≤ nκ(XA )Ax − b∗ 2 .  
   
  148  
   
  2.2  
   
  S. Fujishige et al.  
   
  The Centroid Mapping  
   
  Let us denote by 3N the set of all ordered pairs (I0 , I1 ) of disjoint subsets I0 , I1 ⊆ N , and let I∗ := {i ∈ N | u(i) < ∞}. For any (I0 , I1 ) ∈ 3N with I1 ⊆ I∗ , we let L(I0 , I1 ) := {x ∈ RN | ∀i ∈ I0 : x(i) = 0, ∀i ∈ I1 : x(i) = u(i) } . We call {Ax | x ∈ B(u) ∩ L(I0 , I1 )} ⊆ Z(A, u) a pseudoface of the Z(A, u). We note that every face of Z(A, u) is a pseudoface, but there might be pseudofaces that do not correspond to any face. We deﬁne a centroid set for (I0 , I1 ) as C(I0 , I1 ) := arg min {Ay − b | y ∈ L(I0 , I1 ))} . y  
   
  Proposition 1. For (I0 , I1 ) ∈ 3N with I1 ⊆ I∗ , C(I0 , I1 ) is an aﬃne subspace of RN , and there exists w ∈ RM such that Ay = w for every y ∈ C(I0 , I1 ). The centroid mapping Ψ : B(u) → RN is a mapping that satisﬁes Ψ (Ψ (x)) = Ψ (x) and  
   
  Ψ (x) ∈ C(I0 (x), I1 (x)) , ∀x ∈ B(u)  
   
  We say that x ∈ B(u) is a stable point if Ψ (x) = x. A simple, ‘oblivious’ centroid mapping arises by taking the minimum-norm point of the centroid set: Ψ (x) := arg min{y | y ∈ C(I0 (x), I1 (x))} .  
   
  (1)  
   
  However, this mapping has some undesirable properties. For example, we may have an iterate x that is already in C(I0 (x), I1 (x)), but Ψ (x) = x. Instead, we aim for centroid mappings that move the current point ‘as little as possible’. The centroid mapping Ψ is called cycle-free, if the vector Ψ (x) − x is cycle-free w.r.t. A for every x ∈ B(u). ×N be a positive diagonal matrix. Lemma 3. For every x ∈ B(u), let D(x) ∈ RN >0 Then, the following Ψ (x) deﬁnes a cycle-free centroid mapping:  
   
  Ψ (x) := arg min{D(x)(y − x) | y ∈ C(I0 (x), I1 (x))} .  
   
  (2)  
   
  We emphasize that D(x) in the statement is a function of x and can be any positive diagonal matrix. Note also that the diagonal entries for indices in I0 (x) ∪ I1 (x) do not matter. In our experiments, deﬁning D(x) with diagonal entries 1/x(i)+1/(u(i)−x(i)) for i ∈ J(x) performs particularly well. Intuitively, this choice aims to move less the coordinates close to the boundary. The next proposition follows from Lagrangian duality. We note that Ψ (x) as in (1) or (2) can be computed by solving a system of linear equations. Proposition 2. For a partition N = I0 ∪ I1 ∪ J, the centroid set can be written as C(I0 , I1 ) = y ∈ L(I0 , I1 ) | (AJ ) (Ay − b) = 0 .  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  3  
   
  149  
   
  The Update-and-Stabilize Framework  
   
  Now we describe a general algorithmic framework MNPZ(A, b, u) for solving (P), shown in Algorithm 1. Similarly to Wolfe’s MNP algorithm, the algorithm comprises major and minor cycles. We maintain a point x ∈ B(u), and x is stable at the end of every major cycle. Each major cycle starts by calling the subroutine Update(x); the only general requirement on this subroutine is: (U1) for y = Update(x), y = x if and only if x is optimal to (P), and Ay − b < Ax − b otherwise, and (U2) if y = x, then for any λ ∈ [0, 1), z = λy + (1 − λ)x satisﬁes Ay − b < Az − b. Property (U1) can be obtained from any ﬁrst order algorithm; we introduce some important examples below. Property (U2) might be violated if using a ﬁxed step-length, which is a common choice. In order to guarantee (U2), we can post-process the ﬁrst order update that returns y  by choosing y as the optimal point on the line segment [x, y  ]. The algorithm terminates once x = Update(x). In the minor cycles, as long as w := Ψ (x) = x, i.e., x is not stable, we set x := w if w ∈ B(u); otherwise, we set the next x as the intersection of the line segment [x, w] and the boundary of B(u). The requirement (U1) is already suﬃcient to show ﬁnite termination.  
   
  Algorithm 1: MNPZ(A, b, u)  
   
  1 2 3 4 5 6 7 8 9 10 11 12  
   
  Input : A ∈ RM ×N , b ∈ RM , u ∈ (R ∪ {∞})N Output: An optimal solution x to (P) x ←initial point from B(u) ; repeat x ← Update(x) ; w ← Ψ (x) ; while Ψ (x) = x do α∗ ← arg max{α ∈ [0, 1] | x + α(w − x) ∈ B(u)} ; x ← x + α∗ (w − x) ; w ← Ψ (x) ;  
   
  // Major cycle // Minor cycle  
   
  x←w; until x = Update(x) return x  
   
  Theorem 1. Consider any Update(x) subroutine that satisﬁes (U1) and any centroid mapping Ψ . The algorithm MNPZ(A, b, u) ﬁnds an optimal solution to (P) within 3n major cycles. Every major cycle contains at most n minor cycles.  
   
  150  
   
  S. Fujishige et al.  
   
  We can implement the Update(x) subroutine satisfying (U1) and (U2) using various ﬁrst order methods for constrained optimization. Recall the notation g x for the gradient g x ; we use g = g x when x is clear from the context. The following property of stable points can be compared to the optimality conditions: Lemma 4. If x(= Ψ (x)) is a stable point, then g(j) = 0 for all j ∈ J(x). We now describe three classical options. We stress that the choice of the centroid mapping Ψ can be chosen independently of the update step. The Frank–Wolfe Update. The Frank–Wolfe or conditional gradient method is applicable only in the case when u(i) is ﬁnite for every i ∈ N . In every update step, we start by computing y¯ as the minimizer of the linear objective g, y over B(u), that is, y¯ ∈ arg min{ g, y | y ∈ B(u)}. We set Update(x) := x if g, y¯ = g, x , or y = Update(x) is selected so that y minimizes 12 Ay − b2 on the line segment [x, y¯]. Clearly, y¯(i) = 0 if g(i) > 0, and y¯(i) = u(i) if g(i) < 0. But, y¯(i) can be chosen arbitrarily if g(i) = 0. In this case, we keep y¯(i) = x(i); this will be signiﬁcant to guarantee stability of solutions in the analysis. The Projected Gradient Update. The projected gradient update moves in the opposite gradient direction to y¯ := x − λg for some step-length λ > 0, and obtains the output y = Update(x) as the projection y of y¯ to the box B(u). This projection simply changes every negative coordinate to 0 and every y¯(i) > u(i) to y(i) = u(i). To ensure (U2), we can perform an additional step that replaces y by the point y  ∈ [x, y] that minimizes 12 Ay  − b2 . Consider now an uncapacitated instance (i.e., u(i) = ∞ for all i ∈ N ), and let x be a stable point. Recall I1 (x) = ∅ in the uncapacitated setting. Lemma 4 allows us to write the projected gradient update in the following simple form that also enables to use optimal line search. Deﬁne z x (i) := max{−g x (i), 0}, and use z = z x when clear from the context. Note that x is optimal to (P) if and only if z = 0. We use the optimal line search  
   
  y := arg min 12 Ay − b2 | y = x + λz, λ ≥ 0 . y  
   
  If z = 0, this can be written explicitly as y := x +  
   
  z2 z. Az2  
   
  To verify this formula, note that z2 = − g, z , since either z(i) = 0 or z(i) = −g(i).  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  151  
   
  The Wolfe Update. Our third update resembles Wolfe’s algorithm. In the uncapacitated case, it corresponds to the Wolfe–Wilhelmsen algorithm. Given a stable point x ∈ B(u), we select a coordinate j ∈ N where either j ∈ I0 (x) and g(j) < 0 or j ∈ I1 (x) and g(j) > 0, and set y such that y(i) = x(i) if i = j, and y(j) is chosen in [0, u(j)] so that 12 Ay − b2 is minimized. Analogously to Wolfe’s algorithm, we can maintain basic solutions throughout. Namely, if AJ is linearly independent for J = J(x), then one can show that  AJ is also linearly independent for J  = J(y) = J ∪ {j}, where y = Update(x ). Assume we start with x = 0, i.e., J(x) = I1 (x) = ∅, I0 (x) = N . Then, AJ(x) remains linearly independent throughout. Hence, every stable solution x is a basic solution to (P). Note that whenever AJ(x) is linearly independent, C(I0 (x), I1 (x)) contains a single point, hence, Ψ (x) is uniquely deﬁned. Consider now the uncapacitated setting. For z = z x , let us return y = x if z = 0. Otherwise, let j ∈ arg maxk z(k); note that j ∈ I0 (x). Let x(i) if i ∈ N \ {j}, y(i) := z(i) if i = j. Ai 2 It is easy to verify that the Frank–Wolfe, projected gradient, and Wolfe update rules all satisfy (U1) and (U2). For projected gradient, for the updates in the uncapacitated form as described above, (U2) is guaranteed. For the general form with upper bounds, we can perform a post-processing as noted above to ensure (U2). We say that Update(x ) is a cycle-free update rule, if for every x ∈ B(u) and y = Update(x ), x − y is cycle-free w.r.t. A. One can show that the Frank–Wolfe, projected gradient, and Wolfe updates are all cycle-free.  
   
  4  
   
  Analysis  
   
  Theorem 2. Consider an uncapacitated instance of (P), and assume we use a cycle-free centroid mapping. Algorithm 1 terminates with an optimal solution in O(n3 κ2 (XA )A2 log(n + κ(XA ))) major cycles using projected gradient updates, and in O(n4 κ2 (XA )A2 log(n + κ(XA ))) major cycles using Wolfe updates. In both cases, the total number of minor cycles is O(n4 κ2 (XA )A2 log(n+κ(XA ))). Proximity Bounds. We show that if using a cycle-free update rule and a cycle-free centroid mapping, the movement of the iterates in Algorithm 1 can be bounded by the change in the objective value. First, a nice property of the centroid set is that the movement of Ax directly relates to the decrease in the objective value. Namely, Lemma 5. For x ∈ B(u), let y ∈ C(I0 (x), I1 (x)). Then, Ax − Ay2 = Ax − b2 −Ay−b2 . Consequently, if Ψ is a cycle-free centroid mapping and y = Ψ (x), then  
   
  x − y2 ≤ n2 κ2 (XA ) Ax − b2 − Ay − b2 . Next, let us consider the movement of x during a call to Update(x ).  
   
  152  
   
  S. Fujishige et al.  
   
  Lemma 6. Let x ∈ B(u) and y = Update(x ). Then, Ax − Ay2 ≤ Ax − b2 − Ay − b2 . If using a cycle-free update rule, we also have  
   
  x − y2 ≤ n2 κ2 (XA ) Ax − b2 − Ay − b2 . Lemma 7. Let x ∈ B(u), and let x be an iterate obtained by consecutive t major or minor updates of Algorithm 1 using a cycle-free update rule and a cycle-free centroid mapping, starting from x. Then,  √ x − x  ≤ nκ(XA ) 2t · 21 Ax − b2 − 12 Ax − b2 . Geometric Convergence of the Projected Gradient and Wolfe Updates. Recall that η(x) denotes the optimality gap at x. Theorem 3. Consider an uncapacitated instance of (P), and let x ≥ 0 be a stable point. Then for y = Update(x) using the projected gradient update, we 2 2 2 κ (XA )A ) η(x). Using the Wolfe updates, we have have η(y)  
   
  ≤ 1 − 31/(2n 2 2 η(y) ≤ 1 − 1/(2n κ (XA )A ) η(x). The theorem follows easily from the next two lemmas. First, we formulate the update progress using optimal line search, and next, we use Lemma 2 to bound z. Lemma 8. For a stable point x ≥ 0, the projected gradient update satisﬁes Ax − b2 − Ay − b2 ≥ z2 /A2 , and the Wolfe update satisﬁes Ax − b2 − Ay − b2 = z(j)2 /Aj 2 . x Lemma  9. For√a stable point x ≥ 0 and the update direction z = z , we have z ≥ η(x)/( 2nκ(XA )).  
   
  Proof. Let x∗ ≥ 0 be an optimal solution to (P) as in Lemma 2, and b∗ = Ax∗ . Using convexity of f (x) := 12 Ax−b2 , we have p∗ = f (x∗ ) ≥ f (x)+ g, x∗ −x ≥ f (x) − z, x∗ − x , where the second inequality follows by noting that for each i ∈ N , either z(i) = −g(i), or z(i) = 0 and g(i)(x∗ (i) − x(i)) ≥ 0. From the Cauchy-Schwarz inequality and Lemma 2, we get p∗ ≥ f (x) − z · x∗ − x ≥ f (x) − nκ(XA )Ax − b∗  · z, that is, z ≥ η(x)/nκ(XA )Ax − b∗ . The proof is complete by showing 2η(x) ≥ Ax − b∗ 2 . Recalling that η(x) = 12 Ax − b2 − 12 Ax∗ − b2 and that b∗ = Ax∗ , this is equivalent to Ax − Ax∗ , Ax∗ − b ≥ 0. This can be further written as x − ∗ x∗ , g x ≥ 0, which is implied by the ﬁrst order optimality condition at x∗ . This proves 2η(x) ≥ Ax − b∗ 2 , and hence the lemma follows. Overall Convergence Bounds. We now prove Theorem 2. Using Lemma 7 and Theorem 3, we can derive the following stronger proximity bound: Lemma 10. Consider an uncapacitated instance of (P). Let x ≥ 0 be an iterate of Algorithm 1 using projected gradient updates, and let x ≥ 0 be any  later iterate. Then, for a value Θ := O(n2.5 κ2 (XA )A), we have x − x  ≤ Θ η(x).  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  153  
   
  We need one more auxiliary lemma. Lemma 11. Consider an uncapacitated instance of (P), and let x ≥ 0 be a stable point. Let x ˆ ≥ 0 such that for each i ∈ N , either x ˆ(i) = x(i), or x ˆ(i) = x − Ax2 . 0 < x(i). Then, Aˆ x − b2 = Ax − b2 + Aˆ For the threshold Θ as in Lemma 10 and for any x ≥ 0, let us deﬁne    J  (x) := i | x(i) > Θ η(x) . The following is immediate from Lemma 10. Lemma 12. Consider an uncapacitated instance of (P). Let x ≥ 0 be an iterate of Algorithm 1 using projected gradient updates, and x ≥ 0 be any later iterate. Then, J  (x) ⊆ J(x ). Proof (Proof of Theorem 2). At any point of the algorithm, let J  denote the Consider a stable iterate x union of the sets J  (x) for all iterations thus far.  at the beginning of any major cycle, and let ε := η(x)/4nΘA. Theorem 3 (XA )A2 log(n + for projected gradient updates guarantees that within O(n2 κ2  κ(XA ))) major cycles we arrive at an iterate x such that η(x ) < ε. The bound is O(n3 κ2 (XA )A2 log(n + κ(XA ))) for Wolfe updates. We note that log(n + κ(XA ) + A) = O(log(n + κ(XA ))) according to Remark 1. We show that (3) J  (x ) ∩ I0 (x) = ∅. From here, we can conclude that J  was extended between iterates x and x . This may happen at most n times, and so we get the claimed bounds on the number of major cycles. The bound on the minor cycles for projected gradient updates follows since every major cycle contains at most n minor cycles. For Wolfe updates, it follows since every major cycle adds on one component to J(x) whereas every minor cycle removes at least one. Hence, the total number of minor cycles is at most m plus the total number of major cycles. For a contradiction, assume that (3) does not hold. Thus, for every i ∈ I0 (x), ˆ ∈ RN as x ˆ(i) := 0 if i ∈ I0 (x), and we have x (i) ≤ Θε. Let us deﬁne x  By the above assumption, ˆ x − x ∞ ≤ Θε, and x ˆ(i) := x (i) if i ∈ J(x). √  x − b2 = therefore Aˆ x − Ax  ≤ nΘAε. From Lemma 11, we can bound Aˆ  2  2 ∗ 2 2 2 x − Ax  ≤ 2p + (nΘ A + 2)ε . Recall that since x is a Ax − b + Aˆ ˆ is a feasible stable solution, Ax−b = min {Ay − b : y ∈ L(I0 (x), ∅)}. Since x solution to this program, it follows that Aˆ x − b2 ≥ Ax − b2 . We get that x − b2 − 2p∗ ≤ (nΘ2 A2 + 2)ε2 , in contradiction 2η(x) = Ax − b2 − 2p∗ ≤ Aˆ with the choice of ε.  
   
  5  
   
  Computational Experiments  
   
  We give preliminary computational experiments of diﬀerent versions of our algorithm, and compare them to standard gradient methods. The experiments were  
   
  154  
   
  S. Fujishige et al.  
   
  programmed and executed by MATLAB version R2021b on a personal computer having 11th Gen Intel(R) Core(TM) i7-11370H @ 3.30GHz and 16GB of memory. We present results on randomly generated uncapacitated instances. The full version contains more experiments, also on capacitated instances, and also including the Frank–Wolfe method. The entries of the m × n matrix A and the m dimensional vector b were chosen independently uniformly at random from the interval [−0.5, 0.5]. Thus, the underlying LP Ax = b, x ≥ 0 may or may not be feasible. For the case m = 1000, n = 1050, this leads to infeasible instance with high probability. In this case, we also generated feasible instances by sampling coeﬃcients w(i) ∈ [0, 1] uniformly at random, and setting b = Aw. We test each combination of two update methods: Projected Gradient (PG) and Wolfe (W); and two centroid mappings, the ‘oblivious’ mapping (1) and the ‘local norm’ mapping (2) with diagonal entries 1/x(i) + 1/(u(i) − x(i)). Recall that for Wolfe updates, there is a unique centroid mapping. We benchmark against standard constrained ﬁrst order methods: the projected gradient (PG), and the projected fast (accelerated) gradient method (PFG). In contrast to our algorithm, these do not ﬁnitely terminate. We stopped these algorithms once they found a near-optimal solution within a certain accuracy threshold. We stopped each algorithm when the computation time reached 180 s. For each (m, n), we test all the algorithms 10 times and the results shown below are the 10-run averaged ﬁgures. Table 1 shows the overall computational times; values in brackets show the number of trials whose computation time exceeded 180 s. For the ‘near-square’ case m = 1000, n = 1050, status ‘I’ denotes infeasible and ‘F’ feasible instances. Table 2 shows the number of major cycles and the total number of minor cycles. In our framework, projected gradient updates perform signiﬁcantly better than Wolfe updates, except for infeasible ‘near-square’ instances. For Wolfe updates, the number of major and minor cycles is similar; projected gradient performs much fewer major cycles. Among the two centroid mappings, the ‘localnorm’ update (2) performs signiﬁcantly better than the ‘oblivious’ update (1). There is a marked diﬀerence between infeasible and feasible ‘near-square’ instances. Our algorithms perform well on feasible instances. For infeasible instances, the running time is much longer, with an excessive number of minor cycles. As one may expect, projected fast gradient is signiﬁcantly better than project gradient. For ‘rectangular’ (n ≥ 2m) instances, our method with projected gradient updates together with the centroid mapping (2), outperforms fast gradient by a factor 10 or more. This is despite the fact that centroid mappings are computationally more expensive than ﬁrst order methods. For feasible near-square instances, the performance in these two cases is similar. However, for infeasible near-square instances, our algorithms are outperformed by projected gradient and projected fast gradient methods.  
   
  An Update-and-Stabilize Framework for the Minimum-Norm-Point Problem  
   
  155  
   
  Table 1. Computation time (in sec) for random uncapacitated instances m n Status  
   
  100 200 200 400  
   
  PG+(1) 0.37 3.19 PG+(2) 0.04 0.31 0.20 1.90 W PG PFG  
   
  300 600  
   
  500 1000  
   
  500 3000  
   
  11.07 0.81 6.69  
   
  79.17 1.76 33.75  
   
  142.67 (4) 58.57 5.68 2.37 57.72 0.86 47.83 22.80 149.73  
   
  3.49 87.07 (3) 118.91 (5) 112.85 (5) 5.31 0.17 4.13 17.48 47.33 (1) 6.17  
   
  1000 1000 1050 1050 I F  
   
  6.26 5.15  
   
  180.00 (10) 92.59  
   
  Table 2. # of major cycles (ﬁrst number) and total # of minor cycles (second number) for random uncapacitated instances m n Status  
   
  100 200  
   
  200 400  
   
  300 600  
   
  500 1000  
   
  500 3000  
   
  1000 1000 1050 1050 I F  
   
  PG+(1) 6.0 9.5 11.6 11.9 1.0 4.1 1.0 199.7 462.6 759.6 1505.2 1513.9 599.7 31.6 PG+(2) 2.2 23.5 W  
   
  2.8 30.9  
   
  2.6 36.9  
   
  2.2 29.8  
   
  121 265.4 401.1 653.5 144.6 333.4 506.1 810.2  
   
  1.0 1.0  
   
  4.1 1.0 570.2 3.1  
   
  501.4 508.2  
   
  526.7 1091.6 530.8 1182.2  
   
  Acknowledgments. The third author would like to thank Richard Cole, Daniel Dadush, Christoph Hertrich, Bento Natura, and Yixin Tao for discussions on ﬁrst order methods and circuit imbalances.  
   
  References 1. Bach, F.: Learning with submodular functions: a convex optimization perspective. Found. Trends Mach. Learn. 6(2–3), 145–373 (2013) 2. Chakrabarty, D., Jain, P., Kothari, P.: Provable submodular minimization using Wolfe’s algorithm. In: Advances in Neural Information Processing Systems, vol. 27 (2014) 3. Dadush, D., Huiberts, S., Natura, B., Végh, L.A.: A scaling-invariant algorithm for linear programming whose running time depends only on the constraint matrix. In: Proceedings of the 52nd Annual ACM Symposium on Theory of Computing (STOC), pp. 761–774 (2020) 4. Dadush, D., Natura, B., Végh, L.A.: Revisiting Tardos’s framework for linear programming: faster exact solutions using approximate solvers. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp. 931–942 (2020)  
   
  156  
   
  S. Fujishige et al.  
   
  5. De Loera, J.A., Haddock, J., Rademacher, L.: The minimum Euclidean-norm point in a convex polytope: Wolfe’s combinatorial algorithm is exponential. SIAM J. Comput. 49(1), 138–169 (2020) 6. Ekbatani, F., Natura, B., Végh, A.L.: Circuit imbalance measures and linear programming. In: Surveys in Combinatorics 2022. London Mathematical Society Lecture Note Series, pp. 64–114. Cambridge University Press, Cambridge (2022) 7. Ene, A., Vladu, A.: Improved convergence for 1 and ∞ regression via iteratively reweighted least squares. In: International Conference on Machine Learning, pp. 1794–1801. PMLR (2019) 8. Fujishige, S.: Lexicographically optimal base of a polymatroid with respect to a weight vector. Math. Oper. Res. 5(2), 186–196 (1980) 9. Fujishige, S.: A capacity-rounding algorithm for the minimum-cost circulation problem: a dual framework of the Tardos algorithm 35(3), 298–308 (1986) 10. Fujishige, S., Hayashi, T., Yamashita, K., Zimmermann, U.: Zonotopes and the LP-Newton method. Optim. Eng. 10(2), 193–205 (2009) 11. Fujishige, S., Isotani, S.: A submodular function minimization algorithm based on the minimum-norm base. Pac. J. Optim. 7(1), 3–17 (2011) 12. Fulkerson, D.: Networks, frames, blocking systems. Math. Decis. Sci. Part I, Lect. Appl. Math. 2, 303–334 (1968) 13. Hoﬀman, A.J.: On approximate solutions of systems of linear inequalities. J. Res. Natl. Bur. Stand. 49(4), 263–265 (1952) 14. Lacoste-Julien, S., Jaggi, M.: On the global linear convergence of Frank-Wolfe optimization variants. In: Advances in Neural Information Processing Systems, vol. 28 (2015) 15. Lawson, C.L.: Contribution to the theory of linear least maximum approximation. Ph.D. thesis (1961) 16. Necoara, I., Nesterov, Y., Glineur, F.: Linear convergence of ﬁrst order methods for non-strongly convex optimization. Math. Program. 175(1), 69–107 (2019) 17. Orlin, J.B.: A faster strongly polynomial minimum cost ﬂow algorithm. Oper. Res. 41(2), 338–350 (1993) 18. Osborne, M.R.: Finite Algorithms in Optimization and Data Analysis. Wiley, Hoboken (1985) 19. Peña, J., Vera, J.C., Zuluaga, L.F.: New characterizations of Hoﬀman constants for systems of linear constraints. Math. Program. 1–31 (2020) 20. Rockafellar, R.T.: The elementary vectors of a subspace of RN . In: Combinatorial Mathematics and Its Applications: Proceedings North Carolina Conference, Chapel Hill, 1967, pp. 104–127. The University of North Carolina Press (1969) 21. Tardos, É.: A strongly polynomial minimum cost circulation algorithm. Combinatorica 5(3), 247–255 (1985) 22. Vavasis, S.A., Ye, Y.: A primal-dual interior point method whose running time depends only on the constraint matrix 74(1), 79–120 (1996) 23. Wilhelmsen, D.R.: A nearest point algorithm for convex polyhedral cones and applications to positive linear approximation. Math. Comput. 30(133), 48–57 (1976) 24. Wolfe, P.: Finding the nearest point in a polytope. Math. Program. 11(1), 128–149 (1976)  
   
  Stabilization of Capacitated Matching Games Matthew Gerstbrein1 , Laura Sanità2 , and Lucy Verberk3(B) 1  
   
  3  
   
  University of Waterloo, Waterloo, Canada [email protected]  2 Bocconi University, Milan, Italy [email protected]  Eindhoven University of Technology, Eindhoven, The Netherlands [email protected]   
   
  Abstract. An edge-weighted, vertex-capacitated graph G is called stable if the value of a maximum-weight capacity-matching equals the value of a maximum-weight fractional capacity-matching. Stable graphs play a key role in characterizing the existence of stable solutions for popular combinatorial games that involve the structure of matchings in graphs, such as network bargaining games and cooperative matching games. The vertex-stabilizer problem asks to compute a minimum number of players to block (i.e., vertices of G to remove) in order to ensure stability for such games. The problem has been shown to be solvable in polynomialtime, for unit-capacity graphs. This stays true also if we impose the restriction that the set of players to block must not intersect with a given speciﬁed maximum matching of G. In this work, we investigate these algorithmic problems in the more general setting of arbitrary capacities. We show that the vertex-stabilizer problem with the additional restriction of avoiding a given maximum matching remains polynomial-time solvable. Diﬀerently, without this restriction, the vertex-stabilizer problem becomes NP-hard and even hard to approximate, in contrast to the unit-capacity case. Finally, in unit-capacity graphs there is an equivalence between the stability of a graph, existence of a stable solution for network bargaining games, and existence of a stable solution for cooperative matching games. We show that this equivalence does not extend to the capacitated case. Keywords: Matching  
   
  1  
   
  · Game theory · Network bargaining  
   
  Introduction  
   
  Network Bargaining Games (NBG) and Cooperative Matching Games (CMG) are popular combinatorial games involving the structure of matchings in graphs. CMG were introduced in the seminal paper of Shapley and Shubik 50 years ago [18], and have been widely studied since then. NBG are relatively more recent, and were deﬁned by Kleinberg and Tardos [14] as a generalization of Nash’s 2-player bargaining solution [17]. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 157–171, 2023. https://doi.org/10.1007/978-3-031-32726-1_12  
   
  158  
   
  M. Gerstbrein et al.  
   
  Instances of these games are described by a graph G = (V, E) with weights w ∈ RE ≥0 , where the vertices and the edges model the players and their potential interactions, respectively. The value of a maximum-weight matching, denoted as ν(G), is the total value that players can collectively accumulate. The goal, roughly speaking, is to assign values to players in such a way that players have no incentive to deviate from the current allocation. Formally, in an instance of a NBG, players want to enter in a deal with one of their neighbours, and agree on how to split the value of the deal given by the weight of the corresponding edge. Hence, an outcome is naturally associated with a matching M of G representing the deals, and allocation vector y ∈ RV≥0 with yu + yv = wuv if uv ∈ M , and yv = 0 if v is not matched. An outcome (M, y) is stable if each player’s allocation yu is at least as large as their outside option, formally deﬁned as maxv:uv∈E\M {wuv − yv }. In an instance of a CMG, one wants to ﬁnd an allocation of total value ν(G), given by a vector y ∈ RV≥0 in which no subset of players can gain more by forming a coalition. This condition is enforced by the constraint v∈S yv ≥ ν(G[S]) for all S ⊆ V , where G[S] indicates the subgraph of G induced by the vertices in S. Such allocation is called stable, and the set of stable allocations constitutes the core of the game. Despite having been deﬁned in diﬀerent contexts, there is a tight link between stable solutions of these types of games. In particular, if each game is played on the same graph G, then it has been shown that either a stable solution exists for both games, or for neither game. This follows as both games admit the same polyhedral characterization of instances with stable solutions [7,14]. Speciﬁcally, a stable solution exists if and only if ν(G) equals the value of the standard linear programming (LP) relaxation of the maximum matching problem deﬁned as     xuv ≤ 1 ∀v ∈ V, x ≥ 0 . (1) νf (G) := max w x : u:uv∈E  
   
  A graph G for which ν(G) = νf (G) is called stable. As a result of this characterization, it is easy to see that there are graphs which do not admit stable solutions (to either type of game), such as odd cycles. Given that not all graphs are stable, naturally arises the stabilization problem of how to minimally modify a graph to turn it into a stable one. Stabilization problems attracted a lot of attention in the literature in the past years (see e.g. [1,3–6,13,15,16]). In this context, very natural operations to stabilize graphs are edge- and vertex-removal operations. Those have an interesting interpretation: they correspond to blocking interactions and players, respectively, in order to ensure a stable outcome. While removing a minimum number of edges to stabilize a graph is NP-hard already for unit weight graphs [4], and even hard-to-approximate with a constant factor [11,15], stabilizing the graph via vertex-removal operations turned out to be solvable in polynomial-time. Speciﬁcally, [1,13] showed that computing a minimum-cardinality set of players to block in order to stabilize an unweighted graph (called the vertex-stabilizer problem) can be done in polynomial time. Furthermore, [1] showed that computing a minimum set of players to block in order to make a given maximum matching realizable as a stable outcome  
   
  Stabilization of Capacitated Matching Games  
   
  159  
   
  (called the M -vertex-stabilizer problem) is also eﬃciently solvable. The authors of [15] showed that both results generalize to weighted graphs. This paper focuses on Capacitated NBG, introduced by Bateni et al [2] as a generalization of NBG, to capture the more realistic scenario where players are allowed to enter in more than one deal. This generalization can be modeled by allowing for vertex capacities c ∈ ZV≥0 . The notion of a matching is therefore generalized to a c-matching, where each vertex v ∈ V is matched with at most cv vertices. In this case, the value of a maximum-weight c-matching of a graph G is denoted as ν c (G), and the standard LP relaxation is given by    c  xuv ≤ cv ∀v ∈ V, 0 ≤ x ≤ 1 . (2) νf (G) := max w x : u:uv∈E  
   
  An outcome to the NBG is associated with a c-matching M and a vector a ∈ R2E ≥0 that satisﬁes auv + avu = wuv if uv ∈ M , and auv = avu = 0 otherwise. The concepts of outside option and stable outcome can be deﬁned similarly as in the unit-capacity case, see [2]. The authors of [2] proved that the LP characterization of stable solutions generalize, i.e., there exist a stable outcome for the capacitated NBG on G if and only if ν c (G) = νfc (G) (i.e., G is stable). Farczadi et al [9] show that some other important properties of NBG extend to this capacitated generalization, such as the possibility to eﬃciently compute a so-called balanced solution (we refer to [9] for details). The goal of this paper is to investigate whether the other two signiﬁcant features of NBG mentioned before generalize to the capacitated setting. Namely: (i) Can one still eﬃciently stabilize instances via vertex-removal operations? (ii) Does the equivalence between existence of stable allocations for capacitated CMG and existence of stable solutions for capacitated NBG still hold? Our Results. In this paper we provide an answer to the above questions. We investigate the M -vertex-stabilizer problem and the vertex-stabilizer problem in the capacitated setting in Sects. 3 and 4, respectively. While for unit-capacity graphs both problems are eﬃciently solvable, we show that adding capacities makes the complexity status of the vertex-stabilizer problem diverge. In particular, we prove that the vertex-stabilizer problem is NP-complete, and no n1−ε -approximation is possible, for any ε > 0, unless P=NP. Note that a trivial n-approximation algorithm can be easily developed. In contrast, we show that the M -vertex-stabilizer problem is still polynomialtime solvable in the capacitated setting. Our results here extend those of [15] for unit-capacity graphs, and builds upon an auxiliary construction of [9]. Finally, in Sect. 5 we show that the equivalence between stability of a graph, existence of a stable allocation for CMG and existence of a stable outcome for NBG does not extend in the capacitated setting. In particular, we provide an unstable graph which does attain a stable allocation for the capacitated CMG.1 1  
   
  It is stated in [8] (Theorem 2.3.9) that a stable allocation for capacitated CMG exists iﬀ G is stable, but our example shows this statement is not correct.  
   
  160  
   
  2  
   
  M. Gerstbrein et al.  
   
  Preliminaries and Notation  
   
  Problem Deﬁnition. A set S ⊆ V is called a vertex-stabilizer if G \ S is stable, where G \ S is the subgraph induced by the vertices V \ S. We say that a vertex-stabilizer S preserves a matching M of G if M is a matching in G \ S. We now formally deﬁne the stabilization problems considered in this paper. Vertex-stabilizer Problem: given G = (V, E) with edge weights w ∈ RE ≥0 and vertex capacities c ∈ ZV≥0 , ﬁnd a vertex-stabilizer of minimum cardinality. M -vertex-stabilizer Problem: given G = (V, E) with edge weights w ∈ RE ≥0 , V vertex capacities c ∈ Z≥0 , and a maximum-weight c-matching M , ﬁnd a vertexstabilizer of minimum cardinality among the ones preserving M . An instance of the vertex-stabilizer problem will be denoted as (G, w, c). An instance of the M -vertex-stabilizer problem will be denoted as [(G, w, c), M ]. We say that an instance is stable if G is stable. Without loss of generality, we can assume that cv is bounded by the degree of v ∈ V . Notation. For a vertex v, we let δ(v) be the set of edges of G incident into it, we let N (v) be the set of its neighbours, and N + (v) = N (v) ∪ {v}. For F ⊆ E, we denote by dF v the degree of v in G with respect to the edges in F . We deﬁne w(F ) := e∈F we . Given a c-matching M , we say that v ∈ V is exposed if = 0, and covered if dM for feasible solutions x dM v v > 0. We also use these terms  of (2), called fractional c-matchings, e.g., v is exposed if e∈δ(v) xe = 0. We let n := |V |, and  denote the symmetric diﬀerence operator. We denote a (uv-)walk W by listing its edges and endpoints sequentially, i.e., by W = (u; e1 , . . . , ek ; v). We deﬁne its inverse as W −1 = (v; ek , . . . , e1 ; u). Note that a path is a walk in which edges do not repeat, and internal vertices do not repeat. A cycle is a path which starts and ends at the same vertex. If we refer to the edge set of a walk W , we just write W . Note that this can be a multi-set. Duality and Augmenting Structures. The dual of (2) is given by   τfc (G) := min c y + 1 z : yu + yv + zuv ≥ wuv ∀uv ∈ E, y ≥ 0, z ≥ 0 .  
   
  (3)  
   
  A solution (y, z) feasible for (3) is called a fractional vertex cover. By LP theory, we have ν c (G) ≤ νfc (G) = τfc (G). Definition 1. We say that a walk W is M -alternating (w.r.t. a matching M ) if it alternates edges in M and edges not in M . We say W is M -augmenting if it is M -alternating and w(W \ M ) > w(W ∩ M ). An M -alternating uv-walk W M M ≤ cu and dW ≤ cv . is proper if dW u v Definition 2. Given an M -alternating walk W = (u; e1 , . . . , ek ; v) and an ε > 0, the ε-augmentation of W is the vector xM/W (ε) ∈ RE given by  1 − κ(e)ε if e ∈ M, M/W xe (ε) = (4) κ(e)ε if e ∈ / M,  
   
  Stabilization of Capacitated Matching Games  
   
  161  
   
  where κ(e) = |{i ∈ [k] : ei = e}|. We say that W is feasible if there exists an ε > 0 such that the corresponding ε-augmentation of W is a fractional c-matching. Remark 1. A feasible M -alternating walk with distinct endpoints is proper. Definition 3. An odd cycle C = (v; e1 , . . . , ek ; v) is called an M -blossom if it is M -alternating such that either e1 and ek are both in M , or are both not in M . The vertex v is called the base of the blossom. Definition 4. An M -ﬂower C ∪ P consists of an M -blossom C with base u and an M -alternating path P = (u; e1 , . . . , ek ; v) such that (P, C, P −1 ) is M alternating and feasible. The vertex v is called the root of the ﬂower. The ﬂower is M -augmenting if w(C \ M ) + 2w(P \ M ) > w(C ∩ M ) + 2w(P ∩ M ).  
   
  (5)  
   
  Definition 5. An M -bi-cycle C ∪ P ∪ D consists of two M -blossoms C and D with bases u and v, respectively, and an M -alternating path P = (u; e1 , . . . , ek ; v) such that (P, D, P −1 , C) is M -alternating. The bi-cycle is M -augmenting if w(C \ M ) + 2w(P \ M ) + w(D \ M ) > w(C ∩ M ) + 2w(P ∩ M ) + w(D ∩ M ). (6) Note that, in the last two deﬁnitions, it may happen that P has no edges. Auxiliary Construction. We will use a construction given in [9], to transform an M -vertex-stabilizer instance [(G, w, c), M ] into another one ([(G , w , 1), M  ]) deﬁned on an auxiliary graph with unit capacities. Construction: [(G, w, c), M ] → [(G , w , 1), M  ] 1. For each v ∈ V , create the set Cv = {v1 , . . . , vcv } of cv copies of v, add Cv to V (G ), and initialize J(v) = {1, . . . , cv }. 2. For each uv ∈ M , add a single edge ui vj to both E(G ) and M  with edgeweight wuv , where i ∈ J(u) and j ∈ J(v) are chosen arbitrarily. Remove i and j from J(u) and J(v), respectively. 3. For each edge uv ∈ E \ M , add an edge ui vj to E(G ) with edge-weight wuv , for all ui ∈ Cu and vj ∈ Cv . See Fig. 1 for an example. In this ﬁgure it is easy to see that the matching M  in G is not maximum, even though M is maximum in G.2 Remark 2. If [(G, w, c), M ] has auxiliary [(G , w , 1), M  ], and X ⊆ V is any set of vertices which avoids M , then (G \ X) = G \ X  , where X  = ∪v∈X Cv . We deﬁne a map η to go back from the auxiliary graph G to the original graph G. Speciﬁcally, if ui ∈ V (G ) ∩ Cu for some u ∈ V , then η(ui ) := u, and if ui vj ∈ E(G ) such that ui ∈ Cu , vj ∈ Cv for some u, v ∈ V , then η(ui vj ) := uv. This extends in the obvious way to paths, cycles, walks, and so on. We will need the following theorem. 2  
   
  It was stated in [9, corollary 1] that M is maximum if and only if M  is maximum, but this example shows this to be false.  
   
  162  
   
  M. Gerstbrein et al.  
   
  y t  
   
  u  
   
  v  
   
  x  
   
  t1  
   
  a  
   
  b  
   
  c  
   
  (a) Original graph.  
   
  u1 b1  
   
  z a1  
   
  v1  
   
  b2  
   
  v2  
   
  x1  
   
  x2  
   
  y1  
   
  z1  
   
  c1  
   
  (b) Auxiliary graph.  
   
  Fig. 1. Example of the auxiliary construction on an instance [(G, w, c), M ]. Capacities are all 1 except for cv = cx = cb = 2. Weights are all 1 except for wbc = 0.5. The matching is displayed as bold edges.  
   
  Theorem 1. [(G, w, c), M ] is not stable if and only if the graph G in the auxiliary instance [(G , w , 1), M  ] contains at least one of the following: (i) an M  -augmenting ﬂower; (ii) an M  -augmenting bi-cycle; (iii) a proper M  augmenting path; (iv) an M  -augmenting cycle. Proof. It was proven in [9, Theorem 2] that [(G, w, c), M ] is not stable if and only if [(G , w , 1), M  ] is not stable. We distinguish two scenarios for when the latter condition occurs. If M  is maximum-weight, then G contains an M  -augmenting ﬂower or bi-cycle, see [15, Theorem 1]. If M  is not maximum-weight, G must contain a proper M  -augmenting path or cycle, by standard matching theory. We will refer to an augmenting structure of type (i) − (iv) in Theorem 1 as a basic augmenting structure. The next lemma follows from [15]. Lemma 1. Let [(G , w , 1), M  ] be an unstable instance of NBG. (a) For any M  -exposed vertex u, one can compute a feasible M  -augmenting walk starting at u of length at most 3 |V (G )|, or determine that none exists, in polynomial time. (b) A feasible M  -augmenting uv-walk contains a feasible M  -augmenting uvpath (proper if u = v), an M  -augmenting cycle, an M  -augmenting ﬂower rooted at u or v, or an M  -augmenting bi-cycle. Furthermore, this augmenting structure can be computed in polynomial time. Proof. (a) When given a graph G , a matching M  , a vertex u, and an integer k, algorithm 3 in [15] computes a feasible M  -augmenting uv-walk of length at most k, or determines none exist, for all v ∈ V (G ). Correctness is shown in Lemma 7 and 8 in [15]. The algorithm is polynomial time in k, |V (G )|, and |E(G )|. We use this algorithm and select an arbitrary v for which a uv-walk is returned, or determine that no such walk starting at u exists. Since we set k = 3 |V (G )|, this procedure terminates in polynomial time. (b) Lemma 9 in [15] states that a feasible M  -augmenting uv-walk contains a feasible M  -augmenting uv-path, an M  -augmenting cycle, an M  -augmenting  
   
  Stabilization of Capacitated Matching Games  
   
  163  
   
  ﬂower rooted at u or v, or an M  -augmenting bi-cycle. By remark 1 the path is proper if u = v. Lemma 9 in [15] is proven in a constructive way, hence it also gives a way to compute the augmenting structure in polynomial time. The following easy lemma will be useful. Lemma 2. Given [(G, w, c), M ] and auxiliary [(G , w , 1), M  ], let P be a feasible M  -augmenting walk. Then, η(P ) is a feasible M -augmenting walk. Proof. Let e1 = uv and e2 = vw be two consecutive edges on P . Then η(e1 ) and η(e2 ) are the corresponding edges on η(P ), and they are both incident with η(v). Hence, η(P ) is a walk. For any edge e on P , we have e ∈ M  if and only if η(e) ∈ M . In addition, we = wη(e) . So, η(P ) is an M -augmenting walk. Suppose P = (u; e1 , . . . , ek ; v). Feasibility of P means that either e1 ∈ M  , or u is M  exposed. Likewise for ek and v. It follows that either η(e1 ) ∈ M , or η(u) is M -unsaturated. Likewise for η(ek ) and η(v). This means η(P ) is feasible. The next theorem is standard. Theorem 2. [(G, w, c), M ] is stable if and only if G does not contain a feasible M -augmenting walk. Proof. (⇒) Assume there exists a feasible M -augmenting walk W . Since W is augmenting, w(W \ M ) > w(W ∩ M ), and since W is feasible, xM/W (ε) is a fractional c-matching for some ﬁxed ε > 0. Together they imply νfc (G) ≥ w xM/W (ε) = w(M ) − εw(W ∩ M ) + εw(W \ M ) > w(M ),  
   
  (7)  
   
  i.e., the instance [(G, w, c), M ] is not stable. (⇐) Assume the instance is not stable. Then by Theorem 1, the graph G from the auxiliary [(G , w , 1), M  ] contains a basic augmenting structure, which clearly is a feasible M  -augmenting walk P . Then η(P ) is a feasible M augmenting walk, by Lemma 2.  
   
  3  
   
  M -vertex-stabilizer  
   
  The goal of this section is to prove the following theorem. Theorem 3. The M -vertex-stabilizer problem on weighted, capacitated graphs can be solved in polynomial time. Overview of the Strategy. A natural strategy would be to ﬁrst apply the auxiliary construction described in Sect. 2 to reduce to unit-capacity instances, and then apply the algorithm proposed in [15] which solves the problem exactly. However, there is a critical issue with this strategy. Namely, the auxiliary construction applied to unstable instances does not always preserve maximality of the corresponding matchings, as shown in Fig. 1. In that example, the matching M  is not maximum in G . The algorithm of [15], if applied to an instance where  
   
  164  
   
  M. Gerstbrein et al.  
   
  the given matching is not maximum, is not guaranteed to ﬁnd an optimal solution, but only a 2-approximate one (see Theorem 12 in [15]). In addition, since the auxiliary construction splits a vertex into multiple ones, we may even get infeasible solutions. As a concrete example of this, the algorithm of [15] applied to the instance of Fig. 1b will include b2 in its proposed solution. Mapping this solution to our capacitated instance would imply to remove b, which is clearly not allowed as b is M -covered. To overtake this issue, we do not apply the algorithm of [15] as a black-box, but use parts of it (highlighted in Lemma 1) in a careful way. In particular, we use it to compute a sequence of feasible augmenting walks in G . We actually show that the walks in G which might create the issue described before when mapped backed to G, are the walks in which at least one edge of G is traversed more than once in opposite directions, and that have two distinct endpoints. When this happens, we prove that we can modify the walk and get one where the endpoints coincide, which will still be feasible and augmenting. In this latter case, we can then either correctly identify a vertex to remove (the unique endpoint), or determine that the instance cannot be stabilized. A More Detailed Description. We start by deﬁning the operation of traceback, which we will use to modify the feasible augmenting walks, when needed. Definition 6. Given [(G, w, c), M ] and an M -alternating walk P = (u; e1 , . . . , ek ; v) which repeats an edge in opposite directions, let t be the least index such that et = es for some s < t, and es and et are traversed in opposite directions by P . Then the u-traceback and v-traceback of P are deﬁned as the walks tb(P, u) = (e1 , . . . , et , es−1 , es−2 , . . . , e1 ) and tb(P, v) = (ek , ek−1 . . . , es , et+1 , et+2 , . . . , ek ). The next lemma explains how to use the traceback operation. Due to space constraint, the proof is deferred to the full version of this extended abstract [10]. Lemma 3. Given [(G, w, c), M ] and auxiliary [(G , w , 1), M  ], let P  = (ui ; e1 , . . . , ek ; vj ) be a proper M  -augmenting path such that both ui and vj are M  exposed and η(ui ) = η(vj ). Then tb(η(P  ), η(ui )) and tb(η(P  ), η(vj )) are welldeﬁned, feasible M -alternating walks, and at least one of them is M -augmenting. Proof (Proof of Theorem 3). Let [(G, w, c), M ] be the input for the M -vertexstabilizer problem, with auxiliary [(G , w , 1), M  ]. Algorithm 1 iteratively considers an M  -exposed vertex ui , and computes a feasible M  -augmenting walk U starting at ui , if one exists. Lemma 2 implies that η(U ) is a feasible M augmenting walk in G. Theorem 2 implies that we need to remove at least one vertex of the walk η(U ) to stabilize the graph. Note that every vertex a = ui , vj of U is M  -covered, and hence, η(a) is M -covered. Therefore, the only vertices we can potentially remove are η(ui ) or η(vj ). Hence, if both η(ui ) and η(vj ) are M -covered, the graph cannot be stabilized and Algorithm 1 checks this in line 9. If only one among η(ui ) and η(vj ) is M -covered, then necessarily we have to remove the M -exposed vertex among the two. Algorithm 1 checks this in  
   
  Stabilization of Capacitated Matching Games  
   
  165  
   
  Algorithm 1: ﬁnding an M -vertex-stabilizer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  
   
  32 33 34 35  
   
  input: [(G, w, c), M ] compute the auxiliary [(G , w , 1), M  ] initialize S ← ∅, L ← M  -exposed vertices while L = ∅ do select ui ∈ L and compute a feasible M  -augmenting walk starting at ui using lemma 1(a) if no such walk exists then L ← L \ {ui } else consider the computed feasible M  -augmenting ui vj -walk if both η(ui ) and η(vj ) are M -covered then return infeasible else if η(ui ) is M -covered and η(vj ) is not then S ← S ∪ η(vj ), G ← G \ η(vj ), G ← G \ Cη(vj ) , L ← L \ Cη(vj ) else if η(vj ) is M -covered and η(ui ) is not then S ← S ∪ η(ui ), G ← G \ η(ui ), G ← G \ Cη(ui ) , L ← L \ Cη(ui ) else if η(ui ) = η(vj ) then S ← S ∪ η(ui ), G ← G \ η(ui ), G ← G \ Cη(ui ) , L ← L \ Cη(ui ) else ﬁnd a basic M  -augmenting structure W contained in the ui vj -walk using lemma 1(b) if W is an M  -augmenting cycle or bi-cycle then return infeasible if W is an M  -augmenting flower rooted at ui then S ← S ∪ η(ui ), G ← G \ η(ui ), G ← G \ Cη(ui ) , L ← L \ Cη(ui ) if W is an M  -augmenting flower rooted at vj then S ← S ∪ η(vj ), G ← G \ η(vj ), G ← G \ Cη(vj ) , L ← L \ Cη(vj ) if W is a proper M  -augmenting ui vj -path then compute tb(η(W ), η(ui )) and tb(η(W ), η(vj )) if tb(η(W ), η(ui )) is M -augmenting then S ← S ∪ η(ui ), G ← G \ η(ui ), G ← G \ Cη(ui ) , L ← L \ Cη(ui ) if tb(η(W ), η(vj )) is M -augmenting then S ← S ∪ η(vj ), G ← G \ η(vj ), G ← G \ Cη(vj ) , L ← L \ Cη(vj ) if w(M ) < νfc (G) then return infeasible else return S  
   
  166  
   
  M. Gerstbrein et al.  
   
  line 11 and 13. Note that, by remark 2, instead of computing a new auxiliary for the modiﬁed G, we can just remove Cη(ui ) (resp. Cη(vj ) ) from G . Similarly, if η(ui ) = η(vj ) and η(ui ) is M -exposed, we necessarily have to remove η(ui ). Algorithm 1 checks this in line 16. If instead η(ui ) = η(vj ), and both are M  -exposed, we apply Lemma 1(b) to ﬁnd a basic augmenting structure W contained in U . Once again, we know by Lemma 2 and Theorem 2 that we need to remove a vertex in η(W ). In case W is a cycle or bi-cycle, all vertices of η(W ) are M -covered so the graph cannot be stabilized and Algorithm 1 checks this in line 20. In case W is a M  -augmenting ﬂower with base ui or vj , Algorithm 1 accordingly removes η(ui ) or η(vj ) as all other vertices in η(W ) are M -covered, in line 23 and 25. Finally, if W is a proper (because η(ui ) = η(vj )) M  -augmenting path, by Lemma 3 we know that we can ﬁnd a feasible M -augmenting walk, where the only M -exposed vertex is either η(ui ) or η(vj ). Once again, this implies that this vertex must be removed. Algorithm 1 does so in lines 29 and 31. From the discussion so far, it follows that when we exit the while loop each vertex in S is a necessary vertex to be removed from G, in order to stabilize the instance. We now argue that either removing all vertices in S is also suﬃcient, or G cannot be stabilized. Suppose that G \ S is not stable. Theorem 1 implies that (G \ S) contains a basic augmenting structure Q. Note that Q cannot be an M  -augmenting ﬂower with exposed root, or a proper M  -augmenting path with at least one exposed endpoint. To see this, observe that a ﬂower and path are feasible M  -augmenting walks of length at most 3 |V (G )| and |V (G )|, respectively. Hence, they would have been found by Algorithm 1 in line 4, contradicting that Q exists in (G\S) . It follows that Q is a basic augmenting structure where all vertices are M  -covered. By Lemma 2 η(Q) is a feasible M -augmenting walk where all vertices are M -covered. This implies that G cannot be stabilized. Furthermore, using the ε-augmentation of η(Q) we can obtain a fractional cmatching whose value is strictly greater than w(M ). Hence, w(M ) < νfc (G \ S). Algorithm 1 correctly determines this in line 32. This proves correctness of our algorithm. Finally, we argue about the running time of the algorithm. Note that each operation that the algorithm performs can be done in polynomial time. Furthermore, after each iteration of the while loop, we either determine that the instance cannot be stabilized, or remove a vertex from G. Therefore, the while loop can be executed at most n times. The result follows. We close this section with a remark. The authors in [15] have also considered the following problem: given a weighted graph G and a (non necessarily maximum-weight) matching M , ﬁnd a minimum-cardinality S ⊆ V such that G \ S is stable, and M is a maximum-weight matching in G \ S. This is a generalization of our deﬁnition of the M -vertex-stabilizer problem, which essentially allows M to be not maximum-weight.3 The authors show that this problem is  
   
  3  
   
  In fact, this is the way the M -vertex-stabilizer problem is deﬁned in [15]. We instead use the original deﬁnition in [1, 6] which assumes M to be maximum.  
   
  Stabilization of Capacitated Matching Games  
   
  167  
   
  NP-hard, but admits a 2-approximation algorithm (we mentioned this in the strategy overview), which is best possible assuming Unique Game Conjecture. With a minor modiﬁcation of Algorithm 1, we can generalize this result to the capacitated setting. We state here the result, and refer to the full version of this extended abstract paper for details [10]. Theorem 4. Given a weighted, capacitated graph G = (V, E) and a c-matching M , the problem of computing a minimum-cardinality S ⊆ V such that G \ S is stable, and M is a maximum-weight c-matching in G \ S, admits an eﬃcient 2-approximation algorithm.  
   
  4  
   
  Vertex-Stabilizer  
   
  The goal of this section is to prove the following theorem. Theorem 5. The vertex-stabilizer problem on capacitated graphs is NPcomplete, even if all edges have unit-weight. Furthermore, no eﬃcient n1−ε approximation exists for any ε > 0, unless P = NP. Note that, given an unstable instance (G, w, c), removing all vertices (but two) trivially yields a stable graph. This gives a (trivial) n-approximation algorithm for the vertex-stabilizer problem. The theorem above essentially implies that one cannot hope for a much better approximation. To prove it, we will use: Minimum Independent Dominating Set (MIDS) Problem. Given a graph G = (V, E), compute a minimum-cardinality subset S ⊆ V that is independent (for all uv ∈ E at most one of u and v is in S) and dominating (for all v ∈ V at least one u ∈ N + (v) is in S). There is no eﬃcient n1−ε -approximation for any ε > 0 for the MIDS problem, unless P = NP. [12, corollary 3] Proof (Proof of Theorem 5). The decision variant of the problem asks to ﬁnd a vertex-stabilizer of size at most k. This problem is in NP, since if a vertex set S is given, it can be veriﬁed in polynomial time if |S| ≤ k and if ν c (G \ S) = νfc (G \ S). We prove the NP-hardness and the inapproximability result by giving an approximation-preserving reduction from the MIDS problem. Let G = (V, E) be an instance of the MIDS problem. For v ∈ V , we deﬁne the gadget Γv by V (Γv ) = N + (v) ∪ {v1 , v2 , v3 , v4 } ,   E(Γv ) = uv1 : u ∈ N + (v) ∪ {v1 v2 , v2 v3 , v3 v4 , v2 v4 } . i For e = uv ∈ E and i ∈ {1, . . . , n}, we deﬁne the gadget Γuv by   i V (Γuv ) = u, v, ei1 , ei2 , ei3 , ei4 , ei5 ,   i E(Γuv ) = uei1 , vei1 , ei1 ei2 , ei1 ei3 , ei3 ei4 , ei4 ei5 , ei3 ei5 .  
   
  (8) (9)  
   
  (10) (11)  
   
  168  
   
  M. Gerstbrein et al. v3  
   
  v4  
   
  ei4  
   
  v2  
   
  ei2  
   
  v1 v  
   
  ···  
   
  ei5 ei3 ei1  
   
  N (v)  
   
  (a) Gadget Γv .  
   
  u  
   
  v  
   
  i (b) Gadget Γuv .  
   
  Fig. 2. Examples of gadgets.  
   
  See Fig. 2 for an example of these gadgets. Now let G be deﬁned as the union i , such that vertices from V overlap. We set the capacity as of all Γv and all Γuv E(G ) follows: cv = dv for all v ∈ V , cv1 = dE v + 1 for all v ∈ V , cei1 = cei3 = 2 i i i for e1 , e3 ∈ V (Γuv ) for all e = uv ∈ E and i ∈ {1, . . . , n}, and cv = 1 for all remaining v ∈ V (G ). All edges are set to have unit-weight. The key point is: Claim. G has an independent dominating set of size at most k if and only if (G , 1, c) has a vertex-stabilizer of size at most k. Proof. (⇒) Let S be an independent dominating set of G of size k. The vertices in S naturally correspond with vertices in G . We show that S is a vertex-stabilizer of (G , 1, c). We deﬁne a c-matching M and fractional vertex cover (y, z) on G \ S as follows. First, set yv = 0 for all v ∈ V \ S. Next, for all v ∈ V , consider Γv . Add {uv1 : u ∈ N + (v) \ S} ∪ {v1 v2 , v3 v4 } to M . Note that at least one vertex from N + (v) is in S, since S is dominating. Set yv1 = 0, yv2 = 1, yv3 = yv4 = 0.5, ze = 1 for all e ∈ {uv1 : u ∈ N + (v) \ S} and ze = 0 for the remaining edges in the gadget. i . Since S is Finally, for all e = uv ∈ E and i ∈ {1, . . . , n}, consider Γuv independent, at most one of u and v is in S. If neither are in S, add both uei1 and vei1 to M . If one of them is in S, without loss of generality let it be u, then add vei1 and ei1 ei2 to M . Furthermore, add ei3 ei4 and ei3 ei5 to M . Set yei1 = 1, yei2 = 0, yei3 = yei4 = yei5 = 0.5, and zf = 0 for all edges f in the gadget. Let x be the indicator vector of M . One can verify that x and (y, z) satisfy the complementary slackness conditions for νfc (G \ S) and τfc (G \ S). Since x is integral, this implies that G \ S is stable. (⇐) Let S be a vertex-stabilizer of (G , 1, c) of size k. We show that: (i) S contains at least one vertex of each gadget Γv ; (ii) without loss of generality, one can assume that at most one of u and v is in S for each edge uv ∈ E. (i) Suppose for the sake of contradiction that there is some v ∈ V such that S contains no vertices of Γv . Since G \ S is stable, there is a maximum-cardinality  
   
  Stabilization of Capacitated Matching Games  
   
  fractional c-matching x∗ , that is ⎧ ∗ x ⎪ ⎪ ⎪ e ⎨ 1 xe = ⎪ 0 ⎪ ⎪ ⎩ 0.5  
   
  169  
   
  integral. Deﬁne for each e ∈ E(G \ S) if if if if  
   
  e ∈ E(G \ S) \ E[Γv ], e ∈ {uv1 : u ∈ N + (v)} , e = v1 v2 , e ∈ {v2 v3 , v3 v4 , v2 v4 } .  
   
  (12)  
   
  Note that x is a fractional in G \ S, since x∗ is. However,  c-matching    ∗ ∗ ∗ e∈E[Γv ] xe = dv + 2.5 > e∈E[Γu ] xe , since x is integral. Hence, 1 x > 1 x , ∗ contradicting the optimality of x . (ii) Suppose there is some e = uv ∈ E such that S contains both u and v. All i are then components in G \ S. If u and v are the only vertices in S gadgets Γuv i , then a maximum-cardinality fractional c-matching in from some component Γuv this components is given by xei1 ei2 = xei1 ei3 = 1 and xei3 ei4 = xei4 ei5 = xei3 ei5 = 0.5. Which means this component is not stable, and thus G \ S is not stable, a i that is contradiction. Hence, S must contain at least one vertex of each Γuv neither u nor v. Consequently, k = |S| ≥ n + 2. Since G has only n vertices, it obviously has an independent dominating set of size at most n, and hence of size at most k. Such a set can for example be obtained by a greedy approach. Hence, for the remainder of the proof we can assume that at most one of u and v is in S for each uv ∈ E. We now create a set S  ⊆ V from S, that is an independent dominating set of G of size at most k, as follows. Iterate over v ∈ V . Let Sv = S ∩ V (Γv ). Note that Sv = ∅ by (i). Deﬁne  (Sv ∪ S  ) ∩ N + (v) if this is nonempty,  Sv = (13) v otherwise. Set S  = S  ∪ Sv , and repeat for the next vertex. Clearly, all Sv ’s are nonempty, which means that S  contains at least one vertex from N + (v) for all v ∈ V , which means S  is dominating. Suppose for the sake of contradiction that S  contains both u and v for some edge uv ∈ E. We know S did not contain both of them, by (ii). If S contained exactly one of them, without loss of generality let it be u. Then, when v is considered by the iterative process, (Sv ∪ S  ) ∩ N + (v) contains u, but not v. In particular, this means that we did not add v to Sv and consequently also not to S  , a contradiction. If S contained neither of them, then because we do the process iteratively, one of them will be added ﬁrst to S  . Without loss of generality let it be u. Then again, when v is considered by the iterative process, (Sv ∪ S  ) ∩ N + (v) contains u but not v, so we reach a contradiction in the same way. In conclusion, S  is independent. For all v ∈ V , before we added Sv to S  , we had |Sv \ S  | ≤ |Sv |. Conse quently, |S  | ≤ ∪v∈V |Sv | ≤ |S| = k. By this claim, any minimum-cardinality vertex-stabilizer of (G , 1, c) is of the same size as any minimum independent dominating set of G. Further, any  
   
  170  
   
  M. Gerstbrein et al.  
   
  eﬃcient α-approximation algorithm for the vertex-stabilizer problem translates into an eﬃcient α-approximation algorithm for the MIDS problem. Hence, the result follows from the inapproximability of the MIDS problem.  
   
  5  
   
  Capacitated Cooperative Matching Games  
   
  Cooperative matching games in unit-capacity graphs, deﬁned in the introduction, extend quite easily to capacitated graphs, by replacing each ν with ν c . In unitcapacity graphs G the following statements are equivalent [7,14]: (i) G is stable, (ii) there exists an allocation in the core of the CMG on G, (iii) there exists a stable outcome for the NBG on G. We here note that the equivalence does not extend to capacitated graphs. In particular, as mentioned in the introduction, we still have (i) ⇐⇒ (iii) proven in [2, corollary 3.3]. The implication (i) =⇒ (ii) still holds, and follows  
   
  from [2, lemma 3.4]4 . However, the graph G given in Fig. 3 shows that (ii) =⇒ (i) (and hence (ii) =⇒  
   
  (iii)). Assuming all the edges of G in Fig. 3 have unit weight, it is quite easy to see that ν c (G) = 3 and νfc (G) = 3.5, thus G is not stable. One can check that y = (1, 1, 1, 0) is in the core. 2  
   
  2  
   
  1  
   
  1  
   
  2  
   
  1  
   
  1  
   
  0  
   
  Fig. 3. On the left: the graph G where the values close to the vertices indicate the capacities. Bold edges indicate a maximum c-matching. On the right: the graph G where the values close to the vertices indicate the allocation y. A maximum fractional c-matching is given by xe = 12 for dashed edges, xe = 1 otherwise. Acknowledgements. The second and third authors are supported by the NWO VIDI grant VI.Vidi.193.087. The second author thanks the 2021 Hausdorﬀ Research Institute for Mathematics Program Discrete Optimization, during which part of this work was developed.  
   
  References 1. Ahmadian, S., Hosseinzadeh, H., Sanità, L.: Stabilizing network bargaining games by blocking players. Math. Program. 172, 249–275 (2018) 2. Bateni, M., Hajiaghayi, M., Immorlica, N., Mahini, H.: The cooperative game theory foundations of network bargaining games (2010) 4  
   
  [2] assumes that the graph is bipartite, but bipartiteness is not needed in their proof.  
   
  Stabilization of Capacitated Matching Games  
   
  171  
   
  3. Biró, P., Kern, W., Paulusma, D.: On solution concepts for matching games. In: Kratochvíl, J., Li, A., Fiala, J., Kolman, P. (eds.) Theory Appl. Models Comput., pp. 117–127. Springer, Berlin Heidelberg, Berlin, Heidelberg (2010) 4. Bock, A., Chandrasekaran, K., Könemann, J., Peis, B., Sanità, L.: Finding small stabilizers for unstable graphs. Math. Program. 154, 173–196 (2015) 5. Chandrasekaran, K.: Graph stabilization: a survey. In: Fukunaga, T., Kawarabayashi, K. (eds.) Combinatorial Optimization and Graph Algorithms, pp. 21–41. Springer, Singapore (2017). https://doi.org/10.1007/978-981-10-6147-9_2 6. Chandrasekaran, K., Gottschalk, C., Könemann, J., Peis, B., Schmand, D., Wierz, A.: Additive stabilizers for unstable graphs. Discret. Optim. 31, 56–78 (2019) 7. Deng, X., Ibaraki, T., Nagamochi, H.: Algorithmic aspects of the core of combinatorial optimization games. Math. Oper. Res. 24(3), 751–766 (1999) 8. Farczadi, L.: Matchings and games on networks, Ph. D. thesis, University of Waterloo (2015) 9. Farczadi, L., Georgiou, K., Könemann, J.: Network bargaining with general capacities. arXiv preprint arXiv:1306.4302 (2013) 10. Gerstbrein, M., Sanità, L., Verberk, L.: Stabilization of capacitated matching games. arXiv preprint (2022) 11. Gottschalk, C.: Personal communication (2018) 12. Halldórsson, M.M.: Approximating the minimum maximal independence number. Inf. Process. Lett. 46(4), 169–172 (1993) 13. Ito, T., Kakimura, N., Kamiyama, N., Kobayashi, Y., Okamoto, Y.: Eﬃcient stabilization of cooperative matching games. Theoret. Comput. Sci. 677, 69–82 (2017) 14. Kleinberg, J.M., Tardos, É.: Balanced outcomes in social exchange networks. In: Proceedings of the 40th STOC, pp. 295–304 (2008) 15. Koh, Z.K., Sanità, L.: Stabilizing weighted graphs. Math. Oper. Res. 45(4), 1318– 1341 (2020) 16. Könemann, J., Larson, K., Steiner, D.: Network bargaining: using approximate blocking sets to stabilize unstable instances. In: Serna, M. (ed.) SAGT 2012. LNCS, pp. 216–226. Springer, Heidelberg (2012). https://doi.org/10.1007/978-3642-33996-7_19 17. Nash, J.F.: The bargaining problem. Econometrica 18, 155–162 (1950) 18. Shapley, L., Shubik, M.: The assignment game i: The core. Internat. J. Game Theory 1(1), 111–130 (1971)  
   
  Designing Optimization Problems with Diverse Solutions Oussama Hanguir1(B) , Will Ma2 , and Christopher Thomas Ryan3 1  
   
  2  
   
  Industrial Engineering and Operations Research, Columbia University, New York, NY 10027, USA [email protected]  Graduate School of Business, Columbia University, New York, NY 10027, USA [email protected]  3 UBC Sauder School of Business, University of British Columbia, Vancouver, BC V6T 1Z2, Canada [email protected]  Abstract. We consider the problem of designing a linear program that has diverse solutions as the right-hand side varies. This problem arises in video game settings where designers aim to have players use diﬀerent “weapons” or “tactics” as they progress. We model this design question as a choice over the constraint matrix A and cost vector c to maximize the number of possible supports of unique optimal solutions (what we call “loadouts”) of Linear Programs max{c x | Ax ≤ b, x ≥ 0} with nonnegative data considered over all resource vectors b. We provide an upper bound on the optimal number of loadouts and provide a family of constructions that have an asymptotically optimal number of loadouts. The upper bound is based on a connection between our problem and the study of triangulations of point sets arising from polyhedral combinatorics, and speciﬁcally the combinatorics of the cyclic polytope. Our asymptotically optimal construction also draws inspiration from the properties of the cyclic polytope. Keywords: linear programming  
   
  1  
   
  · triangulations · diversity  
   
  Introduction  
   
  In this paper, we formulate the problem of designing linear programs that allow for diversity in their optimal solutions. This setting is motivated by video games, in particular, the design of competitive games where players optimize their strategies to improve their in-game status. For such games, a desideratum for game designers is for optimizing players to play diﬀerent strategies at diﬀerent stages of the game. Informally, we interpret the player’s problem as solving a Linear Program of the form max{c x | Ax ≤ b, x ≥ 0}. Players at diﬀerent stages of the game have diﬀerent resource vectors b. The columns of A correspond to the tools that the player can use in the game. We call a subset of these tools (represented by subsets of the columns of A) a loadout (which literally means the equipment carried into battle by a soldier), if they correspond to the support c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 172–186, 2023. https://doi.org/10.1007/978-3-031-32726-1_13  
   
  Designing Optimization Problems with Diverse Solutions  
   
  173  
   
  of an optimal solution x∗ to the linear program max{c x | Ax ≤ b, x ≥ 0} for some resource vector b (In fact, we require x∗ to be the unique optimal solution of this linear program, for reasons that will become clear later). The support of a vector corresponds to a selection of the available tools, forming a strategy for how the player approaches the game given available resources. We assume that the game designer is able to choose A and c. We refer to this choice as the design of the game. We measure the diversity of a design as the number of possible loadouts that arise as the resource vector b changes. For a ﬁxed design (A, c) and resource vector b, players solve the linear program (1) LP (A, c, b) : max{c x | Ax ≤ b, x ≥ 0}, where c, A, and b all have nonnegative data. If x is the optimal solution of LP (A, c, b), we deﬁne the support of x as supp(x)  {i ∈ {1, . . . , n} | xi > 0}. If x is the unique optimal solution of LP (A, c, b), then we call supp(x) an optimal loadout (or simply, a loadout) of design (A, c). For ﬁxed n and m, the loadout maximization problem is to choose c and A that maximize the total number of loadouts of the design (A, c). That is, the goal is to design beneﬁts for each tool (the vector c) and limitations on investing in tools (the matrix A) so that the linear programs LP (A, c, b) have as many possible supports of unique optimal solutions as possible, as b varies in Rm . Our Contributions: Our ﬁrst contribution consists in introducing the loadout maximization problem and establishing a link between the loadout maximization problem and the theory of polyhedral subdivisions and triangulations. In particular, for a ﬁxed design (A, c), the theory of triangulations oﬀers a nice decomposition of the cone generated by the columns of the constraint matrix A. This decomposition depends on the objective vector c. We show that for a ﬁxed design (A, c), the loadouts can be seen as elements of this decomposition. This allows us to use a set of powerful tools from the theory of triangulations to prove structural results on the loadouts of a design. Our second contribution is to show a non-trivial upper bound on the number of loadouts of any design. The upper bound involves an interesting connection to the faces of the so-called cyclic polytope, a compelling object central to the theory of polyhedral combinatorics. We also show that this upper bound holds when the constraints of the linear program are equality constraints. The third contribution of this paper is to present a construction of a design (A, c) with a number of loadouts that asymptotically matches the above upper bound. Furthermore, for cases with few constraints, we present optimal constructions that exactly match the upper bound. Due to space constraints, we defer the proofs to the full version1 . Related Work. Our work is closely related to parametric linear programming, which is the study of how optimal properties depend on parameterizations of the data. The study of parametric linear programming dates back to the work of [12,14], [19], and [18] in the 1950s and 1960s. In parametric programming, 1  
   
  Full version: https://arxiv.org/abs/2106.11538.  
   
  174  
   
  O. Hanguir et al.  
   
  the objective is to understand the dependence of optimal solutions on one or more parameters; that is, on the entries of A, b, and c. Our work is novel in the sense that the objective is to understand the structure of the supports of optimal solutions by ﬁxing A and c and having b vary in Rm ≥0 . To the best of our knowledge, this question has not previously been studied in the literature. There have been several studies on the interface of optimization and video games. [8,15,17]. Guo et al. [7] study the impact of selling virtual currency on players’ gameplay behavior, game provider’s strategies, and social welfare. Another signiﬁcant research direction concentrates on studying “loot boxes” in video games. Chen et al. [2] study the design and pricing of loot boxes, while Ryan et al. [13] study the pricing and deployment of enhancements that increase the player’s chance of completing the game. Chen et al. [3] and Huang et al. [9] study the problem of in-game matchmaking to maximize a player’s engagement in a video game.  
   
  2  
   
  Statement of Main Results  
   
  In this section, we state our main results. To make these statements precise, we require some preliminary deﬁnitions. Let [k] denote the set {1, . . . , k} for any positive integer k. Using this notation, we can deﬁne the support of x ∈ Rn≥0 as supp(x) = {j ∈ [n] | xj > 0}. For a matrix A ∈ Rm×n ≥0 , the (i, j)th entry is denoted aij for i ∈ [n] and j ∈ [m], the jth column is denoted Aj for j ∈ [n], and the ith row is denoted ai (where ai is a column vector) for i ∈ [m]. For a m  column vector m y ∈ R , y Aj denote the scalar product of y and column Aj , i.e.,  y Aj = i=1 yi ai,j . Recall the deﬁnition of the linear program LP (A, b, c) in (1). As mentioned in the introduction, we are interested in the unique optimal solutions of the design (A, c). For simplicity, we simply call these the loadouts of design (A, c); that is, L ⊆ [n] is a loadout of design (A, c) if there exists a nonnegative resource ∗ vector b ∈ Rm ≥0 such that LP (A, c, b) has a unique optimal solution x with supp(x∗ ) = L. We say that loadout L is supported by resource vector b. If |L| = k then we say L is a k-loadout. Given a design (A, c) and an integer k ∈ [m], let Lk (A, c) denote the set of all k-loadouts of design (A, c). The set of all loadouts of any size is L(A, c)  ∪nk=1 Lk (A, c). Using this notation, we can restate the loadout optimization problem. Given dimensions n and m and integer k ≤ n, the k-loadout optimization problem is max{|Lk (A, c)| | A ∈ Rm×n , c ∈ Rn , A and c are nonnegative}.  
   
  (Lk )  
   
  We can assume without loss of generality that the linear programs LP (A, c, b) are bounded and thus possess an optimal solution because otherwise there is no optimal solution and, therefore, no loadout. Given that a loadout corresponds to the support of a unique solution of a linear program, any optimal solution with support size greater than m cannot be unique. Therefore, the number of k-loadouts when k > m is always equal to zero. This leads us to consider the optimization problems (Lk ) only for k ∈  
   
  Designing Optimization Problems with Diverse Solutions  
   
  175  
   
  {1, . . . , min(m, n)}. For convenience, we will avoid the trivial case of k = 1 where the optimal number of loadouts is min(m, n). A ﬁnal case we eliminate immediately is when min(m, n) = n, i.e. m ≥ n. In this case, a trivial design is optimal. By setting A = In to be the identity matrix of  size n, and c = (1, . . . , 1), we ensure that for k ∈ [1, n], every one of the nk subsets is a loadout. In summary, we proceed without loss under the assumption that n > m ≥ k ≥ 2. 2.1  
   
  The Cyclic Polytope  
   
  All of our bounds are intimately related to the number of faces on the cyclic polytope, which is formally deﬁned in Sect. 3. A remarkable aspect of the cyclic polytope is that for n > m ≥ 2, the cyclic polytope C(n, m) simultaneously maximizes the number of k-dimensional faces for all k = 0, . . . , m − 1 among mdimensional polytopes over n vertices, a property known as McMullen’s Upper Bound Theorem [11]. The number of k-dimensional faces on C(n, m) is given by the formula   m/2    n−m+−1 fk (C(n, m)) = m−k−1  =0    m   n−−1 + . m−k−1 m− =m/2+1  
   
  When k = m − 1, through the “hockey stick” identity on Pascal’s triangle, this simpliﬁes to     n − m/2 n − m/2 − 1 + . fm−1 (C(n, m)) = m/2  
   
  m/2 − 1 2.2  
   
  Results and Techniques  
   
  Theorem 1. Fix positive integers n, m, k with n > m ≥ k ≥ 2. Then the number of k-loadouts for any design (A, c) with A ∈ Rm×n and c ∈ Rn satisfies   m k |L (A, c)| ≤ fk−1 (C(n + 1, m)) − . (2) k−1 We note that the  trivial upper bound on the number of k-loadouts in a design with n tools is nk . When m < n, the RHS of (2) will always be smaller than this trivial upper bound, which shows that having a limited number of resource types in the game does indeed prevent all subsets of tools from being viable. Theorem 2. Fix positive integers n, m, k with n > m ≥ k ≥ 2. Then there exists an explicit design (A, c) with A ∈ Rm×n and c ∈ Rn≥0 that satisfy ≥0 ⎧ fk−1 (C(n, m)) if k < m/2 ⎪ ⎪ ⎪ ⎨f (C(n, m))/2 if k ≥ m/2 and m is odd, k−1 |Lk (A, c)| ≥ ⎪ or k = m/2 and m is even ⎪ ⎪ ⎩ fk−1 (C(n, m))/4 if k > m/2 and m is even.  
   
  176  
   
  O. Hanguir et al.  
   
  The constructions from Theorem 2 are always within a 1/4-factor of being optimal asymptotically as n → ∞ because it is known that fk−1 (C(n, m)) = 1. n→∞ fk−1 (C(n + 1, m)) lim  
   
  Theorem 3. For n > m = 3, there exists an explicit design (A, c) with A ∈ Rm×n and c ∈ Rn≥0 that satisfy |L3 (A, c)| ≥ 2n − 5 and |L2 (A, c)| ≥ 3n − 6. ≥0 Theorem 4. For n > m = 2, there exists an explicit design (A, c) with A ∈ Rm×n and c ∈ Rn that satisfy |L2 (A, c)| ≥ n − 1. The constructions from Theorem 3 and Theorem 4 are exactly tight; it can be checked that they match the upper bound expression from Theorem 1 when evaluated at m = 3 and m = 2. Example of Construction from Theorem 2 and Intuition. Table 1 shows an example of the asymptotically optimal construction for m = 4 and n = 6. The fact that the cost vector is (1, 1, . . . , 1) is simply a normalization and can be assumed without loss. Our construction provides a pattern that game designers can follow to diversify loadouts on a set of tools 1, . . . , n, by having two types of constraints. The ﬁrst type of constraints (rows 1 and 3) accords more importance to tools with big indices (because these tools have lower costs to rows 1 and 3) while the second type of constraints (rows 2 and 4) give more advantage to tools with a small index (because these tools have lower costs to rows 2 and 4). This “tension” between the two types of constraints ensures that a given combination of tools cannot be optimal for too many resource vectors. This captures the rough intuition that a game with an overpowered tool (meaning one that is more useful than the others but also not signiﬁcantly “cumbersome” to limit its use) leads to uniform strategies among players. In other words, for diversity, all tools should have strengths and weaknesses. Table 1. Example of our construction with m = 4, n = 6, and M = 64 + 1. c  
   
  1  
   
  A 1 M − 12 13 M − 14  
   
  1  
   
  1  
   
  1  
   
  1  
   
  1  
   
  2 M − 22 23 M − 24  
   
  3 M − 32 33 M − 34  
   
  4 M − 42 43 M − 44  
   
  5 M − 52 53 M − 54  
   
  6 M − 62 63 M − 64  
   
  We end this section with a high-level overview of our approach for establishing our upper and lower bounds. All the undeﬁned terminology used here will be deﬁned in more detail in later sections. We prove our upper bound Theorem 1 using a sequence of transformations. We ﬁrst introduce the intermediate concept of an equality loadout problem that replaces the inequality constraint Ax ≤ b with an equality Ax = b. We show that for a ﬁxed design (A, c) and for every dimension k, the number of k-loadouts  
   
  Designing Optimization Problems with Diverse Solutions  
   
  177  
   
  is less than the number of k-equality loadouts (Lemma 1). This allows us to focus on proving an upper bound on the number of equality loadouts. Here, we can exploit the dual structure of the equality LP and prove that equality loadouts belong to a cell complex Δc (A) that is characterized by A and c. Importantly, we show that loadouts correspond to simplicial cells in this cell complex (Lemma 2). In turn, this allows us to, without loss of generality, assume that Δc (A) is a triangulation (as opposed to an arbitrary subdivision), of a cone in the positive orthant of Rm (Lemma 3). We show that triangulations of cones in the positive orthant of Rm correspond to triangulations of points in the lower dimension Rm−1 (Lemma 4). Finally, we show that the simplices in this triangulation can be embedded into faces of a simplicial polytope in Rm . Therefore, any upper bound on the number of faces of polytopes in Rm implies an upper bound on the number of loadouts. This allows us to invoke the “maximality” of the cyclic polytope with respect to its number of faces mentioned in Sect. 2.1. Therefore, the number faces of the cyclic polytope of dimension m bounds the number of faces in a polytope of dimension m, and implies a bound on the number of equality loadouts. We also carefully count the number of extraneous faces added through our transformations, by invoking a bound on the minimal number of faces a polytope can have, which allows us to derive tight bounds for small values of m (Lemma 5). To prove our complementing lower bound Theorem 2, we ﬁrst explicitly provide our design (A, c) in Sect. 5.1, which is also inspired by the cyclic polytope. Compared to the cyclic polytope, every even row of the matrix A has been “ﬂipped”, as we show in the proof, which we now outline. First, we focus on the dual program of LP (A, c, b) and present a suﬃcient condition (Deﬁnition 4) for loadouts in terms of dual variables (Lemma 7). We show that by taking hyperplanes corresponding to the facets of the cyclic polytope in dimension m, one can attempt to construct dual variables that satisfy the suﬃcient condition (Lemma 8). Our aforementioned “ﬂipping” of the even rows in A is crucial to this construction of the dual variables. We show that as long as the facet of the cyclic polytope is of the “odd” parity, the constructed dual variables will indeed be suﬃcient (Lemma 9), and hence such a facet and all of the faces contained within it correspond to loadouts. To be more precise, we require odd parity when m is even, and even parity when m is odd. What we mean by the parity of a facet will be made clear later. Therefore, to count the number of k-loadouts, we need to count the number of (k − 1)-dimensional faces on a cyclic polytope in dimension m that are contained within at least one odd facet. To the best of our knowledge, this is an unsolved problem in the literature. Nonetheless, using Gale’s evenness criterion we can map this to a purely combinatorial problem on binary strings. Through some combinatorial bijections, we show that at worst a factor of 4 is lost when one adds the requirement that the (k − 1)-dimensional face must be contained within at least one odd facet, with the factor improving to 2 if m is odd, and improving to 1 if k is small. These arguments form the cases in Theorem 2. We should note that generally, a cyclic polytope does not have an equal number of odd and even facets. Therefore, one should not expect this factor to always be 2.  
   
  178  
   
  3  
   
  O. Hanguir et al.  
   
  Preliminaries  
   
  We present terminology we use in the proofs of both Theorems 1 and 2. Additional terminology needed in the proof of only one of these results is found in the relevant sections. A d-simplex is a d-dimensional polytope that is the convex hull of d + 1 aﬃnely independent points. For instance, a 0-simplex is a point, a 1-simplex is a line segment and 2-simplex is a triangle. For a matrix A = (A1 , . . . , An ) of rank m, let cone(A) = cone({A1 , . . . , An }) represent the closed convex polyhedral cone {Ax | x ∈ Rn≥0 }. We use the notation cone(C) to denote the cone generated by the columns indexed by C ⊆ [n]. If C ⊆ [n] is a subset of indices, the relative interior of C is the relatively open (i.e., open in its aﬃne hull) convex set    
   
  λAj | λj > 0 for all j ∈ C, and λj = 1 . relintA (C)  j∈C  
   
  j∈C  
   
  A subset F of polytope P is a face if there exists α ∈ Rn and β ∈ R such that α x + β ≤ 0 for all x ∈ P and F = {x ∈ P | α x + β = 0}. If dim(F ) = k then F is called a k-dimensional face or k-face. The faces of dimensions 0, 1, and dim(P ) − 1 are called vertices, edges, and facets, respectively. Furthermore, we say that F is face of C, where F, C ⊆ [n], when cone(F ) is a face of cone(C). We deﬁne a polyhedral subdivision of cone(A) as follows. Definition 1. Let A = (A1 , . . . , An ) be a matrix of rank m. A collection S of subsets of [n] is a polyhedral subdivision of cone(A) if it satisfies the following conditions: – (CP): If C ∈ S and F is aface of C, then F ∈ S . (Closure Property) cone(C). (Union Property) – (UP): cone({1, . . . , n}) ⊂ C∈S  
   
  – (IP): If C, C ∈ S with C = C , then relintA (C) ∩ relintA (C ) = ∅. (Intersection Property) If the set of indices {j1 , . . . , jk } belongs to a subdivision of cone(A), then it is called a cell of the subdivision, and if the cone is of dimension k, it is called a k-cell. We note that a polyhedral cone subdivision is completely speciﬁed by listing its maximal cells. Next, we deﬁne a special subdivision of cone(A) as a function of the cost vector c. The cells of this subdivision map to the loadouts of the design (A, c). and c ∈ Rn≥0 , we deﬁne the polyhedral subdivision Δc (A) of For A ∈ Rm×n ≥0 cone(A) as the family of subsets of {1, . . . , n} such that C ∈ Δc (A) if and only if there exists a column vector y ∈ Rm such that y  Aj = cj if j ∈ C and y  Aj > cj if j ∈ {1, . . . , n}\C. In such a case, we say C is a cell of Δc (A) and that Δc (A) is a cell complex. A cell C ∈ Δc (A) is simplicial if the column vectors (Aj )j∈C are linearly independent. If all the cells of Δc (A) are simplicial, then we say Δc (A) is a triangulation. The maximum size of a simplicial cell is m. The next results shows that Δc (A) is indeed a polyhedral subdivision of cone(A).  
   
  Designing Optimization Problems with Diverse Solutions  
   
  179  
   
  Proposition 1. Δc (A) is a polyherdal subdivision of cone(A). Intuitively, we can think of the subdivision Δc (A) as follows: take the cost vector c, and use it to lift the columns of A to Rn+1 then look at the projection of the upper faces (those faces you would see if you “look from above”). This is illustrated in Example 1. Example 1. Consider the following matrix and cost vectors   1/4 1/2 3/4 A= , c1 = (2, 2.125 + , 2.25) and c2 = (2, 2.125 − , 2.25), 1 1 1 where  > 0 is a small constant. The corresponding subdivisions of cone(A) are  

  Δc1 (A) = {1, 2}, {2, 3}, {1}, {2}, {3}, ∅ and Δc2 (A) = {1, 2, 3}, {1}, {3}, ∅ . For example, to see that {1, 2} is a cell of Δc1 (A), we consider y = (0.5 + 4, 1.875 − ). One can verify that y  A1 = c1 and y  A2 = c2 , while y  A3 > c3 . We observe that for the cost vector c1 , the cell {1, 2} is simplicial, while for c2 , the cell {1, 2, 3} is not simplicial. In our deﬁnition of simplicial cell, we mentioned that if all the cells in the subdivision Δc (A) are simplicial, then Δc (A) is called a triangulation. More generally, a triangulation of cones is a cone subdivision where all the cells are simplicial (the columns of every cell are linearly independent). We will also deﬁne the notion of triangulations of point conﬁgurations, that is sets of points whose convex hull is subdivided into simplices. The formal deﬁnition mirrors that of polyhedral subdivisions and can be found in the full version of the paper. Definition 2 (Cyclic Polytope). The cyclic polytope C(n, d) is defined as the convex hull of n distinct vertices on the moment curve t → (t, t2 , . . . , td ). The precise choice of which n points on this curve are selected is irrelevant for the combinatorial structure of this polytope. Definition 3 (f -vector). The f -vector of a d-dimensional polytope P is given by (f0 (P ), . . . , fd−1 (P )), where fi (P ) is the number of i-dimensional faces in the d-dimensional polytope for all i = 0, . . . , d − 1. For instance, a 3dimensional cube has eight vertices, twelve edges, and six facets, so its f -vector is (f0 (P ), f1 (P ), f2 (P )) = (8, 12, 6).  
   
  4  
   
  Upper Bound (Proof of Theorem 1)  
   
  Throughout this section we ﬁx positive integers n > m ≥ 2 and A ∈ Rm×n ≥0 , c ∈ Rn≥0 . We start by formally introducing the equality loadout problem. We consider the parametric family of linear programming problems with equality constraints LP= (A, c, b) :  
   
  max{c x | Ax = b, x ≥ 0},  
   
  180  
   
  O. Hanguir et al.  
   
  By analogy to the deﬁnition of loadouts in Sect. 2, an equality loadout is deﬁned as a subset of indices L ⊆ {1, . . . , n} such that there exists a resource vector b for which LP= (A, c, b) has a unique optimal solution x∗ such that supp(x∗ ) = L. If |L| = k then we say that L is a k-equality loadout. Given A and c and an integer k ∈ [m], let Lk= (A, c) denote the family of all equality loadouts L of dimension k. Finally, L= (A, c) denotes the family of equality loadouts of all dimensions given k A and c. Namely, L= (A, c)  ∪m k=1 L= (A, c). The following proposition bounds the number of loadouts by the number of equality loadouts, for ﬁxed A and c. n k k Lemma 1. For every A ∈ Rm×n ≥0 , c ∈ R≥0 and k ∈ [m], L (A, c) ⊆ L= (A, c).  
   
  In the rest of this section, assume without loss of generality that A is a fullrow rank matrix. We present, for all k ∈ [m], an upper bound for the number |Lk= (A, c)| of equality loadouts of size k with respect to the design (A, c). Some of the results of this section are known in the literature (an excellent reference is the textbook [4]), but we present them using our notation and adapted to the loadout terminology. We provide proofs for clarity and of our a desire to be as self-contained as possible. The proofs are also suggestive of some aspects of our later constructions in Sect. 5. From Equality Loadouts to Triangulations. The following result links the optimal solutions of LP= (A, c, b) to the cells of subdivision Δc (A). Proposition 2. ( [16], Lemma 1.4) The optimal solutions x to LP= (A, c, b) are the solutions to the problem Find x ∈ Rn s.t. Ax = b, x ≥ 0 and supp(x) lies in a cell of Δc (A).  
   
  (3)  
   
  Lemma 2. A subset L ⊆ [n] is a loadout of (A, c) if and only if it is a simplicial cell in the subdivision Δc (A). The lemma above implies that we can focus on the simplicial cells of the subdivision Δc (A). We next show that we can consider without loss of generality choices of c where all the cells of Δc (A) are simplicial. The idea is that if Δc (A) has some non-simplicial cells, then we can “perturb” the cost vector c to some c and transform at least one non-simplicial cell into one or more simplicial cells. This perturbation conserves all the simplicial cells of Δc (A) and thus the number of equality loadouts for the design (A, c ) cannot be less than the number of equality loadouts for the design (A, c). Without loss of optimality, we can ignore cost vectors c that give rise to non-simplicial cells. We ﬁrst deﬁne the notion of reﬁnement that formalizes the “perturbation” of c. Given two cell complexes C1 and C2 , we say that C1 reﬁnes C2 if every cell of C1 is contained in a cell of C2 . [4, Lemma 2.3.15] shows that if c = c +  · e is perturbation of c with  > 0 suﬃciently small and e = (1, . . . , 1), then the new subdivision Δc (A) reﬁnes Δc (A). Since Δc (A) reﬁnes Δc (A), then Δc (A) will have more cells. However, it is not clear if Δc (A) will have more simplicial cells than Δc (A). We show in the following lemma that this is the case. Lemma 3. A refinement of Δc adds to the number of simplicial cells in Δc .  
   
  Designing Optimization Problems with Diverse Solutions  
   
  181  
   
  In [4, Corollary 2.3.18], it is shown Δc (A) can be reﬁned to a triangulation within a ﬁnite number of reﬁnements (suﬃces for c to be generic). Therefore, the lemma above implies that in order to maximize the number of loadouts for any dimension k ≤ m, we can restrict attention to designs (A, c) such that Δc (A) is a triangulation without loss of generality. has all nonnegative entries, We observe that since the matrix A ∈ Rm×n ≥0 cone(A) is contained entirely in the positive orthant and therefore cannot contain a line. Cones that do not contain lines are called pointed. The following lemma shows that triangulations of pointed cones in dimension m are equivalent to triangulations of a non-restricted set of points (columns) in dimension m − 1. This implies that equality loadouts can be seen as cells of a triangulation of a point conﬁguration. Lemma 4 ([1], Theorem 3.2). Every triangulation T of a pointed cone of dimension m can be considered as a triangulation T of a point configuration of dimension m − 1 such that for 1 ≤ k ≤ m, the k-simplices of T map to (k − 1)-simplices of T . Lemma 4 implies that equality loadouts of dimension k correspond to (k −1)simplices in a triangulation of a point conﬁguration in dimension m − 1. From Cells of a Triangulation to Faces of a Polytope ( [4], Corollary 2.6.5). We now show that any n-point triangulation in Rm−1 can be embedded onto the boundary of an (n+1)-vertex polytope in Rm , in a way such that (k−1)simplices in the triangulation correspond to (k − 1)-faces on the polytope. We then apply the cyclic polytope upper bound on the number of (k − 1)-faces on any (n+1)-vertex polytope in Rm to establish our result. To get a tighter bound, we carefully subtract the “extraneous” faces added from the embedding that did not correspond to (k −1)-simplices in the original triangulation. We lower bound the number of such extraneous faces using the lower bound theorem of [10]. Let T denote the original n-point triangulation in Rm−1 . We will use conv T to refer to the polytope obtained by taking the convex hull of all the faces in T . Let gk−1 (T ) denote the number of (k − 1)-simplices in the triangulation T . We embed conv T into a polytope P in Rm as follows. Let z 1 , . . . , z n ∈ Rm−1 denote the vertices in triangulation T . We now deﬁne the following lifted points in Rm . i , 0). For all i = 1, . . . , n, For all i = 1, . . . , n, let z i denote the point (z1i , . . . , zm−1 i i i let z¯ denote the point (z1 , . . . , zm−1 , ), for some ﬁxed  > 0. Let  > 0, and replace each point z i that is in the interior of conv({z 1 , . . . , z n }) by the “lifted” i , ). The points on the boundary of conv({z 1 , . . . , z n }) point z¯i = (z1i , . . . , zm−1 are not lifted. Let S be the set of the n points in Rm after lifting. Let Sm be the unit sphere of Rm with center at the origin, and S be the projection of S onto Sm , where every point is projected along the line connecting the point to the center of the sphere. The set S has the property that all the points that are on the “equator” hyperplane zm = 0 are exactly the projections of the points of S on the boundary of conv(S) (the points that were not lifted). The other points of S are in the “northern hemisphere” (the half space xm > 0). The ﬁnal step is to adjoin the boundary points to the “south pole”, (0, . . . , 0, −1) ∈ Rm . Let P be the resulting polytope, i.e., P = conv(S ).  
   
  182  
   
  O. Hanguir et al.  
   
  The next lemma shows that for 2 ≤ k ≤ m, the (k − 1)-dimensional faces of P are either (k − 1)-simplices of T , or (k − 2)-faces of T that were adjoined to the south pole. Lemma 5. For 2 ≤ k ≤ m, we have fk−1 (P ) = gk−1 (T ) + fk−2 (T ). The previous lemma implies that gk−1 (T ) = fk−1 (P ) − fk−2 (T ). Since P has n + 1 points, we know from the upper bound theorem that fk−1 (P ) ≤ fk−1 (C(n + 1, m)). Therefore, gk−1 (T ) ≤ fk−1 (C(n + 1, m)) − fk−2 (T ), and all we need is a lower bound on fk−2 (T ). The following lemma uses the lower bound theorem (Theorem 1.1, [10]) to establish a lower bound on fk−2 (T ). The lower bound theorem presents a lower bound on the number of faces in every dimension among all polytopes of dimension d over p points, for d ≥ 2 and p ≥ 2. m Lemma 6. For 2 ≤ k ≤ m, we have gk−1 (T ) ≤ fk−1 (C(n + 1, m)) − k−1 . See the full version of the paper to see how these lemmas come together to prove Theorem 1.  
   
  5  
   
  General Lower Bound (Proof of Theorem 2)  
   
  Throughout this section, we ﬁx positive integers n > m ≥ 4, and explicitly present designs (A, c) that have the number of k-loadouts promised in Theorem 2 for all k ≤ m. For m = 2 and m = 3, the exactly optimal designs are presented in the full version. All of the designs constructed in this paper will satisfy the property that A has linearly independent rows, hence we assume in the rest of this section that A is a full row rank matrix. 5.1  
   
  Construction Based on Moment Curve  
   
  Let t1 , . . . , tn be arbitrary real numbers satisfying 0 < t1 < t2 < . . . < tn . Let M be an arbitrary constant satisfying M ≥ tm . We deﬁne the design (A, c) so (t1 ), . . . vm (tn )]. where that c = (1, . . . , 1) ∈ Rn and A = [vm (t) = t → vm  
   
   t, M − t2 , t3 , M − t4 , . . . ,  
   
  (−1)m + 1 M − (−1)m tm 2  
   
   ∈ Rm .  
   
  Note that the ﬁnal row equals M − tm if m is even, or tm if m is odd. For any such values t1 , . . . , tn and M , we will get a design that satisﬁes our Theorem 2. We set all the entries of the cost vector c to 1 to simplify computations. It is not a requirement and the construction would still hold by setting cj to be any positive number and scaling the column Aj by a factor of cj . We will also later show that any of these constructions satisfy our assumption of A having full row rank.  
   
  Designing Optimization Problems with Diverse Solutions  
   
  183  
   
  Motivation Behind the Construction. Let P be the convex hull of (t1 ), . . . vm (tn )}. Let t → vm (t) = (t, t2 , t3 , . . . , tm )T ∈ Rm denote the m{vm dimensional original moment curve the deﬁnes the cyclic polytope. is motivated by role the cyclic polytope plays in The choice of the curve vm our corresponding upper bound Theorem 1. In fact, Theorem 1 shows that the number of k-dimensional loadouts is less than the number of (k − 1)-dimensional faces of the cyclic polytope C(n + 1, m) (for 2 ≤ k ≤ m). An ideal lower bound proof would connect the number of loadouts to the number of faces of the cyclic polytope. However, simply setting the columns of the constraint matrix A to be points on the moment curve of the cyclic polytope does not guarantee the that describes a existence of loadouts. We therefore, introduce the curve vm “rotated” cyclic polytope and show that it is rotated to ensure that the supporting normals of “half” of the facets are nonnegative. We use these rotated facets to construct a number of loadouts that asymptotically matches the upper bound. The rotation is performed by multiplying the even coordinates of the moments curve by −1, and we use a suﬃciently big constant M to ensure the positivity of the new constraint matrix. 5.2  
   
  Dual Certificate for Loadouts  
   
  Using LP duality, we derive a suﬃcient condition for subsets of [n] to be loadouts. Definition 4. A set C ⊆ [n] is an inequality cell of the design (A, c) if there exists a variable y ∈ Rm such that yi > 0,  
   
  ∀ i ∈ [m];  
   
    
   
  ∀ j ∈ C;  
   
    
   
  ∀ j ∈ C.  
   
  y Aj = cj , y Aj > cj ,  
   
  Here, y can be interpreted as a dual variable. However, in contrast to the deﬁnition of a cell that features in Proposition 2, here we require y > 0. This is because non-negativity is needed for y to be feasible in the dual when the LP has an inequality constraint Ax ≤ b instead of an equality constraint as considered in Proposition 2. Lemma 7. Suppose C ⊆ [n] is an inequality cell with |C| = m. Then every non-empty subset of C is a loadout. To establish Lemma 7, we show that for every subset L ⊆ C, y will verify the complementary slackness constraints with a primal variable x that has support equal to L. This establishes the optimality of x, and to show its uniqueness, we use the assumption that A has a full row rank equal to m. Note that this lemma only works in one direction. If L is a loadout, it is not clear that we can ﬁnd a corresponding dual certiﬁcate that satisﬁes Deﬁnition 4. However, for our construction, we only need the direction proved in the lemma. In order to prove Theorem 2, we consider our design from Sect. 5.1, and show that there are many inequality cells of cardinality m. To do so, we take an  
   
  184  
   
  O. Hanguir et al.  
   
  arbitrary C ⊆ [n] with |C| = m and consider the hyperplane that goes through (tj ) | j ∈ C}. We show in Lemma 8 that the coeﬃcients of the the m points {vm equation for this hyperplane have the same sign. We then use these coeﬃcients to construct a candidate dual vector y. The last step (Lemma 9) is to show that when the hyperplane satisﬁes a gap parity combinatorial condition, this dual vector will indeed satisfy Deﬁnition 4, certifying that C is an inequality cell. Lemma 8. Let C = {j1 , . . . , jm } ⊆ [n] be a subset of m indices with j1 < · · · < jm . The equation   1 ... 1 1 det =0 (4) vm (tj1 ) . . . vm (tjm ) y defines a hyperplane in variable y ∈ Rm that passes through the points (tj1 ), . . . , vm (tjm ). Furthermore if equation (4) is written in the form α1 y1 + vm . . . αm ym − β = 0, then we have α1 = 0, . . . αm = 0, β = 0, and m  
   
  sign(α1 ) = . . . = sign(αm ) = sign(β) = (−1) 2 +m+1 , where sign(αj ) is equal to 1 if αj > 0 and equal to −1 otherwise. We now consider a subset C = {j1 , . . . , jm } ⊆ [n] with j1 < · · · < jm , such that the corresponding hyperplane has equation α1 y1 + . . . αm ym − β = 0, as deﬁned above. The previous lemma shows that the dual variable y = α/β satisﬁes yi > 0 for all i ∈ [m]. We now proceed towards a gap parity condition on the subset C under which setting y = α/β also satisﬁes Deﬁnition 4. Definition 5. (Gaps). For a set C ⊂ [n], a gap of C refers to an index i ∈ [n] \ C. A gap i of C is an even gap if the number of elements in C larger than i is even, and i is an odd gap otherwise. Definition 6. (Facets and Gap Parity). A subset C ⊆ [n] is called a facet if |C| = m and either: (i) all of its gaps are even; or (ii) all of its gaps are odd. If all of its gaps are even, then we call C an even facet and define g(C) = 2. On the other hand, if all of its gaps are odd, then we call C an odd facet and define g(C) = 1. We let g(C) ∈ {1, 2} denote the gap parity of a facet C, with g(C) being undefined if C is not a facet. Lemma 9. Every facet C with g(C) ≡ m (mod 2) is an inequality cell. The proofs of Lemmas 8 and 9 require some technical developments on the sub-determinants of A. The outline of the proof of Lemma 9 is as follows. To show that C = {j1 , . . . , jm } is an inequality cell, we consider the dual certiﬁcate y = α β where α1 y1 + . . . αm ym − β = 0 is the equation of C. By Lemma 8, β and α have the same signs, and that β = 0 and αi = 0 for i ∈ [m]. Therefore, yi > 0, ∀i ∈ [m]. For j ∈ C, y  vm (tj ) =  
   
  (tj ) β α  vm = = 1 = cj . β β  
   
  The last step is to show y  vm (tj ) > cj for j ∈ C.  
   
  Designing Optimization Problems with Diverse Solutions  
   
  5.3  
   
  185  
   
  Counting the Number of k-Loadouts  
   
  The preceding duality certiﬁcates combine to provide a purely combinatorial lower bound on the number of k-loadouts in our construction. Indeed, Lemma 7 shows a subset L ⊆ [n] with |L| = k is a k-loadout as long as L is contained within some inequality cell C. In turn, Lemma 9 shows that C is an inequality cell as long as it is a facet with gap parity opposite to m. The last step is to count the number of k-subsets that are contained within at least one facet with gap parity opposite to m, for all k = 1, . . . , m. The challenge is not to over-count these subsets because such a subset can be contained in diﬀerent facets. We map the counting of these subsets to a purely combinatorial problem on binary strings. Through some combinatorial bijections, we show that at worst a factor of 4 is lost when one adds the requirement that the (k − 1)dimensional face must be contained within at least one odd facet, with the factor improving to 2 if m is odd, and improving to 1 if k is small. The full proofs are deferred to the full version.  
   
  6  
   
  Conclusion  
   
  We study the novel problem of diversity maximization. This problem can be motivated by the video game design context where designing for diversity is one of its core design philosophies. We model this diversity optimization problem as a parametric linear programming problem where we are interested in the diversity of supports of optimal solutions. Using this model, we establish upper bounds and construct designs that match this upper bound asymptotically. To our knowledge, this is the ﬁrst paper to systematically study the question of “diversity maximization” as we have deﬁned it here. The goal here is “diverse-in diverse-out”, if two players have right-hand resource vectors, they will optimally play diﬀerent strategies. We believe there could be other applications for “diverse-in diverse-out” optimization problems. Consider, for example, a diet problem where a variety of ingredients are used in the making of meals, depending on diﬀerent availability in resources. We leave this exploration for future work. There are also natural extensions to our model and analysis that could be pursued. For instance, we have studied the linear programming version of the problem. An obvious next step is the integer linear setting, which also arises naturally in the design of games. Just as in our analysis of the linear program, a deep understanding of the parametric nature of the integer optimization problems is necessary to proceed in the integer setting. [16] introduce a theory of reduced Gr¨ obner bases of toric ideals that play a role analogous to triangulations of cones. Another compelling extension would involve mixed -integer decision sets. This will require a deep appreciation of parametric mixed-integer linear programming, a topic that remains of keen interest in the integer programming community (see, for instance, [5,6]). Finally, another direction is to consider multiple objectives for the player. In our setting, we have assumed a single meaningful objective for the player, such as maximizing the damage of a loadout of weapons.  
   
  186  
   
  O. Hanguir et al.  
   
  References 1. Beck, M., Robins, S.: Computing the Continuous Discretely: Integer-Point Enumeration in Polyhedra. Springer, NY (2007). https://doi.org/10.1007/978-0-38746112-0 2. Chen, N., Elmachtoub, A.N., Hamilton, M.L., Lei, X.: Loot box pricing and design. Management Science (forthcoming) (2020) 3. Chen, Z., et al.: EOMM: An engagement optimized matchmaking framework. In: Proceedings of the 26th International Conference on World Wide Web, pp. 1143– 1150 (2017) 4. De Loera, J.A., Rambau, J., Santos, F.: Triangulations: Structures for Algorithms and Applications. Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-64212971-1 5. Eisenbrand, F., Shmonin, G.: Parametric integer programming in ﬁxed dimension. Math. Oper. Res. 33(4), 839–850 (2008) 6. Gribanov, D., Malyshev, D., Pardalos, P.: Parametric integer programming in the average case: sparsity, proximity, and FPT-algorithms. arXiv preprint arXiv:2002.01307 (2020) 7. Guo, H., Hao, L., Mukhopadhyay, T., Sun, D.: Selling virtual currency in digital games: implications for gameplay and social welfare. Inf. Syst. Res. 30(2), 430–446 (2019) 8. Guo, H., Zhao, X., Hao, L., Liu, D.: Economic analysis of reward advertising. Prod. Oper. Manag. 28(10), 2413–2430 (2019) 9. Huang, Y., Jasin, S., Manchanda, P.: “Level up”: leveraging skill and engagement to maximize player game-play in online video games. Information Systems Research 30(3), 927–947 (2019) 10. Kalai, G.: Rigidity and the lower bound theorem 1. Invent. Math. 88(1), 125–151 (1987) 11. McMullen, P.: The maximum numbers of faces of a convex polytope. Mathematika 17(2), 179–184 (1970) 12. Mills, H.: Marginal values of matrix games and linear programs. In: Kuhn, H.W., Tucker, A.W. (eds.) Linear Inequalities and Related Systems, pp. 183–194. Princeton University Press (1956) 13. Ryan, C.T., Sheng, L., Zhao, X.: Selling enhanced attempts. Available at SSRN 3751523 (2020) 14. Saaty, T., Gass, S.: Parametric objective function (part 1). J. Oper. Res. Soc. Am. 2(3), 316–319 (1954) 15. Sheng, L., Ryan, C.T., Nagarajan, M., Cheng, Y., Tong, C.: Incentivized actions in freemium games. Manufacturing & Service Operations Management (2020) 16. Sturmfels, B., Thomas, R.R.: Variation of cost functions in integer programming. Math. Program. 77(2), 357–387 (1997) 17. Turner, J., Scheller-Wolf, A., Tayur, S.: Scheduling of dynamic in-game advertising. Oper. Res. 59(1), 1–16 (2011) 18. Walkup, D., Wets, R.: Lifting projections of convex polyhedra. Pac. J. Math. 28(2), 465–475 (1969) 19. Williams, A.: Marginal values in linear programming. J. Soc. Ind. Appl. Math. 11(1), 82–94 (1963)  
   
  ReLU Neural Networks of Polynomial Size for Exact Maximum Flow Computation Christoph Hertrich1(B) 1  
   
  and Leon Sering2  
   
  London School of Economics and Political Science, London, UK [email protected]  2 ETH Zurich, Zurich, Switzerland [email protected]   
   
  Abstract. This paper studies the expressive power of artiﬁcial neural networks with rectiﬁed linear units. In order to study them as a model of real-valued computation, we introduce the concept of Max-Aﬃne Arithmetic Programs and show equivalence between them and neural networks concerning natural complexity measures. We then use this result to show that two fundamental combinatorial optimization problems can be solved with polynomial-size neural networks. First, we show that for any undirected graph with n nodes, there is a neural network (with ﬁxed weights and biases) of size O(n3 ) that takes the edge weights as input and computes the value of a minimum spanning tree of the graph. Second, we show that for any directed graph with n nodes and m arcs, there is a neural network of size O(m2 n2 ) that takes the arc capacities as input and computes a maximum ﬂow. Our results imply that these two problems can be solved with strongly polynomial time algorithms that solely uses aﬃne transformations and maxima computations, but no comparison-based branchings. Keywords: Neural Network Expressivity · Strongly Polynomial Algorithms · Minimum Spanning Tree Problem · Maximum Flow Problem  
   
  1  
   
  Introduction  
   
  Artiﬁcial neural networks (NNs) achieved breakthrough results in various application domains like computer vision, natural language processing, autonomous driving, and many more [40]. Also in the ﬁeld of combinatorial optimization (CO), promising approaches to utilize NNs for problem solving or improving classical solution methods have been introduced [7]. However, the theoretical understanding of NNs still lags far behind these empirical successes. All neural networks considered in this paper are feedforward neural networks with rectiﬁed linear unit (ReLU) activations, one of the most popular models in practice [19]. These NNs are directed, acyclic, computational graphs in which The full version is available on arXiv: https://arxiv.org/abs/2102.06635. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 187–202, 2023. https://doi.org/10.1007/978-3-031-32726-1_14  
   
  188  
   
  C. Hertrich and L. Sering  
   
  Fig. 1. A small NN with two input neurons x1 and x2 , a single ReLU neuron labelled with the shape of the ReLU function, and one output neuron y. It computes the function x → y = x2 − max { 0, x2 − x1 } = − max { −x2 , −x1 } = min { x1 , x2 } .  
   
  Fig. 2. This example shows that the outcome of one iteration of the Edmonds-Karp algorithm for computing a maximum ﬂow depends discontinuously on the arc capacities. Here, a small adjustment of the capacity of arc st leads to a drastic change of the ﬂow after the ﬁrst iteration.  
   
  each edge is equipped with a ﬁxed weight and each node with a ﬁxed bias. Each node (neuron) computes an aﬃne transformation of the outputs of its predecessors and applies the ReLU activation function x → max{0, x} on top. The full NN then computes a function mapping real-valued inputs to real-valued outputs. A simple example is given in Fig. 1. The neurons are commonly organized in layers. The depth, width, and size of an NN are deﬁned as the number of layers, the maximum number of neurons per layer, and the total number of neurons, respectively. An important theoretical question about these NNs is concerned with their expressivity: which functions can be represented by an NN of a certain depth, width, or size? Neural network expressivity has been thoroughly investigated from an approximation point of view. For example, so-called universal approximation theorems [3,11,31] show that every continuous function on a bounded domain can be arbitrarily well approximated with only a single nonlinear layer. However, for a full theoretical understanding of this fundamental machine learning model it is necessary to understand what functions can be exactly expressed with different NN architectures. For instance, insights about exact representability have boosted our understanding of the computational complexity of the task to train an NN with respect to both, algorithms [4,36] and hardness results [9,18,20].  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  189  
   
  It is known that a function can be expressed with a ReLU NN if and only if it is continuous and piecewise linear (CPWL) [4]. However, many surprisingly basic questions remain open. For example, it is not known whether two layers of ReLU units (with any width) are suﬃcient to compute the function f : R4 → R, x → max{0, x1 , x2 , x3 , x4 } [24,28]. In this paper we explore another fundamental question within the research stream of exact representability: what are families of CPWL functions that can be represented with ReLU NNs of polynomial size? In other words, using NNs as a model of computation operating on real numbers (in contrast to Turing machines or Boolean circuits, which operate on binary encodings), which problems do have polynomial complexity in this model? Our motivation to study this model stems from a variety of diﬀerent perspectives, including strongly polynomial time algorithms, arithmetic circuit complexity, parallel computation, and learning theory. We believe that classical combinatorial optimization problems are a natural example to study this model of computation because their algorithmic properties are well understood in each of these areas. Clearly, if there are polynomial-size NNs to solve a certain problem, and assuming that the weights of these NNs are computable in polynomial time1 , then there exists a strongly polynomial time algorithm for that problem, simply by executing the NN. However, the converse might be false. This is due to the fact that ReLU NNs only allow a very limited set of possible operations, namely aﬃne combinations and maxima computations. In particular, every function computed by such NNs is continuous, making it impossible to realize instructions like a simple if -branching based on a comparison of real numbers. In fact, there are related models of computation for which the use of branchings is exponentially powerful [32]. For some CO problems, classical algorithms do not involve comparison-based branchings and, thus, can easily be implemented as an NN. This is, for example, true for many dynamic programs. In these cases, the existence of eﬃcient NNs follows immediately. We refer to Hertrich and Skutella [29] for some examples of this kind. In particular, polynomial-size NNs to compute the length of a shortest path in a network from given arc lengths are possible. For other problems, like the Minimum Spanning Tree Problem or the Maximum Flow Problem, all classical algorithms use comparison-based branchings. For example, many maximum ﬂow algorithms use them to decide whether an arc is part of the residual network. More speciﬁcally, in the Edmonds-Karp algorithm a slight perturbation (from 0 to ε) in the capacities can lead to diﬀerent augmenting path and therefore to a completely diﬀerent intermediate ﬂow; see Fig. 2. Such a discontinuous behavior can never be represented by a ReLU NN.  
   
  1  
   
  In circuit complexity language, one would say “if there is a uniform neural network family to solve a certain problem”.  
   
  190  
   
  1.1  
   
  C. Hertrich and L. Sering  
   
  Our Main Results  
   
  In order to make it easier to think about NNs in an algorithmic way, we introduce the pseudo-code language Max-Aﬃne Arithmetic Programs (MAAPs). We show that MAAPs and NNs are equivalent (up to constant factors) concerning three basic complexity measures corresponding to depth, width, and overall size of NNs. Hence, MAAPs serve as a convenient tool for constructing NNs with bounded size and could be useful for further research about NN expressivity beyond the scope of this paper. We use this result to prove our two main theorems. The ﬁrst one shows that computing the value of a minimum spanning tree has polynomial complexity on NNs. The proof is based on a result from subtraction-free circuit complexity [17]. Theorem 1. For a ﬁxed graph with n vertices, there exists an NN of depth O(n log n), width O(n2 ), and size O(n3 ) that correctly maps a vector of edge weights to the value of a minimum spanning tree. The second result shows that computing a maximum ﬂow has polynomial complexity on NNs. Since all classical algorithms involve conditional branchings based on the comparison of real numbers, the proof involves the development of a new strongly polynomial maximum ﬂow algorithm which avoids such branchings. While, in terms of standard running times, the algorithm is deﬁnitely not competitive with algorithms that exploit comparison-based branchings, it is of independent interest with respect to the structural understanding of ﬂow problems. Theorem 2. Let G = (V, E) be a ﬁxed directed graph with s, t ∈ V , |V | = n, and |E| = m. There exists an NN of depth and size O(m2 n2 ) and width O(1) that correctly maps a vector of arc capacities to a vector of ﬂow values in a maximum s-t-ﬂow. Let us point out that in case of minimum spanning trees, the NN computes only the objective value, while for maximum ﬂows, the NN computes the actual solution. There is a structural reason for this diﬀerence: Due to their continuous nature, ReLU NNs cannot compute a discrete solution vector, like an indicator vector of the optimal spanning tree, because inﬁnitesimal changes of the edge weights would lead to jumps in the output. For the Maximum Flow Problem, however, the optimal ﬂow itself does indeed have a continuous dependence on the arc capacities. 1.2  
   
  Discussion of the Results  
   
  Before presenting our result in more detail, we discuss the signiﬁcance and limitations of our results from various perspectives. Due to space constraints, we refer to the full version for a more detailed discussion. Learning Theory. A standard approach to create a machine learning model usually contains the following two steps. The ﬁrst step is to ﬁx a particular  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  191  
   
  hypothesis class. When using NNs, this means to ﬁx an architecture, that is, the underlying graph of the NN. Then, each possible choice of weights and biases of all aﬃne transformations in the network constitutes one hypothesis in the class. The second step is to run an optimization routine to ﬁnd a hypothesis in the class that ﬁts given training data as accurately as possible. A core theme in learning theory is to analyse how the choice of the hypothesis class inﬂuences diﬀerent kind of errors made by the machine learning model. While there exist many attempts to mathematically explain the mysterious success of modern NNs [8], there is still a long way ahead of us. Understanding what CPWL functions are actually contained in the hypothesis classes deﬁned by NNs of a certain size (in particular, polynomial size) is a key insight in this direction. We see our combinatorial, exact perspective as a counterbalance and complement to the usual approximate point of view. Strongly Polynomial Time Algorithms. As pointed out above, polynomialsize NNs correspond to a subclass of strongly polynomial time algorithms with a very limited set of operations allowed. Given that this subclass stems from one of the most basic machine learning models, our grand vision, to which we contribute with our results, is to understand for diﬀerent CO problems whether they admit strongly polynomial time algorithms of this type. Algorithms of this type have not been known before for the two problems considered in this paper. It remains an open question whether such algorithms, and hence, polynomial-size NNs, exist to solve other CO problems for which strongly polynomial time algorithms are known. Can they, for instance, compute the weight of a minimum weight perfect matching in (bipartite) graphs? Can they compute the cost of a minimum cost ﬂow from either node demands or arc costs, while the other of the two quantities is considered to be ﬁxed? A major open question is also to prove lower bounds on NN sizes. Can we ﬁnd a family of CPWL functions (corresponding to a CO problem or not) that can be evaluated in strongly polynomial time, but not computed by polynomialsize NNs? While proving lower bounds in complexity theory always seems to be a challenging task, we believe that not all hope is lost. For example, in the area of extended formulations, it has been shown that there exist problems (in particular, minimum weight perfect matching) which can be solved in strongly polynomial time, but every linear programming formulation to this problem must have exponential size [52]. Possibly, one can show in the same spirit that also polynomial-size NN representations are not achievable. Boolean Circuits. Even though NNs are naturally a model of real computation, it is worth to have a look at their computational power with respect to Boolean inputs. Interestingly, this makes understanding the computational power of NNs much easier. It is easy to see that ReLU NNs can directly simulate AND-, OR-, and NOT-gates, and thus every Boolean circuit [44]. Hence, in Boolean arithmetics, every problem in P can be solved with polynomial-size NNs. However, requiring the networks to solve a problem for all possible realvalued inputs seems to be much stronger. Consequently, the class of functions representable with polynomial-size NNs is much less understood than in Boolean  
   
  192  
   
  C. Hertrich and L. Sering  
   
  arithmetics. Our results suggest that rethinking and forbidding basic algorithmic paradigms (like comparison-based branchings) can help towards improving this understanding. Arithmetic Circuits. As a circuit model with real-valued computation, ReLU networks are naturally closely related to arithmetic circuits. Just like NNs, arithmetic circuits are computational graphs in which each node computes some arithmetic expression (traditionally addition or multiplication) from the outputs of all its predecessors. Arithmetic circuits are well-studied objects in complexity theory [56]. Closer to ReLU NNs, there is a special kind of arithmetic circuits called tropical circuits [33]. In contrast to ordinary arithmetic circuits, they contain maximum (or minimum) gates instead of sum gates and sum gates instead of product gates. Thus, they are arithmetic circuits in the max-plus algebra. A tropical circuit can be simulated by an NN of roughly the same size since NNs can compute maxima and sums. However, neural networks are strictly more powerful than tropical circuits for two reasons: they can realize subtractions (that is, tropical division) by using negative weights and scalar multiplication (tropical exponentiation) with any real number. Thus, lower bounds on the size of tropical circuits do not apply to NNs. A particular example with an exponential gap between NNs and tropical circuits is the computation of the value of a minimum spanning tree. By Jukna and Seiwert [34], no polynomial-size tropical circuit can do this. However, Theorem 1 shows that NNs of cubic size (in the number of nodes of the input graph) are suﬃcient for this task. Parallel Computation. Neural networks are naturally a model of parallel computation by performing all operations within one layer at the same time. Without going into detail here, the depth of an NN is related to the running time of a parallel algorithm, its width is related to the required number of processing units, and its size to the total amount of work conducted by the algorithm. One takeaway from this perspective is that, although the result by Arora et al. [4] guarantees that logarithmic depth should be suﬃcient to compute a maximum ﬂow, this would probably require superpolynomial width and size. The reason is that the Maximum Flow Problem is P-complete [22,23], meaning that it probably cannot be eﬃciently parallelized. 1.3  
   
  Further Related Work  
   
  Using NNs to solve optimization problems started with so-called Hopﬁeld networks in the 1980s [30,35,57], which has also been specialized to the Maximum Flow Problem [2,14,45]. However, the NNs used in these works are conceptually very diﬀerent from modern feedforward NNs that are considered in this paper. In recent years interactions between NNs and CO have regained a lot of attention in the literature [7], for example, for boosting MIP solvers [42] and solving speciﬁc CO problems [6,16,37,38,47,60]. These approaches usually are of heuristic nature without quality or running time guarantees. Concerning the expressivity of ReLU neural networks, various tradeoﬀs between depth and width of NNs [4,15,25,27,41,46,51,53,58,59,62] and  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  193  
   
  approaches to count and bound the number of linear regions of a ReLU NN [26,43,50,51,54] have been found. NNs have been studied from a circuit complexity point of view before [5,49,55]. However, these works focus on Boolean circuit complexity of NNs with sigmoid or threshold activation functions. We are not aware of previous work investigating the computational power of ReLU NNs as arithmetic circuits operating on the real numbers. For an introduction to classical minimum spanning tree and maximum ﬂow algorithms, we refer to textbooks [1,39,61]. The asymptotically fastest known combinatorial maximum ﬂow algorithm due to Orlin [48] runs in O(nm) time for n nodes and m arcs. Recently, almost linear, weakly polynomial algorithms based on interior point methods have been developed [10]. However, polynomialsize NNs necessarily correspond to strongly polynomial algorithms.  
   
  2  
   
  Algorithms and Proof Overview  
   
  In this section we provide an intuitive overview of how we prove our results. The detailed proofs are deferred to the full version due to space constraints. Max-Aﬃne Arithmetic Programs. For the purpose of algorithmic investigations of ReLU NNs, we introduce the pseudo-code language Max-Aﬃne Arithmetic Programs (MAAPs). A MAAP operates on real-valued variables. The only operations allowed in a MAAP are computing maxima and aﬃne transformations of variables as well as parallel and sequential for loops with a ﬁxed 2 number of iterations. In particular, no if branchings are allowed. With a MAAP A, we associate three complexity measures d(A), w(A), and s(A), which can easily be calculated from a MAAP’s description. The intuition behind these measures is that they correspond (up to constant factors) to the depth, width, and size of an NN computing the same function as the MAAP does. We formalize this intuition by proving the following proposition, which is similar to the transformation of circuits into straight-line programs in Boolean or arithmetic circuit complexity. Proposition 3. For a function f : Rn → Rm the following is true. (i) If f can be computed by a MAAP A, then it can also be computed by an NN with depth d(A) + 1, width w(A), and size s(A). (ii) If f can be computed by an NN with depth d + 1, width w, and size s, then it can also be computed by a MAAP A with d(A) = d, w(A) = 2w, and s(A) = 4s. The proof of the proposition works by providing explicit constructions to convert a MAAP into an NN (part (i)), and vice versa (part (ii)) while taking care that the diﬀerent complexity measures translate respectively. The takeaway from this exercise is that for proving that NNs of a certain size can compute certain functions, it is suﬃcient to develop an algorithm in the 2  
   
  In this context, ﬁxed means that the number of iterations cannot depend on the speciﬁc instance. It can still depend on the size of the instance (e.g., the size of the graph in case of the two CO problems considered in this paper).  
   
  194  
   
  C. Hertrich and L. Sering  
   
  Algorithm 1: MSTn : Compute the value of a minimum spanning tree for the complete graph on n ≥ 3 vertices. Input: Edge weights (xij )1≤i 0. However, we cannot recover the shortest s-t path with capacity ak,s . Therefore, in general, ﬂow will not be sent along a single path and the value of the ﬂow output by FindAugmentingFlowk might be strictly less than ak,s . After computing the ai,v values, FindAugmentingFlowk greedily pushes ﬂow from s towards t, using a lexicographic selection rule to pick the next arc to push ﬂow on (line 12 to 22). On the high level, this is similar to the preﬂow-push algorithm, but using the ai,v values that encode the shortest path distance information implicitly. This may leave some nodes with excess ﬂow; a ﬁnal cleanup phase (line 23 to 29) is needed to send the remaining ﬂow back to the source s. An example for the FindAugmentingFlowk -subroutine is given in Fig. 3. We emphasize again that, although the description of the subroutine in the example in Fig. 3 seems to rely heavily on the distance of a node to t, this information is calculated and used only in an implicit way via the precomputed ai,v values. This way, we are able to implement the subroutine without the usage of comparisonbased branchings. The proof of correctness for our algorithm consists of two main steps. The ﬁrst step is the analysis of the subroutine. This involves carefully showing that the returned ﬂow indeed satisﬁes ﬂow conservation, is feasible with respect to the residual capacities, uses only arcs that lie on a s-t-path of length exactly k in the  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  Algorithm 3: FindAugmentingFlowk for a ﬁxed graph G = (V, E) and a ﬁxed length k. Input: Residual capacities (ce )e∈E . 1 2 3 4 5 6  
   
  7 8 9 10 11  
   
  12 13 14 15 16 17 18 19 20 21 22  
   
  23 24 25 26 27 28 29 30 31 32  
   
  // Initializing:  do parallel for each vw ∈ E zvw ← 0 // flow in residual network zwv ← 0 for each (i, v) ∈ [k] × (V \ { t }) do parallel Yvi ← 0 // excessive flow at v in iteration i (from k to 1) ai,v ← 0 // initialize fattest path values // Determining the fattest path values: for each v ∈ Nt− do parallel a1,v ← cvt for i = 2, 3, . . . , k do for each v ∈ V \ { t } do parallel ai,v ← maxw∈Nv+ \{ t } min { ai−1,w , cvw } // Pushing flow of value ak,s from s to t: Ysk ← ak,s // excessive flow at s for i = k, k − 1, . . . , 2 do for v ∈ V \ { t } in index order do for w ∈ Nv+ \ { t } in index order do // Push flow out of v and into w: f ← min { Yvi , cvw , ai−1,w − Ywi−1 } // value we can push over vw such that this flow can still arrive at t zvw ← zvw + f Yvi ← Yvi − f Ywi−1 ← Ywi−1 + f for each v ∈ Nt− do parallel // Push flow out of v and into t: zvt ← Yv1 Yv1 ← 0 // Clean-up by bounding: for i = 2, 3, . . . , k − 1 do for w ∈ V \ { t } in reverse index order do for v ∈ Nw− \ { t } in reverse index order do b ← min { Ywi , zvw } // value we can push backwards along vw zvw ← zvw − b Ywi ← Ywi − b Yvi+1 ← Yvi+1 + b  do parallel for each uv ∈ E yvw ← zvw − zwv return (ye )e∈E  
   
  197  
   
  198  
   
  C. Hertrich and L. Sering  
   
  Fig. 3. Example of the FindAugmentingFlowk subroutine for k = 4. The edge labels in the top ﬁgure are the residual capacity bounds in the current iteration. The ﬁrst step is to compute the fattest path values ai,v , which are depicted as node labels in the top ﬁgure. The values Yvi always denote the excessive ﬂow of a vertex v with distance i from the sink. All values that are not displayed are zero. At s, we initialize Ys4 = a4,s = 6. Then, excessive ﬂow is pushed greedily towards the sink, as shown in the four ﬁgures in the middle. While doing so, we ensure that at each vertex the arriving ﬂow does not exceed its value ai,v . For this reason, ﬂow can get stuck, as it happens at v4 in this example. Therefore, in a ﬁnal cleanup phase, depicted in the two bottom ﬁgures, we push ﬂow back to the source s. Observe that the result is an s-t-ﬂow that is feasible with respect to the residual capacities, uses only paths of length k = 4, and saturates the arc v6 t.  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  199  
   
  residual network, and most importantly, if such a path exists, it saturates at least one arc. This last property can be shown using the lexicographic selection rule to pick the next arc to push ﬂow on. Note that, in general, the subroutine neither returns a single path (as in the Edmonds-Karp algorithm [13]), nor a blocking ﬂow (as in the Dinic algorithm [12]). The second main step is to show that, nevertheless, the properties of the subroutine are suﬃcient to ensure that the distance from s to t in the residual network increases at least every m iterations, such that we terminate with a maximum ﬂow after nm iterations. With the correctness of the whole MAAP at hand, Theorem 2 follows by simply counting the complexity measures d(A), w(A), and s(A), and applying Proposition 3. Acknowledgements. A large portion of this work was completed while both authors were aﬃliated with TU Berlin. We thank Max Klimm, Jennifer Manke, Arturo Merino, Martin Skutella, and László Végh for many inspiring and fruitful discussions and valuable comments. Christoph Hertrich acknowledges funding by DFG-GRK 2434 Facets of Complexity and by the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement ScaleOpt-757481). Leon Sering acknowledges funding by DFG Excellence Cluster MATH+ (EXC-2046/1, project ID: 390685689).  
   
  References 1. Ahuja, R.K., Magnanti, T.L., Orlin, J.B.: Network Flows: Theory, Algorithms, and Applications. Prentice Hall, Upper Saddle River, New Jersey, USA (1993) 2. Ali, M.M., Kamoun, F.: A neural network approach to the maximum ﬂow problem. In: IEEE Global Telecommunications Conference GLOBECOM’91: Countdown to the New Millennium. Conference Record, pp. 130–134 (1991) 3. Anthony, M., Bartlett, P.L.: Neural Network Learning: Theoretical Foundations. Cambridge University Press, Cambridge (1999) 4. Arora, R., Basu, A., Mianjy, P., Mukherjee, A.: Understanding deep neural networks with rectiﬁed linear units. In: International Conference on Learning Representations (2018) 5. Beiu, V., Taylor, J.G.: On the circuit complexity of sigmoid feedforward neural networks. Neural Netw. 9(7), 1155–1171 (1996) 6. Bello, I., Pham, H., Le, Q.V., Norouzi, M., Bengio, S.: Neural combinatorial optimization with reinforcement learning. arXiv:1611.09940 (2016) 7. Bengio, Y., Lodi, A., Prouvost, A.: Machine learning for combinatorial optimization: a methodological tour d’horizon. arXiv:1811.06128 (2018) 8. Berner, J., Grohs, P., Kutyniok, G., Petersen, P.: The modern mathematics of deep learning. arXiv:2105.04026 (2021) 9. Bertschinger, D., Hertrich, C., Jungeblut, P., Miltzow, T., Weber, S.: Training fully connected neural networks is ∃R-complete. arXiv:2204.01368 (2022) 10. Chen, L., Kyng, R., Liu, Y.P., Peng, R., Gutenberg, M.P., Sachdeva, S.: Maximum ﬂow and minimum-cost ﬂow in almost-linear time. arXiv:2203.00671 (2022) 11. Cybenko, G.: Approximation by superpositions of a sigmoidal function. Math. Control Signals Syst. 2(4), 303–314 (1989)  
   
  200  
   
  C. Hertrich and L. Sering  
   
  12. Dinic, E.A.: Algorithm for solution of a problem of maximum ﬂow in a network with power estimation. Soviet Math. Doklady 11, 1277–1280 (1970) 13. Edmonds, J., Karp, R.M.: Theoretical improvements in algorithmic eﬃciency for network ﬂow problems. J. ACM 19(2), 248–264 (1972) 14. Eﬀati, S., Ranjbar, M.: Neural network models for solving the maximum ﬂow problem. Appl. Appl. Math. 3(3), 149–162 (2008) 15. Eldan, R., Shamir, O.: The power of depth for feedforward neural networks. In: Conference on Learning Theory, pp. 907–940 (2016) 16. Emami, P., Ranka, S.: Learning permutations with Sinkhorn policy gradient. arXiv:1805.07010 (2018) 17. Fomin, S., Grigoriev, D., Koshevoy, G.: Subtraction-free complexity, cluster transformations, and spanning trees. Found. Comput. Math. 16(1), 1–31 (2016) 18. Froese, V., Hertrich, C., Niedermeier, R.: The computational complexity of ReLU network training parameterized by data dimensionality. arXiv:2105.08675 (2021) 19. Glorot, X., Bordes, A., Bengio, Y.: Deep sparse rectiﬁer neural networks. In: 14th International Conference on Artiﬁcial Intelligence and Statistics, pp. 315–323 (2011) 20. Goel, S., Klivans, A.R., Manurangsi, P., Reichman, D.: Tight hardness results for training depth-2 ReLU networks. In: 12th Innovations in Theoretical Computer Science Conference (ITCS ’21) (2021) 21. Goldberg, A.V., Tarjan, R.E.: A new approach to the maximum-ﬂow problem. J. ACM (JACM) 35(4), 921–940 (1988) 22. Goldschlager, L.M., Shaw, R.A., Staples, J.: The maximum ﬂow problem is log space complete for P. Theoretical Comput. Sci. 21(1), 105–111 (1982) 23. Greenlaw, R., Hoover, H.J., Ruzzo, W.L.: Limits to parallel computation: Pcompleteness theory. Oxford University Press, Oxford (1995) 24. Haase, C.A., Hertrich, C., Loho, G.: Lower bounds on the depth of integral ReLU neural networks via lattice polytopes. In: International Conference on Learning Representations (ICLR) (2023) 25. Hanin, B.: Universal function approximation by deep neural nets with bounded width and ReLU activations. Mathematics 7(10), 992 (2019) 26. Hanin, B., Rolnick, D.: Complexity of linear regions in deep networks. In: International Conference on Machine Learning (2019) 27. Hanin, B., Sellke, M.: Approximating continuous functions by ReLU nets of minimal width. arXiv:1710.11278 (2017) 28. Hertrich, C., Basu, A., Di Summa, M., Skutella, M.: Towards lower bounds on the depth of ReLU neural networks. Adv. Neural. Inf. Process. Syst. 34, 3336–3348 (2021) 29. Hertrich, C., Skutella, M.: Provably good solutions to the knapsack problem via neural networks of bounded size. In: AAAI Conference on Artiﬁcial Intelligence (2021) 30. Hopﬁeld, J.J., Tank, D.W.: Neural computation of decisions in optimization problems. Biol. Cybernet. 52(3), 141–152 (1985) 31. Hornik, K.: Approximation capabilities of multilayer feedforward networks. Neural Netw. 4(2), 251–257 (1991) 32. Jerrum, M., Snir, M.: Some exact complexity results for straight-line computations over semirings. J. ACM (JACM) 29(3), 874–897 (1982) 33. Jukna, S.: Lower bounds for tropical circuits and dynamic programs. Theory Comput. Syst. 57(1), 160–194 (2015) 34. Jukna, S., Seiwert, H.: Greedy can beat pure dynamic programming. Inf. Process. Lett. 142, 90–95 (2019)  
   
  Poly-Size ReLU Neural Networks for Maximum Flow Computation  
   
  201  
   
  35. Kennedy, M.P., Chua, L.O.: Neural networks for nonlinear programming. IEEE Trans. Circuits Syst. 35(5), 554–562 (1988) 36. Khalife, S., Basu, A.: Neural networks with linear threshold activations: structure and algorithms. In: International Conference on Integer Programming and Combinatorial Optimization, pp. 347–360. Springer, Cham (2022). https://doi.org/10. 1007/978-3-031-06901-7_26 37. Khalil, E., Dai, H., Zhang, Y., Dilkina, B., Song, L.: Learning combinatorial optimization algorithms over graphs. In: Advances in Neural Information Processing Systems 30 (2017) 38. Kool, W., van Hoof, H., Welling, M.: Attention, learn to solve routing problems! In: International Conference on Learning Representations (2019) 39. Korte, B., Vygen, J.: Combinatorial Optimization: Theory and Algorithms, 4th edn. Springer, Heidelberg (2008). https://doi.org/10.1007/3-540-29297-7 40. LeCun, Y., Bengio, Y., Hinton, G.: Deep learning. Nature 521, 436–444 (2015) 41. Liang, S., Srikant, R.: Why deep neural networks for function approximation? In: International Conference on Learning Representations (2017) 42. Lodi, A., Zarpellon, G.: On learning and branching: a survey. TOP 25(2), 207–236 (2017). https://doi.org/10.1007/s11750-017-0451-6 43. Montufar, G.F., Pascanu, R., Cho, K., Bengio, Y.: On the number of linear regions of deep neural networks. In: Advances in Neural Information Processing Systems, vol. 27 (2014) 44. Mukherjee, A., Basu, A.: Lower bounds over Boolean inputs for deep neural networks with ReLU gates. arXiv:1711.03073 (2017) 45. Nazemi, A., Omidi, F.: A capable neural network model for solving the maximum ﬂow problem. J. Comput. Appl. Math. 236(14), 3498–3513 (2012) 46. Nguyen, Q., Mukkamala, M.C., Hein, M.: Neural networks should be wide enough to learn disconnected decision regions. In: International Conference on Machine Learning (2018) 47. Nowak, A., Villar, S., Bandeira, A.S., Bruna, J.: Revised Note on Learning Algorithms for Quadratic Assignment with Graph Neural Networks. arXiv:1706.07450 (2017) 48. Orlin, J.B.: Max ﬂows in O(nm) time, or better. In: Proceedings of the Forty-Fifth Annual ACM Symposium on Theory of Computing (STOC ’13), pp. 765–774. Association for Computing Machinery (2013) 49. Parberry, I., Garey, M.R., Meyer, A.: Circuit Complexity and Neural Networks. MIT Press, Cambridge (1994) 50. Pascanu, R., Montufar, G., Bengio, Y.: On the number of inference regions of deep feed forward networks with piece-wise linear activations. In: International Conference on Learning Representations (2014) 51. Raghu, M., Poole, B., Kleinberg, J., Ganguli, S., Dickstein, J.S.: On the expressive power of deep neural networks. In: International Conference on Machine Learning (2017) 52. Rothvoß, T.: The matching polytope has exponential extension complexity. J. ACM (JACM) 64(6), 1–19 (2017) 53. Safran, I., Shamir, O.: Depth-width tradeoﬀs in approximating natural functions with neural networks. In: International Conference on Machine Learning (2017) 54. Serra, T., Tjandraatmadja, C., Ramalingam, S.: Bounding and counting linear regions of deep neural networks. In: International Conference on Machine Learning (2018) 55. Shawe-Taylor, J.S., Anthony, M.H., Kern, W.: Classes of feedforward neural networks and their circuit complexity. Neural Netw. 5(6), 971–977 (1992)  
   
  202  
   
  C. Hertrich and L. Sering  
   
  56. Shpilka, A., Yehudayoﬀ, A.: Arithmetic circuits: a survey of recent results and open questions. Now Publishers Inc. (2010) 57. Smith, K.A.: Neural networks for combinatorial optimization: a review of more than a decade of research. INFORMS J. Comput. 11(1), 15–34 (1999) 58. Telgarsky, M.: Representation beneﬁts of deep feedforward networks. arXiv:1509.08101 (2015) 59. Telgarsky, M.: Beneﬁts of depth in neural networks. In: Conference on Learning Theory, pp. 1517–1539 (2016) 60. Vinyals, O., Fortunato, M., Jaitly, N.: Pointer networks. In: Advances in Neural Information Processing Systems, vol. 28 (2015) 61. Williamson, D.P.: Network Flow Algorithms. Cambridge University Press, Cambridge (2019) 62. Yarotsky, D.: Error bounds for approximations with deep ReLU networks. Neural Netw. 94, 103–114 (2017)  
   
  On the Correlation Gap of Matroids Edin Husić1 , Zhuan Khye Koh2(B) , Georg Loho3 , and László A. Végh4 1  
   
  IDSIA, USI-SUPSI, Lugano, Switzerland [email protected]  2 Centrum Wiskunde & Informatica, Amsterdam, The Netherlands [email protected]  3 University of Twente, Enschede, The Netherlands [email protected]  4 London School of Economics and Political Science, London, UK [email protected]  Abstract. A set function can be extended to the unit cube in various ways; the correlation gap measures the ratio between two natural extensions. This quantity has been identiﬁed as the performance guarantee in a range of approximation algorithms and mechanism design settings. It is known that the correlation gap of a monotone submodular function is at least 1 − 1/e, and this is tight for simple matroid rank functions. We initiate a ﬁne-grained study of the correlation gap of matroid rank functions. In particular, we present an improved lower bound on the correlation gap as parametrized by the rank and girth of the matroid. We also show that for any matroid, the correlation gap of its weighted rank function is minimized under uniform weights. Such improved lower bounds have direct applications for submodular maximization under matroid constraints, mechanism design, and contention resolution schemes.  
   
  1  
   
  Introduction  
   
  A continuous function h : [0, 1]E → R+ is an extension of a set function f : 2E → R+ if for every x ∈ [0, 1]E , h(x) =Eλ [f (S)] where λ is a probability distribution over 2E with marginals x, i.e., S:i∈S λS = xi for all i ∈ E. Note that this in particular implies f (S) = h(χS ) for every S ⊆ E, where χS denotes the 0-1 indicator vector of S. Two natural extensions are the following. The ﬁrst one corresponds to sam pling each i ∈ E independently with probability xi , i.e., λS = i∈S xi i∈S / (1 − xi ). Thus,    F (x) := f (S) xi (1 − xi ) . (1) S⊆E  
   
  i∈S  
   
  i∈S /  
   
  This is an extended abstract. The full version of the paper with all proofs is available on arXiv:2209.09896. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement no. 757481–ScaleOpt). Z. K. Koh—This work was done while the author was at the London School of Economics. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 203–216, 2023. https://doi.org/10.1007/978-3-031-32726-1_15  
   
  204  
   
  E. Husić et al.  
   
  This is known as the multilinear extension in the context of submodular optimization, see [8]. The second extension corresponds to the probability distribution with maximum expectation: ⎫ ⎧ ⎬ ⎨   λS f (S) : λS = xi ∀i ∈ E, λS = 1, λ ≥ 0 . (2) fˆ(x) := max ⎭ λ ⎩ S⊆E  
   
  S⊆E:i∈S  
   
  S⊆E  
   
  Equivalently, fˆ(x) is the upper part of the convex hull of the graph of f ; we call it the concave extension following terminology of discrete convex analysis [20]. Agrawal, Ding, Saberi and Ye [2] introduced the correlation gap as the worst case ratio F (x) CG(f ) := min . (3) x∈[0,1]E fˆ(x) It bounds the maximum loss incurred in the expected value of f by ignoring correlations. This quantity plays a fundamental role in stochastic optimization [2, 22], mechanism design [7,18,28], prophet inequalities [11,15,24], and a variety of submodular optimization problems [3,12]. The focus of this paper is on weighted matroid rank functions. For a matroid M = (E, I) and a weight vector w ∈ RE + , the corresponding weighted matroid rank function is given by rw (S) := max {w(T ) : T ⊆ S, T ∈ I} . It is monotone nondecreasing and submodular. Recall that a function f : 2E → R is monotone if f (X) ≤ f (Y ) for all X ⊆ Y ⊆ E, and submodular if f (X) + f (Y ) ≥ f (X ∩ Y ) + f (X ∪ Y ) for all X, Y ⊆ E. The correlation gap of a weighted matroid rank function has been identiﬁed as the performance guarantee in a range of approximation algorithms and mechanism design settings: Monotone Submodular Maximization. Calinescu et al. [8] considered the problem m of maximizing a sum of weighted matroid rank functions i=1 fi subject to a matroid constraint. Using an LP relaxation and pipage rounding [1], they gave a (1 − 1/e)-approximation algorithm. This was extended by Shioura [26] to the problem of maximizing a sum of monotone M  -concave functions [19]. In [9], a (1 − 1/e)-approximation algorithm was obtained for maximizing an arbitrary monotone submodular function subject to a matroid constraint. A fundamental special case of this model is the maximum coverage problem. Given m subsets Ei ⊆ E, the corresponding coverage function is deﬁned as this is a special case of maximizing f (S) = |{i ∈ [m] : Ei ∩ S = ∅}|. Note that  m a sum of matroid rank functions: f (S) = i=1 ri (S) where ri (S) is the rank function of a rank-1 uniform matroid with support Ei . Even for maximization under a cardinality constraint, there is no better than (1 − 1/e)-approximation for this problem unless P = N P (see Feige [16]). Recently, tight approximations have been established for the special case when the function values fi (S) are determined by the cardinality of the set S.  
   
  On the Correlation Gap of Matroids  
   
  205  
   
  Barman et al. [5] studied the maximum concave coverage problem: given a monotone concave function ϕ :  Z+ → R+ and weights w ∈ Rm + , the submodular funcm tion is deﬁned as f (S) = i=1 wi ϕ(|S ∩ Ei |).1 The maximum coverage problem corresponds to ϕ(x) = min{1,  x}; on the other extreme, for ϕ(x) = x we get the trivial problem f (S) = j∈S |{i ∈ [m] : j ∈ Ei }|. In [5], they present a tight approximation guarantee for maximizing such an objective subject to a matroid constraint, parametrized by the Poisson curvature of the function ϕ. This generalizes previous work by Barman et al. [6] which considered ϕ(x) = min{, x} (for  > 1), motivated by the list decoding problem in coding theory. It also generalizes the work by Dudycz et al. [14] which considered geometrically dominated concave functions ϕ, motivated by approval voting rules such as Thiele rules, proportional approval voting, and p-geometric rules. In both cases, the obtained approximation guarantees improve over the 1 − 1/e factor. In the full version, we make the observation that the algorithm of Calinescu et al. [8] and Shioura [26] actually has an approximation ratio of mini∈[m] CG(fi ). We also prove that the Poisson curvature of ϕ is equal to the correlation gap of the functions ϕ(|S ∩ Ei |). Hence, the approximation guarantees in [5,6,14] are in fact correlation gap bounds, and they can be obtained via a single uniﬁed algorithm, i.e., the one by Calinescu et al. [8] and Shioura [26]. In particular, the result of Barman et al. [6] which concerned ϕ(x) = min{, x} (for  > 1) boils down to the analysis of uniform matroid correlation gaps. Sequential Posted-Price Mechanisms. Following Yan [28], consider a seller with a set of identical services (or goods), and a set E of unit-demand agents. Each agent i ∈ E has a private valuation vi for winning the service, and 0 otherwise, where vi is drawn independently from a known distribution Fi with positive smooth density function over [0, L] for some large L. The seller can only service certain subsets of the agents simultaneously; this is captured by a matroid M = (E, I) where I represents the feasible subsets. Mechanisms like Myerson’s mechanism [21] or the VCG mechanism [13,17, 27] have optimal revenue or welfare guarantees, but suﬀer from complicated formats [4] or high computational overhead [23]. Hence, simple mechanisms are often favoured in practice, such as sequential posted-price mechanisms (SPM), in which the seller makes take-it-or-leave-it price oﬀers to agents one by one. Yan [28] showed that the greedy SPM of Chawla et al. [10] achieves an approximation CG(rw ), where rw is the weighted rank function of M with ratio of inf w∈RE + weights w. Contention Resolution Schemes. Chekuri et al. [12] introduced contention resolution (CR) schemes as a tool for maximizing a (not necessarily monotone) submodular function f subject to downward-closed constraints, such as matroid constraints, knapsack constraints, and their intersections. Let M = (E, I) be a matroid imposing one of these constraints. Given a fractional solution x with 1  
   
  We note that such functions are exactly the one-dimensional monotone M  -concave functions fi : Z+ → R+ .  
   
  206  
   
  E. Husić et al.  
   
  multilinear extension value F (x), their CR scheme randomly rounds x to an CG(rw )F (x). Here, integral solution χS where S ∈ I such that E[χS ] ≥ inf w∈RE + rw is again the weighted rank function of M with weights w. Motivated by the signiﬁcance of the correlation gap in algorithmic applications, we study the correlation gap of weighted matroid rank functions. It is well-known that CG(f ) ≥ 1 − 1/e for every monotone submodular function f [8]. Moreover, the extreme case 1 − 1/e is already achieved by the rank function of a rank-1 uniform matroid as |E| → ∞. More generally, the rank function of a rank- uniform matroid has correlation gap 1 − e−  /! ≥ 1 − 1/e [6,28]. Other than for uniform matroids, we are not aware of any previous work that gave better than 1 − 1/e bounds on the correlation gap of speciﬁc matroids. First, we show that among all weighted rank functions of a matroid, the smallest correlation gap is realized by its (unweighted) rank function. Theorem 1. For any matroid M = (E, I) with rank function r = r1 , inf CG(rw ) = CG(r).  
   
  w∈RE +  
   
  For the purpose of lower bounding CG(rw ), Theorem 1 allows us to ignore the weights w and just focus on the matroid M. As an application, to bound the approximation ratio of sequential posted-price mechanisms as in [28], it suﬃces to focus on the underlying matroid. We remark that M can be assumed to be connected, that is, it cannot be written as a direct sum of at least two nonempty m matroids. Otherwise, r = i=1 ri for matroid rank functions ri with disjoint supports, and so CG(r) = mini∈[m] CG(ri ). For example, the correlation gap of a partition matroid is equal to the smallest correlation gap of its parts (uniform matroids). Our goal is to identify the parameters of a matroid which govern its correlation gap. A natural candidate is the rank r(E). However, as pointed out by Yan [28], there exist matroids with arbitrarily high rank whose correlation gap is still 1 − 1/e, e.g., partition matroids with rank-1 parts. The 1 − e−  /! bound for uniform matroids [6,28] is suggestive of girth as another potential candidate. Recall that the girth of a matroid is the smallest size of a dependent set. On its own, a large girth does not guarantee improved correlation gap bounds: in the full version, we show that for any γ ∈ N, there exist matroids with girth γ whose correlation gaps are arbitrarily close to 1 − 1/e. It turns out that the correlation gap heavily depends on the relative values of the rank and girth of the matroid. Our second result is an improved lower bound on the correlation gap as a function of these two parameters. Theorem 2. Let M = (E, I) be a loopless matroid with rank function r, rank r(E) = ρ, and girth γ. Then, γ−2  
   
     i ρ ρ 1 1 e−ρ  (γ − 1 − i) (e − 1)i − ≥1− . CG(r) ≥ 1 − + i e ρ i! e i=0 Furthermore, the last inequality is strict whenever γ > 2.  
   
  On the Correlation Gap of Matroids  
   
  207  
   
  Figure 1 illustrates the behaviour of the expression in Theorem 2. For any ﬁxed girth γ, it is monotone decreasing in ρ. On the other hand, for any ﬁxed rank ρ, it is monotone increasing in γ. In the full version, we also give complementing albeit non-tight upper bounds that behave similarly with respect to these parameters. When ρ = γ − 1, our lower bound simpliﬁes to 1 − e−ρ ρρ /ρ!, i.e., the correlation gap of a rank-ρ uniform matroid (proven in the full version).  
   
  Fig. 1. Our correlation gap bound as a function of the rank ρ and girth γ separately.  
   
  The rank and girth have meaningful interpretations in the aforementioned applications. For instance, the problem of maximizing a sum of weighted consider m matroid rank functions i=1 fi under a matroid constraint (E, J ). For every i ∈ [m], let Mi be the matroid of fi . In game-theoretic contexts, each fi usually represents the utility function of agent i. Thus, our goal is to select a bundle of items S ∈ J which maximizes the total welfare. If Mi has girth γ and rank ρ, this means that agent i is interested in γ −1 ≤ k ≤ ρ items with positive weights. The special case ρ = γ − 1 (uniform matroids) has already found applications in list decoding [6] and approval voting [14]. On the other hand, for sequential posted-price mechanisms, if the underlying matroid M has girth γ and rank ρ, this means that the seller can service γ − 1 ≤ k ≤ ρ agents simultaneously. To the best of our knowledge, our results give the ﬁrst improvement over the (1 − 1/e) bound on the correlation gap of general matroids. We hope that our paper will motivate further studies into more reﬁned correlation gap bounds, exploring the dependence on further matroid parameters, as well as obtaining tight bounds for special matroid classes. 1.1  
   
  Our Techniques  
   
  We now give a high-level overview of the proofs of Theorem 1 and Theorem 2. Weighted Rank Functions. The ﬁrst step in proving both theorems is to deduce structural properties of the points which realize the correlation gap. In Theorem 4, we show that such a point x can be found in the independent set polytope  
   
  208  
   
  E. Husić et al.  
   
  P. This implies that rˆw (x) = w x for any weights w ∈ RE + . Moreover, we deduce that x(E) is integral. To prove Theorem 1, we ﬁx a matroid M and derive a contradiction for a nonuniform weighting. More precisely, we consider a weighting w ∈ RE + and a point rw (x∗ ) < CG(r). By the above, we x∗ ∈ [0, 1]E which give a smaller ratio Rw (x∗ )/ˆ rw (x∗ ) = Rw (x∗ )/w x∗ . We pick w such that can use the simpler form Rw (x∗ )/ˆ it has the smallest number of diﬀerent values. If the number of distinct values is at least 2, then we derive a contradiction by showing that a better solution can be obtained by increasing the weights in a carefully chosen value class until they coincide with the next smallest value. The greedy maximization property of matroids is essential for this argument. Uniform Matroids. Before outlining our proof of Theorem 2, let us revisit the correlation gap of uniform matroids. Let M = (E, I) be a uniform matroid on n elements with rank ρ = r(E). If ρ = 1, then it is easy to verify that the symmetric point x = (1/n) · 1 realizes the correlation gap 1 − 1/e. Since x lies in the independent set polytope, we have rˆ(x) = 1 x = 1. If one samples each i ∈ E with probability 1/n, the probability of selecting at least one element is R(x) = 1 − (1 − 1/n)n . Thus, CG(r) = 1 − (1 − 1/n)n , which converges to 1 − 1/e as n → ∞. More generally, for ρ ≥ 1, Yan [28] showed that the symmetric point x = (ρ/n) · 1 similarly realizes the correlation gap 1 − e−ρ ρρ /ρ!. Poisson Clock Analysis. To obtain the (1 − 1/e) lower bound on the correlation gap of a monotone submodular function, Calinescu et al. [8] introduced an elegant probabilistic analysis. Instead of sampling each i ∈ E with probability xi , they consider n independent Poisson clocks of rate xi that are active during the time interval [0, 1]. Every clock may send at most one signal from a Poisson process. Let Q(t) be the set of elements whose signal was sent between time 0 and t; the output is Q(1). It is easy to see that E[f (Q(1))] ≤ F (x). In [8], they show that the derivative of E[f (Q(t))] can be lower bounded as f ∗ (x) − E[f (Q(t))] for every t ∈ [0, 1], where   ∗ fS (i)xi (4) f (x) := min f (S) + S⊆E  
   
  i∈E  
   
  is an extension of f such that f ∗ ≥ fˆ. The bound E[f (Q(1))] ≥ (1 − 1/e)f ∗ (x) is obtained by solving a diﬀerential inequality. Thus, F (x) ≥ E[f (Q(1))] ≥ (1 − 1/e)f ∗ (x) ≥ (1 − 1/e)fˆ(x) follows. A Two Stage Approach. If f is a matroid rank function, then f ∗ = fˆ (see Theorem 3). Still, the factor (1 − 1/e) in the analysis of [8] cannot be improved: for an integer x ∈ P, we lose a factor (1−1/e) due to E[f (Q(1))] = (1−1/e)F (x), even though the extensions coincide: F (x) = fˆ(x). Our analysis in Sect. 4 proceeds in two stages. Let M = (E, I) be a matroid with rank ρ and girth γ. The basic idea is that up to sets of size γ − 1, our  
   
  On the Correlation Gap of Matroids  
   
  209  
   
  matroid ‘looks like’ a uniform matroid. Since the correlation gap of uniform matroids is well-understood, we ﬁrst extract a uniform matroid of rank γ − 1 from our matroid, and then analyze the contribution from the remaining part separately. More precisely, we decompose the rank function as r = g + h, where g(S) = min{|S|, } is the rank function of a uniform matroid of rank  = γ − 1. Note that the residual function h := f − g is not submodular in general, as h(S) = 0 for all |S| ≤ . We will lower bound the multilinear extensions G(x) and H(x) separately. As g is the rank function of a uniform matroid, similarly as above we can derive a tight lower bound on G in terms of its rank  = γ − 1. Bounding H(x) is based on a Poisson clock analysis as in [8], but is signiﬁcantly more involved. Due to the monotonicity of h, directly applying the result in [8] would yield E[h(Q(1)] ≥ (1 − 1/e)h∗ (x). However, h∗ (x) = 0 whenever M is loopless ( ≥ 1), as h(∅) = 0 and h({i}) = 0 for all i ∈ E. So, the argument of [8] directly only leads to the trivial E[h(Q(1))] ≥ 0. Nevertheless, one can still show that, conditioned on the event |Q(t)| ≥ , the derivative of E[H(Q(t))] is at least r∗ (x) −  − E[H(Q(t))]. Let T ≥ 0 be the earliest time such that |Q(T )| ≥ , which we call the activation time of Q. Then, solving a diﬀerential inequality produces E[h(Q(1))|T = t] ≥ (1 − e−(1−t) )(r∗ (x) − ) for all t ≤ 1. To lower bound E[h(Q(1))], it is left to take the expectation over all possible 1 ¯ activation times T ∈ [0, 1]. Let h(x) = (r∗ (x) − ) 0 Pr[T = t](1 − e−(1−t) )dt ¯ be the resulting expression. We prove that h(x) is concave in each direction ei − ej for i, j ∈ E. This allows us to round x to an integer x ∈ [0, 1]E such ¯  ) ≤ h(x); ¯ recall that x(E) ∈ Z by Theorem 4. that x (E) = x(E) and h(x ¯ After substantial simpliﬁcation of h(x ), we arrive at the formula in Theorem 2, except that ρ is replaced by x(E). So, the rounding procedure eﬀectively shifts the dependency of the lower bound from the value of x to the value of x(E). Since x(E) ≤ ρ by Theorem 4, the ﬁnal step is to prove that the formula in Theorem 2 is monotone decreasing in ρ.  
   
  2  
   
  Preliminaries  
   
  We denote Z+ and R+ as the integers and nonnegative reals  set of nonnegative n! if n ≥ k, and 0 otherwise. For a set S respectively. For n, k ∈ Z+ , nk = k!(n−k)! and i ∈ S, j ∈ / S, we use the shorthand S − i = S \ {i} and S + j = S ∪ {j}. For a function f : 2E → R, a set S ⊆ E and an element i ∈ E, let fS (i) denote the marginal gain of adding  i to S, i.e., fS (i) := f (S + i) − f (S). For x ∈ RE and S ⊆ E, we write x(S) = i∈S xi . Matroids. Let M = (E, I) be a matroid with rank function r : 2E → Z+ . Its independent set polytope P(r) is the convex hull of incidence vectors of indepen dent sets in I. Equivalently, P(r) = x ∈ RE + : x(S) ≤ r(S) ∀S ⊆ E , as shown by Edmonds [25, Theorem 40.2]. We need another classical result by Edmonds [25, Theorem 40.3] on intersecting the independent set polytope with a box. Theorem 3. For a matroid rank function r : 2E → Z+ and x ∈ RE +, max{y(E) : y ∈ P(r), y ≤ x} = min{r(T ) + x(E \ T ) : T ⊆ E}.  
   
  210  
   
  E. Husić et al.  
   
  Probability Distributions. Let Bin(n, p) denote the binomial distribution with n trials and success probability p. Let Poi(λ) denote the Poisson distribution with rate λ. Recall that Pr(Poi(λ) = k) = e−λ λk /k! for any k ∈ Z+ . Definition 1. Given random variables X and Y , we say that X is at least Y in the concave order if for every concave function ϕ : R → R, we have E[ϕ(X)] ≥ E[ϕ(Y )] whenever the expectations exist. It is denoted as X ≥cv Y . Lemma 1 ([6]). For any n ∈ N and p ∈ [0, 1], we have Bin(n, p) ≥cv Poi(np). Properties of the Multilinear Extension. For a set function f : 2E → R, let F : [0, 1]E → R denote its multilinear extension. We will use the following well-known properties of F , see e.g. [9]. Proposition 1. If f is monotone, then F (x) ≥ F (y) for all x ≥ y. Proposition 2. If f is submodular, then for any x ∈ [0, 1]E and i, j ∈ E, the function φ(t) := F (x + t(ei − ej )) is convex.  
   
  3  
   
  Locating the Correlation Gap  
   
  In this section, given a weighted matroid rank function rw , we locate a point x∗ ∈ [0, 1]E on which the correlation gap CG(rw ) is realized, and derive some structural properties. Using this, we prove Theorem 1, i.e., the smallest correlation gap over all possible weightings is attained by uniform weights. We start with a more convenient characterization of the concave extension of rw . Lemma 2. Let M = (E, I) be a matroid with rank function r and weights E w ∈ RE ˆw (x) = max{w y : y ∈ P(r), y ≤ x}. + . For any x ∈ [0, 1] , we have r Next, we show that x∗ can be chosen to lie in the independent set polytope P(r); and that supp(x∗ ) is a tight set w.r.t. x∗ , meaning x∗ (E) = r(supp(x∗ )). Theorem 4. Let M = (E, I) be a matroid with rank function r. For any weights ∗ ∗ w ∈ RE rw (x∗ ) + \ {0}, there exists a point x ∈ P(r) such that CG(rw ) = Rw (x )/ˆ ∗ ∗ and x (E) = r(supp(x )). Proof (of Theorem 1). For the purpose of contradiction, suppose that there exist ∗ E such that Rw (x∗ )/ˆ rw (x∗ ) < CG(r). weights w ∈ RE + and a point x ∈ [0, 1] ∗ According to Theorem 4, we may assume that x ∈ P(r). Thus, rˆw (x∗ ) = w x∗ by Lemma 2. Let w1 > w2 > · · · > wk ≥ 0 denote the distinct values of w. For each i ∈ [k], let Ei ⊆ E denote the set of elements with weight wi . Clearly, k ≥ 2, as rw (x∗ ) = w1 R(x∗ )/(w1 x∗ (E)) = R(x∗ )/x∗ (E) ≥ CG(r). Let otherwise Rw (x∗ )/ˆ us pick a counterexample with k minimal. First, we claim that wk > 0. Indeed, if the smallest weight is wk = 0, then Rw (x∗ ) and rˆw (x∗ ) remain unchanged after setting we ← w1 and x∗e ← 0 for all e ∈ Ek ; this contradicts the minimal choice of k.  
   
  On the Correlation Gap of Matroids  
   
  211  
   
  Let X be the random variable for the set obtained by sampling every element e ∈ E independently with probability x∗e . Let IX ⊆ X denote a maximum weight independent subset of X. Recall the well-known property of matroids that a maximum weight independent set can be selected greedily in decreasing order of the weights we . We ﬁx an arbitrary tie-breaking rule inside each set Ei . The correlation gap of rw is given by  k  i Rw (x∗ ) S⊆E Pr(X = S)rw (S) i=1 w e∈Ei Pr(e ∈ IX ) = . = k ∗  ∗ i ∗ rˆw (x ) w x i=1 w x (Ei )   
   
  Consider the set J := arg min  
   
  e∈Ei  
   
  Pr(e ∈ IX ) . i)  
   
  x∗ (E  
   
  i∈[k]  
   
  We claim that J \ {1} = ∅. Suppose that J = {1} for a contradiction. Deﬁne the point x ∈ P(r) as xe := x∗e if e ∈ E1 , and xe := 0 otherwise. Then, we get a contradiction from w1 R(x ) CG(r) ≤ = rˆ(x )  
   
    
   
  e∈E1 Pr(e ∈ w1 x∗ (E1 )  
   
  IX )  
   
  k  
  0. Now, pick any index j ∈ J \ {1}. Since wj > 0, we have  k  i wj e∈Ej Pr(e ∈ IX ) e∈Ei Pr(e ∈ IX ) i=1 w ≤ . k i ∗ wj x∗ (Ej ) i=1 w x (Ei ) So, we can increase wj to wj−1 without increasing the correlation gap. That is, ¯e := wj−1 if e ∈ Ej and w ¯e := we otherwise, we get deﬁning w ¯ ∈ RE + as w    i j−1 Rw (x∗ ) i=j w e∈Ei Pr(e ∈ IX ) + w e∈Ej Pr(e ∈ IX )  ≥ ∗ i ∗ j−1 ∗ rˆw (x ) x (Ej ) i=j w x (Ei ) + w  Pr(X = S)r (S) Rw¯ (x) w ¯ S⊆E . = ≥ min w ¯  x∗ ˆw¯ (x) x∈[0,1]E r The equality holds because for every S ⊆ E, IS remains a max-weight independent set with the new weights w. ¯ This contradicts the minimal choice of k.    
   
  4  
   
  Lower Bounding the Correlation Gap  
   
  This section is dedicated to the proof of Theorem 2. Let M = (E, I) be a matroid with rank function r, rank ρ = r(E) and girth γ > 1. By Theorem 4, there exists a point x∗ ∈ P(r) such that CG(r) = R(x∗ )/r(x∗ ) and x∗ (E) = r(supp(x∗ )). For the sake of brevity, we denote  = γ − 1 and λ = x∗ (E) ∈ Z+ . Note that if  
   
  212  
   
  E. Husić et al.  
   
  λ < , then supp(x∗ ) is independent. As x∗ (E) = r(supp(x∗ )) = |supp(x∗ )|, we have x∗i = 1 for all i ∈ supp(x∗ ). Since x∗ is integral, the correlation gap is 1 because R(x∗ ) = rˆ(x∗ ). Henceforth, we will assume that λ ≥ . From Lemma 2, we already know that rˆ(x∗ ) = 1 x∗ = λ. So, it remains to analyze R(x∗ ). Let g be the rank function of a rank- uniform matroid on ground set E, and deﬁne the function h := r −g ≥ 0. By linearity of expectation, R(x∗ ) = G(x∗ ) + H(x∗ ). We lower bound G(x∗ ) and H(x∗ ) separately. 4.1  
   
  Lower Bounding G(x∗ )  
   
  As g is the rank function of a uniform matroid, the arguments of Yan [28] and Barman et al. [6] apply. In particular, since G is a symmetric polynomial, and convex along ei − ej for all i, j ∈ E by Proposition 2, we have   
   
       λ λ ∗ · 1 = E min Bin n, G(x ) ≥ G , ≥ E [min {Poi(λ), }] . (5) n n The last inequality follows from Lemma 1. The latter expectation is equal to  j−1 k −λ   −1     λ e λk e−λ =− . (6) Pr(Poi(λ) ≥ j) = ( − k) 1− k! k! j=1 j=1 k=0  
   
  4.2  
   
  k=0  
   
  Lower Bounding H(x∗ )  
   
  Our analysis of H(x∗ ) uses the Poisson clock setup of Calinescu et al. [8], which incrementally builds a set Q(1) as follows. Each element i ∈ E is assigned a Poisson clock of rate x∗i . We start all the clocks simultaneously at time t = 0, and begin with the initial set Q(0) = ∅. For t ∈ [0, 1], if the clock on an element i rings at time t, then we add i to our current set Q(t). We stop at time t = 1. ∗ Clearly, Pr(i ∈ Q(1)) = 1 − e−xi ≤ x∗i for all i ∈ E. Since h is monotone, ∗ Proposition 1 yields H(x∗ ) ≥ H(1 − e−x ) = E[h(Q(1))], where equality is due to independence of the Poisson clocks. So, it suﬃces to lower bound E[h(Q(1))]. Let t ∈ [0, 1) and consider an inﬁnitesimally small interval [t, t + dt]. For each i ∈ E, the probability of adding i during this interval is Pr(Poi(x∗i dt) ≥ 1) = x∗i dt + O(dt2 ). Note that the probability of adding two or more elements is also O(dt2 ). Since dt is very small, we can eﬀectively neglect all O(dt2 ) terms. Definition 2. We say that Q is activated at time T if |Q(t)| <  for all t < T and |Q(t)| ≥  for all t ≥ T . We call T the activation time of Q. Let S ⊆ E where |S| ≥  and let t ≥ t ≥ 0. Conditioning on the events Q(t) = S and T = t , the expected increase of h(Q(t)) (up to O(dt2 ) terms) is  rS (i)x∗i dt ≥ (λ −  − h(S))dt, E[h(Q(t + dt)) − h(Q(t))|Q(t) = S ∧ T = t ] = i∈E  
   
  On the Correlation Gap of Matroids  
   
  213  
   
  where the inequality is due to   h(S) + rS (i)x∗i = r(S) −  + rS (i)x∗i ≥ r∗ (x∗ ) −  = rˆ(x∗ ) −  = λ − . i∈E  
   
  i∈E  
   
  The inequality follows from the deﬁnition of r∗ in (4), the second equality is by Theorem 3, while the third equality is due to Lemma 2 because x∗ ∈ P(r). Dividing by dt and taking expectation over S, we obtain for all t ≥ t ≥ 0, 1 E[h(Q(t + dt)) − h(Q(t))|T = t ] ≥ λ −  − E[h(Q(t))|T = t ]. dt  
   
  (7)  
   
  Let φ(t) := E[h(Q(t))|T = t ]. Then, (7) can be written as dφ dt ≥ λ −  − φ(t). t dφ To solve this diﬀerential inequality, let ψ(t) := et φ(t) and consider dψ dt = e ( dt + t   φ(t)) ≥ e (λ − ). Since ψ(t ) = φ(t ) = 0, we get  t  t  dψ ds ≥ es (λ − )ds = (et − et )(λ − ) ψ(t) = ds   t t   
   
  for all t ≥ t . It follows that E[h(Q(t))|T = t ] = φ(t) = e−t ψ(t) ≥ (1 − et −t )(λ − ) for all t ≥ t . In particular, at time t = 1, we have E[h(Q(1))|T = t ] ≥  (1 − et −1 )(λ − ) for all t ≤ 1. By the law of total expectation,  1 E[h(Q(1))] ≥ (λ − ) Pr(T = t)(1 − et−1 )dt. (8) 0  
   
  Now, the cumulative distribution function of T is given by    ∗ ∗ Pr(T ≤ t) = 1 − (1 − e−xi t ) e−xi t i∈S /  
   
  S⊆E: i∈S |S| . Then, using  (10) evaluates λ−i−2 1 = λ− −i−1 , we can simplify (10) as  
   
  λ−i−1 1 λ−i−1 −i−1  
   
        −1 ! λ λ−i−2 1 e−1 − e−(λ−i) (λ − ) 1 − (−1)−i + i −i−1 e i=0      −1  λ λ−i−2 i 1 =λ 1− (−1)−i−1 e . −  + e−λ i −i−1 e i=0  
   
  (11)  
   
  The sum in (11) can be viewed as a univariate polynomial of degree  − 1 in α ∈ R for α = e. Taking its Taylor expansion at α = 1, we can rewrite (11) as   −1    λ 1 λ 1− ( − i)(e − 1)i . −  + e−λ i e i=0 4.3  
   
  (12)  
   
  Putting Everything Together  
   
  We are ﬁnally ready to lower bound the correlation gap of the matroid rank function r. Recall that we assumed λ >  in the previous subsection. Combining the lower bounds (6) and (12) gives us CG(r) =  
   
     −1 λ G(x∗ ) + H(x∗ ) 1 e−λ  λi i + = 1 − ( − i) (e − 1) − . (13) i 1 x∗ e λ i=0 i!  
   
  On the other hand, if λ = , then h = 0. By (6), we obtain CG(r) =  
   
   −1   −1 e− G(x∗ ) G(x∗ ) k k e− ≥ 1 − =1− , = 1 −  ∗ 1 x   k! ( − 1)!  
   
  (14)  
   
  k=0  
   
  which agrees with (13) when λ =  (proven in full version). To ﬁnish the proof of Theorem 2, it is left to show that (13) is a decreasing function of λ because λ ≤ ρ. We also need to prove that the ﬁnal expression is strictly greater than 1 − 1/e whenever  ≥ 2. These are done in the full version.  
   
  On the Correlation Gap of Matroids  
   
  215  
   
  References 1. Ageev, A.A., Sviridenko, M.: Pipage rounding: a new method of constructing algorithms with proven performance guarantee. J. Comb. Optim. 8(3), 307–328 (2004) 2. Agrawal, S., Ding, Y., Saberi, A., Ye, Y.: Price of correlations in stochastic optimization. Oper. Res. 60(1), 150–162 (2012) 3. Asadpour, A., Niazadeh, R., Saberi, A., Shameli, A.: Sequential submodular maximization and applications to ranking an assortment of products. In: EC 2022: The 23rd ACM Conference on Economics and Computation, p. 817 (2022) 4. Ausubel, L.M., Milgrom, P.: The lovely but lonely Vickrey auction. In: Cramton, P., Shoham, Y., Steinberg, R. (eds.) Combinatorial Auctions, chap. 1. MIT Press (2006) 5. Barman, S., Fawzi, O., Fermé, P.: Tight approximation guarantees for concave coverage problems. In: 38th International Symposium on Theoretical Aspects of Computer Science (STACS). LIPIcs, vol. 187, pp. 1–17 (2021) 6. Barman, S., Fawzi, O., Ghoshal, S., Gürpinar, E.: Tight approximation bounds for maximum multi-coverage. Math. Program. 192(1), 443–476 (2022) 7. Bhalgat, A., Chakraborty, T., Khanna, S.: Mechanism design for a risk averse seller. In: Goldberg, P.W. (ed.) WINE 2012. LNCS, vol. 7695, pp. 198–211. Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-35311-6_15 8. Calinescu, G., Chekuri, C., Pál, M., Vondrák, J.: Maximizing a submodular set function subject to a matroid constraint (Extended Abstract). In: Fischetti, M., Williamson, D.P. (eds.) IPCO 2007. LNCS, vol. 4513, pp. 182–196. Springer, Heidelberg (2007). https://doi.org/10.1007/978-3-540-72792-7_15 9. Călinescu, G., Chekuri, C., Pál, M., Vondrák, J.: Maximizing a monotone submodular function subject to a matroid constraint. SIAM J. Comput. 40(6), 1740–1766 (2011) 10. Chawla, S., Hartline, J.D., Malec, D.L., Sivan, B.: Multi-parameter mechanism design and sequential posted pricing. In: Schulman, L.J. (ed.) Proceedings of the 42nd ACM Symposium on Theory of Computing, STOC 2010, Cambridge, Massachusetts, USA, 5–8 June 2010, pp. 311–320. ACM (2010) 11. Chekuri, C., Livanos, V.: On submodular prophet inequalities and correlation gap. In: 14th International Symposium on Algorithmic Game Theory, SAGT. Lecture Notes in Computer Science, vol. 12885, p. 410 (2021) 12. Chekuri, C., Vondrák, J., Zenklusen, R.: Submodular function maximization via the multilinear relaxation and contention resolution schemes. SIAM J. Comput. 43(6), 1831–1879 (2014) 13. Clarke, E.H.: Multipart pricing of public goods. Public choice, pp. 17–33 (1971) 14. Dudycz, S., Manurangsi, P., Marcinkowski, J., Sornat, K.: Tight approximation for proportional approval voting. In: Bessiere, C. (ed.) Proceedings of the TwentyNinth International Joint Conference on Artiﬁcial Intelligence, IJCAI 2020, pp. 276–282. ijcai.org (2020) 15. Dughmi, S.: Matroid secretary is equivalent to contention resolution. In: 13th Innovations in Theoretical Computer Science Conference, ITCS. LIPIcs, vol. 215, pp. 1–23 (2022) 16. Feige, U.: A threshold of ln n for approximating set cover. J. ACM (JACM) 45(4), 634–652 (1998) 17. Groves, T.: Incentives in teams. Econometrica: J. Econometric Soc. 41, 617–631 (1973) 18. Hartline, J.D.: Mechanism design and approximation (2013)  
   
  216  
   
  E. Husić et al.  
   
  19. Leme, R.P.: Gross substitutability: an algorithmic survey. Games Econom. Behav. 106, 294–316 (2017) 20. Murota, K.: On basic operations related to network induction of discrete convex functions. Optim. Methods Softw. 36(2–3), 519–559 (2021) 21. Myerson, R.B.: Optimal auction design. Math. Oper. Res. 6(1), 58–73 (1981) 22. Nikolova, E.: Approximation algorithms for reliable stochastic combinatorial optimization. In: Serna, M., Shaltiel, R., Jansen, K., Rolim, J. (eds.) APPROX/RANDOM -2010. LNCS, vol. 6302, pp. 338–351. Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-642-15369-3_26 23. Nisan, N., Ronen, A.: Computationally feasible VCG mechanisms. J. Arti. Intell. Res. 29, 19–47 (2007) 24. Rubinstein, A., Singla, S.: Combinatorial prophet inequalities. In: Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 1671–1687. SIAM (2017) 25. Schrijver, A.: Combinatorial optimization: polyhedra and eﬃciency, vol. 24. Springer (2003) 26. Shioura, A.: On the Pipage rounding algorithm for submodular function maximization - a view from discrete convex analysis. Discret. Math. Algorithms Appl. 1(1), 1–24 (2009) 27. Vickrey, W.: Counterspeculation, auctions, and competitive sealed tenders. J. Financ. 16(1), 8–37 (1961) 28. Yan, Q.: Mechanism design via correlation gap. In: Proceedings of the twentysecond annual ACM-SIAM symposium on Discrete Algorithms, pp. 710–719. SIAM (2011)  
   
  A 4/3-Approximation Algorithm for Half-Integral Cycle Cut Instances of the TSP Billy Jin1(B) , Nathan Klein2 , and David P. Williamson1 1  
   
  Cornell University, Ithaca, USA {bzj3,davidpwilliamson}@cornell.edu 2 University of Washington, Seattle, USA [email protected]   
   
  Abstract. A long-standing conjecture for the traveling salesman problem (TSP) states that the integrality gap of the standard linear programming relaxation of the TSP (sometimes called the Subtour LP or the Held-Karp bound) is at most 4/3 for symmetric instances of the TSP obeying the triangle inequality. In this paper we consider the halfintegral case, in which a feasible solution to the LP has solution values in {0, 1/2, 1}. Karlin, Klein, and Oveis Gharan [9], in a breakthrough result, were able to show that in the half-integral case, the integrality gap is at most 1.49993; Gupta et al. [6] showed a slight improvement of this result to 1.4983. Both of these papers consider a hierarchy of critical tight sets in the support graph of the LP solution, in which some of the sets correspond to cycle cuts and the others to degree cuts. Here we show that if all the sets in the hierarchy correspond to cycle cuts, then we can ﬁnd a distribution of tours whose expected cost is at most 4/3 times the value of the half-integral LP solution; sampling from the distribution gives us a randomized 4/3-approximation algorithm. We note that known bad cases for the integrality gap have a gap of 4/3 and have a half-integral LP solution in which all the critical tight sets in the hierarchy are cycle cuts; thus our result is tight.  
   
  1  
   
  Introduction  
   
  In the traveling salesman problem (TSP), we are given a set of n cities and the costs cij of traveling from city i to city j for all i, j, and the goal of the problem is to ﬁnd the least expensive tour that visits each city exactly once and returns to its starting point. An instance of the TSP is called symmetric if cij = cji for all i, j. Costs obey the triangle inequality (or are metric) if cij ≤ cik + ckj for all i, j, k. For ease of exposition, we consider the problem input as a complete graph G = (V, E) for the set of cities V , with ce = cij for edge e = (i, j). All instances we consider will be symmetric and obey the triangle inequality. In a breakthrough result, Karlin, Klein, and Oveis Gharan [8] gave the ﬁrst approximation algorithm with performance ratio better than 3/2, although the c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 217–230, 2023. https://doi.org/10.1007/978-3-031-32726-1_16  
   
  218  
   
  B. Jin et al.  
   
  amount by which the bound was improved is quite small (approximately 10−36 ). The algorithm follows the Christoﬁdes-Serdyukov template by selecting a random spanning tree from the max-entropy distribution, then using a T -join on the odd degree vertices of the tree to create a connected Eulerian subgraph. One special case of the TSP is known as the half-integral case. To understand the half-integral case, we need to introduce a well-known LP relaxation of the TSP, sometimes called the Subtour LP or the Held-Karp bound [4,7], which is as follows:  ce xe min e∈E  
   
  s.t.  
   
  x(δ(v)) = 2,  
   
  ∀ v ∈ V,  
   
  x(δ(S)) ≥ 2, 0 ≤ xe ≤ 1,  
   
  ∀ S ⊂ V, S = ∅, ∀e ∈ E,  
   
  where δ(S) is the set of all  edges with exactly one endpoint in S and we use the shorthand that x(F ) = e∈F xe . A half-integral solution to the Subtour LP is one such that xe ∈ {0, 1/2, 1} for all e ∈ E, and a half-integer instance of the TSP is one whose LP solution is half-integral.  
   
  Fig. 1. Illustration of a known worst-case example for the integrality gap for the symmetric TSP with triangle inequality. The ﬁgure on the left gives an (unweighted) graph, and costs cij are the shortest path lengths in the graph. The ﬁgure in the center gives the LP solution, in which the dotted edges have value 1/2, and the solid edges have value 1. The ﬁgure on the right gives the optimal tour. The ratio of the cost of the optimal tour to the value of the LP solution tends to 4/3 as k increases.  
   
  The integrality gap of an LP relaxation is the worst-case ratio of an optimal integer solution to the linear program to the optimal linear programming  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  219  
   
  solution. Wolsey [13] showed that the analysis of the Christoﬁdes-Seryukov algorithm could be used to show that the integrality gap of the Subtour LP is at most 3/2. It is known that the integrality gap of the Subtour LP is at least 4/3, due to a set of half-integral graph TSP instances shown in Fig. 1, and another set of half-integral weighted instances due to Boyd and Sebő [2] known as k-donuts. Schalekamp, Williamson, and van Zuylen [11] have conjectured that half-integral instances are the worst-case instances for the integrality gap. It has long been conjectured that the integrality gap is exactly 4/3, but until the work of Karlin et al. there had been no progress on the conjecture for several decades. In the case of half-integral instances, some results are known. Mömke and Svensson [10] have shown a 4/3-approximation algorithm for half-integral graph TSP (in which cost cij is the number of edges in the shortest i-j path in an input graph), also yielding an integrality gap of 4/3 for such instances; because of the worst-case examples of Fig. 1, their result is tight. Boyd and Carr [1] give a 4/3approximation algorithm (and an integrality gap of 4/3) for a subclass of halfinteger solutions they call triangle points (in which the half-integer edges form disjoint triangles); the examples of Fig. 1 show that their result is tight also. Boyd and Sebő [2] give an upper bound of 10/7 for a subclass of half-integral solutions they call square points (in which the half-integer edges form disjoint 4-cycles). In a paper released just prior to their general improvement, Karlin, Klein, and Oveis Gharan [9] (KKO) gave a 1.49993-approximation algorithm in the halfintegral case; in particular, they show that given a half-integral solution, they can produce a tour of cost at most 1.49993 times the value of the corresponding objective function. Gupta, Lee, Li, Mucha, Newman, and Sarkar [6] improve this factor to 1.4983. With the improvements on the 3/2 bound remaining very incremental for weighted instances of the TSP, even in the half-integral case, we turn the question around and look for a large class of weighted half-integral instances for which we can prove that the 4/3 conjecture is correct, preferably one containing the known worst-case instances. To deﬁne our instances, we turn to some terminology of KKO. The KKO result uses induction on a hierarchy of critical tight sets of the half-integral LP solution x. A set S ⊂ V is tight if the corresponding LP constraint is met with equality; that is, x(δ(S)) = 2. A set S is critical if it does not cross any other tight set; that is, for any other tight set T , either S ∩ T = ∅ or S ⊆ T or T ⊆ S. The critical tight sets then give rise to a natural tree-like hierarchy based on subset inclusion. KKO follow a Christoﬁdes-Serdyukov style algorithm that performs induction on the hierarchy. In their analysis, they diﬀerentiate between cycle cuts (in which the child nodes of a parent are linked by pairs of edges in a chain) and degree cuts (in which the child nodes of a parent form a 4-regular graph; more detail is given in subsequent sections). In this paper, we will consider half-integral instances in which there are only cycle cuts, which we will refer to as half-integral cycle cut instances. Our contribution is to give a randomized 43 -approximation algorithm for these instances. More precisely, we give a distribution over connected Eulerian subgraphs such  
   
  220  
   
  B. Jin et al.  
   
  that each edge e is used with expectation at most 43 xe , which implies the result (note that edges are sometimes doubled in the Eulerian graph). Our main theorem is as follows: Theorem 1. There is a randomized 4/3-approximation algorithm for halfintegral cycle cut instances  of the TSP that produces an Eulerian tour with expected cost at most 43 e∈E ce xe . It is not hard to show that both the bad examples in Fig. 1 and the k-donut instances of Boyd and Sebő [2] are cycle cut instances (Boyd and Carr’s result for triangle points works for the examples of Fig. 1, but not for k-donuts). Thus our bound of 4/3 is tight and cannot be improved. Our approach to the problem is novel and does not use the same ChristoﬁdesSerdyukov framework as employed by KKO and others. Instead, we perform a top-down induction on the hierarchy of critical tight sets. For each set in the hierarchy, we deﬁne a set of “patterns” of edges incident on it such that the set has even degree. For each pattern, we give a distribution of edges connecting the chain of child nodes in the cycle cut, which induces a distribution of patterns on each child. Crucially, we then show that there is a feasible region R of distributions over patterns, such that if the distribution of patterns on the parent node belongs to R, then the induced distribution on patterns on each child node also belongs to R. Our abstract is structured as follows. We give some needed preliminary deﬁnitions in Sect. 2. We then sketch our main result in Sect. 3, and conclude in Sect. 4. Due to space constraints, some proofs are omitted or sketched. The full paper can be accessed at https://arxiv.org/abs/ 2211.04639.  
   
  2  
   
  Preliminaries  
   
  Given a half-integral LP solution x, we construct a 4-regular 4-edge-connected multigraph G = (V, E) by including a single copy of every edge e for which xe = 12 and two copies of every edge e for which xe = 1. We state the following for general k-edge-connected multigraphs. In our setting, k = 4. Definition 1. For a k-edge-connected multigraph G = (V, E), we say: – Any set S ⊆ V such that |δ(S)| = k (i.e., its boundary is a minimum cut) is a tight set. – A set S ⊆ V is proper if 2 ≤ |S| ≤ n − 2 and a singleton if |S| = 1. – Two sets S, S  ⊆ V cross if all of S  S  , S   S, S ∩ S  , and V  (S ∪ S  ) = ∅ are non-empty. The following are two standard facts about minimum cuts; for proofs see [5]. Lemma 1. If two tight sets S and S  cross, then each of S  S  , S   S, S ∩ S  and S ∪ S  are tight. Moreover, there are no edges from S  S  to S   S, and there are no edges from S ∩ S  to S ∪ S  .  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  221  
   
  Lemma 2. Let G = (V, E) be a k-regular k-edge-connected graph. Suppose either |V | = 3 or G has at least one proper min cut, and every proper min cut is crossed by some other proper min cut. Then, k is even and G forms a cycle, with k/2 parallel edges between each adjacent pair of vertices. We now deﬁne our class of instances. Definition 2 (Cycle cut instance). We say a graph G is a cycle cut instance if every non-singleton tight set S can be written as the union of two tight sets A, B = S. As mentioned in the introduction this condition captures the two known integrality gap examples of the subtour LP. We now show an equivalent deﬁnition of cycle cut instances after giving some deﬁnitions. First, ﬁx an arbitrary root vertex r ∈ V , and for all cuts we consider we will take the side which does not contain r. Definition 3 (Critical cuts). A critical cut is any tight set S ⊆ V {r} which does not cross any other tight set. Definition 4 (Hierarchy of critical cuts, H). Let H ⊆ 2V r be the set of all critical cuts. The hierarchy naturally gives rise to a parent-child relationship between sets as follows: Definition 5 (Child, parent, E → (S)). Let S ∈ H such that |S| ≥ 2. Call the maximal sets C ∈ H for which C ⊂ S the children of S, and call S their parent. Finally, deﬁne E → (S) to be the set of edges with endpoints in two diﬀerent children of S. Definition 6 (Cycle cut, degree cut). Let S ∈ H with |S| ≥ 2. Then we call S a cycle cut if when G  S and all of the children of S are contracted, the resulting graph forms a cycle of length at least three with two parallel edges between each adjacent node. Otherwise, we call it a degree cut. While this deﬁnition of a cycle cut may sound specialized, due to Lemma 2, cycle cuts arise very naturally from collections of crossing min cuts. Lemma 3. If G is a cycle cut instance, then for any choice of r, H is composed only of cycle cuts (and singletons). One can also show that if for some choice of r, H is composed only of cycle cuts, then G is a cycle cut instance. Thus, in the remainder of the paper, we assume H is a collection of cycle cuts. Given S ∈ H, let a0 = G  S and let a1 , . . . , ak be its children in H (which are either vertices or cycle cuts). By Lemma 2 a0 , . . . , ak can be arranged into a cycle such that two edges go between each adjacent vertex. WLOG let a1 , . . . , ak be in counterclockwise order starting from a0 . We call a1 the leftmost child of S and ak the rightmost child.  
   
  222  
   
  B. Jin et al. GS  
   
  S  
   
  Fig. 2. S is an example of a cycle cut with three children. In blue are contracted critical tight sets. In gray is the rest of the graph with S contracted. As in Lemma 2, we can see that when G  S is contracted into a single vertex, the resulting graph is a cycle with 2 edges between each adjacent vertex. In our recursive proof of our main theorem in Sect. 3, we are given a distribution of Eulerian tours over G/S, so in particular on the red edges here, and will then extend it to G with the blue critical sets contracted by picking a distribution over the black edges. (Color ﬁgure online)  
   
  Definition 7 (External and internal cycles cuts). Let S ∈ H such that S = V  {r} be a cut with parent S  . We call S external if in the ordering a0 , . . . , ak of S  (as given above), S = a1 or S = ak . Otherwise, call S internal. For example, if the blue nodes in Fig. 2 are contracted cycle cuts, the left and right nodes are external, while the middle one is internal. Note that for an cycle cut S with parent S  , if S is external then |δ(S) ∩ δ(S  )| = 2, and if S is internal then |δ(S) ∩ δ(S  )| = 0. Using the following simple fact, we will now describe our convention for drawing and describing cycle cuts: Lemma 4. Let A, B, C ∈ H be three distinct critical cuts such that A  B and B ∩ C = ∅ or B ⊆ C. Then |δ(A) ∩ δ(C)| ≤ 1. Definition 8 (δ L (S), δ R (S)). Let S ∈ H be a cycle cut. We will deﬁne a partition of δ(S) into two sets δ L (S), δ R (S) each consisting of two edges. If S = V  {r}, then it has a parent S  . S  has children a1 , . . . , ak such that S = ai for i = 0. Let δ L (S) = δ(S) ∩ δ(ai−1 ) and δ R (S) = δ(S) ∩ δ(ai+1 (mod k+1) ). In other words, we partition the edges of S into the two edges going to the left neighbor of S in the cycle deﬁned by S  ’s children and the two edges going to the right neighbor. Otherwise S = V  {r}. Then if a1 , . . . , ak are the children of S, let δ L (S) consist of an arbitrary edge from δ(a1 ) ∩ δ(S) and an arbitrary edge from δ(ak ) ∩ δ(S). Let δ R (S) = δ(S)  δ L (S). By Lemma 4 and the deﬁnition of δ L (S), δ R (S) for S = V  {r}, if S  is an external child of a cycle cut S, then |δ L (S) ∩ δ(S  )| = |δ R (S) ∩ δ(S  )| = 1. This allows us to adopt the following convention for drawing cycle cuts which we will call the caterpillar drawing of S: for an example, see Fig. 3. Formally,  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  223  
   
  let S ∈ H be a cycle cut with children a1 , . . . , ak ∈ H. Arrange a1 , . . . , ak in a horizontal line. First, expand a1 vertically into its children (if it is not a singleton) such that the unique edge in δ L (S) ∩ δ(a1 ) is pointing up (if it is a singleton, simply draw this edge pointing up. Then, expand a2 , . . . , ak one by one into their respective children (if they exist), placing the children vertically in increasing or decreasing order of their index so that the edges from ai to ai+1 do not cross. If ak is a singleton, arbitrarily choose which edge to draw pointing up. Otherwise, let a be the topmost child of ak . Draw the unique edge in δ(S) ∩ δ(a ) pointing up. There are two types of cycle cuts: Definition 9 (Straight and twisted cycle cuts). Let S ∈ H be a cycle cut. If δ L (S) has both edges pointing up in the caterpillar drawing of S, then call it a straight cycle cut. Otherwise, call it a twisted cycle cut. See Fig. 3 for examples.  
   
  S  
   
  S  
   
  Fig. 3. Caterpillar drawings of two diﬀerent cycle cuts S. The red edges are in the δ L (S) partition, and the blue edges are in the δ R (S) partition. The left drawing is a straight cycle cut, and the right is a twisted cycle cut as per Deﬁnition 9 (Color ﬁgure online).  
   
  In the next section, we abbreviate the caterpillar drawing by contracting the non-singleton children of S (see Fig. 4). We do so partially for cleaner pictures but also to emphasize that all the relevant information used by our construction in the following section is contained in the abbreviated pictures.  
   
  S  
   
  S  
   
  Fig. 4. On the left is a shorthand caterpillar drawing for the straight cycle cut on the left in Fig. 3 obtained by contracting its children. Similarly for the right. We will use this style of picture in future sections.  
   
  224  
   
  3  
   
  B. Jin et al.  
   
  Proof of Theorem 1  
   
  We now present a summary of the proof of our main result, a 43 -approximation for half-integral cycle-cut instances of the TSP. To prove Theorem 1, we construct a distribution of Eulerian tours such that every edge is used at most 23 of the time. Since xe = 12 for every edge in the graph, this immediately implies that when we sample a tour from this distribution, its expected cost is at most 43 times the value of the LP. We work on the cycle cut hierarchy from the top down, and inductively specify the distribution of edges that enter every cut. Figure 4 depicts our convention for visualizing a cycle cut as described in Sect. 2. We say that a cycle cut is even if it contains an even number of children, and odd otherwise. Fig. 6 illustrates the patterns we use, where “pattern” refers to a multiset of edges that enter a cycle cut. For each pattern entering a parent cycle cut, we give (randomized) rules which describe how to connect up its children – this induces a distribution of patterns entering each child. We represent this process using a Markov chain with 4 states, illustrated in Fig. 6. The ﬁgure shows the mapping from patterns to states; the transitions will come from the rules for connecting up the children, which we describe later. In the ﬁgure, each state contains two pictures, which represent the parity of the edges in the patterns that are mapped to the state. Speciﬁcally, a present edge is used exactly once, whereas an edge that is not present may be either unused or doubled. For example, Fig. 7 illustrates all possible patterns that are captured by the top picture of state 1. Finally, we maintain the invariant that if a cycle cut is in a given state, then each of the two pictures are equally likely. (When we later give the rules for connecting up the children, we will ensure this invariant is preserved.) Thus, when we say a cycle cut is in a given state with probability p, this means the parity of the pattern entering it follows the top picture in the state with probability p2 , and the bottom picture with probability p2 . We will use the phrase “the distribution of patterns entering a cycle cut C is (p1 , p2 , p3 , p4 )” to mean that for all i ∈ {1, 2, 3, 4}, C is in state i with probability pi . To prove our main result, we will give a feasible region R of distributions over the states of the Markov chain, such that: 1) If the distribution of patterns entering a cycle cut C belongs to R, there is a way to connect up the children of C such that the distribution on each child also belongs to R, and 2) for each p ∈ R, the corresponding rule for connecting the children of C uses each edge in E → (C) at most 23 = 43 xe of the time in expectation. The feasible region is given in Deﬁnition 10. As long as R is nonempty, 1) and 2) are suﬃcient to give the result since we can induce any distribution on the cycle cut V  {r}. Definition 10 (The Feasible Region). Let   2 1 R = (p1 , p2 , p3 , p4 ) ∈ R4+ : p1 + p2 + p3 + p4 = 1, p1 + p2 = , p2 + p4 ≥ . 3 3 See Fig. 5 for an visualization of R in a 2-dimensional space.  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  1 3  
   
  (0, 13 )  
   
  225  
   
  ( 23 , 13 )  
   
  q  
   
  Z  
   
  1 6  
   
  p 1 6  
   
  1 3  
   
  1 2  
   
  2 3  
   
  Fig. 5. The feasible region of distributions is R = {(p, where Z is the polytope above. S1  
   
  S2  
   
  S3  
   
  S4  
   
  2 3  
   
  − p,  
   
  1 3  
   
  − q, q) : (p, q) ∈ Z},  
   
  Fig. 6. The patterns and how they map to states of a Markov chain. The states are unchanged regardless of the number of children: they are deﬁned only with respect to which of the edges are in. Note that we ignore doubled edges.  
   
  To describe the transitions of the Markov chain, we give (randomized) rules that dictate, for a cycle cut C and a pattern entering it, how to connect up its children. These rules depend on whether C is even or odd. The ﬁnal form of the Markov chains is illustrated in Fig. 8.1 The meaning of taking one transition is as follows. Suppose the distribution of patterns entering C is (p1 , p2 , p3 , p4 ), 1  
   
  In the ﬁgure, if there is a variable on an arc, it means that any transition probability in the range of that variable is possible. For example, in Peven , we can transition from S2 to S1 with probability z for any z ∈ [0, 1]; the transition from S2 to S3 then happens with probability 1 − z.  
   
  226  
   
  B. Jin et al.  
   
  Fig. 7. In our illustrations of the patterns entering a given cycle cut, any edge that is not present may either be unused or doubled. Therefore, all four of the given edge conﬁgurations are represented by the upper left most state, S1 .  
   
  and suppose (q1 , q2 , q3 , q4 ) is the resulting distribution after one transition of a Markov chain. What this means is that for each child of C, the distribution of patterns entering it will be either (q1 , q2 , q3 , q4 ) or (q2 , q1 , q3 , q4 ) depending on if the child is straight or twisted, respectively (see Deﬁnition 9 and Fig. 3). In particular, it can be shown that if (q1 , q2 , q3 , q4 ) is the distribution induced on a child which is a straight cycle cut, then (q2 , q1 , q3 , q4 ) would be the distribution induced on a child which is a twisted cycle cut. Thus, it is suﬃcient to check that: i) the distributions induced on straight children lie in the feasible region and ii) if (q1 , q2 , q3 , q4 ) is a distribution induced on straight children, then (q2 , q1 , q3 , q4 ) is also in the feasible region. This corresponds to the set of distributions induced on the children being symmetric under this transformation.2  
   
  1/2  
   
  z  
   
  S1  
   
  1/2  
   
  S3  
   
  S2  
   
  1−z 1/2  
   
  1/2 Pev en  
   
  z ∈ [0, 1], w ∈ [0, 1]  
   
  x  
   
  w  
   
  S4  
   
  1−x  
   
  1−w  
   
  z  
   
  S1  
   
  S3  
   
  S2  
   
  1−z y  
   
  1−y Po dd  
   
  w  
   
  S4  
   
  1−w  
   
  x ∈ [ 13 , 1], y ∈ [ 13 , 1], z ∈ [0, 23 ], w ∈ [0, 23 ]  
   
  Fig. 8. The variables on the arcs indicate that one can feasibly transition according to any probability in the range.  
   
  2  
   
  Note that the feasible region is not symmetric under this transformation. The distribution induced on the children is thus a symmetric subset of the feasible region.  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  227  
   
  Proposition 1. For any cycle cut C ∈ H and any distribution of patterns entering C, there is a way to connect its children so that the induced distribution on each child is given by 1) applying the corresponding Markov chain in Fig. 8, and then 2) swapping the ﬁrst two coordinates if the child is twisted. Proof (Sketch). The proof involves going through the 8 cases one by one (depending on the parity of the cut, and which of the 4 states it is in), and showing that in each case, there is a (randomized) rule for connecting the children that achieve the transitions in Fig. 8. To illustrate the main idea, we show the rule in the case that C is even and in state 4. In this case, the rule for connecting the children of C is illustrated in Fig. 9. Let w ∈ [0, 1]. With probability w, we make all children transition to state 2. To do this, ﬁrst suppose C has all 4 single edges entering it (the top picture in the left box). In this case, we consider the pairs of edges in E → (C) from left to right, and alternate 1) doubling one of the two edges with equal probability (shown by the dotted black edges), and 2) using both edges (shown by the solid black edges). Because C is even, the rightmost pair of edges ends up falling in case 1) of the alternating rule, and so all children transition to state 2. The case where all the edges entering C are used an even number of times (the bottom picture in the left box) is quite similar, except we begin the alternating rule by using both edges. On the other hand, with probability 1 − w, we transition back to state 4. This is accomplished by using each pair of edges in the top case of state 4, and by doubling one edge from each pair uniformly at random in the bottom case of state 4. The net transition probabilities are then (0, w, 0, 1 − w), where w can be any number from 0 to 1.  

  w  
   
  + (1 − w)  
   
  Fig. 9. Transition for state 4 in the even case.  
   
  We ensure that in all cases, each edge in E → (C) is used 12 , 12 , 1, 1 times in expectation if the pattern entering C belongs to state 1, 2, 3, 4, respectively. Therefore, if p = (p1 , p2 , p3 , p4 ) are the probabilities that we are in states 1, 2, 3, 4 respectively, then each edge in E → (C) is used exactly 21 p1 + 12 p2 + p3 + p4 = 1 − 12 (p1 + p2 ) of the time in expectation. Thus to get a 43 -approximation, it is necessary that p1 + p2 ≥ 23 . Note that if p ∈ R, then p1 + p2 = 23 , so that each edge is used exactly 23 of the time.  
   
  228  
   
  B. Jin et al.  
   
  To complete the proof, we only need show that if the distribution of patterns entering a cycle cut C belongs to R, then the induced distributions on the children also belong to R. Thus R is suﬃcient, in sense that if the distribution entering a cycle cut belongs to R, then it is possible to get a 43 -approximation all the way down the hierarchy using the Markov chains in Fig. 8. Moreover, we are able to show that R is necessary; if the distribution entering a cycle cut does not belong to R, then it is impossible to obtain a 43 -approximation using our Markov chains. In this sense, R is the largest feasible region using our technique. Theorem 2. 1. (R is suﬃcient) If the distribution of patterns entering a cycle cut belongs to R, then there are feasible Markov chains (among the ones shown in Fig. 8) such that the induced distribution entering each child also belongs to R. 2. (R is necessary) Suppose the distribution of patterns entering a cycle cut does not belong to R. Then it is not possible to obtain a 43 -approximation using the Markov chains in Fig. 8. Proof (Sketch). For 1), we show that for any p ∈ R and for C even or odd, there are feasible values for the transition probabilities of the corresponding Markov chain such that the resulting distribution q ∈ R (and also q with its ﬁrst two coordinates swapped is in R.) The values of the transition probabilities are derived as a function of p. For 2), we consider an arbitrary distribution p (not necessarily in R), and let q(1) and q(2) be the distributions obtained by applying Peven once and twice, respectively. We then argue that p must belong to R in order for q(1) and q(2) to each have their ﬁrst two coordinates sum to at  
   
  least 23 . Example. To give the reader some more intuition, we give a speciﬁc example of how to maintain distributions in R on all the cuts in the hierarchy by choosing appropriate transition probabilities on the Markov chains in Fig. 8. Let p = ( 49 , 29 , 29 , 19 ) and q = ( 29 , 49 , 29 , 19 ) (i.e. q is p with the ﬁrst two coordinates swapped). It is easy to check that p, q ∈ R. We now show for any half-integral cycle cut instance, it is possible to make it so that the distribution entering any cycle cut is either p or q. To see this, let C be a cycle cut and suppose C is odd. Set the transition probabilities in Podd to be x = y = z = w = 23 . For these probabilities, it is easy to check that Podd p = Podd q = p.3 On the other hand, if C is even, setting z = w = 1 in Peven gives Peven p = p, and setting z = 34 , w = 1 gives Peven q = p. Thus, as long as the distribution entering C is p or q, we can make the distribution on each child of C be either p or q. Together with Proposition 1, this already proves a 43 -approximation for halfintegral cycle cut instances. The additional contribution of Theorem 2 is an exact characterization of the region of distributions that give a 43 -approximation using our techniques. 3  
   
  In fact, it can be checked that for these probabilities, Podd maps every distribution (whose ﬁrst two coordinates sum to 23 ), to p.  
   
  Half-Integral Cycle Cut Instances of the TSP  
   
  4  
   
  229  
   
  Conclusion and Open Questions  
   
  Our result leads to several interesting open questions. One such open question is whether our result extends to the case of cycle cuts for non-half-integral solutions. We believe this to be possible through a more reﬁned understanding of the patterns that result from considering non-half-integral solutions. Clearly a better understanding of what happens in the case of degree cuts is needed to make substantial progress on the overall half-integral case. We think it is possible to improve incrementally on the 1.4983-approximation of Gupta et al. [6] by using a combination of ideas from this paper with a few other small improvements. Recall that in a degree cut, each vertex has degree four, there are no parallel edges, and every proper cut has at least six edges crossing it. Ideally one would be able to show that any distribution on a parent cut lying in the feasible region of Fig. 5 could be used to induce a distribution on patterns of the children of the degree cut in a subregion of the feasible region with each edge used at most 2/3 of the time; such a result would lead immediately to a 4/3 integrality gap for half-integral instances. Acknowledgment. The ﬁrst and third authors would like to thank Anke van Zuylen for early discussions on this problem. The ﬁrst and third authors were supported in part by NSF grant CCF-2007009. The ﬁrst author was also supported by NSERC fellowship PGSD3-532673-2019. The second author was supported in part by NSF grants DGE1762114, CCF-1813135, and CCF-1552097. We would like to thank Martin Drees for his helpful suggestions that allowed us to simplify the proof of the main result.  
   
  References 1. Boyd, S., Carr, R.: Finding low cost TSP and 2-matching solutions using certain half-integer subtour vertices. Discret. Optim. 8, 525–539 (2011) 2. Boyd, S., Sebő, A.: The salesman’s improved tours for fundamental classes. Math. Program. 186, 289–307 (2021) 3. Christoﬁdes, N.: Worst case analysis of a new heuristic for the traveling salesman problem. Report 388, Graduate School of Industrial Administration, CarnegieMellon University, Pittsburgh, PA (1976) 4. Dantzig, G., Fulkerson, R., Johnson, S.: Solution of a large-scale traveling-salesman problem. J. Oper. Res. Soc. Am. 2(4), 393–410 (1954). ISSN 00963984. URL https://www.jstor.org/stable/166695 5. Fleiner, T., Frank, A.: A quick proof for the cactus representation of mincuts. Technical Report QP-2009-03, Egerváry Research Group, Budapest (2009). https:// www.cs.elte.hu/egres 6. Gupta, A., Lee, E., Li, J., Mucha, M., Newman, H., Sarkar, S.: Matroid-based TSP rounding for half-integral solutions. In: Aardal, K., Sanità, L. (eds.) Integer Programming and Combinatorial Optimization. LNCS, vol. 13265, pp. 305– 318 (2022). https://doi.org/10.1007/978-3-031-06901-7_23,See also https://arxiv. org/pdf/2111.09290.pdf 7. Held, M., Karp, R.M.: The traveling-salesman problem and minimum spanning trees. Oper. Res. 18, 1138–1162 (1971)  
   
  230  
   
  B. Jin et al.  
   
  8. Karlin, A.R., Klein, N., Gharan, S.O.: A (slightly) improved approximation algorithm for metric tsp. In: STOC. ACM (2021) 9. Karlin, A.R., Klein, N., Gharan, S.O.: An improved approximation algorithm for TSP in the half integral case. In: Makarychev, K., Makarychev, Y., Tulsiani, M., Kamath, G., Chuzhoy, J. (eds.) STOC, pp. 28–39. ACM (2020) 10. Mömke, T., Svensson, O.: Removing and adding edges for the traveling salesman problem. J. ACM, 63 (2016). Article 2 11. Schalekamp, F., Williamson, D.P., van Zuylen, A.: 2-matchings, the traveling salesman problem, and the subtour LP: a proof of the Boyd-Carr conjecture. Math. Oper. Res. 39(2), 403–417 (2014) 12. Serdyukov, A.: On some extremal walks in graphs. Upravlyaemye Sistemy 17, 76– 79 (1978) 13. Wolsey, L.A.: Heuristic analysis, linear programming and branch and bound. Math. Program. Study 13, 121–134 (1980)  
   
  The Polyhedral Geometry of Truthful Auctions Michael Joswig1,2 , Max Klimm1(B) , and Sylvain Spitz1  
   
  2  
   
  1 Technische Universität Berlin, 10623 Berlin, Germany {joswig,spitz}@math.tu-berlin.de, [email protected]  Max-Planck Institute for Mathematics in the Sciences, 04103 Leipzig, Germany  
   
  Abstract. The diﬀerence set of an outcome in an auction is the set of types that the auction mechanism maps to the outcome. We give a complete characterization of the geometry of the diﬀerence sets that can appear for a dominant strategy incentive compatible multi-unit auction showing that they correspond to regular subdivisions of the unit cube. This observation is then used to construct mechanisms that are robust in the sense that the set of items allocated to a player does change only slightly when the player’s reported type is changed slightly.  
   
  1  
   
  Introduction  
   
  Mechanism design is concerned with the implementation of favorable social outcomes in environments where information is distributed and only released strategically. Speciﬁcally, this article is concerned with multi-dimensional mechanism design problems where a set of m items is to be allocated to a set of n players. The attitude of each player for receiving a subset of the items is determined by the so-called type of the player and is their private information and not available to the mechanism. In this setting, a mechanism elicits the types from the players, and—based on the reported types—decides on an allocation of the items to the players, and on a price vector that speciﬁes the amount of money that the different players have to pay to the mechanism. In order to incentivize the players to truthfully report their types to the mechanism, one is interested in mechanisms that have the property that no matter what the other players report to the mechanism, no player can beneﬁt from misreporting their type; mechanisms that enjoy this property are called dominant strategy incentive compatible, short DSIC. In this paper, we investigate the geometric properties of DSIC mechanisms. Because DSIC mechanisms require truthful reporting of the type no matter of the types declared by the other players, they can be characterized by the one-player mechanisms that arise when the declared valuations of the other players are ﬁxed. As an example for a mechanism, consider the basic case of a combinatorial auction (see De Vries and Vohra [41] for a survey) where two items are sold to two players with additive valuations. In that case, each player i has a twoparameter type θi = (θi,1 , θi,2 ) where the scalar θi,j is the monetary equivalent c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 231–245, 2023. https://doi.org/10.1007/978-3-031-32726-1_17  
   
  232  
   
  M. Joswig et al.  
   
   θ1,2  
   
   θ1,2  
   
  Q{2}  
   
  Q{1,2}  
   
  Q∅  
   
  Q{1}  
   
   θ1,2  
   
  Q{2}  
   
  Q{1,2}  
   
  4/3  
   
  Q{2}  
   
  Q{1,2}  
   
  Q∅  
   
  Q{1}  
   
  1  
   
  1 (a)  
   
  2/3  
   
  Q∅  
   
  Q{1}  
   
   θ1,1  
   
  4/3 (b)  
   
   θ1,1  
   
  2/3  
   
   θ1,1  
   
  (c)  
   
  Fig. 1. Diﬀerence sets of several mechanisms; cf. [39, Fig. 1].  
   
  that player i attaches to receiving item j. For illustration, assume that player 2 reported θ2 = (1, 1) and consider the corresponding one-player mechanism for player 1. If each item j is sold independently to the bidder i with the highest  (breaking ties in favor of player 1), we obtain that player 1 reported type θi,j  ≥ 1. Geometrically, this one-player mechanism receives item j if and only if θ1,j can be represented by its diﬀerence sets QS , S ∈ 2{1,2} where QS is equal to the closure of the set of types reported by player 1 so that they get allocated the set of items S. The diﬀerence sets were introduced by Vohra [40, p. 41] and reveal valuable information about the properties of the mechanism; see Fig. 1. Figure 1a shows the diﬀerence sets of the mechanism selling each item to the highest bidder; Figs. 1b and c show the diﬀerence sets of other DSIC mechanisms (not speciﬁed here). Under reasonable assumptions, the diﬀerence sets form a polyhedral decomposition of the type space. In this paper, we are interested in characterizing their polyhedral geometry. This is a continuation of work of Vidali [39] who showed that the two combinatorial types shown in Fig. 1b and c are the only cases that can appear for a DSIC mechanism for two items (where the combinatorial type in Fig. 1a is a common degenerate case of both). She then also suggested a similar characterization of the combinatorial types that can appear for three items and asked how these ﬁndings can be generalized to more items. Characterizing the combinatorial types of mechanisms is interesting for a variety of reasons. First, such geometric arguments are often used in order to characterize the set of allocation functions that are implementable by a DSIC mechanism. For instance, the diﬀerence sets whose closures have nonempty intersection correspond exactly to two-cycles in an auxiliary network used by Rochet [35] in order to characterize the allocation functions that are implementable by DSIC mechanisms. Second, the combinatorial types can be used to study the sensitivity of mechanisms to deviations in the reported types. As an example consider the mechanism in Fig. 1a. For any  > 0, reporting the type (1 − , 1 − ) yields no item for player 1 while the report of the type (1 + , 1 + ) grants them both items. Put diﬀerently, a small change in the reported type may  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  233  
   
  change the outcome from no items being allocated to player 1 to all items being allocated to the same player. This is in contrast with the mechanism shown in Fig. 1c where a small change in the reported type may change the cardinality of the set of allocated items only by 1.1 Third, the combinatorial types of the mechanism are relevant for the eﬃciency of the mechanism; see, e.g., [13,39]. Our Results. We give a complete characterization of the combinatorial types of all DSIC combinatorial auctions with m items for any value of m. This answers an open question of Vidali [39] about how to generalize her results for m = 2 and m = 3 to larger values of m. We employ methods from polyhedral geometry [16] and tropical combinatorics [26]. Our results rest on the observation that a multiplayer mechanism is DSIC if and only if its single-player components are DSIC; see [36]. We show that for m items, the combinatorial types of those single-player components are in bijection to equivalence classes of regular subdivisions of the m-dimensional unit cube. We identify the relevant symmetries for exchangeable items and conclude that there are exactly 23 nondegenerate combinatorial types for m = 3 and 3,706,261 such types for m = 4 (Theorem 9). We then use this characterization to study the optimal sensitivity of mechanisms to slight changes in the reported types. Speciﬁcally, we show that for any number of items m, there is a one-player combinatorial auction so that the cardinality of the set of items received by the player changes by at most 1 when the reported type is slightly perturbed (Proposition 11). We also give bounds on a similar measure involving the Hamming distance of the set of received items (Proposition 12). In the full version of this paper, we further show how to apply the same methodology in order to classify the combinatorial types of aﬃne maximizers with n players. Further Related Work. Rochet’s Theorem [35] states that an allocation function is implementable by a DSIC mechanism if and only if the allocation networks of the corresponding one-player mechanisms have no ﬁnite cycles of negative lengths. There is a substantial stream of literature exhibiting conditions where it is enough to require conditions on shorter cycles [4,5,8,9,11,18,27]; for instance, it suﬃces to require the nonnegativity for cycles of length 2 when the preferences are single-peaked [30] or when the type-space is convex [36]. Roberts [34] showed that when the type space of all players is RΩ , then only aﬃne maximizers are implementable by a DSIC mechanism. Gui et al. [23] and Vohra [40] studied the diﬀerence sets QA of a mechanism and showed that under reasonable assumptions their closures are polyhedra. Vidali [39] studied the geometry of the polyhedra for the case of two and three items. In recent years, tropical geometric methods proved to be useful for algorithmic game theory and lead to new results in mechanism design [7,28,37], mean payoﬀ games [1,2], linear optimization [3] and beyond. Beyond the scope of combinatorial auctions, our results are also applicable to the mechanism design problem of scheduling on unrelated machines [12,14,17,21,31]. 1  
   
  This higher stability of the mechanism in Fig. 1c comes at the expense of a smaller social welfare (i.e., sum of player valuations of the received items) which is maximized for the mechanism in Fig. 1a. Maximizing social welfare, however, is mathematically well-understood since it is achieved by the class of VCG-mechanisms [15, 22, 38].  
   
  234  
   
  2  
   
  M. Joswig et al.  
   
  Preliminaries  
   
  In this section, we give a brief overview of basic concepts from mechanism design theory, polyhedral geometry and tropical combinatorics used in this paper. For a more comprehensive treatment we refer to [16,26,29,32]. Mechanism Design. A multi-dimensional mechanism design problem consists of a ﬁnite set [m] := {1, . . . , m} of items and a ﬁnite set [n] := {1, . . . , n} of players. Every player i has a type θi = (θi,1 , . . . , θi,m ) ∈ Rm , where the value θi,j , for j ∈ [m], is the monetary value player i attaches to receiving item j. A vector θ = (θ1 , . . . , θn ) with θi ∈ Rm for all i ∈ [n] is called a type vector and Rn×m is the space of all type vectors. The type θi is the private information of player i and unknown to all other players j = i and the mechanism designer. Let      n×m  ai,j = 1 for all j ∈ [m] Ω = A ∈ {0, 1}   i∈[n]  
   
  be the set of allocations of the m items to the n players. The i-th row Ai of an allocation matrix A ∈ Ω corresponds to the allocation for the i-th player. A (direct revelation) auction mechanism is a tuple M = (f, p) consisting of an allocation function f : Rn×m → Ω and a payment function p : Rn×m → Rn . The mechanism ﬁrst elicits a claimed type vector θ = (θ1 , . . . , θn ) ∈ Rn×m where θi ∈ Rm is the type reported by player i. It then chooses an alternative f (θ ) and payments p(θ ) = (p1 (θ ), . . . , pn (θ )) ∈ Rn where pi (θ ) is the payment from player i to the mechanism. We assume that the players’ utilities are quasi-linear and the valuations are additive, i.e., the utility of player i with type θi when the type vector reported to the mechanism is θ is ui (θ | θi ) = fi (θ )·θi −pi (θ ), where fi (θ ) is the i-th row of f (θ ) = A. An auction mechanism is called dominant strategy incentive compatible (DSIC) or truthful if ui (θ | θi ) ≥ ui ((θi , θ−i ) | θi ), for all i ∈ [n], θ ∈ Rn×m , and θi ∈ Rm . Here and throughout, (θi , θ−i ) denotes the type vector where player i reports θi and every other player j reports θj as in θ. An allocation function is truthfully implementable, or just truthful, (in weakly dominant strategies) if there is an incentive compatible direct revelation mechanism M = (f, p). For an allocation A ∈ Ω, let RA = {θ ∈ Rn×m | f (θ) = A} be the preimage of A under f , and let QA = cl(RA ) be the topological closure of RA . We call QA the diﬀerence set of A. Polyhedral Geometry and Tropical Combinatorics. We consider the maxtropical semiring (T, ⊕, ) with T := R ∪ {−∞}, a ⊕ b := max{a, b} and a  b := a + b. Picking coeﬃcients λu ∈ T for u ∈ Zm such that only ﬁnitely many are distinct from −∞ deﬁnes an m-variate tropical (Laurent) polynomial, p, whose evaluation at x ∈ Rm reads  p(x) = λu  xu = max {λu + x · u | u ∈ Zm } . (1) u∈Zm  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  235  
   
  y (0, 2)  
   
  (2, 1)  
   
  (0, 2)  
   
  (1, 1)  
   
  q  
   
  (0, 1)  
   
  (0, 1) (2, 0) (0, 0)  
   
  (a)  
   
  (2, 1)  
   
  x  
   
  (0, 0)  
   
  (1, 0)  
   
  (1, 1)  
   
  (1, 0)  
   
  (2, 0)  
   
  (b)  
   
  Fig. 2. (a) Tropical hypersurface H(p) and (b) dual regular subdivision of supp(p), where p(x, y) = max{0, x + 1, y + 1, 2x, x + y, 2y − 1, 2x + y − 2}. In (a) regions are marked by their support vectors; in (b) the same labels mark vertices of the subdivision. Conversely, e.g., the blue quadrangular cell on the right is dual to the vertex q on the left. (Color ﬁgure online)  
   
  The support of p is the set supp(p) = {u ∈ Zm | λu = −∞}. The tropical hypersurface H(p) is the set of points x ∈ Rm such that the maximum in (1) is attained at least twice. The tropical hypersurface partitions the set Rm \ H(p) into sets in which the maximum of (1) is attained exactly once, for some ﬁxed u ∈ Zm ; see Fig. 2a. Taking the closure of such a part, we get a region of H(p), which is a (possibly unbounded) polyhedron. The Newton polytope N (p) = conv(supp(p)) of a tropical polynomial p is the convex hull of its support. A ﬁnite set C of polyhedra in Rm is a polyhedral complex, if it is closed with respect to taking faces and if for any two P, Q ∈ C the intersection P ∩Q is a face of both P and Q. The polyhedra in C are the cells of C. If every polyhedron in C is bounded, it is a polytopal complex. Further, given a ﬁnite set of points U ⊂ Rm , a polytopal complex C in Rm is a polytopal subdivision of U if the vertices of all polytopes in C are points in U and if the union of all polytopes in C is the convex hull of the points in U . If the cells of a polytopal subdivision are all simplices, it is called a triangulation. A subdivision of U is called regular, if it can be obtained via a lifting function  λ : U → R on U . Formally, let P (U, λ) := conv (u, λ(u)) ∈ Rm+1  u ∈ U be the lifted polytope. Its upper faces have an outer normal vector with positive last coordinate. Projecting these upper faces by omitting the last coordinate yields a polytopal subdivision of U that is called the regular subdivision of U induced by λ. The following proposition explains the duality between a tropical hypersurface and the regular subdivision of its support. Here we identify a polytopal subdivision with its ﬁnite set of cells, partially ordered by inclusion. A proof can be found in [26, Theorem 1.13.]; see Fig. 2 for an example.  
   
  236  
   
  M. Joswig et al.  
   
  Proposition 1. Let p = max {λu + x · u | u ∈ Zm } be a tropical Laurent polynomial. Then there is an inclusion reversing bijection between the regular subdivision of the support of p with respect to λ(u) = λu and the polyhedral complex induced by the regions of H(p).  
   
  3  
   
  Characterization of One-Player Mechanisms  
   
  In many applications, the intersections of diﬀerence sets QA are special, as the mechanism is essentially indiﬀerent between the outcomes and uses a tie-breaking rule or random selection to determine the outcome. Observing which diﬀerence sets intersect and which do not gives rise to a combinatorial pattern which we attribute to the allocation function. We want to study these patterns in order to classify which of them can be attributed to truthfulness. We express such a pattern as an abstract simplicial complex over the allocation space and call it the indiﬀerence complex of the allocation function. Formally, an abstract simplicial complex over some ﬁnite set E is a nonempty set family S of subsets of E, such that for any set S ∈ S and any subset T ⊆ S, we also have T ∈ S. The maximal elements (by inclusion) of an abstract simplicial complex are called facets. Deﬁnition 2 (Indiﬀerence Complex). The indiﬀerence complex I(f ) of an allocation function f is the abstract simplicial complex deﬁned as    
   
  QA = ∅ . I(f ) = O ⊆ Ω  A∈O  
   
  Note that the indiﬀerence complex I(f ) is precisely the nerve complex of the family of diﬀerence sets of f ; see [10, §10]. Recall that an allocation function f is implementable if there is a DSIC mechanism M = (f, p). Likewise, we call an indiﬀerence complex I implementable, if there is an implementable allocation function f such that I(f ) = I. We deﬁne the local allocation function of player i for a given type vector θ−i to be fi,θ−i (θi ) = Ai , where Ai is the i-th row of A = f (θi , θ−i ). Further, let m m us ﬁx a payment vector p ∈ R2 , which we index by  a ∈ {0, 1} .  allocations Then, for any type θi ∈ Rm , we let up (θi ) = max θi · a − pa  a ∈ {0, 1}m . The resulting function up : Rm → R is a max-tropical polynomial of degree m. We refer to the allocation in {0, 1}m which maximizes up (θi ) as arg max up (θi ). We restate [32, Proposition 9.27], which says that in a truthful setting, the local allocation functions are deﬁned by such tropical polynomials, where the vector p depends only on the types of the other players. Proposition 3. The allocation function f is truthful, if and only if for all players i ∈ [n] and all type vectors θ ∈ Rn×m , there exists a payment vector m pi (θ−i ) ∈ R2 , such that fi,θ−i (θi ) ∈ arg max upi (θ−i ) (θi ).  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  237  
   
  As an important consequence of Proposition 3, the allocation function f is truthful if and only if all of its local functions fi,θ−i are truthful. Therefore, for the remainder of this section, we ﬁx a player i and the type vector θ−i of the other players and consider the corresponding one-player mechanism for player i. Note that in this setting, not all items need to be allocated, since the non-allocated items will be distributed among the remaining players. That is, from now on we abuse the notation slightly by considering single-player allocation functions f : Rm → Ω = {0, 1}m . Next, we want to discuss the relationship between the indiﬀerence complex and the allocation network, which is a tool often used to analyze the truthfulness of allocation functions. The latter is the weighted complete directed graph Gf with a node for each allocation a ∈ Ω and where the arc lengths are given as (a, a ) = inf θ∈Ra {θ · a − θ · a}. The value of (a, a ) is the minimal loss of the player’s valuation that would occur if the mechanism always chooses allocation a instead of a . Recall that Ra = {θ ∈ Rm | f (θ) = a}. We can link the indiﬀerence complex and the allocation network through the following proposition. This generalizes [36, Proposition 5] and also occurs in [39, Lemma 3], without a proof. Here we restate the result in our notation, adding a short proof for the sake of completeness. Proposition 4. Let (f, p) be a DSIC mechanism with quasi-linear utilities for one player. Let C = (a(1) , . . . , a(k) = a(1) ) be a cycle in the allocation network Gf , such that for each j ∈ [k − 1], we get Qa(j) ∩ Qa(j+1) = ∅. Then the length of the cycle C is 0. Proof. Let C = (a(1) , . . . , a(k) ) be a cycle as in the statement of the proposition. Using [36, Proposition 5], we obtain that for any θ ∈ Qa(j) ∩Qa(j+1) , the equation θ · a(j) − θ · a(j+1) = (a(j) , a(j+1) ) is satisﬁed. Since the mechanism (f, p) is truthful and θ ∈ Qa(j) ∩ Qa(j+1) , we obtain θ · a(j) − pa(j) = θ · a(j+1) − pa(j+1) . Therefore pa(j) − pa(j+1) = (a(j) , a(j+1) ). Adding up all the lengths of the arcs of C we get 0, which ﬁnishes the proof.   A consequence of Proposition 4 is that all cycles in Gf with the property that all of its edges connect two common nodes of some facet O ⊆ Ω of the indiﬀerence complex I(f ), have length 0. Especially, each oriented cycle in the one-skeleton of I(f ) is also a zero-cycle in Gf . For the remainder of this section, our goal is to classify truthful allocation functions for the given type of allocation mechanisms. Recall that Proposition 3 shows that the diﬀerence sets of a truthful one-player allocation mechanism are exactly the regions of the tropical utility function of the player. We use this observation to give an alternative proof for the following theorem. It states that there is a bijection between implementable one-player indiﬀerence complexes for m items and the regular subdivisions of the m-dimensional cube. A similar result has been shown by Frongillo and Kash [19], who employ power diagrams. The latter are equivalent to regular subdivisions as shown by Aurenhammer [6].2 2  
   
  Characterizations of implementability in terms of geometric subdivisions of the type space have been used before, e.g., in [24, Proposition 2].  
   
  238  
   
  M. Joswig et al.  
   
  Theorem 5. An indiﬀerence complex I for m items and one player is implementable if and only if there is a regular subdivision S of the m-dimensional unit cube, such that the facets of I are precisely the vertex sets of the maximal cells of S. Proof. Let I be an indiﬀerence complex. It is implementable if and only if there exists a truthful allocation function f with I(f ) = I. By Proposition 3, this is m equivalent to the fact that there is a payment vector p ∈ R2 , such that the diﬀerence sets Qa are exactly the regions of the tropical hypersurface H(up ). As the Newton polytope of up is the unit cube [0, 1]m , Proposition 1 provides a duality between the diﬀerence sets Qa and the regular subdivision of [0, 1]m with respect to the lifting λ(a) = −pa . Hence, a maximal cell in the regular subdivision with vertices (a(1) , . . . , a(k) ) corresponds to a maximal set of allocations such that a∈{a(1) ,...,a(k) } Qa = ∅. The latter is a facet of I(f ). Conversely, if we start with a regular subdivision S of the unit cube induced by some lifting λ, setting the prices pa = −λ(a) and deﬁning f (θ) ∈ arg max up (θ) results in a DSIC mechanism such that the indiﬀerence complex I(f ) corresponds to S in the way described in the statement of the theorem.   Note that the proof is constructive. Further, Theorem 5 says that the simplicial complex I(f ) is precisely the crosscut complex of the poset of cells of the regular subdivision S [10, §10]. If S is a triangulation then its crosscut complex is S itself, seen as an abstract simplicial complex. The main consequence of Theorem 5 is that for truthful one-player mechanisms with additive and quasi-linear utilities, the partitioning of the type space into diﬀerence sets is characterized by the duality to the regular subdivision of the cube, which is captured by the indiﬀerence complex. Example 6. Consider the one-player case with m = 3 items and where the player has a type θ ∈ R3 . Let f be the local allocation function which we deﬁne via f (θ) ∈ arg max{θ · a − pa | a ∈ {0, 1}3 }, with p000 = 0, p100 = p010 = p001 = 3/7, p110 = p101 = p011 = 8/7, and p111 = 10/7. Figure 3 shows the subset of the type space for θ ∈ [0, 1]3 . The ﬁve facets of I(f ) are {0, 1, 2, 4}, {2, 3, 4, 7}, {1, 4, 5, 7}, {1, 2, 3, 7}, {3, 5, 6, 7}; here we use the binary encoding 4a1 + 2a2 + a3 for the vertex a ∈ {0, 1}3 . Those cells form a regular triangulation of [0, 1]3 , which is type F in Fig. 4. We deﬁne two allocation functions f, g : Rm → Ω as combinatorially equivalent if their indiﬀerence complexes agree; i.e., I(f ) = I(g). As before we are primarily concerned with the case where Ω = {0, 1}m and the allocation functions are truthful allocations of m items. In this way we can relate the allocation space with regular subdivisions of the cube [0, 1]m . Deﬁnition 7. A truthful allocation function on m items is nondegenerate if the associated regular subdivision of the m-cube is a triangulation. Triangulations of m-cubes are described in [16, §6.3]. The ﬁrst two columns of Table 1 summarize the known values of the number of all (regular) triangulations of the m-cube. In particular the second column shows the number of  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  239  
   
  Q1111  
   
  Q000 00 0  
   
  Fig. 3. Subdivision of the subset of the type space, where θ ∈ [0, 1]3 , induced by the allocation function described in Example 6. The region Q000 corresponds to the corner in the lower back of the cube and Q111 corresponds to the upper front corner. This and other pictures were obtained via polymake [20]. Table 1. Triangulations of m-cubes. Orbit sizes refer to regular triangulations m All 2 3 4  
   
  Regular  
   
  Sym(m)-orbits Γm -orbits  
   
  2 2 2 74 74 23 92,487,256 87,959,448 3,706,261  
   
  1 6 235,277  
   
  combinatorial types of nondegenerate truthful allocations. The number of all, not necessarily regular, triangulations of the 4-cube was found by Pournin [33]. The corresponding numbers of triangulations for m ≥ 5 are unknown. Remark 8. Any regular subdivision may be reﬁned to a regular triangulation, on the same set of vertices; see [16, Lemma 2.3.15]. Our next goal is to explain the third and fourth columns of Table 1. To this end we need to discuss the symmetries of the cube, which are known. That will be the key to understanding (truthful) allocations of exchangeable items. The automorphism group, Γm , of the m-cube [0, 1]m comprises those bijections on the vertex set which map faces to faces. The group Γm is known to be a semidirect product of the symmetric group Sym(m) with Zm 2 ; its order is m! · 2m . Here the j-th component of Zm 2 ﬂips the j-th coordinate, and this is a reﬂection at the aﬃne hyperplane xj = 12 ; that map does not have any ﬁxed points among the vertices of [0, 1]m . The subgroup Zm 2 of all coordinate ﬂips acts transitively on the 2m vertices. The symmetric group Sym(m) naturally acts on the coordinate directions; this is precisely the stabilizer of the origin in Γm . Since the cells in each triangulation of [0, 1]m are convex hulls of a subset of the vertices, the group Γm also acts on the set of all triangulations of [0, 1]m . Moreover, since Γm acts via aﬃne maps, it sends regular triangulations  
   
   to regular triangulations. The stabilizer Sym(m) acts transitively on the m k vertices of [0, 1]m with exactly k ones. In this way, a Sym(m)-orbit of regular triangulations corresponds to a set of nondegenerate truthful allocation functions for which the  
   
  240  
   
  M. Joswig et al.  
   
  Fig. 4. The combinatorial types of truthful allocation functions corresponding to the six Γ3 -orbits of the 3-cube, together with the corresponding triangulations (exploded) and their tight spans; cf. [16, Fig. 6.35]. The tight span of a regular triangulation S is the subcomplex of bounded cells of the tropical hypersurface dual to S (seen as an ordinary polyhedral complex); see [26, §10.7]. The numbers below the types show how many regular triangulations or Sym(3)-orbits are of the given type, respectively.  
   
  indiﬀerence complexes agree, up to permuting the items. We call such allocation functions combinatorially equivalent for exchangeable items. The Sym(m)-orbits of regular triangulations have been computed with mptopcom [25]; see the third column of Table 1. By Theorem 5 those triangulations bijectively correspond to the implementable indiﬀerence complexes. So that computation furnishes a proof of the following result. Theorem 9. There are 23 combinatorial types of nondegenerate truthful allocation functions for one player and m = 3 exchangeable items. Further, the corresponding count for m = 4 yields 3,706,261. It makes sense to focus on the combinatorics of triangulations, without paying attention to their interpretations for auctions. This amounts to studying the orbits of the full group Γm acting on the set of (regular) triangulations; see the fourth column of Table 1. The six Γ3 -orbits of triangulations of the 3-cube are depicted in Fig. 4. This number expands to 23 if we consider the possible choices of locating the origin. We illustrate the idea for the subdivision of the type space in Fig. 3. Its Γ3 -orbit splits into two Sym(3)-orbits: one from putting the origin in one of the four cubes or in one of the four noncubical cells.  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  241  
   
  Remark 10. Vidali considered a more restrictive notion of nondegeneracy of allocation functions [39, Deﬁnition 8], and in [39, Theorem 1] she arrived at a classiﬁcation of ﬁve types for three items. In our terminology, the number of types is equal to six, which is the count of Γ3 -orbits of regular triangulations of [0, 1]3 reported in Table. 1. The missing type in the classiﬁcation of Vidali is type F (as in Fig. 4), arising from Example 6. Further details will be given in the full version of this paper.  
   
  4  
   
  Sensitivity of Mechanisms  
   
  In this section, we study by how much the allocations for a ﬁxed player may change under a slight modiﬁcation of the reported type. These changes are measured in the following two ways. For two localallocations a, b ∈ {0, 1}m , let the cardinality distance be dc (a, b) := |a|1 − |b|1 , and let the Hamming distance be dh (a, b) := |a − b|1 , where | · |1 is the 1-norm. Note that the cardinality distance is a pseudometric. Let f be an one-player allocation function, we deﬁne the cardinality sensitivity of f as    μc (f ) = max dc (a, b)  a, b ∈ F for some F ∈ I(f ) . The Hamming sensitivity μh (f ) arises in the same way, with dh instead of dc . Intuitively, the cardinality sensitivity μc (f ) is the maximal amount such that any slight change in the type of the player does not cause her allocated bundle to change its cardinality by more than μc (f ). Let Φm be the set of truthful allocation functions for one player and m items. We are now interested in computing the values Mc (m) := minf ∈Φm μc (f ) and Mh (m) := minf ∈Φm μh (f ). Our strategy to compute these values is as follows. From Theorem 5 we know that the indiﬀerence complexes of allocation functions f ∈ Φm are in bijection with the regular subdivisions of [0, 1]m . So we need to identify those subdivisions, for which the maximal distance between any two vertices of one of its cells is minimized. In this way, we can compute Mc (m) exactly, and we give bounds for Mh (m). Proposition 11. The minimal cardinality sensitivity of DSIC one-player mechanisms is Mc (m) = 1. Proof. We ﬁrst slice the unit cube into the polytopes    m   m  Pk = x ∈ [0, 1]  k − 1 ≤ xi ≤ k , k = 1, . . . , m .  i=1  
   
  The polytopes P1 , . . . , Pm form the maximal cells of a polytopal subdivision S m 2 of [0, 1]m . That subdivision is regular with height function λ(x) = − ( i=1 xi ) . This proves the claim, as for each Pk , the diﬀerence in the coordinate sums of two of its vertices diﬀer by at most one.    
   
  242  
   
  M. Joswig et al.  
   
  Note that the height function we used in the proof of the last proposition m 2 leads to the mechanism which is deﬁned by the prices p(a) = ( i=1 ai ) for the allocations a ∈ {0, 1}m . Proposition 12. The minimal Hamming sensitivity for DSIC one-player mechanisms on m ≥ 3 items is bounded by 2 ≤ Mh (m) ≤ m − 1. Proof. For the lower bound let us consider a triangle with the vertices a, b, c ∈ {0, 1}m . If we assume dh (a, b) = dh (a, c) = 1 then the vertices a and b (resp. a and c) diﬀer by a coordinate ﬂip. Therefore, the vertices b and c diﬀer by either two coordinate ﬂips or none. As b = c, the former is the case and dh (b, c) = 2. As the maximal cells of a subdivision of [0, 1]m for m ≥ 2 contain at least three vertices, this proves the lower bound. For the upper bound, we show that there is a subdivision, S, of [0, 1]m such that no cell of S contains two antipodal vertices, i.e., two vertices such that their sum equals the all ones vector. We ﬁrst consider the case where m is odd. For a vertex x ∈ {0, 1}m , let Δ(x) be the cornered simplex with apex x. That is, its vertices comprise x and all its neighbors in the vertex-edge graph of the unit cube; cf. [16, Fig. 6.3.1]. Let Sm be the subdivision of [0, 1]m with the following maximal cells: the big cell is the convex hull of all vertices with an even number m of ones,  and the small cells are the cornered simplices Δ(x), where x ∈ {0, 1} with xi odd. The subdivision S3 is the triangulation of type F in Fig. 4; for m ≥ 5 the big cell is not a simplex, and so Sm is not a triangulation in general. At any rate, the subdivision Sm is always regular: it is induced by the height function which sends a vertex x to 0, if it has an even number of ones and to −1, if that number is odd. For m ≥ 3 odd, no antipodal pair of vertices is contained in any cell of Sm , which proves the claim for the uneven case. If the dimension m is even, we consider the m-dimensional unit cube as a prism over [0, 1]m−1 . Then m − 1 is odd, and we can employ the subdivision Sm−1 of [0, 1]m−1 that we discussed before. We obtain a subdivision, Sm , of [0, 1]m whose maximal cells are prisms over the maximal cells of Sm−1 . The subdivision Sm is again regular: this can be seen from assigning the vertices x × {0} and x × {1} the same height as the vertex x in Sm−1 . Now let P be a maximal cell in Sm−1 , such that Q = P × [0, 1] is a maximal cell of Sm . If Q contained an antipodal pair of vertices, then by removing the last coordinate, we would get an antipodal pair in P , which is absurd. This completes the proof.    
   
  5  
   
  Conclusion  
   
  We studied DSIC allocation mechanisms where a set of m items is allocated to n players. These mechanisms can be described by the corresponding one-player mechanisms when the types declared by the other players are ﬁxed. For a single player, the allocations correspond to vectors {0, 1}m , and the combinatorial types of the allocation mechanisms correspond to regular subdivisions of the m-dimensional unit cube. We then used this insight to design mechanisms that  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  243  
   
  are robust in the sense that small changes in the declared type do not lead to a major change in the set of allocated items. In the full version of this paper, we will show how this method can be applied in order to describe aﬃne maximizers with n players. For multiple copies of items, the deterministic allocations to a single player correspond to a subset of the lattice Nm , and it seems plausible that DSIC mechanisms for such scenarios can also be described by regular subdivisions. Question 13. How does our approach generalize to allocation mechanisms in a setting with multiple copies of items? Acknowledgments. We thank Benny Moldovanu for pointing out the work of Frongillo and Kash [19]. Further, we are indebted to three anonymous reviewers for their comments and corrections. This work was supported by Deutsche Forschungsgemeinschaft under Germany’s Excellence Strategy, Berlin Mathematics Research Center (Grant EXC-2046/1, project-ID 390685689). M. Joswig has further been supported by “Symbolic Tools in Mathematics and their Application” (TRR 195, project-ID 286237555).  
   
  References 1. Akian, M., Gaubert, S., Guterman, A.: Tropical polyhedra are equivalent to mean payoﬀ games. Internat. J. Algebra Comput. 22(1), 1250001 (2012). https://doi. org/10.1142/S0218196711006674 2. Allamigeon, X., Benchimol, P., Gaubert, S., Joswig, M.: Combinatorial simplex algorithms can solve mean payoﬀ games. SIAM J. Opt. 24(4), 2096–2117 (2014). https://doi.org/10.1137/140953800 3. Allamigeon, X., Benchimol, P., Gaubert, S., Joswig, M.: What tropical geometry tells us about the complexity of linear programming. SIAM Rev. 63(1), 123–164 (2021). https://doi.org/10.1137/20M1380211 4. Archera, A., Kleinberg, R.: Truthful germs are contagious: a local-to-global characterization of truthfulness. Games Econ. Behav. 86, 340–366 (2014). https://doi. org/10.1016/j.geb.2014.01.004 5. Ashlagi, I., Braverman, M., Hassidim, A., Monderer, D.: Monotonicity and implementability. Econometrica 78(5), 1749–1772 (2010). https://doi.org/10.3982/ ECTA8882 6. Aurenhammer, F.: Power diagrams: Properties, algorithms and applications. SIAM J. Comput. 16(1), 78–96 (1987). https://doi.org/10.1137/0216006 7. Baldwin, E., Klemperer, P.: Understanding preferences: “demand types", and the existence of equilibrium with indivisibilities. Econometrica 87(3), 867–932 (2019). https://doi.org/10.3982/ECTA13693 8. Berger, A., Müller, R., Naeemi, S.H.: Characterizing implementable allocation rules in multi-dimensional environments. Soc. Choice Welfare 48(2), 367–383 (2016). https://doi.org/10.1007/s00355-016-1008-6 9. Bikhchandani, S., Chatterji, S., Lavi, R., Mu’alem, A., Nisan, N., Sen, A.: Weak monotonicity characterizes deterministic dominant-strategy implementation. Econometrica 74(4), 1109–1132 (2006). https://doi.org/10.1111/j.1468-0262.2006. 00695.x  
   
  244  
   
  M. Joswig et al.  
   
  10. Björner, A.: Topological methods. In: Handbook of Combinatorics, vol. 1, 2, pp. 1819–1872. Elsevier, Amsterdam (1995) 11. Carbajala, J.C., Müller, R.: Implementability under monotonic transformations in diﬀerences. J. Econ. Theory 160, 114–131 (2015). https://doi.org/10.1016/j.jet. 2015.09.001 12. Christodoulou, G., Koutsoupias, E., Kovács, A.: On the Nisan-Ronen conjecture. In: 2021 IEEE 62nd Annual Symposium on Foundations of Computer Science (FOCS), pp. 839–850 (2022). https://doi.org/10.1109/FOCS52979.2021.00086 13. Christodoulou, G., Koutsoupias, E., Vidali, A.: A characterization of 2-player mechanisms for scheduling. In: Proceedings of the 16th Annual European Symposium on Algorithms, (ESA), pp. 297–307 (2008). https://doi.org/10.1007/9783-540-87744-8_25 14. Christodoulou, G., Koutsoupias, E., Vidali, A.: A lower bound for scheduling mechanisms. Algorithmica 55(4), 729–740 (2009). https://doi.org/10.1007/s00453-0089165-3 15. Clarke, E.H.: Multipart pricing of public goods. Public Choice 11, 17–33 (1971). https://doi.org/10.1007/bf01726210 16. De Loera, J.A., Rambau, J., Santos, F.: Triangulations: Structures for algorithms and applications, Algorithms and Computation in Mathematics, vol. 25. Springer, Berlin (2010). https://doi.org/10.1007/978-3-642-12971-1 17. Dobzinski, S., Shaulker, A.: Improved lower bound for truthful scheduling, abs/2007.04362 (2020) 18. Edelman, P.H., Weymark, J.A.: Dominant strategy implementability and zero length cycles. Econ. Theor. 72(4), 1091–1120 (2020). https://doi.org/10.1007/ s00199-020-01324-7 19. Frongillo, R.M., Kash, I.A.: General truthfulness characterizations via convex analysis. Games Econ. Behav. 130, 636–662 (2021). https://doi.org/10.1016/j.geb. 2021.09.010 20. Gawrilow, E., Joswig, M.: a framework for analyzing convex polytopes. In: Polytopes–combinatorics and computation (Oberwolfach, 1997), DMV Sem., vol. 29, pp. 43–73. Birkhäuser, Basel (2000). https://doi.org/10.1007/978-3-0348-84389_2 21. Giannakopoulos, Y., Hammerl, A., Poças, D.: A New Lower Bound for Deterministic Truthful Scheduling. Algorithmica 83(9), 2895–2913 (2021). https://doi.org/ 10.1007/s00453-021-00847-2 22. Groves, T.: Incentives in teams. Econometrica 41, 617–631 (1973). https://doi. org/10.2307/1914085 23. Gui, H., Müller, R., Vohra, R.V.: Dominant strategy mechanisms with multidimensional types. In: Lehmann, D., Müller, R., Sandholm, T. (eds.) Computing and Markets. Dagstuhl Seminar Proceedings, vol. 5011, pp. 1–23 (2005). https:// doi.org/10.4230/DagSemProc.05011.8 24. Jehiel, P., Moldovanu, B., Stacchetti, E.: Multidimensional mechanism design for auctions with externalities. J. Econ. Theory 85(2), 258–293 (1999). https://doi. org/10.1006/jeth.1998.2501 25. Jordan, C., Joswig, M., Kastner, L.: Parallel enumeration of triangulations. Electron. J. Combin. 25(3), Paper 3.6, 27 (2018). https://doi.org/10.37236/7318 26. Joswig, M.: Essentials of tropical combinatorics. Graduate Studies in Mathematics, American Mathematical Society, Providence, RI (2022) 27. Kushnir, A.I., Lokutsievskiy, L.V.: When is a monotone function cyclically monotone? Theor. Econ. 16, 853–879 (2021). https://doi.org/10.3982/TE4305  
   
  The Polyhedral Geometry of Truthful Auctions  
   
  245  
   
  28. Lin, B., Tran, N.M.: Two-player incentive compatible outcome functions are aﬃne maximizers. Linear Algebra Its Appl. 578, 133–152 (2019). https://doi.org/10. 1016/j.laa.2019.04.027 29. Maclagan, D., Sturmfels, B.: Introduction to tropical geometry, Graduate Studies in Mathematics, vol. 161. American Mathematical Society, Providence, RI (2015) 30. Mishra, D., Pramanik, A., Roy, S.: Multidimensional mechanism design in single peaked type spaces. J. Econ. Theory 153, 103–116 (2014). https://doi.org/10. 1016/j.jet.2014.06.002 31. Nisan, N., Ronen, A.: Algorithmic mechanism design. Games Econ. Behav. 35(1), 166–196 (2001). https://doi.org/10.1006/game.1999.0790 32. Nisan, N., Roughgarden, T., Tardos, E., Vazirani, V.V.: Algorithmic game theory. Cambridge University Press, USA (2007). https://doi.org/10.1017/ CBO9780511800481 33. Pournin, L.: The ﬂip-graph of the 4-dimensional cube is connected. Discrete Comput. Geometry 49(3), 511–530 (2013). https://doi.org/10.1007/s00454-013-9488y 34. Roberts, K.: The characterization of implementable choice rules. Aggregation and Revelation of Preferences, pp. 321–349 (1979) 35. Rochet, J.C.: A necessary and suﬃcient condition for rationalizability in a quasilinear context. J. Math. Econ. 16(2), 191–200 (1987). https://doi.org/10.1016/ 0304-4068(87)90007-3 36. Saks, M.E., Yu, L.: Weak monotonicity suﬃces for truthfulness on convex domains. In: Riedl, J., Kearns, M.J., Reiter, M.K. (eds.) Proceedings of the 6th ACM Conference on Electronic Commerce (EC), pp. 286–293 (2005). https://doi.org/10.1145/ 1064009.1064040 37. Tran, N.M., Yu, J.: Product-mix auctions and tropical geometry. Math. Oper. Res. 44(4), 1396–1411 (2019). https://doi.org/10.1287/moor.2018.0975 38. Vickrey, W.: Counterspeculation, auctions, and competitive sealed tenders. J. Finance 16, 8–37 (1961). https://doi.org/10.1111/j.1540-6261.1961.tb02789.x 39. Vidali, A.: The geometry of truthfulness. In: Leonardi, S. (ed.) Proceedings of the 5th International Workshop on Internet and Network Economics (WINE), pp. 340–350 (2009). https://doi.org/10.1007/978-3-642-10841-9_31 40. Vohra, R.V.: Mechanism design. A Linear Programming Approach, Econometric Society Monographs, vol. 47. Cambridge University Press, Cambridge (2011). https://doi.org/10.1017/CBO9780511835216 41. de Vries, S., Vohra, R.V.: Combinatorial auctions: a survey. INFORMS J. Comput. 15, 284–309 (2003). https://doi.org/10.1287/ijoc.15.3.284.16077  
   
  Competitive Kill-and-Restart and Preemptive Strategies for Non-clairvoyant Scheduling Sven Jäger1 , Guillaume Sagnol2(B) , Daniel Schmidt genannt Waldschmidt2 , and Philipp Warode3 1  
   
  RPTU Kaiserslautern-Landau, Paul-Ehrlich-Straße 14, 67663 Kaiserslautern, Germany [email protected]  2 TU Berlin, Straße des 17. Juni 136, 10623 Berlin, Germany {sagnol,dschmidt}@math.tu-berlin.de 3 HU Berlin, Unter den Linden 6, 10099 Berlin, Germany [email protected]   
   
  Abstract. We study kill-and-restart and preemptive strategies for the fundamental scheduling problem of minimizing the sum of weighted completion times on a single machine in the non-clairvoyant setting. First, we show a lower bound of 3 for any deterministic non-clairvoyant kill-andrestart strategy. Then, we give for any b > 1 a tight analysis for the natural b-scaling kill-and-restart strategy as well as for a randomized variant √ of it. In particular, we show a competitive ratio of (1 + 3 3) ≈ 6.197 for the deterministic and of ≈ 3.032 for the randomized strategy by making use of the largest eigenvalue of a Toeplitz matrix. In addition, we show that the preemptive Weighted Shortest Elapsed Time First (WSETF) rule is 2-competitive when jobs are released online, matching the lower bound for the unit weight case with trivial release dates for any nonclairvoyant algorithm. Furthermore, we prove performance guarantees smaller than 10 for adaptions of the b-scaling strategy to online release dates and unweighted jobs on identical parallel machines.  
   
  1  
   
  Introduction  
   
  Minimizing the total weighted completion time on a single processor is one of the most fundamental problems in the ﬁeld of machine scheduling. The input consists of n jobs with processing times p1 , . . . , pn and weights w1 , . . . , wn , and the task is  to sequence them in such a way that the sum of weighted complen wj Cj . tion times j=1 wj Cj is minimized. We denote this problem as 1 || Full version preprint: http://arxiv.org/abs/2211.02044. The research of the second, third and fourth authors was supported by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany’s Excellence Strategy — The Berlin Mathematics Research Center MATH+ (EXC-2046/1, project ID: 390685689). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 246–260, 2023. https://doi.org/10.1007/978-3-031-32726-1_18  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  247  
   
  Smith [29] showed in the 50’s that the optimal schedule is obtained by the Weighted Shortest Processing Time ﬁrst (WSPT) rule, i.e., jobs are sequenced in non-decreasing order of the ratio of their processing time and their weight. Reality does not always provide all information beforehand. Around 30 years ago, the non-clairvoyant model, in which the processing time of any job becomes known only upon its completion, was introduced for several scheduling problems [10,25,27]. It is easy to see that no non-preemptive non-clairvoyant algo rithm can be constant-competitive for 1 || Cj . In their seminal work, Motwani et al. [25] proved for this problem that allowing preemption breaks the nonconstant barrier. Speciﬁcally, they showed that the round-robin algorithm is 2-competitive, matching a lower bound for all non-clairvoyant algorithms. This opened up a new research direction, leading to constant-competitive preemptive non-clairvoyant algorithms in more general settings, like weighted jobs [21], multiple machines [6,15,16], precedence constraints [11], and non-trivial release dates. When jobs are released over time, they are assumed to be unknown before their arrivals (online scheduling). No lower bound better than 2 is known for this case, whereas the best known upper bound before this work was 3, see e.g. [23]. But there is a downside of the preemptive paradigm as it uses an unlimited number of interruptions at no cost and has a huge memory requirement to maintain the ability to resume all interrupted jobs. Therefore, we continue by studying the natural class of kill-and-restart strategies that—inspired by computer processes—can abort the execution of a job (kill), but when processed again later, the job has to be re-executed from the beginning (restart). It can be considered as an intermediate category of algorithms between preemptive and non-preemptive ones, as on the one hand jobs may be interrupted, and on the other hand all completed jobs have been processed as a whole. Hence, by removing all aborted executions one obtains a non-preemptive schedule. This class of algorithms has already been investigated since the 90’s [27], but to the best of our knowledge, the competitive ratio of non-clairvoyant kill-and-restart strategies for the total completion time objective has never been studied. Our Contribution. We start by strengthening the preemptive lower bound of 2 for the kill-and-restart model.  Theorem 1. For 1 || Cj , no deterministic non-clairvoyant kill-and-restart 2 on instances with strategy can achieve a competitive ratio smaller than 3 − n+1 n ≥ 3 jobs, even if every job j has processing time pj ≥ 1. The main part of this work is devoted to the natural b-scaling strategy Db that repeatedly probes each unﬁnished job for the time of some integer power of b > 1 multiplied by its weight. While the fact that D2 is 8-competitive can easily be concluded from the 2-competitiveness of the weighted round-robin algorithm [21], a tight analysis requires more involved techniques. 3/2    wj Cj . Moreover, Theorem 2. For b > 1, Db is 1+ 2b b−1 -competitive for 1 || for all b > 1 this bound is tight, even for unit weight instances. In particular, for √ b = 3 the competitive ratio is 1 + 3 3 ≈ 6.196.  
   
  248  
   
  S. Jäger et al.  
   
  Our main technique is to reduce the problem of ﬁnding the exact competitive ratio to the computation of the largest eigenvalue of a tridiagonal Toeplitz matrix. Subsequently, we obtain a signiﬁcantly better exact competitive ratio for a randomized version Rb of the b-scaling strategy. √  Theorem 3. For every b > 1, Rb is √b+2b−1 -competitive for 1 || wj Cj . b log(b) Moreover, for all b > 1 this bound is tight, even for unit weight instances. In particular, for b ≈ 8.16 the competitive ratio is ≈ 3.032. The analysis mimics that of the deterministic strategy, but it is necessary to group jobs with similar Smith ratios. This approach leads to the computation of the largest eigenvalues of a sequence of banded symmetric Toeplitz matrices, and the result is obtained by taking its limit. We then study more general scheduling environments. For the  online problem wj Cj , we close in which jobs are released over time, denoted by 1 | rj , pmtn | the gap for the best competitive ratio of preemptive algorithms by analyzing the Weighted Shortest Elapsed Time First rule (WSETF). This algorithm runs at every point in time the job(s) with minimum ratio of elapsed processing time over weight.  wj Cj . Theorem 4. WSETF is 2-competitive for 1 | rj , pmtn | Theorem 4 generalizes the known 2-competitiveness for trivial release dates shown by Kim and Chwa [21]. It also matches the performance guarantee of the best known stochastic online scheduling policy, called F-GIPP [24], for the stochastic variant of the problem, where the probability distributions of the processing times are given at the release dates and the expected objective value is to be minimized. Our improvement upon the analysis of this policy, applied to a single machine, is threefold: First, our strategy does not require any information about the distributions of the processing times, second, we compare to the clairvoyant optimum, while F-GIPP is compared to the optimal non-anticipatory policy, and third, WSETF is more intuitive and easier to implement in applications than the F-GIPP policy. Using Theorem 4, we then give an upper bound on the competitive ratio of a generalized version of Db for jobs arriving online over time.  2b4 Theorem 5. Db is 2b2 −3b+1 -competitive for 1 | rj | wj Cj . In particular, for √ 9+ 17 , 8  
   
  √ 107+51 17 32  
   
  ≈ 9.915.  Finally, we also analyze the unweighted problem P || Cj on multiple identical parallel machines.  2 −b Theorem 6. Db is 3bb−1 -competitive for P || Cj . In particular, for b = √ √ 3+ 6 3 , its performance guarantee is 5 + 2 6 ≈ 9.899.  
   
  b=  
   
  its performance guarantee is  
   
  The proofs of these results are sketched in Sect. 3 to 6 below; full proofs are provided in the preprint [17].  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  249  
   
  Related Work. The clairvoyant oﬄine variants of all scheduling problems considered in this paper are well understood; either there is a polynomialtime algorithm [8,29], or the problem is strongly NP-hard [22,26] and there is a polynomial-time approximation scheme [1]. In the clairvoyant online model, where the processing times become known at the jobs’ release dates, there is a 1.566-competitive deterministic algorithm [28] and a deterministic lower bound of 1.073 [9], when preemption is allowed. For non-preemptive online scheduling the best possible deterministic competitive ratio is exactly 2. [2,14]. In the non-clairvoyant setting no (randomized) non-preemptive algorithm is constant-competitive, so that allowing preemption is crucial. Motwani et al. [25] showed that the simple (non-clairvoyant) round-robin procedure has a competitive ratio of 2 for minimizing the total completion time on identical machines. A weighted variant was presented for a single machine by Kim and Chwa [21] and for identical machines by Beaumont et al. [6]. In the context of non-clairvoyant online scheduling one distinguishes between total (weighted) completion time and total (weighted) ﬂow time. For weighted ﬂow time constant competitiveness is unattainable [25]. Besides work on non-constant competitiveness [7], the problem has been primarily studied in the resource augmentation model [18]. Kim and Chwa and Bansal and Dhamdhere [4] independently showed that WSETF is (1 + ε)-speed (1 + 1/ε)-competitive for weighted ﬂow time on a single machine, entailing a 4-competitive algorithm without speed augmentation for weighted completion time [5]. The proof technique used is, however, not suitable for obtaining better bounds for the weighted completion time objective. For unrelated machines there is a (1 + ε)-speed O(1/ε2 )-competitive algorithm [16]. Shmoys et al. [27] introduced the kill-and-restart model in the context of makespan minimization. We are not aware of any work for the total completion time objective in the non-clairvoyant model. However, for the clairvoyant online model, lower bounds on the competitive ratio of kill-and-restart strategies have been obtained [9,31], and van Stee and La Poutré [30] developed a 3/2-competitive strategy for a single machine, beating the aforementioned best competitive ratio of 2 for non-preemptive algorithms. Motwani et al. also considered preemptive scheduling with a limited number of allowed preemptions, for which they devised algorithms similar to the kill-and-restart strategies presented in this paper. The kill-and-restart model also shares many similarities with optimal search problems, in particular the w-lanes cow-path problem. For w = 2, deterministic and randomized strategies achieving the best possible competitive ratio are studied in [3,20], respectively. This work has been extended by Kao et al. [19] to the general case w ∈ N.  
   
  2  
   
  Preliminaries  
   
  We consider the machine scheduling problem of minimizing the weighted sum of completion times on a single machine ( 1 || wj Cj ). Formally, an instance I = (p, w) consists of a vector of processing times p = (pj )nj=1 and a vector  
   
  250  
   
  S. Jäger et al.  
   
  of weights w = (wj )nj=1 . Sequencing jobs in WSPT order, i.e., ordered nondecreasingly by their Smith ratios pj /wj , yields an optimal schedule, denoted by OPT(I). We also denote its objective value by OPT(I). The focus of our work lies on the analysis of non-clairvoyant strategies. We call a strategy non-clairvoyant if it does not use information on the processing time pj of a job j before j has been completed. A deterministic strategy D is said to be c-competitive if, for all instances I = (p, w), D(I) ≤ c · OPT(I), where D(I) denotes the cost of the strategy D for instance I. The competitive ratio of D is deﬁned as the inﬁmum over all c such that D is c-competitive. Similarly, a randomized strategy R, is said to be c-competitive if, for all instances I = (p, w), E[R(I)] ≤ c · OPT(I), where E[·] denotes the expected value. The following proposition suggests to consider strategies beyond non-preemptive ones. Proposition 1. No randomized non-preemptive non-clairvoyant strategy has a  constant competitive ratio for 1 || Cj . Proof sketch. Consider n − 1 unit jobs and one job of length n2 , randomize uniformly over all permutations, and use Yao’s principle [32].   Due to this negative result, we study non-clairvoyant kill-and-restart strategies for 1 || wj Cj that may abort the processing of a job, but when it is processed again later, it has to be executed from the beginning. Such a strategy performs probings (t, j, τ ), i.e., it processes at time t job j for a time of min{τ, pj }. More formally, for a given state consisting of the current time, the set of unﬁnished jobs and lower bounds on the processing times learned from past probings, a kill-and-restart strategy decides on a family of probings (ti , ji , τi )i∈I , such that the intervals (ti , ti + τi ), i ∈ I, are disjoint. Whenever a job is completed, i.e., a job is processed completely within one probing, the strategy decides on new probings. We require that probings be chosen independently of the actual processing times of unﬁnished jobs, ensuring that kill-and-restart strategies are non-clairvoyant. A formal deﬁnition is given in the full version. Observe that such strategies may not be implementable, e.g., on a Turing machine, as the above deﬁnition allows for an inﬁnite number of probings in a bounded time range. This subtlety is in fact inherent to all scheduling problems with unknown processing times or search problems with unknown distances. It is not hard to see that no deterministic kill-and-start strategy can be constantcompetitive without inﬁnitesimal probing, as there is no lower bound on the processing times at time 0. On the other hand, inﬁnitesimal probing can be avoided if we know a lower bound on the pj ’s, thus turning the strategies analyzed in this paper into implementable algorithms. We denote by YjD (I, t) the total time for which the machine has been busy processing job j until time t in the schedule constructed by the strategy D on the instance I.  
   
  3  
   
  Lower Bound  
   
  In contrast to the lower bound of 2 for preemptive algorithms by Motwani et al. [25], we prove a higher lower bound for kill-and-restart strategies.  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  251  
   
   Theorem 1. For 1 || Cj , no deterministic non-clairvoyant kill-and-restart 2 on instances with strategy can achieve a competitive ratio smaller than 3 − n+1 n ≥ 3 jobs, even if every job j has processing time pj ≥ 1. 2  
   
  +n) 2 Proof. Let ε ∈ ( n+1 , 1] and deﬁne T := (2−ε)(n ε(n+1)−2 . Consider an arbitrary deterministic kill-and-restart strategy  D with the initially chosen family of probings (ti , ji , τi )i∈I . Let Yj (θ) := i∈I:ti 1 is simple and quite natural: it proceeds by rounds q ∈ Z. In round q every non-completed job j is probed (once) for wj bq , in the order of job indices. To execute Db , we can store for each job its rank at time t, i.e., the largest q such that it was probed for wj bq−1 until t. At any end of a probing, Db probes the job j with minimum rank q and minimum index for time wj bq . We also introduce a randomized variant Rb of the strategy Db . Randomization occurs in two places: First the jobs are reordered according to a permutation Σ drawn uniformly at random from Sn at the beginning. Second, we replace the probing time wj bq of the qth round by wj bq+Ξ with a random uniform oﬀset Ξ ∼ U([0, 1]). In general, Db starts with inﬁnitesimally small probings at time 0 in rounds q → −∞. As discussed earlier, this is not implementable. However, if a lower bound of wj bqmin on every processing time pj is known, the algorithm can start with round q = qmin . 4.1  
   
  The Deterministic b-scaling Strategy  
   
   wj Cj . For an We compute tight bounds for the competitive ratio of Db for 1 || instance I := (p, w), we denote by sj := pj /wj the Smith ratio of job j ∈ [n] and  
   
  252  
   
  S. Jäger et al.  
   
  by Djk := YjDb (I, CkDb (I)) the amount of time spent probing job j before the completion of job k. For all j, k ∈ [n] we deﬁne the weighted mutual delay Δjk by Δjk := wk Djk + wj Dkj if j = k and Δjj := wj Djj . Thus, it holds Db (I) =  
   
  n  j=1  
   
  wj CjDb (I)  
   
  =  
   
  n  j=1  
   
  wj  
   
  n   
   
  Dkj =  
   
  k=1  
   
    
   
  Δjk .  
   
  1≤j≤k≤n  
   
  We ﬁrst provide an overestimator of Δjk that is piecewise linear in sj and sk . Lemma 1. Define the function F : {(s, s ) ∈ R2>0 : s ≤ s } → R by  log s+1 b 2b + s if logb (s) = logb (s ) b−1 F (s, s ) := 2 logb s +1 b · ( b−1 + 1) + s otherwise. Then for all j, k ∈ [n] such that sj ≤ sk , it holds Δjk ≤ wj wk F (sj , sk ). Proof sketch. Let qj := logb (sj )−1, so that bqj < sj ≤ bqj +1 . By distinguishing between the case where jobs j, k complete in the same round, i.e., logb (sj ) = logb (sk ), and the case where k completes in a later round, we obtain an upper bound of the form Δjk ≤ wj wk F˜ (sj , sk ), where F˜ is deﬁned as F except that all occurrences of ﬂoor operations logb (s), s ∈ {sj , sk } are replaced by logb (s) − 1. The result follows by observing that F˜ is non-decreasing with respect to both its arguments and taking its upper semi-continuous envelope.   Summing the bounds of the previous lemma yields    wj wk F min(sj , sk )), max(sj , sk ) =: U (p, w). Db (p, w) ≤  
   
  (1)  
   
  1≤j≤k≤n  
   
  We next prove a lemma showing that for bounding the ratio U/OPT we can restrict to instances in which all Smith ratios are integer powers of b. Lemma 2. For any instance (p, w), there exists another instance (p , w) with pj = wj bqj for some qj ∈ Z, for all j ∈ [n], such that U (p, w) U (p , w) ≤ . OPT(p, w) OPT(p , w) Proof sketch. Let Q := {logb (sj ) : j ∈ [n]} \ Z. We construct the vector p by sequentially rounding the Smith ratios of a subset of jobs Jq = {j ∈ [n] : sj = bq } with q := min Q to a larger or a smaller value, in such a way that the ratio U/OPT does not decrease, and we repeat this until Q = ∅. Speciﬁcally, for δ ∈ R we deﬁne the modiﬁed processing times pj (δ) = pj + wj δ1Jq (j). Both δ → U (p(δ), w) and δ → OPT(p(δ), w) are linear in a neighborhood of 0 in which the order of the Smith ratios does not change and no job changes the round U (p(δ),w ) where it completes. Thus, δ → OPT(p(δ),w ) is a monotone rational function in this neighborhood, so δ can be increased or decreased to a value such that |Q| is decremented by 1, without decreasing our bound on the competitive ratio.    
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  253  
   
  The next lemma gives a handy upper bound for the competitive ratio of Db relying on the ratio of two quadratic forms.   Lemma 3. For every L ∈ N, let AL := 12 bmin(i,j)−1 · 1{i=j} 1≤i,j≤L and  1 min(i,j)−1  BL := 2 b be symmetric matrices. For any instances (p, w) 1≤i,j≤L  
   
  there exists an integer L and a vector x ∈ RL ≥0 such that  
   
  2b x AL x Db (p, w) ≤ +1+b· . OPT(p, w) b−1 x BL x Proof sketch. Let i0 ∈ Z and L ∈ N be such that the Smith ratio of each job is of the form bi0 −1+ for some ∈ [L] in the instance (p , w) from Lemma 2. Let J i0 −1+ be the subset of jobs with Smith ratio , for ∈ [L], and deﬁne the  equal to b  L vectors x, y ∈ R such that x = j∈J wj and y = j∈J wj2 , respectively. We 2b +1)·OPT(p , w)+ show that OPT(p , w) ≥ bi0 x BL x and that U (p , w) = ( b−1 i0 +1 b x AL x. Then, the result follows from (1) and Lemma 2.   In order to determine an upper bound for the competitive ratio of Db , we need to bound the ratio of the two quadratic forms in the bound of Lemma 3. To this end, we bound the maximum eigenvalue of the matrix ZL := YL− AL YL−1 , where YL YL = BL is the Cholesky decomposition of the matrix BL . An explicit computation of the matrix ZL reveals that it is tridiagonal. In particular, the principal submatrix of ZL obtained by deleting the ﬁrst row and ﬁrst column is a tridiagonal Toeplitz matrix, which we refer to as TL−1 . 3/2    wj Cj . Moreover, Theorem 2. For b > 1, Db is 1+ 2b b−1 -competitive for 1 || for all b > 1 this bound is tight, even for unit weight instances. In particular, for √ b = 3 the competitive ratio is 1 + 3 3 ≈ 6.196.   
   
  Lx Proof sketch. Due to Lemma 3, it only remains to bound ρL := supx∈RL xx  A . B Lx As described above, we can express ρL as the largest eigenvalue of the matrix ZL , whose principal submatrix TL−1 √is a tridiagonal Toeplitz matrix. This has −2/(b−1) on the main diagonal and b/(b−1) on both adjacent diagonals. We show value as the largest eigenthat the largest eigenvalue of ZL converges to the same √ √ −2 π L→∞ −2 + 2b−1b · cos L −−−−→ b−1 + 2b−1b . value of TL−1 , which has the closed form b−1 3/2   Therefore, we obtain by Lemma 3 that Db is 1 + 2b b−1 -competitive. This ratio is minimized for b = 3, yielding the desired bound. For the tightness part, we deﬁne the vector xL ∈ RL ≥0 by  
   
  −1  
   
  xL, = 2(Lb  
   
  and show that  
   
  −1/2  
   
  (b − 1))  
   
  x L A L xL x L B LxL  
   
   · max 0,  
   
  √  
   
  converges to  
   
  b · sin  
   
   ( − 1)π  
   
  √ 2( b−1) b−1  
   
  L  
   
  − sin  
   
   π  
   
  L  
   
  , ∀ ∈ [L],  
   
  as L → ∞. The above formula  
   
  was obtained by transforming the eigenvector belonging to λmax (TL−1 ). Then, for t > 0 and ε > 0 we construct an instance with nL, = t · xL,  jobs of unit  
   
  254  
   
  S. Jäger et al.  
   
  weight and processing times equal to b +ε, for = 1, . . . , L, ordered in such a way that in each round, the jobs that ﬁnish are executed after all failed probings. A careful analysis of the weighted mutual delays Δjk shows that Db /OPT = 2b b−1  
   
  +b·  
   
   n L A L n L +a L n L  n L B L n L +b L n L  
   
  + oε→0 (1) for some vectors aL , bL ∈ RL . Finally, the  
   
  result follows by letting ε → 0 and t → ∞ and using nL = t(xL + ot→∞ (1)).   4.2  
   
  The Randomized b-scaling Strategy  
   
  We now consider the randomized variant Rb of the strategy Db , in which jobs are ordered according to a random permutation Σ and probed for wj bq+Ξ in round q ∈ Z, with Ξ ∼ U([0, 1]). As in the analysis of the deterministic strategy, we start with a lemma giving an overestimator of Δjk for jobs j and k such that sj ≤ sk . This time, our overestimator is not piecewise linear in sj and sk anymore, but depends on a concave function applied to the ratio sskj ≥ 1. The next lemma follows from standard calculations involving integrals of the form β ξ β −bα b dξ = b log b and case distinctions on the rounds in which j and k complete. α 2 Lemma 4. Let f (α) := 1+α 2 + log b + j = k such that sj ≤ sk it holds  
   
  α−1 2 log b  
   
  · (1 − log(α)) for α ∈ [1, b]. For all  
   
     s  
   
  1 k E[Δjj ] = wj2 sj · 1+ ≤ wj2 sj ·f (1) and E[Δjk ] = wj wk sj ·f min b, . log b sj The diﬃculty of proving the main result of this subsection resides in the fact that we cannot reduce to a worst-case instance in which all Smith ratios are integer powers of b. Instead, we push the technique used for Theorem 2 to the limit, by partitioning the set of jobs according to the interval of the form [bi/K , b(i+1)/K ) containing their Smith ratio, and letting K → ∞. This leads to the analysis of a Toeplitz matrix which is not tridiagonal anymore but has a bandwitdth of 2K − 1. While the maximum eigenvalue of this matrix does not have a closed-form expression for K > 1, its limit for L → ∞ can be computed using the Fourier series associated with this matrix. √  -competitive for 1 || wj Cj . Theorem 4. For every b > 1, Rb is √b+2b−1 b log(b) Moreover, for all b > 1 this bound is tight, even for unit weight instances. In particular, for b ≈ 8.16 the competitive ratio is ≈ 3.032. Proof sketch. For K ∈ N, let β = b1/K . We group the set of all jobs into sets Jk = {j ∈ [n] : β k ≤ sj < β k+1 } for all k ∈ Z. Using Lemma 4 and calculations similar to those used in the proof of Theorem 2, we show that   Rb (p, w) ≤ β f (β) + λmax (Z) , OPT(p, w) K−1 i+1 where Z := ) − f (β i ))Zi and Zi is a sparse symmetric matrix i=1 (f (β having non-zero entries only on its ±ith and ±(i − 1)th superdiagonals for all  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  255  
   
  i ∈ [K − 1]. The principal submatrix of Z obtained by removing its ﬁrst row and column is a Toeplitz matrix T of size L × L. Then,√ we show by using a when both L Schur complement that the above bound is smaller than √b+2b−1 b log(b) and K grow to ∞, with L/K → ∞. To construct a matching lower bound on the competitive ratio, we have to use an approximate eigenvector zˆ ∈ RL of T π −1/2 sin L+1 because no closed form is available if K > 1. We set z := ( L+1 2 ) L→∞  
   
  ˆ z ˆ 2 −−−−→ λmax (T ) by using the Fourier series for ∈ [L] and show that zˆ T z/ associated with T . The rest of the proof mimics the steps used in in Theorem 2,   where b is replaced by β = b1/K and we let K → ∞.  
   
  5  
   
  Weighted Shortest Elapsed Time First  
   
  In this we consider the online time model, where each job j arrives at its release date rj and is not known before that time. Thus, an instance for our problem is now given by a triple I = (p, w, r) of processing times, weights, and release dates of all jobs. Intuitively, the classical Weighted Shortest Elapsed Time First (WSETF) rule is the limit for ε → 0 of the algorithm that divides the time into time slices of length ε and in each time slice processes a job with minimum ratio of elapsed processing time over weight. To formalize this limit process we allow fractional schedulesS that, at every point in time t, assign each job j a n rate yjS (t) ∈ [0, 1] so that j=1 yjS (t) ≤ 1 for all t ∈ R≥0 and yjS (t) = 0 if t < rj or t t > CjS (I), where CjS (I) is the smallest t such that YjS (I, t) := 0 yjS (s) ds ≥ pj . At any time t let J(t) be the set of all released and unﬁnished jobs, and let A(t) be the set of all jobs from J(t) that currently have minimum ratio of elapsed time over weight.  Then WSETF sets the rate for all jobs j ∈ A(t) to yjWSETF (t) := wj / k∈A(t) wk and to 0 for all other jobs. In other words, WSETF always distributes the available processor rate among the jobs in J(t) so as to maximize minj∈J(t) YjWSETF (I, t)/wj . The following gives the tight competitive ratio of WSETF for non-clairvoyant online scheduling on a single machine.  Theorem 5. WSETF is 2-competitive for 1 | rj , pmtn | wj Cj . Proof sketch. To bound the optimal objective value from below, we consider the ∞ mean busy times MjS (I) := 0 t · yjS (t) dt of all jobs j in the optimal schedule. It is well known [12,13] that the the sum of weighted mean busy times is minimized by the Preemptive WSPT (PWSPT) rule, which always processes an available job with smallest index nratio pj /wj ). Therefore, it n (i.e. with smallest Smith suﬃces to show that j=1 wj · CjWSETF (I) ≤ 2 · j=1 wj · MjPWSPT (I). For instances I0 with trivial release dates, the weighted delay of each job in the WSETF schedule compared to the optimal WSPT schedule is exactly its processing time multiplied with the total weight of jobs with larger indices, or  
   
  256  
   
  S. Jäger et al.  
   
  in other words, its weighted completion time is n   
   
  wj · CjWSETF (I0 ) = wj · CjWSPT (I0 ) +  
   
  wk · pj  
   
  (2)  
   
  k=j+1  
   
    
   
  = wj · MjWSPT (I0 ) +  
   
  n  wj + wk · pj . 2 k=j+1  
   
    (∗)  
   
  In order to extend this observation to instances I with release dates, we deﬁne for each job j an auxiliary instance I(j) with trivial release dates and relate the completion times of j in the WSETF and PWSPT schedules for I to the completion times in the corresponding schedules for I(j). We then bound the diﬀerence wj (CjWSETF (I) − MjPWSPT (I)) by an expression generalizing (∗). To this end, we apply (Eq. 2) to the instance I(j) and use the fact that each deviation of the PWSPT schedule from the WSPT schedule for the instance without release dates increases the total weighted mean busy time. Finally, we show that the sum of the obtained bounds over all jobs is equal to the sum of weighted mean busy times in the PWSPT schedule.    
   
  6  
   
  Upper Bounds for More General Settings  
   
  In this section, we give  upper bounds on  the competitive ratio of the b-scaling wj Cj and P || Cj . Let I = (p, w, r, m) denote an strategy for 1 | rj | instance on m identical parallel machines in which each job j has processing time pj , weight wj and release date rj . The overall idea is to compare the schedule of Db to schedules of WSETF and round-robin (RR) for the release date and the parallel machine case, respectively, since, by Theorem 4 and [25], both strategies are 2-competitive. To this end, we need to consider modiﬁed instances with increased processing times and release dates. The following straightforward lemma bounds the increase of the optimal costs under these modiﬁcations. Lemma 5. Let I = (p, w, r, m) and I  = (p , w, r  , m) be two instances with p ≤ αp and r  ≤ αr. Then, we have OPT(I  ) ≤ α · OPT(I).  wj Cj we extend Db as follows: At the end of a probing, probe For 1 | rj | the job with minimum rank and index that is released and not completed.  2b4 -competitive for 1 | rj | wj Cj . In particular, for Theorem 5. Db is 2b2 −3b+1 √ 9+ 17 , 8  
   
  √  
   
  17 its performance guarantee is 107+51 ≈ 9.915. 32 We prove a slightly stronger result by bounding the ratio of Db (I) to the cost of an optimal preemptive schedule for I.  
   
  b=  
   
  Proof sketch. Let I = (p, w, r, 1) be an arbitrary instance. As a ﬁrst step we construct an auxiliary instance I  = (p , w, r  , 1) as follows: We deﬁne processing times pj ≤ pj ≤ bpj such that pj /wj = bqj with qj = logb (pj /wj ), i.e., all  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  257  
   
  Smith ratios in the instance I  are integer powers of b. Further, we deﬁne new release dates rj ≥ rj by either setting rj to the end of the probing that runs at rj in the schedule of I  , whenever such a probing exists, or rj = rj otherwise. By construction, we have rj ≤  
   
  b3 2b−1 rj  
   
  and pj ≤ bpj ≤   
   
  b3 2b−1 pj  
   
  for any job j.  
   
  b3 2b−1 OPT(I).  
   
  Moreover, we obtain Therefore, by Lemma 5, we have OPT(I ) ≤ Db (I) ≤ Db (I  ), as the sequence of probings in both schedules is the same and the processing times in I  are longer. Next, we consider another instance I  = (p , w, r  , 1) with processing times qj qj +1 b bi = bb−1 = b−1 pj . We show inductively that, pj := YjDb (I  , CjDb (I  )) = i=−∞ by construction, at any completion time of a job j in the schedule of WSETF for I  , all already released, not completed jobs with minimum rank qj were probed by Db for an amount of wj bqj . Therefore, by deﬁnition of I  and I  we have CjDb (I  ) ≤ CjWSETF (I  ) and hence, Db (I  ) ≤ WSETF(I  ). Altogether, we obtain Db (I) ≤ Db (I  ) ≤ WSETF(I  ) ≤ 2OPT(I  ) ≤  
   
  2b 2b4 OPT(I  ) ≤ 2 OPT(I), b−1 2b − 3b + 1  
   
  applying Lemma 5 a second time.    For P || Cj we extend Db as follows: probe each job for bq in a list scheduling manner. If at most m jobs remain, process each job on a distinct machine until completion, otherwise increase q by 1 and repeat. √  2 −b Theorem 6. Db is 3bb−1 -competitive for P || Cj . In particular, for b = 3+3 6 , √ its performance guarantee is 5 + 2 6 ≈ 9.899. Proof sketch. Let I = (p, 1, 0, m) be an instance and deﬁne a new instance I  = (p , 1, 0, m) with processing times pj = bqj where qj = logb pj . Note that pj ≤ bpj and Db (I) ≤ Db (I  ). For the schedule of Db on I  , let Ti (q) denote the point in time, when the last probing of length bq on machine i ends. Next, we deﬁne another instance I  = (p , 1, 0, m), where the processing times pj are deﬁned to be the exactly the elapsed time of j in the schedule of Db for I  at its completion time. We consider the schedule of RR on I  and denote by T  (q) the point in time where the elapsed time of all non-completed jobs is m q+1 1  exactly bb−1 . By induction, we show that T  (q) = m i=1 Ti (q). This identity  Db  RR  allows us to relate Cj (I ) and Cj (I ). In particular, we obtain j CjDb (I  ) ≤  RR   j Cj (I ) + pj . The 2-competitiveness of RR and Lemma 5 yield Db (I) ≤ Db (I  ) ≤ RR(I  ) +  
   
    
   
  pj ≤ 2OPT(I  ) + OPT(I  )  
   
  j  
   
   2b  2b + 1 OPT(I  ) ≤ + 1 · b · OPT(I). ≤ b−1 b−1    
   
  258  
   
  7  
   
  S. Jäger et al.  
   
  Conclusion  
   
  We studied kill-and-restart as well as preemptive strategies for the problem of minimizing the sum of weighted completion times and gave a tight analysis of the  deterministic and randomized version of the natural b-scaling strategy for  wj Cj . 1 || wj Cj as well as of WSETF for 1 | rj , pmtn | We hope that this work might lay a basis for obtaining tight bounds on the performance of the b-scaling strategy for more general settings such as nontrivial release dates and parallel machines. Moreover, we think that the class of kill-and-restart strategies combines the best of two worlds. On the one hand, they allow for interruptions leading to small competitive ratios in contrast to non-preemptive algorithms, on the other hand, they reﬂect the non-preemptive property of only completing a job if it has been processed as a whole. Acknowledgements. We thank Sungjin Im for helpful comments on an earlier version of this manuscript.  
   
  References 1. Afrati, F., et al.: Approximation schemes for minimizing average weighted completion time with release dates. In: 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp. 32–43. IEEE (1999). https://doi.org/10.1109/ SFFCS.1999.814574 2. Anderson, E.J., Potts, C.N.: Online scheduling of a single machine to minimize total weighted completion time. Math. Oper. Res. 29(3), 686–697 (2004). https:// doi.org/10.1287/moor.1040.0092 3. Baeza-Yates, R.A., Culberson, J.C., Rawlins, G.J.E.: Searching in the plane. Inf. Comput. 106(2), 234–252 (1993). https://doi.org/10.1006/inco.1993.1054 4. Bansal, N., Dhamdhere, K.: Minimizing weighted ﬂow time. ACM Trans. Algorithms 3(4), 39:1–39:14 (2007). https://doi.org/10.1145/1290672.1290676 5. Bansal, N., Pruhs, K.: Server scheduling in the weighted p -norm. In: FarachColton, Martín (ed.) LATIN 2004. LNCS, vol. 2976, pp. 434–443. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-24698-5_47 6. Beaumont, O., Bonichon, N., Eyraud-Dubois, L., Marchal, L.: Minimizing weighted mean completion time for malleable tasks scheduling. In: 26th International Symposium on Parallel and Distributed Processing (IPDPS), pp. 273–284. IEEE (2012). https://doi.org/10.1109/ipdps.2012.34 7. Becchetti, L., Leonardi, S.: Nonclairvoyant scheduling to minimize the total ﬂow time on single and parallel machines. J. ACM 51(4), 517–539 (2004). https://doi. org/10.1145/1008731.1008732 8. Conway, R.W., Maxwell, W.L., Miller, L.W.: Theory of Scheduling. AddisonWesley Publishing Company, Boston (1967) 9. Epstein, L., van Stee, R.: Lower bounds for on-line single-machine scheduling. Theor. Comput. Sci. 299(1), 439–450 (2003). https://doi.org/10.1016/S03043975(02)00488-7 10. Feldmann, A., Sgall, J., Teng, S.H.: Dynamic scheduling on parallel machines. Theor. Comput. Sci. 130(1), 49–72 (1994). https://doi.org/10.1016/03043975(94)90152-X  
   
  Competitive Kill-and-Restart and Preemptive Strategies  
   
  259  
   
  11. Garg, N., Gupta, A., Kumar, A., Singla, S.: Non-clairvoyant precedence constrained scheduling. In: Baier, C., Chatzigiannakis, I., Flocchini, P., Leonardi, S. (eds.) 46th International Colloquium on Automata, Languages, and Programming (ICALP). LIPIcs, vol. 132, pp. 63:1–63:14 (2019). https://doi.org/10.4230/LIPIcs.ICALP. 2019.63 12. Goemans, M.X.: A supermodular relaxation for scheduling with release dates. In: Cunningham, W.H., McCormick, S.T., Queyranne, M. (eds.) IPCO 1996. LNCS, vol. 1084, pp. 288–300. Springer, Heidelberg (1996). https://doi.org/10.1007/3540-61310-2_22 13. Goemans, M.X.: Improved approximation algorthims for scheduling with release dates. In: Proceedings of the Eighth Annual ACM-SIAM Symposium Discrete Algorithms (SODA), pp. 591–598. SIAM (1997) 14. Hoogeveen, J.A., Vestjens, A.P.A.: Optimal on-line algorithms for single-machine scheduling. In: Cunningham, W.H., McCormick, S.T., Queyranne, M. (eds.) IPCO 1996. LNCS, vol. 1084, pp. 404–414. Springer, Heidelberg (1996). https://doi.org/ 10.1007/3-540-61310-2_30 15. Im, S., Kulkarni, J., Munagala, K.: Competitive algorithms from competitive equilibria: non-clairvoyant scheduling under polyhedral constraints. J. ACM 65(1), 1–33 (2017). https://doi.org/10.1145/3136754 16. Im, S., Kulkarni, J., Munagala, K., Pruhs, K.: SelﬁshMigrate: A scalable algorithm for non-clairvoyantly scheduling heterogeneous processors. In: 55th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp. 531–540 (2014). https://doi.org/10.1109/FOCS.2014.63 17. Jäger, S., Sagnol, G., Schmidt genannt Waldschmidt, D., Warode, P.: Competitive kill-and-restart and preemptive strategies for non-clairvoyant scheduling (2022). https://doi.org/10.48550/ARXIV.2211.02044 18. Kalyanasundaram, B., Pruhs, K.: Speed is as powerful as clairvoyance. J. ACM 47(4), 617–643 (2000). https://doi.org/10.1145/347476.347479 19. Kao, M.Y., Ma, Y., Sipser, M., Yin, Y.: Optimal constructions of hybrid algorithms. J. Alg. 29(1), 142–164 (1998). https://doi.org/10.1006/jagm.1998.0959 20. Kao, M.Y., Reif, J.H., Tate, S.R.: Searching in an unknown environment: an optimal randomized algorithm for the cow-path problem. Inf. Comput. 131(1), 63–79 (1996). https://doi.org/10.1006/inco.1996.0092 21. Kim, J., Chwa, K.: Non-clairvoyant scheduling for weighted ﬂow time. Inf. Process. Lett. 87(1), 31–37 (2003). https://doi.org/10.1016/S0020-0190(03)00231-X 22. Labetoulle, J., Lawler, E.L., Lenstra, J.K., Rinnooy Kan, A.H.G.: Preemptive scheduling of uniform machines subject to release dates. In: Pulleyblank, W.R. (ed.) Progress in Combinatorial Optimization, pp. 245–261. Academic Press (1984). https://doi.org/10.1016/B978-0-12-566780-7.50020-9 23. Lindermayr, A., Megow, N.: Permutation predictions for non-clairvoyant scheduling. In: Proceedings of the 34th Symposium on Parallelism in Algorithms and Architectures (SPAA), pp. 357–368 (2022). https://doi.org/10.1145/3490148. 3538579 24. Megow, N., Vredeveld, T.: A tight 2-approximation for preemptive stochastic scheduling. Math. Oper. Res. 39(4), 1297–1310 (2014). https://doi.org/10.1287/ moor.2014.0653 25. Motwani, R., Phillips, S., Torng, E.: Nonclairvoyant scheduling. Theor. Comput. Sci. 130(1), 17–47 (1994). https://doi.org/10.1016/0304-3975(94)90151-1 26. Rinnooy Kan, A.H.G.: Machine Scheduling Problems: Classiﬁcation, Complexity and Computations. Martinus Nijhoﬀ (1976). https://doi.org/10.1007/978-1-46134383-7  
   
  260  
   
  S. Jäger et al.  
   
  27. Shmoys, D.B., Wein, J., Williamson, D.P.: Scheduling parallel machines online. SIAM J. Comput. 24(6), 1313–1331 (1995). https://doi.org/10.1137/ S0097539793248317 28. Sitters, R.: Competitive analysis of preemptive single-machine scheduling. Oper. Res. Lett. 38(6), 585–588 (2010). https://doi.org/10.1016/j.orl.2010.08.012 29. Smith, W.E.: Various optimizers for single-stage production. Nav. Res. Logist. Q. 3(1–2), 59–66 (1956). https://doi.org/10.1002/nav.3800030106 30. van Stee, R., La Poutré, H.: Minimizing the total completion time on-line on a single machine, using restarts. J. Alg. 57(2), 95–129 (2005). https://doi.org/10. 1016/j.jalgor.2004.10.001 31. Vestjens, A.P.A.: On-line machine scheduling. Ph.D. thesis, Technische Universiteit Eindhoven (1997). https://doi.org/10.6100/IR500043, https://pure.tue.nl/ ws/ﬁles/1545064/500043.pdf 32. Yao, A.C.C.: Probabilistic computations: toward a uniﬁed measure of complexity. In: 18th Annual IEEE Symposium on Foundations of Computer Science (SFCS), pp. 222–227 (1977). https://doi.org/10.1109/SFCS.1977.24  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP Anna R. Karlin, Nathan Klein(B) , and Shayan Oveis Gharan University of Washington, Seattle, USA {karlin,nwklein,shayan}@cs.washington.edu  
   
  Abstract. We show that the max entropy algorithm can be derandomized (with respect to a particular objective function) to give a deterministic 3/2− approximation algorithm for metric TSP for some  > 10−36 . To obtain our result, we apply the method of conditional expectation to an objective function constructed in prior work which was used to certify that the expected cost of the algorithm is at most 3/2 −  times the cost of an optimal solution to the subtour elimination LP. The proof in this work involves showing that the expected value of this objective function can be computed in polynomial time (at all stages of the algorithm’s execution).  
   
  1  
   
  Introduction  
   
  One of the most fundamental problems in combinatorial optimization is the traveling salesperson problem (TSP), formalized as early as 1832 (c.f. [App+07, Ch 1]). In an instance of TSP we are given a set of n cities V along with their pairwise symmetric distances, c : V ×V → R≥0 . The goal is to ﬁnd a Hamiltonian cycle of minimum cost. In the metric TSP problem, which we study here, the distances satisfy the triangle inequality. Therefore, the problem is equivalent to ﬁnding a closed Eulerian connected walk of minimum cost. It is NP-hard to approximate TSP within a factor of 123 122 [KLS15]. An algorithm of Christoﬁdes-Serdyukov [Chr76,Ser78] from four decades ago gives a 3 2 -approximation for TSP. Over the years there have been numerous attempts to improve the Christoﬁdes-Serdyukov algorithm and exciting progress has been made for various special cases of metric TSP, e.g., [OSS11,MS11,Muc12,SV12, HNR21,KKO20,HN19,Gup+21]. Recently, [KKO21] gave the ﬁrst improvement for the general case by demonstrating that the so-called “max entropy” algorithm of the third author, Saberi, and Singh [OSS11] gives a randomized 32 −  approximation for some  > 10−36 . The method introduced in [KKO21] exploits the optimum solution to the following linear programming relaxation of metric TSP studied by [DFJ59,HK70, GB93], also known as the subtour elimination LP:  
   
  c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 261–274, 2023. https://doi.org/10.1007/978-3-031-32726-1_19  
   
  262  
   
  A. R. Karlin et al.  
   
  min  
   
    
   
  x{u,v} c(u, v)  
   
  u,v  
   
  s.t.,  
   
    
   
  x{u,v} = 2  
   
  ∀v ∈ V,  
   
  u  
   
    
   
  (1) x{u,v} ≥ 2,  
   
  ∀S  V, S = ∅  
   
  u∈S,v ∈S /  
   
  x{u,v} ≥ 0  
   
  ∀u, v ∈ V.  
   
  However, [KKO21] had two shortcomings. First, it did not show that the integrality gap of the subtour elimination polytope is bounded below 32 . Second, it was randomized, and the analysis in that work was by nature “non-constructive” in the sense that it used the optimal solution; thus it was not clear how to to derandomize it using the method of conditional expectation. Other methods of derandomization seem at the moment out of reach and may require algorithmic breakthroughs. A followup work, [KKO22], remedied the ﬁrst shortcoming by showing an improved integrality gap. While it did not address the question of derandomization, a byproduct of that work is an analysis of the max entropy algorithm which is in principle polynomially-time computable as it avoids looking at OPT. The purpose of the present work is to show that this analysis can indeed be done in polynomial-time, from which the following can be deduced (remedying the second shortcoming of [KKO21]): Theorem 1. Let x be a solution to LP (1) for a TSP instance. For some absolute constant  > 10−36 , there is a deterministic algorithm (in particular, a derandomized version of max entropy) which outputs a TSP tour with cost at most 32 −  times the cost of x. Thus, this work in some sense completes the exploratory program concerning whether the max entropy algorithm for TSP beats 3/2 (initiated by [OSS11] in 2011), as now the above two weaknesses of [KKO21] have been addressed. Of course, much work remains in determining the true approximation factor of the algorithm; in this regard we are only at the tip of the iceburg. Using the recent exciting work of Traub, Vygen, and Zenklusen reducing path TSP to TSP [TVZ20] our theorem also implies that there is a deterministic 32 −  approximation algorithm for path TSP. 1.1  
   
  High Level Proof Overview  
   
  The high level strategy for derandomizing the max entropy algorithm is to use the method of conditional expectation on an objective function given by the analysis in [KKO22]. The max entropy algorithm, similar to Christoﬁdes’ algorithm, ﬁrst selects a spanning tree and then adds a minimum cost matching on the odd vertices of the tree. While Christoﬁdes selects a minimum cost spanning tree, here the spanning tree is sampled from a distribution. In particular, after solving the natural LP  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  263  
   
  relaxation for the problem to obtain a fractional solution x, a tree is sampled from the distribution μ which has maximal entropy subject to the constraint PT ∼μ [e ∈ T ] = xe for all e ∈ E (with possibly some exponentially small error in these constraints). [KKO21,KKO22] construct a so-called “slack” vector which is used to show the expected cost of the matching (over the randomness of the trees) is at most 12 −  times the cost of an optimal solution to the LP. Given a solution x to LP (1) these works imply that there is a random vector m as a function of the tree T ∼ μ such that: (1) The cost of the minimum cost matching on the odd vertices of tree T is at most c(m) (with probability 1), and (2) ET ∼μ [c(m)] ≤ ( 12 − )c(x). Let C = ET ∼μ [c(T ) + c(m)]. This will be the objective function to which we will apply the method of conditional expectation. Since the expected cost of the tree T is c(x), as PT ∼μ [e ∈ T ] = xe , by (2) C is at most ( 32 − )c(x). Since by (1) for a given tree T , c(T ) + c(m) is an upper bound on the cost of the output of the algorithm (with probability 1), this shows that the expected cost of the algorithm is bounded strictly below 3/2. Ideally, one would like μ to have polynomial sized support. Then one could simply check the cost of the output of the algorithm on every tree in the support, and the above would guarantee that some tree gives a better-than-3/2 approximation. However, the max entropy distribution can have exponential sized support, and it’s not clear how to ﬁnd a similarly behaved distribution with polynomial sized support. Instead, let Tpartial be the family of all partial settings of the edges of the graph to 0 or 1 where the edges set to 1 are acyclic. For Set = {Xe1 , . . . , Xei } ∈ Tpartial , and 1 ≤ j ≤ i, we use Xej to indicate whether ej is set to 1 or 0. The method of conditional expectations is then used as follows: Process the edges in an arbitrary order e1 , . . . , em and for each edge ei : (1) Assume we inductively have chosen a valid assignment Set ∈ Tpartial to edges e1 , . . . , ei−1 . (2) Let Set+ = Set ∪ {Xei = 1}. Compute C + = ET ∼μ [c(T ) + c(m) | Set+ ]. Similarly, let Set− = Set ∪ {Xei = 0} and compute C − = ET ∼μ [c(T ) + c(m) | Set− ]. (3) Let Set ← Set+ or Set ← Set− depending on which quantity is smaller. After a tree is obtained, add the minimum cost matching on the odd vertices of T . The resulting algorithm is shown in Algorithm 3 (see Algorithm 2 for its instantiation in a simple case). As C ≤ ( 32 − )c(x), this algorithm succeeds with probability 1. We only need to show it can be made to run in polynomial time. Since we can compute the expected cost of the tree conditioned on Set using linearity of expectation and the matrix tree theorem (Sect. 2.2), it remains to show that ET ∼μ [c(m)|Set] can be computed deterministically and eﬃciently for any Set ∈ Tpartial . Key Contributions. The key contribution of this paper is to show how to do this computation eﬃciently, which is based on two observations:  
   
  264  
   
  A. R. Karlin et al.  
   
  (1) The ﬁrst is that the vector m (whose cost upper bounds the cost of the minimum cost matching on the odd vertices of the tree) can be written as the (weighted) sum of indicators of events that depend on the sampled tree T , and each of these events happens only when a constant number of (not necessarily disjoint) sets of edges have certain parities or certain sizes. (2) The second is that the probability of any such event can be deterministically computed in polynomial time by evaluating the generating polynomial of all spanning trees at certain points in CE , see Lemma 10. Structure of the Paper. After reviewing some preliminaries, in Sect. 3 we review the matrix tree theorem and show (as a warmup) how to compute the probability two (not necessarily disjoint) sets of edges both have an even number of edges in the sampled tree. In Sect. 4, we then give a complete description and proof of a deterministic algorithm for the special “degree cut” case of TSP. Unlike the subsequent sections of the paper, Sect. 4 is self-contained and thus directed towards readers looking for more high-level intuition or those not familiar with [KKO21,KKO22]. In Sect. 5 we show (2) from above and give the deterministic algorithm in the general case. The remainder of the paper then involves proving (1) for the general deﬁnition of m from [KKO21,KKO22].  
   
  2 2.1  
   
  Preliminaries Notation  
   
  For a set of edges A ⊆ E and (a tree) T ⊆ E, we write AT = |A ∩ T |. For a tree T , we will say a cut S ⊆ V is odd in T if δ(S)T is odd and even in T otherwise. If the tree is understood we will simply say even or odd. We use δ(S) = {{u, v} ∈ E : |{u, v} ∩ S| = 1} to denote the set of edges that leave S, and E(S) = {{u, v} ∈ E : |{u, v} ∩ S| = 2} to denote the set of edges inside of S.  For a set A ⊆ E and a vector x ∈ R|E| we write x(A) := e∈A xe . 2.2  
   
  Randomized Algorithm of [KKO21]  
   
  Let x0 be an optimum solution of LP (1). Without loss of generality we assume x0 has an edge e0 = {u0 , v0 } with x0e0 = 1, c(e0 ) = 0. (To justify this, consider the following process: given x0 , pick an arbitrary node, u, split it into two nodes u0 , v0 and set x{u0 ,v0 } = 1, c(e0 ) = 0 and assign half of every edge incident to u to u0 and the other half to v0 .) Let E0 = E ∪ {e0 } be the support of x0 and let x be x0 restricted to E and G = (V, E). By Lemma 1 x0 restricted to E is in the spanning tree polytope (2) of G. We write G = (V, E, x) to denote the (undirected) graph G together with special vertices u0 , v0 and the weight function x : E → R≥0 . Similarly, let G0 = (V, E0 , x0 ) and let G/e0 = G0 /{e0 }, i.e. G/e0 is the graph G0 with the edge e0 contracted.  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  265  
   
  Definition 1. For a vector λ : E → R≥0 , a λ-uniform distribution μλ over spanning trees of G = (V, E) is a distribution where for every spanning tree λe  . T ⊆ E, Pμλ [T ] =   e∈T  λe T  
   
  e∈T  
   
  Theorem 2 ([Asa+10]). Let z be a point in the spanning tree polytope (see (2)) of a graph G = (V, E). For any  > 0, a vector λ : E → R≥0 can be found such that the corresponding λ-uniform spanning tree distribution, μλ , satisfies  Pμλ [T ] ≤ (1 + ε)ze , ∀e ∈ E, T ∈T :T e  
   
  i.e., the marginals are approximately preserved. In the above T is the set of all spanning trees of (V, E). The algorithm is deterministic and running time is polynomial in n = |V |, − log mine∈E ze and log(1/). [KKO22] showed that the following (randomized) max entropy algorithm has expected cost of the output is at most ( 32 − )c(x). Algorithm 1. (Randomized) Max Entropy Algorithm for TSP Find an optimum solution x0 of Eq. (1), and let e0 = {u0 , v0 } be an edge with x0e0 = 1, c(e0 ) = 0. Let E0 = E ∪ {e0 } be the support of x0 and x be x0 restricted to E and G = (V, E). Find a vector λ : E → R≥0 such that for any e ∈ E, PT ∼μλ [e ∈ T ] = xe (1 ± 2−n ). Sample a tree T ∼ μλ . Let M be the minimum cost matching on odd degree vertices of T . Output T ∪ M .  
   
  2.3  
   
  Polyhedral Background  
   
  For any graph G = (V, E), Edmonds [Edm70] gave the following description for the convex hull of spanning trees of a graph G = (V, E), known as the spanning tree polytope. z(E) = |V | − 1,  
   
  z(E(S)) ≤ |S| − 1 ∀S ⊆ V,  
   
  ze ≥ 0 ∀e ∈ E.  
   
  (2)  
   
  Edmonds [Edm70] proved that the extreme point solutions of this polytope are the characteristic vectors of the spanning trees of G. Lemma 1 ([KKO21, Fact 2.1]). Let x0 be a feasible solution of (1) such that x0e0 = 1 with support E0 = E ∪ {e0 }. Let x be x0 restricted to E; then x is in the spanning tree polytope of G = (V, E). Since c(e0 ) = 0, the following fact is immediate. Lemma 2. Let G = (V, E, x) where x is in the spanning tree polytope. If μ is any distribution of spanning trees with marginals x then ET ∼μ [c(T ∪ e0 )] = c(x).  
   
  266  
   
  A. R. Karlin et al.  
   
  To bound the cost of the min-cost matching on the set O(T ) of odd degree vertices of the tree T , we use the following characterization of the O(T )-join polyhedron due to Edmonds and Johnson [EJ73]. Proposition 1. For any graph G = (V, E), cost function c : E → R+ , and a set O ⊆ V with an even number of vertices, the minimum weight of an O-join equals the optimum value of the following integral linear program. min c(y) y(δ(S)) ≥ 1  
   
  3  
   
  s.t. S ⊆ V, |S ∩ O| odd  
   
  ye ≥ 0 ∀e ∈ E  
   
  (3)  
   
  Computing Probabilities  
   
  The deterministic algorithm depends on the computation of various probabilities and conditional expectations. In this section (and additionally later in Sect. 5), we show to do these calculations eﬃciently. 3.1  
   
  Notation  
   
  Let BE be the set of all probability measures on the Boolean algebra 2|E| . Let μ ∈ BE . The generating polynomial gμ : R[{ze }e∈E ] of μ is deﬁned as follows:   gμ (z) := μ(S) ze . S  
   
  3.2  
   
  e∈S  
   
  Matrix Tree Theorem  
   
  Let G = (V, E) with |V | = n. For e = (u, v) we let Le = (1u − 1v )(1u − 1v )T be the Laplacian of e. Recall Kirchhoﬀ’s matrix tree theorem: Theorem 3 (Matrix  tree theorem). For a graph G = (V, E) let gT ∈ R[ze1 , . . . , zem ] = T ∈T z T be the generating polynomial of the spanning trees of G. Then, we have gT ({ze }e∈E ) =  
   
   1 det( ze Le + 11T /n). n e∈E  
   
   Given a vector λ ∈ R|E| and a set S ⊆ E, let λS := i∈S λi . Recall that the λ-uniform distribution μλ is the probability distribution over spanning trees where the probability of every tree T is λT . Then the generating polynomial of μλ is     1 λT z T = gT ({λe ze }e∈E ) = det ze λe Le + 11T /n gμλ (z) = n T ∈T  
   
  e∈E  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  267  
   
  and can be evaluated at any z ∈ CE eﬃciently using a determinant computation. Thus we can compute PT ∼μ [e ∈ T ] by computing the sum of the probabilities of trees in the graph G/{e}, i.e. the graph with e contracted, as follows:  / T] = 1 − λT PT ∼μ [e ∈ T ] = 1 − PT ∼μ [e ∈ T ∈T :e∈T /  
   
  where to compute the sum in the RHS we evaluate gμλ at ze = 0, zf = 1 for all f = e. Thus, Lemma 3. Given a λ-uniform distribution μλ over spanning trees, for every edge e, we can compute PT ∼μλ [e ∈ T ] in polynomial time. Given some Set ∈ Tpartial , we contract each edge e with Xe = 1 in Set and delete each edge e with Xe = 0 in Set. Let G be the resulting graph with n vertices, with corresponding λe ∝ λe for all e ∈ G normalized such that  T = 1. T  ∈G λ  T 1/n−1 Remark 1. A vector λ ∈ R|E| is normalized by setting λe = λe / T λ  1/n−1 i.e., λe = λe /gT ({λe }e∈E ) . Thus at the cost of another application of the matrix-tree theorem, we assume without loss of generality that we are always dealing with λ values that are normalized. Putting the previous facts together, we obtain Lemma 4. Given a λ-uniform distribution μλ and some Set ∈ Tpartial , we can compute a vector λ such that μλ = μλ|Set . 3.3  
   
  Computing Parities in a Simple Case  
   
  Lemma 5. Let A, B ⊆ E and μλ be a λ-uniform distribution over spanning trees. Then, we can compute PT ∼μλ [AT , BT even] in polynomial time. Proof. First observe that I {AT , BT even} =  
   
  1 (1 + (−1)AT + (−1)BT + (−1)((AB)∪(BA))T ) 4  
   
  One can easily check that if AT and BT are even, this is 1, and otherwise it is 0. To compute PT ∼μλ [A and B even in T ] it is enough to compute the expected value of this indicator. By linearity of expectation it is therefore enough to compute the expectation of (−1)FT for any set F ⊆ E. We can do this using Theorem 3. Setting zeF = −1 if e ∈ F and zeF = +1 otherwise, we exactly have:   
   
  (−1)FT λT = ET ∼μλ (−1)FT . gμλ (z F ) = T ∈T  
   
  The lemma follows.  
   
  268  
   
  A. R. Karlin et al.  
   
  Remark 2. We can use the same approach to compute PT ∼μλ [AT odd, BT even] or the probability that both are odd. All we need to do is to multiply (−1)AT with a −1 if AT needs to be odd (and similarly for BT ), and (−1)((AB)∪(BA))T with a −1 if we are looking for diﬀerent parities in AT , BT . Given some Set ∈ Tpartial , by Lemma 4 we can compute μλ = μλ|Set . Applying the above lemma to μλ , it follows (after appropriately updating the parities to account for edges set to 1 in Set): Corollary 1. Let A, B ⊆ E. We can compute PT ∼μ [A and B even in T | Set] in polynomial time.  
   
  4  
   
  A Deterministic Algorithm in the Degree Cut Case  
   
  As a warmup, in this section we show how to implement the deterministic algorithm for the so-called “degree cut case,” i.e., when for every set of vertices S with 2 ≤ |S| ≤ n − 2 we have x(δ(S)) ≥ 2 + η for some absolute constant η > 0. See Algorithm 2.  
   
  Algorithm 2 . A Deterministic Approximation Algorithm for Metric TSP in the Degree Cut Case 1: Given a solution x0 of the LP (1), with an edge e0 with xe0 = 1. 2: Let G be the support graph of x. 3: Find a vector λ : E → R≥0 such that for any e ∈ E, PT ∼μλ [e ∈ T ] = xe (1 ± 2−n ) (see Section 2.2). 4: Initialize Set := ∅ 5: while there exists e = e0 not set in Set do − 6: Let Set+ := Set ∪ {Xe = 1} and  let Set  := Set ∪ {Xe = 0};  + 7: if ET ∼μλ c(T ) + c(m) | Set ≤ ET ∼μλ c(T ) + c(m) | Set− (m from Deﬁnition 2) then 8: Set := Set+ ; 9: else 10: Set := Set− ; 11: end if 12: end while 13: Return T = {e : Xe = 1 in Set} together with min cost matching on odd degree vertices of T .  
   
  Construction of the Matching Vector. We describe a simple construction for the matching vector m : T → R|E| for the degree cut case. It will ensure that for a tree T , m is in the O(T )-Join polyhedron where O(T ) is the set of odd vertices of T (we emphasize that m is a function of T ). Therefore, c(m) is an upper bound on the cost of the minimum cost matching on the odd vertices of T as desired.  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  269  
   
  Let p = 2 · 10−10 (note that we have not optimized this constant and in the degree cut case it can be greatly improved). We say that an edge e = (u, v) is good if PT ∼μ [u, v both even in T ] ≥ p, where we say a vertex v is even in a tree T if δ(v)T is even. The vector m will consist of the convex combination of two feasible points in the O(T )-Join polyhedron, g and b (where g is for “good” edges and b is for “bad” edges). For a tree T and an edge e = (u, v) we let: 1 xe If u and v are both even in T ge = 2+η 1 Otherwise 2 xe Lemma 6. g is in the O(T )-Join polyhedron. Proof. First, consider any cut consisting of a single vertex v (or its complement). If v is odd, we need to ensure that g(δ(v)) ≥ 1. If v is odd, then ge = xe /2 for all e ∈ δ(v), so this follows from the fact that x(δ(v)) = 2. Now consider any cut S with 2 ≤ |S| ≤ n−2. We now argue that g(δ(S)) ≥ 1 with probability 1. This follows from the fact that: g(δ(S)) ≥  
   
  1 1 x(δ(S)) ≥ (2 + η) = 1, 2+η 2+η  
   
  where we use that every cut S with 2 ≤ |S| ≤ n − 2 has x(δ(S)) ≥ 2 + η. let:  
   
  We now design our second vector b. For a tree T and an edge e = (u, v) we 1+η xe If e is good be = 2+η 1 2+η xe If e is bad We will crucially use the following:  
   
  Corollary 2 (Corollary of Theorem 5.14 from[KKO21]). Let v be a vertex. Then, if Gv is the set of good edges adjacent to v, x(Gv ) ≥ 1. In [KKO21], it is shown that if xe is bounded away from 1/2, then e is a good edge. Furthermore, for any two edges e and f adjacent to v with xe ≈ xf ≈ 1/2, at least one is good. So, v can have only one bad edge which has fraction about 1/2, giving the above corollary (therefore it is even true that x(Gv ) ≥ 3/2 − γ for some small γ > 0). Given this, we can show the following: Lemma 7. b is in the O(T )-Join polyhedron. Proof. For any non-vertex cut, similar to above, the O(T )-Join constraint is easily satisﬁed. For a vertex cut v, we use that by the above theorem the x weight of the set of good edges adjacent to v is at least 1. Therefore, b(v) ≥ 1+η 1 2+η + 2+η = 1.  
   
  270  
   
  A. R. Karlin et al.  
   
  Definition 2 (Matching vector m in the degree cut case). Let m = αb + (1 − α)g, for some 0 < α < 1 we choose in the next subsection. Since b and g are both in the O(T )-Join polyhedron, so is m. Lemma 8. For any good edge e, E [ge ] ≤ ( 12 −  
   
  ηp 4+2η )xe .  
   
  Proof. Let pe = PT ∼μ [u, v even]. We can compute:  
   
     pe p 1 1 − pe 1−p ηp + + − E [ge ] = xe ≤ xe = xe , 2+η 2 2+η 2 2 4 + 2η as desired. Therefore, for any good edge e,  
   
    
   
   1+η 1 ηp E [me ] ≤ α − + (1 − α) xe 2+η 2 4 + 2η For any bad edge e, we have  
   
  E [me ] ≤ To make the two equal, we set α =  
   
  E [me ] ≤  
   
  α 1−α + 2+η 2 p 2+p .  
   
   xe  
   
  Therefore,  
   
  p/(2 + p) 1 − p/(2 + p) + 2+η 2  
   
   xe  
  0. Therefore the randomized algorithm has expected cost at most ( 32 − )c(x), which is enough to prove that Algorithm 2 deterministically ﬁnds a tree plus a matching whose cost is at most ( 32 − )c(x). Thus the only remaining question is the computational complexity of Algorithm 2, which we address now. Computing E [c(T ) + c(m) | Set]. Now that we have explained the construction of m, we observe that there is a simple deterministic algorithm to compute E [c(T ) + c(m) | Set] in polynomial time. First, compute E [c(T ) | Set]. By linearity of expectation it is enough to compute P [e ∈ T | Set] for all e ∈ E. To do this, we ﬁrst apply Lemma 4 to ﬁnd λ such that μλ = μλ|Set and then apply Lemma 3. Now to compute E [c(m) | Set], it suﬃces to compute E [me | Set] for any Set ∈ Tpartial , P [e ∈ T | Set] and any e = (u, v). Given the deﬁnition of m, the only event depending on the tree is the event P [u, v even | Set]. This can be computed with Corollary 1.  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  271  
   
  Algorithm 3. A Deterministic Approximation Algorithm for Metric TSP 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12:  
   
  5  
   
  Given a solution x0 of the LP (1), with an edge e0 with xe0 = 1. Let G be the support graph of x. Find a vector λ : E → R≥0 such that for any e ∈ E, PT ∼μλ [e ∈ T ] = xe (1 ± 2−n ) Perform Preprocessing Steps 1, 2, 3, 4, 5, and 6 Initialize Set := ∅. while there exists e = e0 not set in Set do Let Set+ := Set ∪ {Xe = 1} and let Set−:= Set ∪ {Xe = 0}; Compute S + = EET ∼ μλ c(T ) | Set+ + e∈E Ec(s∗ ) (e, Set+ ) + Ec(s) (e, Set+ ). Compute S − = EET ∼ μλ c(T ) | Set− + e∈E Ec(s∗ ) (e, Set− ) + Ec(s) (e, Set− ). If S + ≤ S − , let Set := Set+ . Otherwise let Set := Set− . end while Return T = {e : Xe = 1 in Set} together with min cost matching on odd degree vertices of T .  
   
  General Case  
   
  The matching vector m in the general case, [KKO22, Thm 6.1], can be written as s + s∗ + 12 x where s, s∗ are functions of the tree T ∼ μλ and some independent Bernoullis B. Roughly speaking, the (slack) vector s∗ : E → R≥0 takes care of matching constraints for near minimum cuts that are crossed and the (slack) vector s : E → R takes care of the constraints corresponding to cuts which are not crossed. Most importantly, the guarantee is that for a ﬁxed tree T the expectation of c(s) + c(s∗ ) + 12 c(x) over the Bernoullis is at least c(M ) where M is the minimum cost matching on the odd vertices of T . Furthermore, E [c(s) + c(s∗ )] ≤ −c(x) which is the necessary bound to begin applying the method of conditional expectation in Algorithm 3. Remark 3. The deﬁnitions of s and s∗ , the proof that E [c(s) + c(s∗ )] ≤ −c(x), and the proof that x/2 + E [s + s∗ | T ] is in the O(T )-join polyhedron come from [KKO21,KKO22]. Here, we will review how to construct the random slack vectors s, s∗ for a given spanning tree T and then explain how to eﬃciently compute E [c(s) + c(s∗ ) | Set] deterministically for any Set ∈ Tpartial . Unfortunately, a reader who has not read [KKO21,KKO22] may not be able to understand the motivation behind the details of the construction of s, s∗ . However, ?? and ?? are self-contained in the sense that a reader should be able to verify that E [c(s) + c(s∗ ) | Set] can be computed eﬃciently and deterministically. Our theorem boils down to showing the following two lemmas: Lemma 9. For any Set ∈ Tpartial , there is a polynomial time deterministic algorithm that computes: (1) ET ∼μλ [c(s∗ ) | Set] (shown in Ec(s∗ ) (e, Set)) (2) ET ∼μλ [c(s) | Set] (shown in Ec(s) (e, Set))  
   
  272  
   
  A. R. Karlin et al.  
   
  The crux of proving the above lemma is to show that for a given edge e and any Set, each of E [s∗e | Set] and E [se | Set] can be written as the (weighted) sum of indicators of events that depend on the sampled tree T , and each of these events happens only when a constant number of (not necessarily disjoint) sets of edges have certain parities or certain sizes. Technically speaking, these weighted sums are non-trivial for some of the events deﬁned in [KKO21,KKO22]. Given that, the following is enough to prove Lemma 9, as it gives a deterministic algorithm to compute the probability that a collection of (not necessarily disjoint) sets of edges have certain parities or certain sizes. (1) of Lemma 9 is proved in ??, and (2) in ??. The algorithm for each part requires a series of preprocessing steps and function deﬁnitions that we have marked with gray boxes. In each section, the ﬁnal procedure to calculate the expected cost of the slack vector is given in a yellow box at the end of the corresponding section. Lemma 10. Given a probability distribution μ : 2[n] → R≥0 and an oracle O that can evaluate gμ (z1 , . . . , zn ) at any z1 , . . . , zn ∈ C. Let E1 , . . . , Ek be a collection of (not necessarily disjoint) subsets of [n] and (σ1 , . . . , σk ) ∈ Fm1 × · · · × Fmk . Then, we can compute, PT ∼μ [(Ei )T = σi (mod mi ), ∀1 ≤ i ≤ k] . in N := m1 . . . mk -many calls to the oracle.1  I{e∈Ej } Proof. For each of the sets Ei , deﬁne a variable xi , and substitute j xj for ze into the polynomial gμ and call the resulting polynomial g. Then g(x1 , . . . , xk ) =  
   
    
   
  P [S]  
   
  i=1  
   
  S∈supp(μ)  
   
  Where recall (Ei )S = |Ei ∩ S|. Now, let ωi := e 1 m1 · · · mk  
   
    
   
  k   
   
  (e1 ,...,ek )∈Fr1 ×···×Frk i=1  
   
  k   
   
  √ 2π −1 mi  
   
  (Ei )S  
   
  xi  
   
  . We claim that  
   
  ωi−ei σi g(ω1e1 , . . . , ωkek )  
   
  = PS∼μ [(Ei )S ≡ σi mod mi , ∀1 ≤ i ≤ k] So the algorithm only needs to call the oracle N many times to compute the sum in the LHS.  
   
  1  
   
  Note that since we are dealing with irrational numbers, we will not be able to compute this probability exactly. However by doing all calculations with poly(n, N ) bits of precision we can ensure our estimate has exponentially small error which will suﬃce to get the bounds we need later.  
   
  A Deterministic Better-than-3/2 Approximation Algorithm for Metric TSP  
   
  273  
   
  To see this identity, notice that we can write the LHS as 1 m1 · · · mk =  
   
    
   
  P [S]  
   
    
   
  P [S]  
   
   S∈supp(μ)  
   
  P [S]  
   
  k   
   
  ⎛  
   
  ⎝ 1 mi i=1 k   
   
    
   
  k  i=1  
   
  (e1 ,...,ek )∈Fm1 ×···×Fmk S∈supp(μ)  
   
  S∈supp(μ)  
   
  =  
   
    
   
  −ei σi +ei (Ei )S  
   
  ωi  
   
  ⎞  
   
  ((Ei )S −σi )ei ⎠  
   
  ωi  
   
  ei ∈Fmi  
   
  I {(Ei )S − σi ≡ 0 mod σi }  
   
  i=1  
   
  where the last equality uses that ωi is the mi ’th root of unity. The RHS is exactly equal to the probability that (Ei )S ≡ σi mod mi for all i. Remark 4. When we apply this lemma in this paper, we will always let k be a constant and mi ≤ |V | for all i. Thus, it will always use a polynomial number of calls to an oracle evaluating the generating polynomial of a spanning tree distribution μλ . By Theorem 3, for any z ∈ C|E| : gμλ ({ze }e∈E ) =  
   
   1 det( λe ze Le + 11T /n), n e∈E  
   
  which can be computed in polynomial time. Corollary 3. Let μλ be a λ-uniform spanning tree distribution and let Set ∈ Tpartial . Then, let E1 , . . . , Ek be a collection of (not necessarily disjoint) subsets of [n] and (σ1 , . . . , σk ) ∈ Fm1 × · · · × Fmk . Then, we can compute, PT ∼μλ [(Ei )T = σi  
   
  (mod mi ), ∀1 ≤ i ≤ k | Set] .  
   
  in N := m1 . . . mk -many calls to the oracle. Proof. Construct a new graph G by contracting all edges with Xe = 1 in Set and deleting all edges with Xe = 0. We then update all σi by subtracting the number of edges that are set to 1 in Ei by Set. Then we apply Lemma 10 to the λ-uniform spanning tree distribution over G with the updated σ and the same m.  
   
  References [App+07] Applegate, D.L., Bixby, R.E., Chvatal, V., Cook, W.J.: The Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Mathematics). Princeton University Press, Princeton, NJ, USA (2007) [Asa+10] Asadpour, A., Goemans, M.X., Madry, A., Gharan, S.O., Saberi, A.: An o(log n/ log log n) approximation algorithm for the asymmetric traveling salesman problem. In: SODA, pp. 379–389 (2010)  
   
  274  
   
  A. R. Karlin et al.  
   
  [Chr76] Nicos Christoﬁdes. Worst case analysis of a new heuristic for the traveling salesman problem. Report 388, Graduate School of Industrial Administration, Carnegie-Mellon University, Pittsburgh, PA, 1976 [DFJ59] Dantzig, G.B., Fulkerson, D.R., Johnson, S.: On a linear programming combinatorial approach to the traveling salesman problem. OR 7, 58–66 (1959) [Edm70] Edmonds, J.: Submodular functions, matroids and certain polyhedra. In: Combinatorial Structures and Their Applications, pp. 69–87, New York, NY, USA (1970). Gordon and Breach [EJ73] Edmonds, J., Johnson, E.L.: Matching, Euler tours and the Chinese postman. Math. Program. 5(1), 88–124 (1973) [GB93] Goemans, M., Bertsimas, D.: Survivable network, linear programming relaxations and the parsimonious property. Math. Program. 60, 06 (1993) [Gup+21] Gupta, A., Lee, E., Li, J., Mucha, M., Newman, H., Sarkar, S.: Matroidbased TSP rounding for half-integral solutions. CoRR, abs/2111.09290 (2021) [HK70] Held, M., Karp, R.M.: The traveling salesman problem and minimum spanning trees. Oper. Res. 18, 1138–1162 (1970) [HN19] Haddadan, A., Newman, A.: Towards improving christoﬁdes algorithm for half-integer TSP. In: Bender, M.A., Svensson, O., Herman, G., editors, ESA, vol. 144 of LIPIcs, pp. 56:1–56:12. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2019) [HNR21] Haddadan, A., Newman, A., Ravi, R.: Shorter tours and longer detours: uniform covers and a bit beyond. Math. Program. 185(1–2), 245–273 (2021) [KKO20] Karlin, A.R., Klein, N., Gharan, S.O.: An improved approximation algorithm for TSP in the half integral case. In: Makarychev, K., Makarychev, Y., Tulsiani, M., Kamath, G., Chuzhoy, J., editors, STOC, pp. 28–39. ACM (2020) [KKO21] Karlin, A.R., Klein, N., Gharan, S.O.: A (slightly) improved approximation algorithm for metric tsp. In: STOC. ACM (2021) [KKO22] Karlin, A., Klein, N., Gharan, S.O.: A (slightly) improved bound on the integrality gap of the subtour LP for tsp. In: FOCS, pp. 844–855. IEEE Computer Society (2022) [KLS15] Karpinski, M., Lampis, M., Schmied, R.: New inapproximability bounds for TSP. J. Comput. Syst. Sci. 81(8), 1665–1677 (2015) [MS11] Moemke, T., Svensson, O.: Approximating graphic tsp by matchings. In: FOCS, pp. 560–569 (2011) -approximation for graphic TSP. In: STACS, pp. 30–41 (2012) [Muc12] Mucha, M.: 13 9 [OSS11] Gharan, S.O., Saberi, A., Singh, M.: A randomized rounding approach to the traveling salesman problem. In: FOCS, pp. 550–559. IEEE Computer Society (2011) [Ser78] Serdyukov, A.I.: O nekotorykh ekstremal’nykh obkhodakh v grafakh. Upravlyaemye sistemy 17, 76–79 (1978) [SV12] Sebö, A., Vygen, J.: Shorter tours by nicer ears: CoRR abs/1201.1870 (2012) [TVZ20] Traub, V., Vygen, J., Zenklusen, R.: Reducing path TSP to TSP. In: Makarychev, K., Makarychev, Y., Tulsiani, M., Kamath, G., Chuzhoy, J., editors, STOC, pp. 14–27. ACM (2020)  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts Aleksandr M. Kazachkov1(B)  
   
  and Egon Balas2  
   
  1  
   
  2  
   
  University of Florida, Gainesville, FL, USA [email protected]  Carnegie Mellon University, Pittsburgh, PA, USA [email protected]   
   
  Abstract. Disjunctive cutting planes can tighten a relaxation of a mixed-integer linear program. Traditionally, such cuts are obtained by solving a higher-dimensional linear program, whose additional variables cause the procedure to be computationally prohibitive. Adopting a Vpolyhedral perspective is a practical alternative that enables the separation of disjunctive cuts via a linear program with only as many variables as the original problem. The drawback is that the classical approach of monoidal strengthening cannot be directly employed without the values of the extra variables appearing in the extended formulation. We derive how to compute these values from a solution to the linear program generating V-polyhedral disjunctive cuts. We then present computational experiments with monoidal strengthening of cuts from disjunctions with as many as 64 terms. Some instances are dramatically impacted, with strengthening increasing the gap closed by the cuts from 0 to 100%. However, for larger disjunctions, monoidal strengthening appears to be less eﬀective, for which we identify a potential cause.  
   
  1  
   
  Introduction  
   
  Disjunction-based cutting planes, or disjunctive cuts, are a strong class of valid inequalities for mixed-integer programming problems, which can be used as a framework for analyzing or generating general-purpose cuts [8]. Their strength comes at a high computational cost, due to which only very special cases of disjunctive cuts have been deployed in optimization solvers. As a step towards practicality, Balas and Kazachkov [10] introduce a relaxation-based V-polyhedral paradigm for disjunctive cuts, which trades oﬀ some theoretical strength for computational eﬃciency. The approach selects a small number of points and rays whose convex hull forms a relaxation of the disjunction; as a result, some potential cuts are no longer valid, but strong cuts are nevertheless guaranteed to be E. Balas passed away during the preparation of this manuscript, which started when both authors were at Carnegie Mellon University. The core ideas and early results are documented in the PhD dissertation of Kazachkov [37, Chapter 5]. A.M. Kazachkov completed the computational experiments, analysis, and writing independently. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 275–290, 2023. https://doi.org/10.1007/978-3-031-32726-1_20  
   
  276  
   
  A. M. Kazachkov and E. Balas  
   
  obtainable. Further, cuts from this relaxation, called V-polyhedral (disjunctive) cuts (VPCs), can be generated via a relatively compact linear program, called the point-ray linear program (PRLP), compared to the usual higher-dimensional cut-generating linear program (CGLP) for disjunctive cuts [8,14,15]. Hence, with VPCs, it is more computationally eﬃcient to improve the disjunction by adding terms and increase the relaxation quality, thereby accessing disjunctive cuts that diﬀer substantially from the families of cuts typically applied in solvers. VPCs improve the average (integrality) gap closed substantially relative to Gomory mixed-integer cuts (GMICs) and other standard cuts in solvers. However, the computational experiments by Balas and Kazachkov [10] reveal a curiosity: there are instances for which GMICs (which can be derived as cuts from a two-term disjunction) remain stronger than VPCs even when using large variable disjunctions. For example, for the instance 10teams, originally part of the 3rd Mixed Integer Programming Library (MIPLIB) [18], GMICs close 100% of the integrality gap, while VPCs from a 64-term disjunction close 0% of the gap. A potential explanation for this phenomenon is that GMICs beneﬁt from a strengthening procedure that cannot be directly applied to VPCs. Speciﬁcally, the GMIC two-term disjunction can be obtained via monoidal strengthening of a disjunction on a single variable [9,12,38]. Monoidal strengthening of cuts from more general disjunctions is also possible, but the procedure ostensibly requires a simple disjunction, where each term only imposes a single new constraint. This is not a theoretical barrier, as any cut from a general disjunction can also be derived from a simple disjunction obtained from the general one by aggregating the constraints deﬁning each disjunctive term. The multipliers for this aggregation are precisely the Farkas certiﬁcate for the validity of the cut. The key challenge for VPCs is that this certiﬁcate is not readily available, because the PRLP only has variables for the cut coeﬃcients, compared to the CGLP that explicitly includes variables for the Farkas multipliers. Our contributions, summarized next, are to identify a way to eﬃciently apply monoidal strengthening for the particular version of the VPC framework introduced in Balas and Kazachkov [10], as well as to implement and computationally evaluate this strengthening idea. Contributions. Given a VPC, one can solve the CGLP with cut coeﬃcients ﬁxed and retrieve the required values of the aggregation multipliers, in order to apply monoidal strengthening. Unfortunately, the computational eﬀort associated to this is likely to be prohibitive. Our ﬁrst contribution, discussed in Sect. 3, is observing that solving the CGLP is unnecessary: it suﬃces to use the inverse of an easily-identiﬁed nonsingular matrix per disjunctive term. Furthermore, for the type of simple VPCs proposed and tested by Balas and Kazachkov [10], this inverse is readily available within the cut generation process. Next, in Sect. 4, we discuss computational experiments with strengthening simple VPCs on a set of benchmark instances. We compare the strength to unstrengthened VPCs and to GMICs, for disjunctions ranging in size up to 64 terms. We ﬁnd that strengthening can signiﬁcantly improve the gap closed for some instances. Furthermore, we see that GMICs and unstrengthened VPCs tend to be complementary in terms of which instances they beneﬁt, but applying  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  277  
   
  monoidal strengthening enables the two families to be simultaneously eﬀective for more instances. The results are most striking for two-term disjunctions, in which strengthened VPCs close 40% more gap than unstrengthened VPCs, on average. For example, returning to the instance 10teams, the VPCs from a single variable disjunction close 0% of the integrality gap, but this value goes to 100% after strengthening the cuts. However, as the size of the disjunction increases, the relative improvement by strengthening becomes smaller. Our ﬁnal contribution, in Sect. 5, is identifying a theoretical source of this weakness. Related Work. A focal point in the literature on monoidal strengthening for disjunctive cuts [9] (see also Balas [8, Section 7]) is the special case of split disjunctions, which are parallel two-term disjunctions that are used for GMICs and related cut families. In this context, the use of the CGLP leads to lift-andproject cuts (L&PCs) [14], to which monoidal strengthening can be applied [15, Section 2.4]. The family of strengthened L&PCs is equivalent to GMICs, as shown by Balas and Perregaard [12], and to mixed-integer rounding inequalities [45,46], as discussed in Cornuéjols and Li [23]. Balas and Perregaard [12] provide an appealing geometric interpretation of this connection via intersection cuts [7]: every undominated L&PC can be derived as an intersection cut from a basis in the original problem space. As a result, L&PCs can be generated without explicitly building the CGLP and without hindering a posteriori strengthening of the cuts. Bonami [19] presents a diﬀerent method for separating L&PCs in the original space of variables that is also amenable to strengthening. Avoiding formulating the higher-dimensional CGLP is the key advance that has enabled the eﬀective inclusion of L&PCs in several solvers. Sidestepping the CGLP continues to be crucial to move beyond split disjunctions. However, the aforementioned approaches [12,19] rely on properties of the split set; for example, with general disjunctions, there exist cuts that dominate all intersection cuts [5,11,40], so one cannot hope to merely pivot among bases in the original space. Nonetheless, a stream of work [20,36,40] extends cut generation in the original space to general two-term disjunctions, and monoidal strengthening applies to the resulting cuts [28]. No further extension of this technique to more general disjunctions has been reported in the literature. This motivates the use of VPCs, due to the PRLP’s advantage of having the same number of variables as the original problem. The diﬃculty is that a description of a polyhedron using points and rays may be exponentially larger than using inequalities, causing exponentially many constraints in the PRLP. This naturally leads to row generation in prior work by Perregaard and Balas [48] and Louveaux et al. [44] when invoking the V-polyhedral perspective. In the experiments by Perregaard and Balas [48], for disjunctions with 16 terms, separating cuts via the PRLP with row generation is an order of magnitude faster than via the CGLP. Nonetheless, row generation is time consuming, as multiple PRLPs must be solved to ﬁnd one valid inequality. The remedy by Balas and Kazachkov [10] is to construct a relaxation of each disjunctive term, where the resulting PRLP has few rows and immediately produces valid cuts. This is successful at quickly generating cuts from large  
   
  278  
   
  A. M. Kazachkov and E. Balas  
   
  disjunctions, but the average gap closed by the cuts alone is less than that from GMICs. It is only when VPCs and GMICs are used together that a marked improvement in gap closed is observed, which shows that VPCs aﬀect a diﬀerent region of the relaxation than GMICs. However, as mentioned with the 10teams instance in which GMICs close all of the gap, while VPCs close none, the results also suggest that the absence of strengthening for VPCs is a signiﬁcant deﬁciency. As discussed, the vanilla monoidal strengthening presented by Balas and Jeroslow [9] does not directly apply to VPCs due to the lack of the values of the aggregation multipliers. Balas and Qualizza [13, Section 6] show that a crosspolytope disjunction, arising from using multiple rows of the simplex tableau, can be strengthened by modularizing the inequalities deﬁning the disjunction, replacing the coeﬃcients of integer-restricted nonbasic variables, and they prove the form of the optimal strengthening for the two-row case. An alternative to monoidal strengthening is the group-theoretic approach [32, 35], equivalent to monoidal strengthening under some conditions. Speciﬁcally, “trivial lifting” has been applied to simple disjunctions [16,24–26,49]. Evaluating the trivial lifting is expensive in general [30], and it does not directly apply to arbitrary disjunctive cuts. While this paper exclusively approaches disjunctive cut generation via the VPC framework, there exist other methods for producing strong disjunctive cuts without solving the higher-dimensional CGLP. Any such approach could potentially beneﬁt from the eﬃcient computation of a Farkas certiﬁcate. For example, a common technique in the literature is to use a disjunction to strengthen cuts via tilting, which has been applied to linear and nonlinear integer optimization problems [37,39,42,47].  
   
  2  
   
  Notation and Background  
   
  Our target is to ﬁnd strong valid cuts to tighten the natural linear relaxation of the mixed-integer linear program below, given rational data: min  
   
  x∈Rn  
   
  cT x Ai· x ≥ bi  
   
  for i ∈ [q],  
   
  xj ≥ 0 xj ∈ Z  
   
  for j ∈ [n], for j ∈ I.  
   
  (IP)  
   
  Here, [n] ..= {1, . . . , n} for any integer n, and I ⊆ [n] is the set of integerrestricted variables. For a given matrix A, we denote the ith row by “Ai· ” and the jth column by “A·j ”. Let PI denote the feasible region of (IP), and let P ..= {x ∈ Rn≥0 : Ax ≥ b}. One way to strengthen the formulation P (with respect to PI ) is to use logical conditions to formulate a disjunction, from which valid inequalities for PI can then be derived. Suppose ∨t∈T (Dt x ≥ D0t ) is a valid disjunction, in the sense that PI ⊆ ∪t∈T {x ∈ Rn : Dt x ≥ D0t }. Let Qt ..= {x ∈ P : Dt x ≥ D0t }. This is an H-polyhedral (inequality) description. We assume Qt = ∅ for all t ∈ T .  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  279  
   
  Let P t ..= {x ∈ Rn : At x ≥ bt } denote a relaxation of Qt , where At x ≥ bt is deﬁned by a subset of the constraints deﬁning Qt . For the VPC procedure, we must ensure that P t has relatively few extreme points and rays, i.e., it has a compact V-polyhedral description (P t , Rt ), so that P t = conv(P t ) + cone(Rt ). Deﬁne the disjunctive hull PD ..= cl conv(∪t∈T P t ), which can be described by the point-ray collection (P, R) ..= (∪t∈T P t , ∪t∈T Rt ). For t ∈ T , let qt be the number of rows of At . We ﬁrst summarize some important disjunctive programming concepts and the two cut-generating paradigms that we are relating. CGLP. One way to generate valid cuts for PD is through the CGLP, which is an application of disjunctive programming duality [8, Section 4]. Speciﬁcally, an inequality αT x ≥ β is valid for PD if and only if the inequality is valid for each P t , t ∈ T . Consequently, by Farkas’s lemma [27], αT x ≥ β is valid for PD if and only if the following system is feasible, in variables (α, β, {v t }t∈T ), where  v t ∈ R1×qt is a row vector of appropriate length for each t ∈ T : ⎫ αT = v t At ⎬ t t β≤v b for all t ∈ T . (1) ⎭ qt v t ∈ R≥0 We refer to {v t }t∈T as the Farkas certificate for the validity of αT x ≥ β for PD . To generate cuts with (1), one typically maximizes the violation with respect to a PI -infeasible point, after adding a normalization, which can be a crucial choice [29]. For example, the constant of the cut can be ﬁxed to β¯ ∈ R:   ¯ {v t }t∈T ) is feasible to (1) . ¯ (α, {v t }t∈T ) : (α, β, (CGLP(β))  
   
  PRLP. An alternative way to generate disjunctive cuts is through the reverse polar of PD [8, Section 5], which is deﬁned with respect to a given β¯ ∈ R as   α ∈ Rn : αT x ≥ β¯ for all x ∈ PD . Clearly this captures all of the valid inequalities for PD whose constant is equal ¯ Since x ∈ PD if and only if x ∈ conv(P) + cone(R), it holds that αT x ≥ β¯ to β. is valid for PD if and only if it is satisﬁed by all of the points and rays in (P, R). ¯ ¯ in variables α ∈ Rn , for a ﬁxed β: This yields the system (PRLP(β)), αT p ≥ β¯  
   
  for all p ∈ P  
   
  α r≥0  
   
  for all r ∈ R.  
   
  T  
   
  ¯ (PRLP(β))  
   
  ¯ are what we refer to as VPCs. The feasible solutions to (PRLP(β)) ¯ over (CGLP(β)) ¯ is the absence of As discussed, the advantage of (PRLP(β)) the Farkas multipliers as variables, so VPCs are generated without requiring a ¯ is that these missing lifted space. As we see next, the disadvantage to (PRLP(β)) variables are used in strengthening the cuts after they are generated.  
   
  280  
   
  A. M. Kazachkov and E. Balas  
   
  Monoidal Strengthening. Balas and Jeroslow [9] strengthen cuts with a monoid:   |T | . mt ≥ 0 . (M) M .= m ∈ Z : t∈T  
   
  It is also assumed that, for each t ∈ T , there exists a ﬁnite lower bound vector t such that Dt x ≥ t for all x ∈ PI . Let Δt ..= D0t − t . To strengthen the cut, we improve the underlying disjunction. Speciﬁcally, given a valid disjunction ∨t∈T (Dt x ≥ D0t ), for any m ∈ M and k ∈ I, the ˜ tx ≥ D ˜ t ) is also valid, where D ˜ t ..= Dt + Δt mt , and D ˜t = disjunction ∨t∈T (D 0 ·j ·k ·k t D·j for all j = k. The strengthened cut is obtained by applying the Farkas certiﬁcate of the unstrengthened cut to the strengthened disjunction. Let qt denote the number of constraints in Dt x ≥ D0t for term t ∈ T . Given 1×qt × R≥0 , deﬁne row vectors (ut , ut0 ) ∈ R1×q ≥0 t αkt ..= ut A·k + ut0 D·k .  
   
  (αkt )  
   
  Then (using an appropriate CGLP) the cut αT x ≥ β is valid for PD , where αk ..= max{αkt } t∈T  
   
  and  
   
  β ..= min{ut b + ut0 D0t }. t∈T  
   
  (The above applies to cuts valid for ∨t∈T Qt ; for PD , assume a value of zero for the ˆtk ..= αk −αkt . multipliers on constraints of Qt that are not present in P t .) Deﬁne u T We now apply monoidal strengthening to the cut α x ≥ β. 1×qt Theorem 1 ([9, Theorem 3]). Given (ut , ut0 ) ∈ R1×q × R≥0 for t ∈ T , the ≥0 T .  
   
  k .= αk for k ∈ / I, and, for k ∈ I, inequality α  
   
  x ≥ β is valid for PI , where α    t  uk + ut0 Δt mt . α  
   
  k ..= inf max αkt + ut0 Δt mt = αk + inf max −ˆ m∈M t∈T  
   
  m∈M t∈T  
   
  Thus, the Farkas certiﬁcate {(ut , ut0 )}t∈T is used for monoidal strengthening. Computing these values without solving the CGLP is our next target.  
   
  3  
   
  Correspondence Between PRLP and CGLP Solutions  
   
  Let α ¯ T x ≥ β¯ be a valid inequality for PD , corresponding to a feasible solution ¯ Our goal is to compute Farkas multipliers certifying the cut’s to (PRLP(β)). validity without explicitly solving the CGLP. While one can solve for values ¯ T = v t At , β¯ = v t bt , v t ≥ 0, we provide an improvement via v t that satisfy α basic linear programming concepts. We ﬁrst present a special case in Sects. 3.1 and 3.2, when the disjunctive terms P t are not primal degenerate, a condition that is satisﬁed by the VPC procedure implemented for our experiments. Then, Sect. 3.3 discusses a challenge posed by the general case. We assume that α ¯ T x ≥ β¯ is supporting for all terms in T . This is for ease of notation, as otherwise we would need to add an index t to the constant side. Concretely, the assumption is without loss of generality because, for any term  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  281  
   
  t ∈ T , we can increase the constant side of the cut until we obtain an inequality α ¯ T x ≥ β¯t that is supporting for term t, though perhaps invalid for other terms. ¯ with The value of β¯t can be quickly calculated by taking the dot product of α ¯ T x ≥ β¯t every point in P t . We can then ﬁnd a certiﬁcate v t of the validity of α ¯ We for P t , which also serves as a certiﬁcate for the weaker inequality α ¯ T x ≥ β. state, without proof, a slightly more general version of this in Lemma 2. Lemma 2. For t ∈ T , let C t ⊇ P t and β¯t ≥ β¯ such that α ¯ T x ≥ β¯t is valid for ¯ T x ≥ β¯t C t . Then, given any Farkas certificate for the validity of the inequality α for C t , the same multipliers certify that α ¯ T x ≥ β¯ is valid for P t . For convenience, we introduce extra notation to refer to the feasible region of Qt as Aˆt x ≥ ˆbt , and we deﬁne the number of these constraints as qˆt ..= q + qt + n. For N ⊆ [ˆ qt ], deﬁne AˆtN x ≥ ˆbtN as the constraints of Qt indexed by N . 3.1  
   
  Simple VPCs  
   
  Our experimental setup in Sect. 4 follows that of Balas and Kazachkov [10], who focus on a variant of the VPC framework called simple VPCs. Let pt be a vertex of Qt , for t ∈ T . There exists a cobasis for pt , a set of n linearly independent qt ] denote constraints among those deﬁning Qt that are tight at pt . Let N t ⊆ [ˆ the indices of these n constraints, and deﬁne the basis cone C t ..= {x ∈ Rn : AˆtN t x ≥ ˆbtN t }. The inequality α ¯ T x ≥ β¯ is a simple VPC if P t is a basis cone for each term. The (translated) cone C t has a particularly easy V-polyhedral representation: there is a single extreme point pt , and there are n extreme rays {ri }i∈[n] . The ith extreme ray of C t corresponds to increasing the “slack” on the ith constraint deﬁning C t [21, Chapter 6]. Lemma 3 states that, for simple ¯ can be computed via VPCs, the values of the variables {v t }t∈T to (CGLP(β)) the dot product of the cut coeﬃcients with the rays of C t . Lemma 3. Let C t be a basis cone defined by N t , the indices of n linearly inde¯ T x ≥ β¯ is valid for C t , then the multiplier on pendent constraints of Qt . If α t ¯ T ri , where ri is column i of (AˆtN t )−1 . constraint i ∈ [n] of C has value vit = α Proof. Add nonnegative slack variables stN t for each row indexed by N t , so that AˆtN t x − stN t = btN t . Then observe that, being a cobasis, AˆtN t is invertible, so x = (AˆtN t )−1 btN t + (AˆtN t )−1 stN t = pt + i∈N t ri sti . The last equality follows from the derivation of the rays of C t ; see, for example, Conforti et al. [21, Chapter 6]. Therefore, for simple VPCs, the Farkas certiﬁcate can be computed with no extra eﬀort when given the point-ray representation of PD . Moreover, Balas and Kazachkov [10] obtain simple VPCs from the leaf nodes of a partial branch-andbound tree and use pt as the optimal solution to the linear relaxation at each leaf; implemented carefully, this can further reduce the computational load for generating then strengthening VPCs, as the values of the rays can be read from the optimal tableau, which is typically readily available from a solver.  
   
  282  
   
  3.2  
   
  A. M. Kazachkov and E. Balas  
   
  Relaxations Without Primal Degeneracy  
   
  Suppose the relaxation P t ⊇ Qt is a simple polyhedron, in which every extreme point and ray is deﬁned by a unique basis [50]. The basis cone C t used for simple VPCs is one example. While the basis cone setting may seem quite narrow, it turns out to encompass more general situations. Speciﬁcally, there always exists ¯ T x ≥ β¯ is valid and supporting for C t . a basis cone C t ⊇ P t such that α Lemma 4. Let P t be a simple polyhedron, and suppose the point-ray collection ¯ T x ≥ β¯ be a valid inequality (P t , Rt ) satisfies P t = conv(P t ) + cone(Rt ). Let α t t t ¯ T x ≥ β¯ is valid for the for P . Then there exists a vertex p ∈ P such that α t t basis cone C associated to p , defined with respect to the constraints of P t . Proof. Let pt be an optimal solution to minx {¯ αT x : x ∈ P t } = minp {¯ αT p : p ∈ t T t . ¯ . ¯ p. Note that the rays in R need not be considered, as the P }. Deﬁne βt = α optimization problem must be bounded since α ¯ T x ≥ β¯t is valid for all x ∈ P t . t The point p has a unique basis, so the basis cone C t is deﬁned by the (precisely) n constraints of P t that are tight at pt . Optimality of pt implies all reduced costs ¯ ¯ T pt = β¯t ≥ β, are nonnegative. It follows that α ¯ T r ≥ 0 every ray r ∈ C t . Since α T t ¯ the inequality α ¯ x ≥ β is valid for C . Therefore, we can invoke Lemmas 2 and 3 to ﬁnd the Farkas certiﬁcate for this case. Note that, when the given point-ray collection only contains extreme points and rays, the rays of C t for any basis cone of the simple polyhedron P t can be computed as the rays Rt , along with the directions p − pt for every point p ∈ P t that is adjacent (one pivot away) from pt . 3.3  
   
  Relaxations with Primal Degeneracy  
   
  Up to now, we have made the convenient assumption that the relaxation P t is a simple polyhedron. More generally, there always exists a basis cone C t , such that a cut valid for P t is valid for C t . With Example 5, we illustrate the complication if α ¯ T x ≥ β¯ is supporting at a primal degenerate point of P t : a basis for that point needs to be chosen carefully, as the inequality may not be valid for some basis cones. It can be computationally involved to ﬁnd a valid basis in these situations, which prevents a direct application of our approach relying on simple polyhedra. The purpose of this example is to highlight a crucial obstacle to a complete correspondence between PRLP and CGLP solutions, but we do not further investigate the nondegenerate case in this paper. Example 5. Figure 1 shows a polyhedron P , deﬁned as the feasible solutions to −(13/8)x1 − (1/4)x2 − x3 ≥ −15/8 (1/2)x1 + x2 ≥ 1/2 (1/2)x1 − x3 ≥ −3/4 (1/2)x1 − x2 ≥ −1/2 x2 ≥ 0.  
   
  (c1) (c2) (c3) (c4) (c5)  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  283  
   
  Fig. 1. Example 5: Disjunctive terms with primal degeneracy, despite a nondegenerate initial polyhedron. The VPC is the red wavy line in the second panel. (Color ﬁgure online)  
   
  A valid cut from the disjunction (−x1 ≥ 0) ∨ (x1 ≥ 1) has coeﬃcients α ¯T = (−5/8, −1/4, −1) and constant β¯ = −7/8. The cut, depicted in the right panel, is incident to point p1 = (0, 1/2, 3/4) on P 1 ..= {x ∈ P : −x1 ≥ 0}. This point is tight for four inequalities: three deﬁning P (constraints (c2)-(c4)), and the disjunction-deﬁning inequality −x1 ≥ 0. Note that P is simple, but P 1 is not. To construct the cobasis N 1 , such that the inequality is valid for the associated basis cone C 1 , we must select three linearly independent constraints among those that are tight at p1 . One of the inequalities must be −x1 ≥ 0, as otherwise we have not imposed the disjunction at all (but we also know the cut is not valid for P ). It can be veriﬁed that the only valid choice for this example is N 1 containing the indices for (c3), (c4), and the disjunctive inequality −x1 ≥ 0.   
   
  4  
   
  Computational Experiments  
   
  We implement monoidal strengthening for simple VPCs, building on the code used by Balas and Kazachkov [10] from https://github.com/akazachk/vpc. Our goal for the computational study is to measure the eﬀect of monoidal strengthening on the percent integrality gap closed by VPCs, compared to unstrengthened VPCs and GMICs, and evaluated across diﬀerent disjunction sizes. The code is run on HiPerGator, a shared cluster through Research Computing at the University of Florida. The computational setup is nearly identical to the one described in Balas and Kazachkov [10, Section 5 and Appendix C]. We select instances from the union of the MIPLIB [4,17,18,31,41], CORAL [22], and NEOS sets, restricted to those with at most 5,000 rows and columns and based on other criteria given in [10, Appendix C]. This yields 332 instances suitable for gap closed comparisons. However, we only report on 274 of these  
   
  284  
   
  A. M. Kazachkov and E. Balas  
   
  332 instances, due to memory resource constraints on the cluster. Despite this reduced dataset, we can identify recurring patterns in how monoidal strengthening aﬀects instances. Instances are presolved with Gurobi [34], but cut generation is done via the C++ interface to COIN-OR [43], using Clp [3] for solving linear programs and Cbc [1] for constructing disjunctions based on partial branch-andbound trees. We test six diﬀerent disjunction sizes, stopping branching when the number of leaf nodes (disjunctive terms) is 2 for  ∈ [6]. Thus, we report results with monoidal strengthening of disjunctive cuts from up to 64-term disjunctions, though only one disjunction is used at a time. One GMIC is generated per fractional integer variable at an optimal solution to the linear programming relaxation, and the number of GMICs is also used as the limit for the number of VPCs we generate for that instance per ﬁxed choice of disjunction. One round of cuts is used for both procedures. GMICs are generated through CglGMI [2], while the VPC generation procedure is identical to that of Balas and Kazachkov [10], with strengthening applied afterwards. While Lemma 3 enables us to calculate the values of the Farkas multipliers via the rays of each relaxation P t , and these values are readily available based on how we built the PRLP, we do not avail of this connection. Instead, we calculate ¯ T (At )−1 . This approach is still more direct than solving a feasibility version vt = α ¯ with α of (CGLP(β)) ¯ ﬁxed. We opt for numerical safety for this exploratory investigation, so we use the Eigen library [33] to recompute the inverse of At rather than reading from the Cbc / Clp internal basis inverse for each term. We report the average percent integrality gap closed by VPCs and GMICs in Table 1. The ﬁrst six data rows contain the results for each ﬁxed disjunction size. The penultimate data row, labeled “Best”, uses the highest gap closed per instance across all disjunctions. The last data row, labeled “Wins”, reports the number of instances for which the “Best” gap closed is at least 10−3 higher than the gap closed by GMICs. In the columns, we refer to GMICs by “G”, unstrengthened VPCs by “V”, strengthened VPCs by “V+ ”. The columns “G+V” and “G+V+ ” refer to GMICs applied together with VPCs. There are two sets of instances: “All” reports on all 274 instances, while “≥10%” reports on the 97 instances for which unstrengthened VPCs alone close at least 10% of the integrality gap for the “Best” values. In terms of overall gap closed, despite the monoidal strengthening procedure, as reported by Balas and Kazachkov [10], VPCs alone do not outperform GMICs for the “All” set, but using VPCs and GMICs together provides around 40% improvement in gap closed relative to GMICs alone. While adding VPCs with GMICs might double the number of cuts, one round of VPCs continues to close substantial more gap even after multiple rounds of solver-default cuts [10]. Hence, VPCs tighten the relaxation in diﬀerent regions relative to GMICs. This is also highlighted by the “≥10%” set, which are instances for which VPCs have strong performance; for this set, GMICs are relatively weaker, with the best VPCs per instance (used alone) providing a 75% improvement in average percent gap closed over GMICs alone. We also see this in the “Wins” row: for the “≥10%” set, VPCs alone outperform GMICs for 73 of the 97 instances in the set.  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  285  
   
  Table 1. Average percent gap closed by VPCs and GMICs according to the number of leaf nodes used to construct the partial branch-and-bound tree. “Best” refers to the maximum gap closed per instance across all partial tree sizes. All G  
   
  V  
   
  V+  
   
  ≥10% G+V G+V+ G V  
   
  V+  
   
  G+V G+V+  
   
  17.95 18.37 18.98 20.54 22.31 23.72  
   
  6.47 8.35 11.16 16.05 22.28 25.85  
   
  18.13 19.14 20.66 24.86 29.59 32.90  
   
  2 leaves 4 leaves 8 leaves 16 leaves 32 leaves 64 leaves  
   
  17.21 2.28 3.25 17.21 3.35 3.72 17.21 4.51 4.76 17.21 6.41 6.57 17.21 8.78 8.97 17.21 10.46 10.57  
   
  18.18 18.54 19.15 20.67 22.48 23.83  
   
  Best Wins  
   
  17.21 11.93 12.57 24.67 24.89 103 104 185 190  
   
  16.29 16.29 16.29 16.29 16.29 16.29  
   
  5.34 7.81 10.84 15.81 21.82 25.59  
   
  18.59 19.48 20.91 25.04 29.97 33.14  
   
  16.29 29.26 29.53 35.27 35.59 73 73 94 94  
   
  Next, we summarize observations about the eﬀect of monoidal strengthening. We start with the ﬁrst data row, in which VPCs are derived from one split disjunction per instance. For the set “All”, monoidal strengthening aﬀects the gap closed by VPCs for 87 instances and increases the average gap closed by VPCs by ~1% from 2.28% to 3.25%, a 40% relative improvement. For the set “≥10%”, the corresponding relative improvement is 20%. Although the two-term case is encouraging, and a similar relative improvement in gap closed would be substantial for larger disjunctions, this unfortunately does not materialize. From Table 1, we see that as the disjunction size increases, the contribution of monoidal strengthening tends to further diminish, with an absolute improvement in gap closed of only 0.1% for VPCs from a 64-term disjunction. We will discuss a potential cause for this in the next section. We now compare the columns “G+V+ ” to “G+V”. On the set “All”, even for split disjunctions, the eﬀect of strengthening is minimal when VPCs are combined with GMICs, with strengthening only yielding an additional 0.23% in percent gap closed, preserving around 23% of the improvement between “V+ ” and “V”. For larger disjunctions, while the absolute increase in gap closed by strengthened VPCs is small, over 80% of that improvement is preserved when adding GMICs together with VPCs. A closer examination of the results supports the hypothesis that monoidal strengthening is a key factor enabling GMICs to close more gap than VPCs. We sort the instances by the increase in gap closed by strengthened VPCs compared to unstrengthened ones, using the best gap closed across all disjunction sizes, per column. Table 2 shows the top ten instances, sorted by the last column, which calculates the diﬀerence between “V+ ” and “V”. The table includes the instance 10teams discussed earlier, as well as six other instances for which unstrengthened VPCs close at most 5% of the gap. We see that monoidal strengthening of VPCs bridges a large portion of the diﬀerence with GMICs for these instances. For neos-1281048, the situation is reversed: 121 GMICs close no gap while 29  
   
  286  
   
  A. M. Kazachkov and E. Balas  
   
  Table 2. Percent gap closed for instances where strengthening VPCs works best. Instance  
   
  G  
   
  V  
   
  V+  
   
  G+V  
   
  G+V+ V+ −V  
   
  10teams 100.00 0.00 100.00 100.00 100.00 100.00 neos-1281048 0.00 17.09 29.36 17.09 29.36 12.27 neos-1599274 34.65 0.00 11.19 34.65 34.65 11.19 f2gap401600 62.97 2.53 11.34 63.31 71.77 8.80 prod2 2.31 27.60 35.90 27.63 35.91 8.29 neos-942830 6.25 0.00 6.25 6.25 6.25 6.25 p0548 48.62 3.28 9.03 49.03 55.11 5.75 mkc 6.08 2.60 6.56 6.35 9.61 3.96 f2gap201600 60.27 8.58 12.13 60.27 60.27 3.56 neos-4333596-skien 20.84 7.05 9.83 20.84 20.85 2.78  
   
  unstrengthened VPCs close 17% of the gap, which is further improved to 29% after strengthening. From this table, we also observe the phenomenon that the value in column “G+V” is typically either entirely due to GMICs or to VPCs, but which cuts are more important varies by instance. The situation remains similar for the column “G+V+ ”, though now we ﬁnd several cases (f2gap401600, p0548, mkc) in which the two cut families add to each other. While running time is not our focus, and the shared computing environment makes wall clock times unreliable, Table 3 provides the average number of seconds for a single run of each instance, including generating then strengthening VPCs. On average, cut generation takes, in total, from less than a second for two-term disjunctions to 50 s for 16-term disjunctions, 150 s for 32-term disjunctions, and nearly 9 min for 64-term disjunctions. The time per cut, on average, is less than 0.1 s for two-term disjunctions, ranging up to 9 s for 32 terms and over 30 s for 64 terms.  
   
  5  
   
  Choosing a Relaxation Amenable to Strengthening  
   
  In this section, we examine a potential cause of the diminishing eﬀect of monoidal strengthening with larger disjunctions. From Theorem 1, given an initial cut αT x ≥ β, we can strengthen coeﬃcient αk , k ∈ I, to  t  α  
   
  k = αk + inf max −ˆ uk + ut0 Δt mt , m∈M t∈T  
   
  Table 3. Average time (seconds) to generate the cuts in column V+ of Table 1. Statistic  
   
  Set  
   
  2 leaves 4 leaves 8 leaves 16 leaves 32 leaves 64 leaves  
   
  Cut time (s) All 0.76 ≥10% 0.92  
   
  6.39 9.31  
   
  15.33 21.06  
   
  49.90 130.45  
   
  149.84 273.51  
   
  525.78 521.99  
   
  Time/cut (s) All 0.08 ≥10% 0.07  
   
  0.39 0.35  
   
  0.97 0.79  
   
  2.65 2.46  
   
  9.00 7.75  
   
  30.54 20.19  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  287  
   
  t where u ˆtk = αk − (ut A·k + ut0 D·k ) is the slack on the CGLP constraint αk ≥ t . Equivalently, u ˆtk is the Farkas multiplier for the nonnegativity ut A·k + ut0 D·k constraint xk ≥ 0. The next lemma restates the (known) reason that a nonbasic integral variable k is required for monoidal strengthening.  
   
  Lemma 6. If u ˆtk = 0, then α  
   
  k = αk . Proof. In this case, α  
   
  k = αk + inf m∈M maxt∈T {ut0 Δt mt } . Since for every m ∈ M, and ut0 Δt ≥ 0, the optimal solution is m = 0.  
   
  t∈T  
   
  mt ≥ 0  
   
  In the correspondence in Sect. 3, we ultimately ﬁnd a point pt ∈ P t such that αT p : p ∈ P t }. We then compute a basis cone at pt α ¯ pt = β¯t , where β¯t = minp {¯ for which the cut is valid and use this (translated) cone to compute the values of the Farkas certiﬁcate. However, by complementary slackness, if ptk > 0, then necessarily u ˆtk = 0. Although at ﬁrst this appears simultaneously unfortunate and unavoidable, there are two potential remedies. First, there may be dual degeneracy in the choice of pt : each such point can lead to a diﬀerent Farkas certiﬁcate and therefore a diﬀerent strengthening. Second, as observed by Balas and Qualizza [6], “sometimes weaking a disjunction helps the strengthening”. Though in that context, the weakening involves adding terms to the disjunction, the sentiment ¯ then one can seek a diﬀerent, potentially applies to our setting as well: if β¯t > β, t ¯ T x ≥ β¯ infeasible, basis of Q in which more integer variables are nonbasic and α is still valid for the associated basis cone. The computational results support the above intuition. When VPCs are generated from a split disjunction, on average, around 95% of the generated cuts per instance have any coeﬃcient strengthened with the monoidal technique. This decreases to 85% for 64-term disjunctions. Furthermore, on average among VPCs to which strengthening has been applied, 20% of the cut coeﬃcients are strengthened for split disjunctions, while this value steadily decreases as disjunction size increases, so among the analogous VPCs from 64-term disjunctions, only 10% of the coeﬃcients are strengthened. T  
   
  6  
   
  Conclusion  
   
  We show that strengthening cuts from general disjunctions is possible without explicitly solving a higher-dimensional CGLP, and that this strengthening can have a high impact for certain instances. However, several challenges are also highlighted for future work. First, the strengthening does not work well on average for larger disjunctions. While we propose a viable explanation and remedy, it is computationally demanding and requires development. Second, the optimal monoidal strengthening involves solving an integer program per cut; this is a relatively small and easy problem, but it nonetheless can be slow for larger disjunctions, as suggested by Table 3, which includes strengthening time. One can reduce this load by selectively strengthening only the most promising cuts, identiﬁed by theoretical properties or good heuristics, or to forego optimality in  
   
  288  
   
  A. M. Kazachkov and E. Balas  
   
  the strengthened cut coeﬃcients. Our computational results indicate that VPCs and GMICs seem to have complementary aﬀects; understanding this better is an opportunity to more widely adopt disjunctive cuts.  
   
  References 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12.  
   
  13. 14. 15. 16. 17. 18. 19. 20. 21.  
   
  22.  
   
  COIN-OR Branch and Cut. https://github.com/coin-or/Cbc COIN-OR Cut Generation Library. https://github.com/coin-or/Cgl COIN-OR Linear Programming. https://github.com/coin-or/Clp Achterberg, T., Koch, T., Martin, A.: MIPLIB 2003. Oper. Res. Lett. 34(4), 361– 372 (2006) Andersen, K., Cornuéjols, G., Li, Y.: Split closure and intersection cuts. Math. Program., 102(3, Ser. A), 457–493 (2005) Balas, E., Qualizza, A.: Monoidal cut strengthening revisited. Discrete Optim. 9(1), 40–49 (2012) Balas, E.: Intersection cuts–a new type of cutting planes for integer programming. Oper. Res. 19(1), 19–39 (1971) Balas, E.: Disjunctive programming. Ann. Discrete Math. 5, 3–51 (1979) Balas, E., Jeroslow, R.G.: Strengthening cuts for mixed integer programs. Eur. J. Oper. Res. 4(4), 224–234 (1980) Balas, E., Kazachkov, A.M.: V-polyhedral disjunctive cuts (2022). https://arxiv. org/abs/2207.13619 Balas, E., Kis, T.: On the relationship between standard intersection cuts, lift-andproject cuts and generalized intersection cuts. Math. Program., 1–30 (2016) Balas, E., Perregaard, M.: A precise correspondence between lift-and-project cuts, simple disjunctive cuts, and mixed integer Gomory cuts for 0-1 programming. Math. Program. 94(2–3, Ser. B), 221–245 (2003). The Aussois 2000 Workshop in Combinatorial Optimization Balas, E., Qualizza, A.: Intersection cuts from multiple rows: a disjunctive programming approach. EURO J. Computat. Optim. 1(1), 3–49 (2013) Balas, E., Ceria, S., Cornuéjols, G.: A lift-and-project cutting plane algorithm for mixed 0-1 programs. Math. Program. 58(3, Ser. A), 295–324 (1993) Balas, E., Ceria, S., Cornuéjols, G.: Mixed 0-1 programming by lift-and-project in a branch-and-cut framework. Man. Sci. 42(9), 1229–1246 (1996) Basu, A., Bonami, P., Cornuéjols, G., Margot, F.: Experiments with two-row cuts from degenerate tableaux. INFORMS J. Comput. 23(4), 578–590 (2011) Bixby, R.E., Boyd, E.A., Indovina, R.R.: MIPLIB: a test set of mixed integer programming problems. SIAM News 25, 16 (1992) Bixby, R.E., Ceria, S., McZeal, C.M., Savelsbergh, M.W.P.: An updated mixed integer programming library: MIPLIB 3.0. Optima, 58, 12–15, 6 (1998) Bonami, P.: On optimizing over lift-and-project closures. Math. Program. Comput. 4(2), 151–179 (2012) Bonami, P., Conforti, M., Cornuéjols, G., Molinaro, M., Zambelli, G.: Cutting planes from two-term disjunctions. Oper. Res. Lett. 41(5), 442–444 (2013) Conforti, M., Cornuéjols, G., Zambelli, G.: Integer Programming, vol. 271 of Graduate Texts in Mathematics. Springer, Cham (2014). https://doi.org/10.1007/9783-319-11008-0 CORAL. Computational Optimization Research at Lehigh. MIP instances. https://coral.ise.lehigh.edu/data-sets/mixed-integer-instances/ (2020). Accessed Sept 2020  
   
  Monoidal Strengthening of Simple V-Polyhedral Disjunctive Cuts  
   
  289  
   
  23. Cornuéjols, G., Li, Y.: Elementary closures for integer programs. Oper. Res. Lett. 28(1), 1–8 (2001) 24. Dey, S.S., Wolsey, L.A.: Two row mixed-integer cuts via lifting. Math. Program. 124(1–2, Ser. B), 143–174 (2010) 25. Dey, S.S., Lodi, A., Tramontani, A., Wolsey, L.A.: On the practical strength of two-row tableau cuts. INFORMS J. Comput. 26(2), 222–237 (2014) 26. Espinoza, D.G.: Computing with multi-row Gomory cuts. Oper. Res. Lett. 38(2), 115–120 (2010) 27. Farkas, J.: Theorie der einfachen Ungleichungen. J. Reine Angew. Math. 124, 1–27 (1902) 28. Fischer, T., Pfetsch, M.E.: Monoidal cut strengthening and generalized mixedinteger rounding for disjunctions and complementarity constraints. Oper. Res. Lett. 45(6), 556–560 (2017) 29. Fischetti, M., Lodi, A., Tramontani, A.: On the separation of disjunctive cuts. Math. Program. 128(1–2, Ser. A), 205–230 (2011) 30. Fukasawa, R., Poirrier, L., Xavier, Á.S.: The (not so) trivial lifting in two dimensions. Math. Program. Comp. 11(2), 211–235 (2019) 31. Gleixner, A., et al.: MIPLIB 2017: Data-Driven compilation of the 6th mixedinteger programming library. Math. Prog. Comp., (2021) 32. Gomory, R.E., Johnson, E.L.: Some continuous functions related to corner polyhedra. Math. Program. 3(1), 23–85 (1972) 33. Guennebaud, G., et al.: Eigen v3. http://eigen.tuxfamily.org (2010) 34. Gurobi Optimization, LLC. Gurobi Optimizer Reference Manual (2022) 35. Johnson, E.L.: On the group problem for mixed integer programming. Math. Program. Stud. 2, 137–179 (1974) 36. Júdice, J.J., Sherali, H.D., Ribeiro, I.M., Faustino, A.M.: A complementarity-based partitioning and disjunctive cut algorithm for mathematical programming problems with equilibrium constraints. J. Global Optim. 36(1), 89–114 (2006) 37. Kazachkov, A.M.: Non-Recursive Cut Generation. PhD thesis, Carnegie Mellon University (2018) 38. Kazachkov, A.M., Serrano, F.: Monoidal cut strengthening. In: Prokopyev, O., Pardalos, P.M., editors, Encyclopedia of Optimization. Springer, US, Boston, MA. Under review 39. Kılınç, M., Linderoth, J., Luedtke, J., Miller, A.: Strong-branching inequalities for convex mixed integer nonlinear programs. Comput. Optim. Appl. 59(3), 639–665 (2014). https://doi.org/10.1007/s10589-014-9690-8 40. Kis, T.: Lift-and-project for general two-term disjunctions. Discrete Optim. 12, 98–114 (2014) 41. Koch, T., Achterberg, T., Andersen, E., Bastert, O., Berthold, T., Bixby, R.E., et al.: MIPLIB 2010: mixed integer programming library version 5. Math. Program. Comput. 3(2), 103–163 (2011) 42. Kronqvist, J., Misener, R.: A disjunctive cut strengthening technique for convex MINLP. Optim. Eng. 22(3), 1315–1345 (2021) 43. Lougee-Heimer, R.: The Common Optimization INterface for Operations Research: promoting open-source software in the operations research community. IBM J. Res. Dev. 47 (2003) 44. Louveaux, Q., Poirrier, L., Salvagnin, D.: The strength of multi-row models. Math. Program. Comput. 7(2), 113–148 (2015) 45. Nemhauser, G.L., Wolsey, L.A.: Integer and combinatorial optimization. WileyInterscience Series in Discrete Mathematics and Optimization. John Wiley & Sons Inc, New York (1988)  
   
  290  
   
  A. M. Kazachkov and E. Balas  
   
  46. Nemhauser, G.L., Wolsey, L.A.: A recursive procedure to generate all cuts for 0-1 mixed integer programs. Math. Program. 46(1), 379–390 (1990) 47. Perregaard, M.: Generating Disjunctive Cuts for Mixed Integer Programs. PhD thesis, Carnegie Mellon University, 9 (2003) 48. Perregaard, M., Balas, E.: Generating cuts from multiple-term disjunctions. In: Aardal, K., Gerards, B. (eds.) IPCO 2001. LNCS, vol. 2081, pp. 348–360. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-45535-3_27 49. Xavier, Á.S., Fukasawa, R., Poirrier, L.: Multirow intersection cuts based on the inﬁnity norm. INFORMS J. Comput. 33(4), 1624–1643 (2021) 50. Ziegler, G.M.: Lectures on Polytopes, vol. 152 of Graduate Texts in Mathematics. Springer-Verlag, New York (1995). https://doi.org/10.1007/978-1-4613-8431-1  
   
  Optimal General Factor Problem and Jump System Intersection Yusuke Kobayashi(B) Kyoto University, Kyoto, Japan [email protected]   
   
  Abstract. In the optimal general factor problem, given a graph G = (V, E) and a set B(v) ⊆ Z of integers for each v ∈ V , we seek for an edge subset F of maximum cardinality subject to dF (v) ∈ B(v) for v ∈ V , where dF (v) denotes the number of edges in F incident to v. A recent crucial work by Dudycz and Paluch shows that this problem can be solved in polynomial time if each B(v) has no gap of length more than one. While their algorithm is very simple, its correctness proof is quite complicated. In this paper, we formulate the optimal general factor problem as the jump system intersection, and reveal when the algorithm by Dudycz and Paluch can be applied to this abstract form of the problem. By using this abstraction, we give another correctness proof of the algorithm, which is simpler than the original one. We also extend our result to the valuated case.  
   
  1 1.1  
   
  Introduction General Factor Problem  
   
  Matching in graphs is one of the most well-studied topics in combinatorial optimization. Since a maximum matching algorithm was proposed by Edmonds [6] in 1960s, a lot of generalizations of the matching problem have been proposed and studied in the literature. Among them, we focus on the general factor problem, which contains several important problems as special cases. In the general factor problem (or also called B-factor problem), we are given a graph G = (V, E) and a set B(v) ⊆ Z of integers for each v ∈ V . The objective is to ﬁnd an edge subset F ⊆ E such that dF (v) ∈ B(v) for any v ∈ V if it exists, where dF (v) denotes the number of edges in F incident to v. Such an edge set is called a B-factor. Since the general factor problem is NP-hard in general (e.g. it contains the 3-edge-coloring problem [13]), polynomially solvable special cases have attracted attention. A B-factor amounts to a perfect matching if B(v) = {1} for each v ∈ V , and it is called a b-factor if B(v) = {b(v)} for each v ∈ V , where b : V → Z. For a, b : V → Z, if B(v) = {a(v), a(v) + 1, a(v) + 2, . . . , b(v) − 1, b(v)} (resp, B(v) = {a(v), a(v) + 2, a(v) + 4, . . . , b(v) − 2, b(v)}) for v ∈ V , then a B-factor is called an (a, b)-factor (resp. an (a, b)-parity factor ). It is well-known The full version is available at arXiv [10]. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 291–305, 2023. https://doi.org/10.1007/978-3-031-32726-1_21  
   
  292  
   
  Y. Kobayashi  
   
  that, in the above cases, we can ﬁnd a B-factor in polynomial time by using a maximum matching algorithm; see [13] and [23, Section 35]. Note that the parity constraint can be dealt with by adding 12 (b(v) − a(v)) self-loops to each v ∈ V and modifying B(v). Another special case is the antifactor problem, in which B(v) = {0, 1, 2, . . . , dE (v)} \ {αv } for some αv ∈ {0, 1, 2, . . . , dE (v)}, that is, exactly one value is forbidden for each v ∈ V . Graphs with an antifactor were characterized by Lov´ asz [14]. The edge-and-triangle partitioning problem is to cover all the vertices in a graph by edges and triangles that are mutually disjoint, which can be easily reduced to the general factor problem with B(v) = {1}, {0, 2}, or {0, 2, 3}. The edge-and-triangle partitioning problem is known to be solvable in polynomial time [4]. All the above polynomially solvable cases have a property that each B(v) has no gap of length more than one. Here, B(v) ⊆ Z is said to have a gap of length p if there exists α ∈ B(v) such that α+1, α+2, . . . , α+p ∈ B(v) and α+p+1 ∈ B(v). It turns out that this is a key property to design a polynomial-time algorithm. Indeed, Cornu´ejols [3] gave a polynomial-time algorithm for the general factor problem with this property and Seb˝ o [24] gave a good characterization. An optimization variant of the general factor problem has also attracted attention, which we call the optimal general factor problem (or the optimal general matching problem). In the problem, given a graph G = (V, E) and a set B(v) ⊆ Z of integers for each v ∈ V , we seek for a B-factor of maximum cardinality. It is the maximum matching problem if B(v) = {0, 1}, and is the maximum b-matching problem if B(v) = {0, 1, . . . , b(v)}, both of which can be solved in polynomial time. In the same way as the search problem described above, we can ﬁnd a maximum (a, b)-factor (or (a, b)-parity factor) in polynomial time; see [23, Section 35]. The optimization variant of the edge-and-triangle partitioning problem was studied with the name of the simplex matching problem, and a polynomial-time algorithm was designed for this problem [1]; see also [22]. Recently, Dudycz and Paluch [5] showed that the optimal general factor problem can be solved in polynomial time if each B(v) has no gap of length more than one. This is deﬁnitely a crucial result in this area, because it is a generalization of all the above results. While their algorithm is very simple, its correctness proof is quite complicated. 1.2  
   
  Jump System Intersection  
   
  In this paper, we introduce an abstract form of the optimal general factor problem by using the concept of jump systems introduced by Bouchet and Cunningham [2] (see also [9,17]). Let V be a ﬁnite set. For x, y ∈ ZV , we say that s ∈ ZV is an (x, y)-step if s1 = 1 and (x + s) − y1 = x − y1 − 1. A non-empty subset J ⊆ ZV is called a jump system if it satisﬁes the following property: (JUMP) For any x, y ∈ J and for any (x, y)-step s, either x + s ∈ J or there exists an (x + s, y)-step t such that x + s + t ∈ J. Typical examples of jump systems include matroids, delta-matroids, integral polymatroids (or submodular systems [7]), and degree sequences of subgraphs.  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  293  
   
  When J ⊆ Z is one-dimensional, one can see that J is a jump system if and only if it has no gap of length more than one. One can also see that the direct product of one-dimensional jump systems is also a jump system. We consider the optimization problem over the intersection of two jump systems, where one is the direct product of one-dimensional jump systems. Jump System Intersection Input. A jump system J ⊆ ZV , a ﬁnite one-dimensional jump system B(v) ⊆ Z for each v ∈ V , and a vector c ∈ ZV . Problem. Find a vector x ∈ J ∩ B maximizing c x, where B ⊆ ZV is the direct product of B(v)’s. If J consists of degree sequences of subgraphs, i.e., J = {dF ∈ ZV | F ⊆ E}, and c(v) = 1 for v ∈ V , then the problem amounts to the optimal general factor problem, which can be solved in polynomial time [5]. On the other hand, if J is a 2-polymatroid and B(v) = {0, 2} for each v ∈ V , then the problem amounts to the matroid matching problem [15] or the matroid parity problem [12]. This implies that the problem cannot be solved in polynomial time if J is given as a membership oracle [8,16]; see also [18]. A similar problem is to determine whether the intersection of two jump systems J1 and J2 is empty or not, which is also hard in general. This problem was studied in [17] as a membership problem of J1 − J2 := {x − y | x ∈ J1 , y ∈ J2 }, because J1 ∩ J2 = ∅ if and only if 0 ∈ J1 − J2 . 1.3  
   
  Our Contribution: Jump System with SBO Property  
   
  A natural question is why the optimal general factor problem can be solved eﬃciently, while the general setting of Jump System Intersection is hard. In this paper, we answer this question by revealing the properties of J that are essential in the argument in [5]. For a positive integer , we denote {1, 2, . . . , } by []. For x, y ∈ ZV , we say that a multiset {p1 , . . . , p } of vectors is a 2-step decomposition ofy − x if pi ∈ ZV and pi 1 = 2 for each i ∈ [], y − x1 = 2, and y − x = i∈[] pi . A non-empty subset J ⊆ ZV is called a jump system with SBO property1 if it satisﬁes the following property: (SBO-JUMP) For any x, y ∈ J, there exists a 2-step decomposition {p1 , . . . , p } of y − x such that x + i∈I pi ∈ J for any I ⊆ []. We can see that (SBO-JUMP) implies (JUMP). To see this, for given x, y ∈ J, suppose that there exist vectors p1 , . . . , p ∈ ZV satisfying the conditions in (SBO-JUMP). Then, for any (x, y)-step s, there exists an (x + s, y)-step t such that s + t = pi for some i ∈ [], and hence x + s + t = x + pi ∈ J. Therefore, if J is a jump system with SBO property, then it is a jump system such that v∈V x(v) has the same parity for any x ∈ J, which is called a constant parity jump system. See [21] for a characterization of constant parity jump systems. We now give a few examples of jump systems with SBO property. 1  
   
  SBO stands for strongly base orderable (see Example 1).  
   
  294  
   
  Y. Kobayashi  
   
  Example 1. A matroid M = (S, B) with a ground set S and a base family B is called strongly base orderable if, for any bases B1 , B2 ∈ B, there exists a bijection f : B1 \B2 → B2 \B1 such that (B1 \X)∪{f (x) | x ∈ X} ∈ B for any X ⊆ B1 \B2 (see e.g., [23, Section 42.6c]). By deﬁnition, the characteristic vectors of the bases of a strongly base orderable matroid satisfy (SBO-JUMP). Note that the characteristic vectors of the bases do not satisfy (SBO-JUMP) if the matroid is not strongly base orderable, which implies that the class of jump systems with SBO property is strictly smaller than that of constant parity jump systems. By merging some elements in Example 1, we obtain the following example, which was studied for linear matroids in a problem similar to Jump System Intersection [25]. Example 2. Let M = (S, B) be a strongly base orderable matroid and let (S1 , S2 , . . . , Sn ) be a partition of S. Then, J = {x ∈ Zn | B ∈ B, x(i) = |B ∩ Si | for i ∈ [n]} satisﬁes (SBO-JUMP). Another example is the set of the degree sequences of subgraphs. Example 3. Let G = (V, E) be a graph and let J be the set of the degree sequences of subgraphs, i.e., J = {dF | F ⊆ E}. Then, J satisﬁes (SBO-JUMP). To see this, for x, y ∈ J, let M, N ⊆ E be edge sets with dM = x and dN = y. Then, the symmetric diﬀerence of M and N can be decomposed into alternating paths P1 , . . . , P and alternating cycles such that {dN ∩Pi − dM ∩Pi | i ∈ []} is a 2-step decomposition of y − x. Note that each Pi is regarded  as an edge subset. ⊆ [], x + i∈I pi is the degree Let pi := dN ∩Pi − dM ∩Pi for i ∈ []. For any I  sequence of the symmetric diﬀerence of M and i∈[I] Pi , and hence it is in J. Our contribution is to introduce the jump system with SBO property and show that (SBO-JUMP) is crucial when we apply the algorithm in [5] for Jump System Intersection. For α, β ∈ Z with α ≤ β that have the same parity, a set {α, α + 2, . . . , β − 2, β} is called a parity interval. The main result in this paper is stated as follows. Theorem 1. There is an algorithm for Jump System Intersection whose    running time is polynomial in v∈V α∈B(v) log(|α| + 1) + v∈V log(|c(v)| + 1) if the following properties hold: (C1) a feasible solution x0 ∈ J ∩ B is given, (C2) J satisfies (SBO-JUMP), and (C3) for any direct product B  ⊆ ZV of parity intervals, there is an oracle for finding a vector x ∈ J ∩ B  maximizing c x. Note that no explicit representation of J is required in this theorem. We only need the oracle in Condition (C3). Note also that Condition (C3) implies the existence of the membership oracle of J. When J is the set of the degree sequences of subgraphs, we see that J satisﬁes (C1)–(C3) as follows. It was shown by Cornu´ejols [3] that a feasible solution x0 ∈ J∩B in (C1) can be found in polynomial time, and (C2) holds by Example 3.  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  295  
   
  The subproblem in (C3) is to ﬁnd a maximum (a, b)-parity factor, which can be solved in polynomial time. Our proof for Theorem 1 is based on the argument of Dudycz and Paluch [5]. While their algorithm is very simple, the correctness proof is quite complicated. In particular, an involved case analysis is required to prove a key lemma [5, Lemma 2]. Our technical contribution in this paper is to give a new simpler proof of this lemma in a slightly diﬀerent form (Lemma 1). In our proof, we use several properties that are peculiar to our problem formulation (see Sect. 4.1), which is an advantage of introducing the abstract form of the optimal general factor problem. We also show that a scaling technique used in [5] is not required in the algorithm, which is another contribution of this paper. We also introduce a quantitative extension of (SBO-JUMP), and extend Theorem 1 to a valuated variant of Jump System Intersection; see Theorem 2. 1.4  
   
  Organization  
   
  The rest of this paper is organized as follows. Some preliminaries are given in Sect. 2. In Sect. 3, we describe our algorithm and prove its correctness by using a key technical lemma (Lemma 1). A proof of Lemma 1 is given in Sect. 4, where properties shown in Sect. 4.1 play important roles to simplify the argument. In Sect. 5, we extend our results to the valuated case and show that a polynomial-time algorithm for the weighted general factor problem is derived from our results. Proofs of theorems/lemmas marked with () are omitted due to the page limitation and given in the full version [10].  
   
  2  
   
  Preliminaries  
   
  Let V be a ﬁnite set. For v ∈ V , let χv ∈ ZV denote the characteristic vector of v, that is, χv (v) = 1 and χv (u) = 0 for u ∈ V \ {v}. For each v ∈ V , we are given a non-empty ﬁnite set B(v) ⊆ Z that has no gap of length more than one, i.e., B(v) is a one-dimensional jump system. Throughout this paper, let B ⊆ ZV be the direct product of B(v)’s, i.e., B := {x ∈ ZV | x(v) ∈ B(v) for any v ∈ V }. For x ∈ ZV , we denote min B ≤ x ≤ max B if min B(v) ≤ x(v) ≤ max B(v) for every v ∈ V . For x ∈ ZV , we deﬁne q(x) = |{v ∈ V | x(v) ∈ B(v)}|. Note that, if min B ≤ x ≤ max B, then q(x) := miny∈B x − y1 , because each B(v) has no gap of length greater than one. Recall that a parity interval is a subset of Z that is of the form {α, α + 2, . . . , β − 2, β}. For v ∈ V , we see that B(v) is uniquely partitioned into inclusionwise maximal parity intervals (see Fig. 1), which we call maximal parity intervals of B(v). For α, β ∈ Z with min B(v) ≤ α ≤ β ≤ max B(v), we deﬁne distB(v) (α, β) as the number of maximal parity intervals of B(v) intersecting [α, β] minus one. In other words, distB(v) (α, β) is the number of pairs of consecutive integers in B(v) ∩ [α, β]. We also deﬁne  
   
  296  
   
  Y. Kobayashi  
   
  Fig. 1. Blue circles are elements in B(v) and red arrows are maximal parity intervals. (Color ﬁgure online)  
   
  distB(v) (β, α) := distB(v) (α, β). For x, y ∈ ZV with min B ≤ x, y ≤ max B, we deﬁne distB (x, y) := v∈V distB(v) (x(v), y(v)); see Fig. 2. Note that distB satisﬁes the triangle inequality.  
   
  Fig. 2. In this two-dimensional example, distB(v1 ) (x(v1 ), y(v1 )) = 3, distB(v2 ) (x(v2 ), y(v2 )) = 2, distB (x, y) = 5, x − y1 = 14, q(x) = 1, and q(y) = 0.  
   
  3  
   
  Algorithm and Correctness  
   
  Our algorithm for Jump System Intersection is basically the same as [5]. We ﬁrst initialize the vector x := x0 , where x0 is as in Condition (C1) in Theorem 1. In each iteration, we compute a vector x ∈ J ∩ B maximizing c x subject to distB (x, x ) ≤ 2. If c x = c x, then the algorithm terminates by returning x. Otherwise, we replace x with x and repeat the procedure. See Algorithm 1 for a pseudocode of the algorithm. In the correctness proof, we use the following key lemma, whose proof is given in Sect. 4. Note again that giving a simpler proof for this lemma is a technical contribution of this paper. Lemma 1. Let x, y ∈ B be vectors with distB (x, y) = 4, let {p1 , . . . , p } be a 2-step decomposition of y − x,  and let wi ∈ R for i ∈ []. Then, there exists a set I ⊆ [] such that z := x + i∈I pi is contained in B, distB (x, z) = 2, and   i∈I wi ≥ min{0, i∈[] wi }.  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  297  
   
  Algorithm 1: Algorithm for Jump System Intersection 1 2 3 4 5 6  
   
  Input: J, B, c, and x0 . Output: x ∈ J ∩ B maximizing c x. x ← x0 ; while true do Find a vector x ∈ J ∩ B maximizing c x subject to distB (x, x ) ≤ 2; if c x = c x then return x x ← x ;  
   
  Remark 1. In Lemma 1, the roles of x and y are symmetric by changing the signs of pi and wi , because I¯ := [] \ I satisﬁes the following:   – x + i∈I pi = y + i∈I¯(−pi ), –  distB (x, z) = 2 ⇐⇒  z) = 2,and     distB (y, ⇐⇒ – w ≥ min 0, w i i i∈I i∈[] i∈I¯(−wi ) ≥ min 0, i∈[] (−wi ) .  Let w ∈ R be the vector consisting of wi ’s, and denote w(I) := i∈I wi for I ⊆ []. We next show the following lemma. Note that almost the same result is shown for degree sequences in [5, Lemma 1]. Lemma 2. Let k be a positive integer. Let x, y ∈ B be vectors with distB (x, y) = 2k and let {p1 , . . . , p } be a 2-step decomposition of y −x. Then,  there exist index sets ∅ = I0  I1  I2  · · ·  Ik = [] such that zj := x + i∈Ij pi is contained in B and distB (zj−1 , zj ) = 2 for j ∈ [k]. Proof. It suﬃces to construct I1 ⊆ [] satisfying the conditions, because I2 , I3 , . . . , Ik−1 can be constructed in this order in the same way. By changing the direction of axes if necessary, we may assume that x(v) ≤ y(v) for every v ∈ V . Then, each pi is equal to χa + χb for some a, b ∈ V (possibly a = b). For z ∈ ZV , we denote φ(z) := (distB (x, z), q(z)) ∈ Z2≥0 . In order to construct I1 , we start with I := I0 = ∅ and add an element one by one to I. During  the procedure, we keep φ(z) ∈ {(0, 0), (0, 2), (1, 1), (2, 0)}, where z := x + i∈I pi . Note that φ(z) = (0, 0) when I is initialized to I0 . If φ(z) = (2, 0), then I1 := I clearly satisﬁes the conditions. Otherwise, it holds that φ(z) ∈ {(0, 0), (0, 2), (1, 1)}. In this case, we show that there exists an index i ∈ [] \ I such that φ(z + pi ) ∈ {(0, 0), (0, 2), (1, 1), (2, 0)} by the following case analysis. – Suppose that φ(z) = (0, 0). Let i be an arbitrary index in [] \ I. Then, pi = χa + χb for some a, b ∈ V (possibly a = b). We see that φ(z + χa ) ∈ {(0, 1), (1, 0)}, and hence φ(z + pi ) = φ(z + χa + χb ) ∈ {(0, 0), (0, 2), (1, 1), (2, 0)}. – Suppose that φ(z) = (0, 2). Then, z + χa + χb ∈ B for some distinct a, b ∈ V such that z(a) < y(a) and z(b) < y(b). Let i be an index in [] \ I such that pi = χa + χc for some c ∈ V (possibly c = a or c = b). Then, we see that φ(z +χa ) = (0, 1), and hence φ(z +pi ) = φ(z +χa +χc ) ∈ {(0, 0), (0, 2), (1, 1)}.  
   
  298  
   
  Y. Kobayashi  
   
  – Suppose that φ(z) = (1, 1). Then, z+χa ∈ B for some a ∈ V with z(a) < y(a). Let i be an index in [] \ I such that pi = χa + χb for some b ∈ V (possibly b = a). Then, we see that φ(z + χa ) = (1, 0), and hence φ(z + pi ) = φ(z + χa + χb ) ∈ {(1, 1), (2, 0)}. If φ(z + pi ) = (2, 0), then I1 := I ∪ {i} satisﬁes the conditions. Otherwise, we replace I with I ∪ {i} and repeat the procedure. Since [] is ﬁnite, this process   terminates by ﬁnding a desired index set I1 , which completes the proof. By using Lemmas 1 and 2, we can evaluate the improvement of the objective value in each iteration of Algorithm 1 as follows. Lemma 3. Let J be a jump system with SBO property, let x∗ ∈ J ∩ B be an optimal solution of Jump System Intersection, and let x ∈ J ∩ B be a vector with x = x∗ . Let x ∈ J ∩ B be a vector maximizing c x subject to 2 (c x∗ − c x). distB (x, x ) ≤ 2. Then, c x − c x ≥ x∗ −x 1 Proof. If distB (x, x∗ ) ≤ 2, then the inequality is obvious. Since distB (x, x∗ ) is even, suppose that distB (x, x∗ ) ≥ 4. Since x, x∗ ∈ J, there exists a 2-step decomposition {p1 , . . . , p } of x∗ −x that satisﬁes the conditions in (SBO-JUMP).  ∗  For i ∈ [], we deﬁne wi = c pi − c x −c x + ε, where ε is a suﬃciently small 1 positive number (e.g. ε = (+1) 2 ) that is used to break ties. Observe that, for   I, I ⊆ [] with |I| = |I |, w(I) = w(I  ) holds because of ε. By Lemma  2, there exist index sets ∅ = I0  I1  I2  · · ·  Ik = [] such that zj := x + i∈Ij pi is contained in B and distB (zj−1 , zj ) = 2 for j ∈ [k]. We choose I1 , I2 , . . . , Ik−1 so that (w(I1 ), w(I2 ), . . . , w(Ik−1 )) is lexicographically maximum. Note that zj ∈ J for j ∈ [k] by (SBO-JUMP). Let j ∈ [k] be the minimum index such that w(Ij−1 ) < w(Ij ). Note that such j must exist, because w(I0 ) = 0 < ε = w(Ik ). Assume that j = 1. Then, the minimality of j shows that w(Ij−2 ) > w(Ij−1 ) < w(Ij ), where we note that w(Ij−2 ) = w(Ij−1 ) as |Ij−2 | = |Ij−1 |. By applying Lemma 1 to a 2-step decomposition {pi | i ∈ Ij \I j−2 } of zj −zj−2 , we obtain an index set I ⊆ Ij \Ij−2  such that zj−1 := zj−2 + i∈I pi is contained in B, distB (zj−2 , z j−1 ) = 2, and   := Ij−2 ∪ I. By zj−1 = x + i∈I  pi and w(I) ≥ min{0, w(Ij \ Ij−2 )}. Let Ij−1 j−1  (SBO-JUMP), we see that zj−1 ∈ J. Furthermore, we obtain  w(Ij−1 ) = w(Ij−2 ) + w(I) ≥ min {w(Ij−2 ), w(Ij )} > w(Ij−1 ),  
   
  which contradicts the choice of Ij−1 . Therefore, we obtain j = 1, that is, 0 = w(I0 ) < w(I1 ). Since 0 < w(I1 ) =  
   
   i∈I1  
   
  c pi −  
   
   c x∗ − c x +ε   
   
  = c z1 − c x −  
   
   c x∗ − c x   
   
   − ε |I1 |  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  299  
   
  and ε is suﬃciently small, we obtain c z1 − c x ≥  
   
  (c x∗ − c x)|I1 | .   
   
  We also see that c x ≥ c z1 , because z1 ∈ J ∩ B and distB (x, z1 ) ≤ 2. By ∗ 1 combining these inequalities with |I1 | ≥ 1 and  = x −x , we obtain c x − 2 2   ∗    c x ≥ x∗ −x 1 (c x − c x). This implies that the global optimality is guaranteed by the local optimality. Corollary 1. In an instance of Jump System Intersection with (C2), a feasible solution x ∈ J ∩ B maximizes c x if and only if c x ≥ c x for any x ∈ J ∩ B with distB (x, x ) ≤ 2. We are now ready to prove the correctness of Algorithm 1. Proof (Proof of Theorem 1). We ﬁrst show that each iteration of Algorithm 1 runs in polynomial time. For x, x ∈ B with distB (x, x ) ≤ 2, we see that x(v) and x (v) are contained in the same maximal parity interval of B(v) for any v ∈ V except at most two elements. Thus, for x ∈ B, {x ∈ B | distB (x, x ) ≤ 2} can be partitioned into O(n2 ) sets, each of which is a direct product of parity intervals. Therefore, we can ﬁnd a vector x ∈ J ∩ B maximizing c x subject to distB (x, x ) ≤ 2 by using the oracle in Condition (C3), O(n2 ) times. We next evaluate the number of iterations inthe algorithm. Let OPT be the optimal value of the problem and let Bsize := v∈V |B(v)|. Since J is a jump system with SBO property by Condition (C2), we can apply Lemma 3. By this lemma, if x is replaced with x in line 6 of Algorithm 1, then  

  2 1 OPT − c x ≤ 1 − ∗ (OPT − c x) ≤ 1 − (OPT − c x), x − x1 Bsize 1 that is, the gap to the optimal value decreases by a factor of at most 1 − Bsize .  Therefore, by repeating this procedure O(Bsize log(OPT−c x0 )) times, the algorithm terminates and returns an optimal solution. This shows that Algorithm 1 solves Jump System Intersection in polynomial time.    
   
  4 4.1  
   
  Outline of the Proof of Lemma 1 Minimal Counterexample  
   
  This section gives an outline of the proof of Lemma 1. A tuple (x, y, (pi )i∈[] , w) is called an instance and a set I satisfying the conditions is called a solution. To derive a contradiction, assume that Lemma 1 does not hold. Suppose that (x, y, (pi )i∈[] , w) is a counterexample that minimizes y − x1 . Among such counterexamples, we choose one that minimizes |{(pi , wi ) | i ∈ []}|, that is, we  
   
  300  
   
  Y. Kobayashi  
   
  minimize the number of diﬀerent (pi , wi ) pairs. Such (x, y, (pi )i∈[] , w) is called a minimal counterexample. Deﬁne U ⊆ V as U := {v ∈ V | distB(v) (x(v), y(v)) ≥ 1}. By changing the direction of axes if necessary, we may assume that x(v) ≤ y(v) for every v ∈ V . Then, each pi is equal to χa +χb for some a, b ∈ V (possibly a = b). We show some properties of the minimal counterexample. Our argument becomes simpler with the aid of these properties. Lemma 4. For any i ∈ [], pi = χa + χb for some a, b ∈ U (possibly a = b). Consequently, x(v) = y(v) for all v ∈ V \ U . Proof. Assume to the contrary that there exists i ∈ [] such that pi = χa + χc for some a ∈ V and for some c ∈ V \ U . Suppose that a = c, i.e., pi = 2χc . We consider a new instance by removing pi and replacing y with y − 2χc ∈ B. By the minimality of the counterexample, the obtained instance has a solution I ⊆ [] \ {i}, which implies that w(I) ≥ 0 or w(I) ≥ w([] \ {i}). Then, I  := I is a solution of the original instance in the former case and I  := I ∪ {i} is a solution of the original instance in the latter case, which is a contradiction. Suppose next that a = c. Since distB(c) (x(c), y(c)) = 0 and x(c), y(c) ∈ B(c), we see that x(c) and y(c) have the same parity. Thus, there exists i ∈ [] \ {i} such that pi = χb + χc for some b ∈ V \ {c}. We merge pi and pi as follows: replace pi and pi with a new vector pi := χa + χb whose weight is wi + wi , and replace y with y − 2χc ∈ B. By the minimality of the counterexample, the obtained instance has a solution I ⊆ ([] \ {i, i }) ∪ {i }. Then, we see that the set (I \ {i }) ∪ {i, i } if i ∈ I,  I := I otherwise is a solution of the original instance, which is a contradiction.  
   
     
   
  Lemma 5. () For any i ∈ [], pi = 2χa for a ∈ U with distB(a) (x(a), y(a)) = 1. Lemma 6. For any i, j ∈ [] with pi = pj , it holds that wi = wj . Proof. Let (x, y, (pi )i∈[] , w) be a minimal counterexample of Lemma 1, and assume that pi = pj does not imply wi = wj . Let I ∗ ⊆ [] be a maximal index set such that pi = pj for any i, j ∈ I ∗ and wi = wj for some i, j ∈ I ∗ . We denote I ∗ = {i1 , i2 , . . . , it }, where wi1 ≥ wi2 ≥ · · · ≥ wit . Let w∗ := 1t w(I ∗ ). Deﬁne wi := w∗ for i ∈ I ∗ and wi := wi for i ∈ [] \ I ∗ . We note that w ([]) = w([]). If there exists a solution I  ⊆ [] for a new instance (x, y, (pi )i∈[] , w ), then I := (I  \ I ∗ ) ∪ {i1 , i2 , . . . , i|I  ∩I ∗ | } is a solution for the original instance (x, y, (pi )i∈[] , w), because wi1 + wi2 + · · · + wi|I  ∩I ∗ | ≥ |I  ∩ I ∗ | · w∗ = w (I  ∩ I ∗ ) implies that w(I) ≥ w(I  ). This shows that instance (x, y, (pi )i∈[] , w ) has no solution, and hence it is a counterexample. Since |{(pi , wi ) | i ∈ []}| < |{(pi , wi ) | i ∈ []}|, this contradics the minimality of   (x, y, (pi )i∈[] , w).  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  Let I + := {i ∈ [] | wi > 0} and z + := x+ the following.  
   
   i∈I +  
   
  301  
   
  pi . By Lemma 6, we observe  
   
  Observation 1. For any i ∈ I + and for any j ∈ [] \ I + , it holds that pi = pj . Since x(v) = y(v) = z + (v) for v ∈ V \ U by Lemma 4, it holds that q(z + ) ≤ |U | ≤ distB (x, y) = 4. We derive a contradiction for the cases when |U | = 4, |U | = 3, and |U | ≤ 2, separately. In this extended abstract we only consider the case when |U | = 3 as a demonstration. The other cases are dealt with in the full version [10]. In the case analysis, we use the following lemma, which is obtained by the same argument as Lemma 2. Here, we denote φ(z) := (distB (x, z), q(z)) ∈ Z2≥0 for z ∈ ZV .  Lemma 7. Let I0 ⊆ [] be an index set such that z0 := x + i∈I0 pi satisfies (2, 0)}. Then, there exists an index set I ⊆ [] with φ(z0 ) ∈ {(0, 0), (0, 2), (1, 1), I0 ⊆ I such that z := x + i∈I pi is contained in B and distB (x, z) = 2, i.e., φ(z) = (2, 0). 4.2  
   
  Part of Case Analysis: |U | = 3  
   
  In this extended abstract, we only consider the case when |U | = 3. Let U = {v1 , v2 , v3 } such that distB(v1 ) (x(v1 ), y(v1 )) = distB(v2 ) (x(v2 ), y(v2 )) = 1 and distB(v3 ) (x(v3 ), y(v3 )) = 2. By Lemmas 4 and 5, for any i ∈ [], either pi = χa +χb for some distinct a, b ∈ U or pi = 2χv3 . Since distB (x, z + )+distB (y, z + ) = 4, by changing the roles of x and y if necessary (see Remark 1), we may assume that distB (x, z + ) ≤ 2.2 Furthermore, since x − z + 1 is even, we see that distB (x, z + ) + q(z + ) is even. Therefore, the pair φ(z + ) := (distB (x, z + ), q(z + )) is one of the following: (0, 0), (0, 2), (1, 1), (1, 3), (2, 0), and (2, 2), where we note that q(z + ) ≤ |U | = 3. We derive a contradiction by considering each case separately. Case 1: φ(z + ) = (0, 0), (0, 2), (1, 1), or (2, 0). By Lemma 7, there exists an index set I ⊆ [] with I + ⊆ I such that  z := x + i∈I pi is contained in B and distB (x, z) = 2. Since wi ≤ 0 for each i ∈ [] \ I, we obtain w(I) ≥ w([]), and hence I is a solution of Lemma 1. This is a contradiction. Case 2: φ(z + ) = (1, 3). In this case, z + (v) ∈ B(v) for v ∈ U . Since z + (v1 ) = y(v1 ), there exists i ∈ []\I + such that pi = χv1 +χu for some u ∈ {v2 , v3 }. Since φ(z + +pi ) = (1, 1), + by Lemma  7, there exists an index set I ⊆ [] with I ∪ {i} ⊆ I such that z := x + j∈I pj is contained in B and distB (x, z) = 2. We see that such I is a solution of Lemma 1 in the same way as Case 1, which is a contradiction. 2  
   
   If we change the roles of x and y, then I − := {i ∈ [] | wi < 0} and z − := y− i∈I − pi + + + play the roles of I and z , respectively. We see that if distB (x, z ) ≥ 3, then distB (y, z − ) ≤ distB (y, z + ) = 4 − distB (x, z + ) ≤ 1.  
   
  302  
   
  Y. Kobayashi  
   
  Case 3: φ(z + ) = (2, 2). Since q(z + ) = 2 and |U | = 3, at least one of z + (v1 ) ∈ B(v1 ) and z + (v2 ) ∈ B(v2 ) holds. By changing the roles of v1 and v2 if necessary, we may assume that z + (v1 ) ∈ B(v1 ). Let v ∗ ∈ {v2 , v3 } be the other element such that z + (v ∗ ) ∈ B(v ∗ ). Since z + (v1 ) = x(v1 ), there exists i1 ∈ I + such that pi1 = χv1 + χu for some u ∈ {v2 , v3 }. Similarly, since z + (v1 ) = y(v1 ), there exists i2 ∈ [] \ I + such that pi2 = χv1 + χu for some u ∈ {v2 , v3 }. By Observation 1, either pi1 = χv1 + χv∗ or pi2 = χv1 + χv∗ holds (Fig. 3). If pi1 = χv1 + χv∗ , then I := I + \ {i1 } is a solution, because w(I) ≥ 0, which is a contradiction; see Fig. 3 (left two). If pi2 = χv1 + χv∗ , then I := I + ∪ {i2 } is a solution, because w(I) ≥ w([]), which is a contradiction; see Fig. 3 (right two).  
   
  Fig. 3. Possible situations in Case 3. A blue edge (u, v) corresponds to an element i ∈ [] \ I + with pi = χu + χv , a red dashed edge (u, v) corresponds to an element i ∈ I + with pi = χu + χv , and a vertex v ∈ V in a rectangle satisﬁes that z + (v) ∈ B(v). (Color ﬁgure online)  
   
  5  
   
  Extension to Valuated Problem  
   
  In this section, we consider a valuated version of Jump System Intersection. Valuated Jump System Intersection Input. A function f : J → Z on a jump system J ⊆ ZV and a ﬁnite onedimensional jump system B(v) ⊆ Z for each v ∈ V . Problem. Find a vector x ∈ J ∩ B maximizing f (x), where B ⊆ ZV is the direct product of B(v)’s. Note that f and J may be given in an implicit way, e.g., by an oracle. To simplify the notation, we extend the domain of f to ZV by setting f (x) = −∞ for x ∈ ZV \ J. The following property is a quantitative extension of (SBO-JUMP). (SBO-M-JUMP) For any x, y ∈ J, there exist real values  g1 , . . . , g and a2-step such that f (x+ i∈I pi ) ≥ f (x)+ i∈I gi decomposition {p1 , . . . , p } of y −x for any I ⊆ [] and f (y) = f (x) + i∈[] gi . Note that we use “M” in the name of the exchange axiom, because it deﬁnes a subclass of M-concave functions on constant parity jump systems [21]; see Remark 2 below. We can see that if f satisﬁes (SBO-M-JUMP), then its eﬀective domain J := {x ∈ ZV | f (x) > −∞} satisﬁes (SBO-JUMP). By using (SBO-MJUMP), we generalize Theorem 1 as follows.  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  303  
   
  Theorem 2. () There is an algorithm for Valuated Jump System Inter  section whose running time is polynomial in v∈V α∈B(v) log(|α| + 1) + maxx∈J log(|f (x)| + 1) if the following properties hold: (C1’) a vector x0 ∈ J ∩ B is given, (C2’) f satisfies (SBO-M-JUMP), and (C3’) for any direct product B  ⊆ ZV of parity intervals, there is an oracle for finding a vector x ∈ J ∩ B  maximizing f (x). Remark 2. Functions with (SBO-M-JUMP) form a subclass of M-concave functions on constant parity jump systems studied in the context of discrete convex analysis [11,19–21]. For J ⊆ ZV , a function f : J → Z is called an Mconcave function on a constant parity jump system [21] if it satisﬁes the following exchange axiom. (M-JUMP) For any x, y ∈ J and for any (x, y)-step s, there exists an (x + s, y)step t such that f (x + s + t) + f (y − s − t) ≥ f (x) + f (y). We can see that (SBO-M-JUMP) implies (M-JUMP) as follows. For x, y ∈ J, suppose that there exist a 2-step decomposition {p1 , . . . , p } of y − x and gi ∈ R for i ∈ [] satisfying the conditions in (SBO-M-JUMP). For any (x, y)-step s, there exists an (x + s, y)-step t such that s + t = pi for some i ∈ []. Such t satisﬁes the conditions in (M-JUMP), because    f (x + s + t) + f (y − s − t) = f (x + pi ) + f x + pj   
   
  j∈[]\{i}  
   
  ≥ (f (x) + gi ) + f (x) +  
   
    
   
   gj = f (x) + f (y).  
   
  j∈[]\{i}  
   
  6  
   
  Weighted Optimal General Factor Problem  
   
  It was shown by Dudycz and Paluch [5] that the edge-weighted variant of the optimal general factor problem can also be solved in polynomial time if each B(v) has no gap of length more than one. Formally, in the weighted optimal general factor problem, given a graph G = (V, E), an edge weight w(e) ∈ Z for e ∈ E, and a set B(v) ⊆ Z of integers F ⊆ E that  for each v ∈ V , we seek for a B-factor  maximizes its total weight e∈F w(e), where we denote w(F ) := e∈F w(e). Their algorithm consists of local improvement steps used in Algorithm 1 and a scaling technique. In what follows in this section, we show that the polynomial solvability of the weighted optimal general factor problem is derived from Theorem 2. Theorem 3 (Dudycz and Paluch [5]). The weighted optimal general factor problem can be solved in polynomial time if each B(v) has no gap of length more than one.  
   
  304  
   
  Y. Kobayashi  
   
  Proof. Let G = (V, E), w, and B be an instance of the weighted optimal general factor problem such that each B(v) has no gap of length more than one. Let J := {dF | F ⊆ E}, and deﬁne f : J → Z by f (x) := max{w(F ) | dF = x, F ⊆ E} for x ∈ J. We now show (C1’), (C2’), and (C3’) in Theorem 2. Since an edge set F0 ⊆ E with dF0 ∈ B can be found in polynomial time by the algorithm of Cornu´ejols [3] (if it exists), we obtain x0 := dF0 satisfying the condition in (C1’). The subproblem in (C3’) is to ﬁnd an (a, b)-factor with parity constraints that maximizes the total edge weight, which can be solved in polynomial time; see [23, Section 35]. To see (C2’), for x, y ∈ J, let M, N ⊆ E be edge sets such that dM = x, dN = y, w(M ) = f (x), and w(N ) = f (y). As in Example 3, the symmetric diﬀerence of M and N can be decomposed into alternating paths P1 , . . . , P and alternating cycles such that {dN ∩Pi − dM ∩Pi | i ∈ []} is a 2-step decomposition of y − x. For i ∈ [], let pi := dN ∩Pi − dM ∩Pi and ∩ Pi ) − w(M ∩ Pi ). For I ⊆ [], letFI ⊆ E be the symmetric diﬀerence gi := w(N   of M and i∈[I] Pi . Then, since dFI = x + i∈I pi and w(FI ) = f (x) + i∈I gi ,   we obtain f (x + i∈I pi ) ≥ f (x) + i∈I gi . This shows (C2’). By Theorem 2, we can ﬁnd x∗ ∈ J ∩ B maximizing f (x∗ ) in polynomial time. Furthermore, an edge set F ∗ ⊆ E satisfying w(F ∗ ) = f (x∗ ) and dF ∗ = x∗ can also be found in polynomial time by a weighted b-factor algorithm. By deﬁnition, such F ∗ is an optimal solution of the weighted optimal general factor problem.    
   
  7  
   
  Concluding Remarks  
   
  In this paper, we have revealed that (SBO-JUMP) is a key property to obtain a polynomial time-algorithm for Jump System Intersection, which is an abstract form of the optimal general factor problem. By using this abstraction, we have obtained a simpler correctness proof for the polynomial solvability of the optimal general factor problem. We have also extended the results to the valuated case. There are some possible directions for future research. It is nice if we obtain more examples of jump systems satisfying (SBO-JUMP) other than Examples 1– 3. It is open whether Jump System Intersection can be solved in polynomial time if each B(v) is given as a union of parity intervals. It is also a natural open problem whether we can obtain a strongly polynomial-time algorithm for the weighted general factor problem. Finally, it is interesting to ﬁnd a new property of J other than (SBO-JUMP) that enables us to design a diﬀerent polynomialtime algorithm. Acknowledgements. The author thanks Kenjiro Takazawa for his helpful comments. This work is supported by JSPS KAKENHI grant numbers 20K11692 and 20H05795, Japan.  
   
  Optimal General Factor Problem and Jump System Intersection  
   
  305  
   
  References 1. Anshelevich, E., Karagiozova, A.: Terminal backup, 3D matching, and covering cubic graphs. SIAM J. Comput. 40, 678–708 (2011) 2. Bouchet, A., Cunningham, W.H.: Delta-matroids, jump systems, and bisubmodular polyhedra. SIAM J. Discret. Math. 8, 17–32 (1995) 3. Cornu´ejols, G.: General factors of graphs. J. Comb. Theory Ser. B 45(2), 185–198 (1988) 4. Cornu´ejols, G., Hartvigsen, D., Pulleyblank, W.: Packing subgraphs in a graph. Oper. Res. Lett. 1(4), 139–143 (1982) 5. Dudycz, S., Paluch, K.E.: Optimal general matchings. In: WG 2018. LNCS, vol. 11159, pp. 176–189. Springer, Cham (2018). arXiv version is available at http:// arxiv.org/abs/1706.07418. https://doi.org/10.1007/978-3-030-00256-5 15 6. Edmonds, J.: Paths, trees, and ﬂowers. Can. J. Math. 17, 449–467 (1965) 7. Fujishige, S.: Submodular Functions and Optimization, 2nd edn, vol. 58. Annals of Discrete Mathematics. Elsevier, Amsterdam (2005) 8. Jensen, P.M., Korte, B.: Complexity of matroid property algorithms. SIAM J. Comput. 11, 184–190 (1982) 9. Kabadi, S.N., Sridhar, R.: Δ-matroid and jump system. J. Appl. Math. Decis. Sci. 2005(2), 95–106 (2005) 10. Kobayashi, Y.: Optimal general factor problem and jump system intersection. arXiv:2209.00779 (2022) 11. Kobayashi, Y., Murota, K., Tanaka, K.: Operations on M-convex functions on jump systems. SIAM J. Discret. Math. 21, 107–129 (2007) 12. Lawler, E.L.: Combinatorial Optimization – Networks and Matroids. Holt, Rinehalt, and Winston, New York (1976) 13. Lov´ asz, L.: The factorization of graphs. II. Acta Mathematica Academiae Scientiarum Hungarica 23, 223–246 (1972) 14. Lov´ asz, L.: Antifactors of graphs. Period. Math. Hung. 4, 121–123 (1973) 15. Lov´ asz, L.: The matroid matching problem. Algebr. Methods Graph Theory Colloq. Math. Soc. J´ anos Bolyai 25, 495–517 (1978) 16. Lov´ asz, L.: Matroid matching and some applications. J. Comb. Theory Ser. B 28, 208–236 (1980) 17. Lov´ asz, L.: The membership problem in jump systems. J. Comb. Theory Ser. B 70, 45–66 (1997) 18. Lov´ asz, L., Plummer, M.D.: Matching Theory. North-Holland, Amsterdam (1986) 19. Minamikawa, N., Shioura, A.: Time bounds of basic steepest descent algorithms for M-convex function minimization and related problems. J. Oper. Res. Soc. Jpn. 64(2), 45–60 (2021) 20. Murota, K.: Discrete Convex Analysis. SIAM, Philadelphia (2003) 21. Murota, K.: M-convex functions on jump systems: a general framework for minsquare graph factor. SIAM J. Discret. Math. 20, 213–226 (2006) 22. Pap, G.: A TDI description of restricted 2-matching polytopes. In: Bienstock, D., Nemhauser, G. (eds.) IPCO 2004. LNCS, vol. 3064, pp. 139–151. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-25960-2 11 23. Schrijver, A.: Combinatorial Optimization. Polyhedra and Eﬃciency. Algorithms and Combinatorics, vol. 24. Springer, Heidelberg (2003) 24. Seb˝ o, A.: General antifactors of graphs. J. Comb. Theory Ser.B 58(2), 174–184 (1993) 25. Szab´ o, J.: Matroid parity and jump systems: A solution to a conjecture of Recski. SIAM J. Discret. Math. 22(3), 854–860 (2008)  
   
  Decomposition of Probability Marginals for Security Games in Abstract Networks Jannik Matuschke(B) KU Leuven, Leuven, Belgium [email protected]  Abstract. Given a set system (E, P), let π ∈ [0, 1]P be a vector of requirement values on the sets and let ρ ∈ [0, 1]E be a vector of probability marginals with e∈P ρe ≥ πP for all P ∈ P. We study the question under which conditions the marginals ρ can be decomposed into a probability distribution on the subsets of E such that the resulting random set intersects each P ∈ P with probability at least πP . Extending a result by Dahan, Amin, and Jaillet [3] motivated by a network security game in directed acyclic graphs, we show that such a distribution exists if P  is an abstract network and the requirements are of the form πP = 1 − e∈P μe for some μ ∈ [0, 1]E . Our proof yields an explicit description of a feasible distribution that can be computed eﬃciently. As a consequence, equilibria for the security game studied in [3] can be eﬃciently computed even when the underlying digraph contains cycles. As a subroutine of our algorithm, we provide a combinatorial algorithm for computing shortest paths in abstract networks, partially answering an open question by McCormick [14]. We further show that a conservation law proposed in [3] for requirement functions in partially ordered sets can be reduced to the setting of aﬃne requirements described above.  
   
  1  
   
  Introduction  
   
  Consider a set system (E, P), where E is a ﬁnite ground set and P ⊆ 2E is a collection of subsets of E. Given probability marginals ρ ∈ [0, 1]E and requirements π ∈ [0, 1]P , we are interested in ﬁnding a probability distribution on the power set 2E of E that is consistent with these marginals and that ensures that each set in P ∈ P is hit with probability at least πP . In other words, we are looking for a solution x to the system    
   
  xS = ρe  
   
  ∀ e ∈ E,  
   
  (1)  
   
  xS ≥ πP S⊆E xS = 1,  
   
  ∀ P ∈ P,  
   
  (2) (3)  
   
  ≥ 0  
   
  ∀ S ⊆ E.  
   
  (4)  
   
  S⊆E:e∈S S⊆E:S∩P =∅  
   
    
   
  xS  
   
  Throughout this paper, we will call a distribution x fulﬁlling (1) to (4) a feasible decomposition of ρ for (E, P) and π, and we will say that the marginals ρ are feasible for (E, P) and π if such a feasible decomposition exists. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 306–318, 2023. https://doi.org/10.1007/978-3-031-32726-1_22  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  307  
   
  A necessary condition for the existence of a feasible decomposition is that the marginals suﬃce to cover each set of the system individually, i.e.,  ∀ P ∈ P. () e∈P ρe ≥ πP We are particularly interested in identifying classes of systems and requirement functions for which () is not only a necessary but also a suﬃcient condition. For such systems, the set of distributions on 2E fulﬁlling (2) can be described by the corresponding polytope of feasible marginals deﬁned by (), which is of exponentially lower dimension. 1.1  
   
  Motivation  
   
  A natural application for feasible decompositions in the setting described above lies in network security games; see, e.g., [1–3,8,16,17] for various examples and applications of network security games. In fact, such a game was also the motivation of Dahan, Amin, and Jaillet [3], who originally introduced the decomposition setting described above. We will discuss their game in detail in Sect. 5. Here, we describe a simpler yet relevant problem as an illustrative example. Consider the following game played on a set system (E, P), where each element e ∈ E is equipped with a usage cost ce ≥ 0 and an inspection cost de ≥ 0. A defender D determines a random subset S of elements from E to inspect at  cost e∈S de (e.g., a set of links of a network at which passing traﬃc is monitored). She anticipates that an attacker A is planning to carry out an illegal action, where A chooses a set in P ∈ P (e.g., a route in the network  along which he smuggles contraband), for which he will receive utility U1 − e∈P ce for some constant U1 > 0. However, if P intersects with the random set S of elements inspected by D, then A is discovered while carrying out his illegal action, reducing his utility by a penalty U2 ≥ U1 . The attacker also has the option to not carry out any attack, resulting in utility 0. Thus, A will  refrain from using P ∈ P if the probability that S ∩ P = ∅ exceeds πP := (U1 − e∈P ce )/U2 . A natural goal for D is to discourage A from attempting any attack at all, while keeping the incurred inspection cost as small as possible. Note that the randomized  that achieve this goal correspond exactly to vectors x that strategies minimize S⊆E e∈S de xS subject to constraints (2) to (4). Unfortunately, the corresponding LP has both an exponential number of variables and an exponential number of constraints in the size of the ground set E. However, assume that we can establish the following three properties for our set system: (i) condition () is suﬃcient for the feasibility of marginals, (ii) we can eﬃciently compute the corresponding feasible decompositions, and  γ . Then (i)allows us (iii) given γ ∈ RE e + , we can eﬃciently solve minP ∈P e∈P to formulate D’s problem in terms of the marginals, i.e., minρ∈[0,1]E e∈E de ρe subject to constraints (), (iii) allows us to separate the linear constraints () and obtain optimal marginals ρ, and (ii) allows us to turn these marginals into a distribution corresponding to an optimal inspection strategy for the defender D. In this paper, we will establish all three conditions for a generic type of set systems called abstract networks.  
   
  308  
   
  1.2  
   
  J. Matuschke  
   
  Abstract Networks  
   
  An abstract network consists of a set system (E, P) where each set P ∈ P (also referred to as an (abstract) path) is equipped with an internal linear order P of its elements, such that for all P, Q ∈ P and all e ∈ P ∩ Q there is a abstract path R ∈ P with R ⊆ {p ∈ P : p P e} ∪ {q ∈ Q : e Q q}. Given P, Q ∈ P and e ∈ P ∩ Q, we use the notation P ×e Q to denote an arbitrary but ﬁxed feasible choice for such an R ∈ P. Intuitively, this deﬁnition is an abstraction of the property of digraphs that one can construct a new path by concatenating a preﬁx and a suﬃx of two intersecting paths. Interesting special cases of abstract networks include P being the set of maximal chains in a partially ordered set (E, ) (here, P is simply the restriction of to P ) and P being the set of simple s-t-paths in a digraph D = (V, A) (here, E = V ∪ A and each path is identiﬁed with the sequence of its nodes and arcs). We remark that in both cases, the order P ×e Q is consistent with P and Q , which is not a general requirement for abstract networks; see, e.g., [10] for examples of abstract networks where this is not the case. Abstract networks were introduced by Hofmann [7] to illustrate the generality of Ford and Fulkerson’s [6] max-ﬂow/min-cut theorem.1 McCormick [14] provided a combinatorial algorithm for computing maximum ﬂows in abstract networks using a membership oracle that, given F ⊆ E, returns P ∈ P with P ⊆ F together with the corresponding order P , or certiﬁes that no such P exists. Martens and McCormick [12] later extended this result by giving a combinatorial algorithm for a weighted version of the problem, using a stronger oracle. Applications of abstract networks include, e.g., line planning for public transit systems [11] and route assignment in evacuation planning [9,15]. 1.3  
   
  Previous Results  
   
  Dahan et al. [3] studied the case where P is the set of maximal chains of a partially ordered set (poset), or, equivalently, the set of s-t-paths in a directed acyclic graph (DAG). They showed that () is suﬃcient for the existence of a feasible distribution when the requirements fulﬁll the following conservation law: πP + πQ = πP ×e Q + πQ×e P  
   
  ∀ P, Q ∈ P, e ∈ P ∩ Q.  
   
  (C)  
   
  Although their result is algorithmic, the corresponding algorithm requires explicitly enumerating all maximal chains and hence does not run in polynomial time in the size of E. However, Dahan et al. [3] provide a polynomial-time algorithm for the case of aﬃne requirements, in which there exists a vector μ ∈ [0, 1]E such that the requirements are of the form  πP = 1 − e∈P μ(e) ∀ P ∈ P. (A) 1  
   
  + Given an abstract network (E,  P) with capacities u ∈ RE + , a ﬂow is a vector f ∈ R fulﬁlling capacity constraints f ≤ u for all e ∈ E. The maximum e P ∈P:e∈P P  abstract ﬂow problem asks for a ﬂow of maximum value P ∈P fP . Hoﬀman [7] showed that the corresponding dual linear program is totally dual integral (even in a more general weighted setting), thus generalizing the max-ﬂow/min-cut theorem.  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  309  
   
  As a consequence of this latter result, the authors were able to characterize Nash equilibria for their network security game (which is a ﬂow-interdiction game played on s-t-paths in a digraph) by means of a compact arc-ﬂow LP formulation and compute such equilibria in polynomial time, under the condition that the underlying digraph is acyclic. Indeed, this positive result is particularly surprising, as similar—and seemingly simpler—ﬂow-interdiction games had previously been shown to be NP-hard, even on DAGs [5]. 1.4  
   
  Our Results  
   
  We extend the results of Dahan et al. [3] for posets/DAGs in multiple directions: 1. For the aﬃne requirements case (A), we show that () is a suﬃcient condition for the feasibility of marginals when (E, P) is an abstract network, by providing an explicit description of a feasible decomposition for this case, based on a natural generalization of shortest-path distances to abstract networks (see Sect. 2). The described solutions have the property that the sets in their support can be represented by an interval matrix. A special case of this result is the case where P is the set of s-t-paths in a digraph (which is not necessarily acyclic). In this case, a feasible decomposition can be computed eﬃciently by a single run of a standard shortest-path algorithm. 2. We also provide an algorithm for eﬃciently computing the corresponding feasible decompositions for the general case of an arbitrary abstract network given by a membership oracle (see Sect. 3). This algorithm makes use of the following result as a subroutine. 3. We provide a combinatorial strongly polynomial algorithm for computing shortest paths in abstract networks when P is given by a membership oracle (see Sect. 4). Beyond its relevance for the present work, this result also gives a partial answer to an open question by McCormick [14], who conjectured that such an algorithm might enable a strongly polynomial algorithm for computing maximum ﬂows in abstract networks. 4. As a consequence of our results, Nash equilibria for the network security game studied by Dahan et al. [3] can be described by a compact polyhedron and computed eﬃciently even when the game is played on an abstract network, including the case of a digraph with cycles (see Sect. 5). 5. We further show that the conservation law (C) proposed in [3] for maximal chains in posets can be reduced to the aﬃne requirements case (A) (see Sect. 6). We provide a polynomial-time algorithm for computing the corresponding weights μ when the requirements π are given by a value oracle. As a consequence, the corresponding feasible decompositions can be computed eﬃciently in this case as well. 6. Finally, we discuss other types of set systems (see Sect. 7). We observe that () is not suﬃcient for the feasibility of the marginals when P consists of the bases of a matroid, perfect matchings of a bipartite graph, or paths in a multicommodity network. We further show that deciding whether a given set of marginals is feasible is NP-hard in general, even when P is given by an explicit list of small sets and the requirements are all equal to 1.  
   
  310  
   
  1.5  
   
  J. Matuschke  
   
  Notation  
   
  Before we discuss our results in detail, we introduce some useful notation concerning abstract networks. Let (E, P) be an abstract network. For P ∈ P and e ∈ P , we use the following notation to denote preﬁxes of P ending at e and suﬃxes of P starting at e, respectively: [P, e] := {p ∈ P : p P e} (P, e) := {p ∈ P : p ≺P e}  
   
  [e, P ] := {p ∈ P : e P p} (e, P ) := {p ∈ P : e ≺P p}  
   
  For any path P ∈ P, we further denote the minimal and maximal element of P with respect to P by sP and tP , respectively. Throughout the paper, proofs of results marked with () can be found in the full version [13].  
   
  2  
   
  Feasible Decompositions in Abstract Networks  
   
  In this section we prove the following theorem, providing an explicit description of feasible decompositions of marginals in abstract networks assuming that requirements are of the form (A) and fulﬁll the necessary condition (). The construction, described in the following theorem, is based on a natural generalization of shortest-path distances in abstract networks. Theorem 1. Let (E, and let ρ, μ ∈ [0, 1]E fulﬁlling   P) be an abstract network condition (), i.e., e∈P ρe ≥ πP := 1 − e∈P μe for all P ∈ P. Deﬁne   αe := min and αe := min {αe , 1 − ρe } f ∈(Q,e) μf + ρf : Q ∈ P, e ∈ Q for e ∈ E. For τ ∼ U [0, 1] drawn uniformly at random from [0, 1], let Sτ := {e ∈ E : αe ≤ τ < αe + ρe }. Then x deﬁned by xS := Pr [Sτ = S] for S ⊆ E is a feasible decomposition of ρ for (E, P) and π. Intuitively, the values αe for e ∈ E in the construction above correspond to the “shortest-path distance” to element e in the abstract network (E, P), with the truncation of αe at 1 − ρe ensuring that [αe , αe + ρe ] ⊆ [0, 1]. Before we prove Theorem 1, let us ﬁrst discuss some of its implications. Interval Structure and Explicit Computation of x. Given the vector α, the nonzero entries of x can be easily determined in polynomial time. Indeed, note that the set Λ := {αe , αe + ρe : e ∈ E} induces a partition of [0, 1] into at most 2|E| + 1 intervals (each with two consecutive values from Λ ∪ {0, 1} as its endpoints), such that Sτ  = Sτ  whenever τ  and τ  are in the same interval. Thus, there are at most 2|E| + 1 non-zero entries in x, whose values can be determined by sorting Λ, determining all corresponding intervals, computing Sτ for one τ in each of these intervals, and then, for each occurring set S, setting xS to the total length of all intervals in which this set is attained.  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  311  
   
  Special Case: Directed Graphs. Consider the case where P is the set of simple s-t-paths in a digraph D = (V, A) and E = V ∪ A. For v ∈ V , let Psv denote the set of simple s-v-paths in D. If we are given explicit access to D (rather than accessing P via a membership oracle), we can compute feasible decompositions as follows. Without loss of generality, we can assume that for any v ∈ V and Q ∈ Psv there is Q ∈ Pst with Q ⊆ Q .2 Then αv = minQ∈Psv f ∈Q\{v} μf +ρf  for v ∈ V and αa = minQ∈Psv f ∈Q μf + ρf for a = (v, w) ∈ A. Hence, the vector α corresponds to shortest-path distances in D with respect to ρ + μ (with costs on both arcs and nodes). Both α and the corresponding feasible decomposition of ρ can be computed by a single run of Dijkstra’s [4] algorithm. Computing feasible decompositions in the general case of arbitrary abstract networks is more involved. We show how this can be achieved in Sect. 3. Proof of Theorem 1. We show that x as constructed in Theorem 1 is a feasible decomposition. Note that  x fulﬁlls (3) and (4) by construction. Note further that x fulﬁlls (1) because S⊆E:e∈S xS = Pr [e ∈ Sτ ] = Pr [αe ≤ τ < αe + ρe ] = ρe for all e ∈ E, where the second identity follows from 0 ≤ αe ≤ 1 − ρe . It remains to prove that x fulﬁlls (2). The following lemma will be helpful in this endeavour. Lemma 2. Given (E, P), ρ, μ, and α as described in Theorem 1, the following two conditions are fulﬁlled for every P ∈ P: 1. αtP + μtP + ρtP ≥ 1 and 2. for every e ∈ P \ {tP } there is e ∈ (e, P ) with αe ≤ αe + μe + ρe . Proof. We ﬁrst show statement 1. By contradiction assume αtP + μtP + ρtP < 1. Let Q ∈ P with tP ∈ Q and f ∈(Q,tP ) μf + ρf = αtP and let R := Q ×tP P .  Note  tP ] and hence e∈R μe + ρe ≤ αtP + μtP + ρtP < 1, implying  that R ⊆ [Q, e∈R ρe < 1 − e∈R μe , a contradiction to (). We now turn to statement 2. If αe ≥ 1 − μe − ρe , then the statement follows with e = tP because αtP≤ 1 ≤ αe + μe + ρe . Thus assume αe < 1 − μe − ρe and let Q ∈ P with αe = f ∈(Q,e) μf + ρf . Let R := Q ×e P . By () we observe  that f ∈R μf + ρf ≥ 1 > αe + μe + ρe , which implies R \ [Q, e] = ∅ because μ, ρ ≥ 0. Thus, let e ∈ R \ [Q, e] be minimal with respect to ≺R . Observe that R \ [Q, e] ⊆ (e, P ) and hence e ∈ (e, P ). The statement then follows from   αe ≤ f ∈(R,e ) μf + ρf ≤ f ∈[Q,e] μf + ρf = αe + μe + ρe , where the second inequality is due to the fact that (R, e ) ⊆ [Q, e] by choice of  e and the fact that μ, ρ ≥ 0. With the help of Lemma 2, we can prove that x fulﬁlls (2) as follows. Let P ∈ P. For e ∈ P deﬁne  μf . φ(e) := Pr [Sτ ∩ [P, e] = ∅ ∧ τ ≤ αe + ρe ] + f ∈[P,e] 2  
   
  This can be ensured by introducing arcs (v, t) with μ(v,t) = 1 and ρ(v,t) = 0 for all v ∈ V \ {t}. Note that this does not change the set of feasible decompositions of ρ.  
   
  312  
   
  J. Matuschke  
   
  Let F := {e ∈ P : φ(e) ≥ αe + μe + ρe }. We will show that tP ∈ F . Note that this suﬃces to prove (2), because the deﬁnition of F together with statement 1 of Lemma 2 imply φ(tP ) ≥ αtP + μtP + ρtP ≥ 1, which in turn yields    xS = Pr [Sτ ∩ P = ∅] ≥ φ(tP ) − μf ≥ 1 − μf = πP . S⊆E:S∩P =∅  
   
  f ∈P  
   
  f ∈P  
   
  We proceed to show tP ∈ F . By contradiction assume this is not the case. Note that F = ∅ because αsP = 0 and φ(sP ) = Pr [sP ∈ Sτ ] + μsP = ρsP + μsP . Thus let e ∈ F be maximal with respect to ≺P . Because e = tP , we can invoke statement 2 of Lemma 2 and obtain e ∈ (e, P ) with αe ≤ αe + μe + ρe .  
   
  (5)  
   
  We will show that e ∈ F , contradicting our choice of e. Note that the deﬁnition of φ and the fact that e P e imply φ(e ) ≥ φ(e) + Pr [e ∈ Sτ ∧ τ > αe + ρe ] + μe ≥ αe + μe + ρe + Pr [e ∈ Sτ ∧ τ > αe + ρe ] + μe ,  
   
  (6)  
   
  where the second inequality follows from e ∈ F . Moreover, observe that e ∈ Sτ if and only if αe ≤ τ < αe + ρe and hence Pr [e ∈ Sτ ∧ τ > αe + ρe ] = αe + ρe − max{αe , αe + ρe } ≥ αe + ρe − (αe + μe + ρe ), where the inequality follows from (5). Combining this bound with (6) yields φ(e ) ≥ αe + μe + ρe and hence e ∈ F , contradicting our choice of e and completing the proof of Theorem 1.    
   
  3  
   
  Computing Feasible Decompositions  
   
  Complementing our existence result from the previous section, we now discuss how to compute corresponding feasible decompositions. We will assume that the ground set E is given explicitly, while the set of abstract paths P is given by a membership oracle that, given F ⊆ E, either returns P ∈ P with P ⊆ F and the corresponding order P , or conﬁrms that no P ∈ P with P ⊆ F exists. By our arguments in Sect. 2, it suﬃces to compute the values of αe for all e ∈ E. Unfortunately, a complication arises in that even ﬁnding a path containing a certain element e ∈ E is NP-hard.3 However, as we show below, it is possible to identify a subset U ⊆ E for which we can compute the values of α, while the elements in E \U turn out to be redundant w.r.t. the feasibility of the marginals. From this, we obtain the following theorem. 3  
   
  Note that even for the special case where P corresponds to the set of simple s-t-paths in a digraph, ﬁnding P ∈ P containing a certain arc e is equivalent to the 2-disjoint path problem (for P to be simple, its preﬁx up to the tail of e and its suﬃx starting from the head of e must be disjoint). Simply side-stepping this issue by introducing additional elements as done in the second remark after Theorem 1 is not possible here, because we are restricted to accessing P only via the membership oracle.  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  313  
   
  Theorem 3. There is an algorithm that, given an  abstract network (E, P) via a membership oracle and ρ, μ ∈ [0, 1]E such that e∈P ρe ≥ πP := 1 − e∈P μe for all P ∈ P, computes a feasible decomposition of ρ for (E, P) and π in time O(|E|3 ·TP ), where TP denotes the time for a call to the membership oracle of P. The Algorithm. Theorem 3 is established via Algorithm 1, which computes values α ¯ e for elements e in a subset U ⊆ E as follows.Starting from U = ∅, the algorithm iteratively computes a path P minimizing f ∈P ∩U μf + ρf and adds the ﬁrst element e of P \ U to U , determining α ¯ e based on the length of (P, e). Algorithm 1: Computing a feasible decomposition Initialize U := ∅.  while minP ∈P f ∈P ∩U μf + ρf < 1 do  Let P ∈ argminP ∈P f ∈P ∩U μf + ρf . Let e := minP P \ U .   Set U := U ∪ {e} and α ¯ e := min f ∈(P,e) μf + ρf , 1 − ρe . return α, ¯ U  
   
  Analysis. First note  that in every iteration of the while loop, the set P \ U is nonempty because f ∈P μf + ρf ≥ 1 by the assumption on the input in Theorem 3. Hence the algorithm is well-deﬁned and terminates  after at most |E| iterations. We further remark that ﬁnding P ∈ P minimizing e∈P ∩U ρf + μf can be done in time O(|E|2 TP ) using the Algorithm 2 described in Sect. 4. The following lemma then suﬃces to complete the proof of Theorem 3. Lemma 4 (). Let α ¯ , U be the output of Algorithm 1 and deﬁne ρ¯e := ρe and ¯e := 0 for e ∈ E \ U . Then μ ¯e := μe for e ∈ U and ρ¯e := 0 and μ   ¯e ≥ π ¯P := 1 − e∈P μ ¯e for all P ∈ P and 1. e∈P ρ  ¯f + ρ¯f : Q ∈ P, e ∈ Q ∪ {1 − ρ¯e } for all e ∈ U . 2. α ¯ e = min f ∈(Q,e) μ Indeed, observe that Lemma 4 together with Theorem 1 implies that α ¯ induces a feasible decomposition x ¯ of ρ¯ for (E, P) and π ¯ . Because ρ¯e ≤ ρe for all e ∈ E and π ¯P ≥ πP for all P ∈ P, this decomposition can be extended to a feasible decomposition of ρ for (E, P) and π by arbitrarily incorporating the elements from E \ U . This completes the proof of Theorem 3.  
   
  4  
   
  Computing Shortest Paths in Abstract Networks  
   
  In this section, we consider the following natural generalization of the classic shortest s-t-path problem in digraphs: Given an abstractnetwork (E, P) and a cost vector γ ∈ RE + , ﬁnd a path P ∈ P minimizing e∈P γe . We provide a combinatorial, strongly polynomial algorithm for this problem, accessing P only via a membership oracle. In fact, the question for such an algorithm was  
   
  314  
   
  J. Matuschke  
   
  already raised by McCormick [14], who conjectured that it can be used to turn (an adaptation of) his combinatorial, but only weakly polynomial algorithm for the maximum abstract ﬂow problem into a strongly polynomial one. Our results show that such a shortest-path algorithm indeed exists, but leave it open how to use it to improve the running time of the maximum abstract ﬂow algorithm. Theorem 5. There is an algorithm that, given an abstract network (E, P) via  a membership oracle and γ ∈ RE + computes P ∈ P minimizing e∈P γe in time O(|E|2 ·TP ), where TP denotes the time for a call to the membership oracle of P. The Algorithm. For notational convenience, we assume that there is s, t ∈ E with sP = s and tP = t for all P ∈ P. Note that this assumption is without loss of generality, as it can be ensured by adding dummy elements s and t to E and including them at the start and end of each path, respectively. The algorithm is formally described as Algorithm 2. It can be seen as a natural extension of Dijkstra’s [4] algorithm in that it maintains for each element e ∈ E a (possibly inﬁnite) label ψe indicating the length of the shortest segment [Qe , e] for some Qe ∈ P with e ∈ Qe found so far, and in that its outer loop iteratively chooses an element with currently smallest label for processing. However, updating these labels is more involved, as an abstract network does not provide local concepts such as “the set of arcs leaving a node”. In its inner loop, the algorithm therefore carefully tries to extend the segment Qe for the currently processed element e to ﬁnd new shortest segments Qe for other elements e . Algorithm 2: Computing a shortest path in an abstract network Initialize T := ∅, ψs := γs , and ψe := ∞ for all e ∈ E \ {s}. Let Qs ∈ P. while ψt > minf ∈E\T ψf do Let e ∈ argminf ∈E\T ψf . Let F := (E \ T ) ∪ [Qe , e]. while there is P ∈ P with P ⊆ F do Let e := minP P \ [Qe , e]. SetF := F \ {e }.  if f ∈[P,e ] γf < ψe then  Set ψe := f ∈[P,e ] γf and Qe := P . Set T := T ∪ {e}. return Qt  
   
  Analysis. The proof of the correctness of Algorithm 2 crucially relies on the following lemma, which essentially certiﬁes that the algorithm does not overlook any shorter path segments when processing an element. Lemma 6 (). Algorithm 2 maintains the following invariant: For all P ∈ P, there is e ∈ P with [e, P ] ∩ T = ∅ and ψe ≤ f ∈[P,e] γf .  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  315  
   
  Proof of Theorem 5. When Algorithm 2 terminates, ψt ≤ ψf for all f ∈ E \ T by the termination criterion of the outer while  loop. Let P ∈ P. By Lemma 6 there is an element e ∈ P \ T with ψe ≤ f ∈[P,e] γf . Note that this implies    f ∈Qt γf = ψt ≤ ψe = f ∈[P,e] γf ≤ f ∈P γf , where the last inequality uses the fact that γf ≥ 0 for all f ∈ E. We conclude that the path Qt returned by the algorithm is indeed a shortest path. To see that the algorithm terminates in polynomial time, observe that the outer while loop stops after at most |E| − 1 iterations, as in each iteration an element from E \ {t} is added to T and the termination criterion is fulﬁlled if T = E \ {t}. Furthermore, each iteration of the inner while loop removes an element from F and hence after at most |F | ≤ |E| iterations no path P ⊆ F exists anymore, implying that the inner while loop terminates.    
   
  5  
   
  Dahan et al.’s Network Security Game  
   
  Dahan et al. [3] studied the following network security game. The input is a E set system (E, P) with capacities u ∈ RE + , transportation cost c ∈ R+ and E the routing entity R, whose interdiction costs d ∈ R+ . There are two players:  : strategy space is the set of ﬂows F := {f ∈ RP + P ∈P:e∈P fP ≤ ue ∀e ∈ E}, and the interdictor I, who selects a subset of elements S ⊆ E to interdict, with the intuition that all ﬂow on interdicted elements is disrupted. Given strategies f ∈ F and S ⊆ E, the payoﬀs for R and I, respectively, are given by    PR (f, S) := P ∈P:P ∩S=∅ fP − P ∈P e∈P ce fP and   PI (f, S) := P ∈P:P ∩S=∅ fP − e∈S de , respectively. That is, R’s payoﬀ is the total amount of non-disrupted ﬂow, reduced by the cost for sending ﬂow f , while I’s payoﬀ is the total amount of ﬂow that is disrupted, reduced by the interdiction cost for the set S. We are interested in ﬁnding (mixed) Nash equilibria (NE) for this game, i.e., random distributions σR and σI over the strategy spaces of I and R, respectively, such that no player can improve their expected payoﬀ by unilateral deviation. However, the eﬃcient computation of such equilibria is hampered by the fact that the strategy spaces of both players are of exponential size/dimension in the size of the ground set E. To overcome this issue, Dahan et al. [3] proposed to consider the following pair of primal and dual linear programs:   πPc fP [LPI ] min ue μe +de ρe [LPR ] max P ∈P  
   
  s.t.  
   
  e∈E  
   
    
   
  fP ≤ ue ∀e ∈ E  
   
  P ∈P:e∈P  
   
    
   
  fP P ∈P:e∈P where πPc := 1 −  
   
    
   
  μe + ρe ≥ πPc ∀P ∈ P  
   
  e∈P  
   
  ≤ de ∀e ∈ E  
   
  f ≥0  
   
  a∈P  
   
  s.t.  
   
    
   
  μ≥0 ρ ≥ 0,  
   
  ca . Dahan et al. [3] showed the following result.  
   
  316  
   
  J. Matuschke  
   
  Theorem 7 (Dahan et al. [3]). Let f ∗ and (μ∗ , ρ∗ ) be optimal solutions Let σI be a feasible decomposition of ρ∗ for to [LPR ] and [LPI ], respectively.  c ∗ (E,  P) and πP :=∗ πP − e∈P μe and let σR be a distribution over F with f ∈F σR,f fP = fP . Then (σR , σI ) is a Nash equilibrium. In particular, note that any  feasible solution to [LPI ] deﬁnes marginals ρ that fulﬁl () for πP := πPc − e∈P μe . Hence, if condition () is suﬃcient for feasibility of marginals in the set system P under aﬃne requirements, any pair of optimal solutions to the LPs induces a Nash equilibrium. If we can moreover eﬃciently compute optimal solutions to the LPs and the corresponding feasible decompositions, we can eﬃciently ﬁnd a Nash equilibrium. Dahan et al. [3] showed that this is possible when P is the set of s-t-paths in a DAG. Hence NE for the game can be found eﬃciently in that setting. This positive result is particularly interesting because NE are hard to compute for the variant of the game in which the interdictor is limited by a budget, even when interdiction costs are uniform, transportation costs are zero, and the game is played on a DAG [5]. Our results in Sects. 2 to 4 imply that all three conditions for the computability of NE are also met when (E, P) is an abstract network (note that we can use Algorithm 2 to separate the constraints of [LPI ]). Hence we can compute Nash equilibria for the above game when (E, P) is an abstract network given by a membership oracle, in time polynomial in |E|, including the case where the game is played on a digraph with cycles. We remark that Dahan et al. [3] also showed that, if there is at least one dual solution with a decomposition that assigns positive probability to the empty set, then all NE of the game are of the form described in Theorem 7. They showed that this condition is always fulﬁlled in the DAG case when all transportation costs are positive. Via a small adjustment to our construction in Sect. 2, the same result can be proven for the case of abstract networks ().  
   
  6  
   
  The Conservation Law for Partially Ordered Sets  
   
  As discussed in Sect. 1, Dahan et al. [3] established the suﬃciency of () in partially ordered sets not only for the case of aﬃne requirements (A) but also for the case where requirements fulﬁll the conservation law (C). However, they left it open whether it is possible to eﬃciently compute the corresponding decompositions in the latter case. In this section, we resolve this question by showing that the conservation law (C) for maximal chains in a poset can be reduced to the case of aﬃne requirements (A) in the corresponding Hasse diagram,4 for which a feasible decomposition then can be computed eﬃciently. Theorem 8 (). Let D = (V, A) be a directed acyclic graph, let s, t ∈ V , and let P ⊆ 2V ∪A be the set of s-t-paths in D. Let π ∈ [0, 1]P such that (C) is fulﬁlled. Then there exists μ ∈ [0, 1]V ∪A such that πP = 1 − e∈P μe . Furthermore, μ can be computed in strongly polynomial time in |V | and |A| when π is given by an oracle that, given P ∈ P, returns πP . 4  
   
  See [13] for details on why the transformation to the Hasse diagram is necessary.  
   
  Decomposition of Probability Marginals in Abstract Networks  
   
  317  
   
  Proof(sketch). By Farkas’ lemma, the existence of μis equivalent to showing that P ∈P (1 − πP )yP ≥ 0 for every y ∈ RP with P ∈P:e∈P yP ≥ 0 for all e ∈ V ∪ A. This property can be established by iteratively applying (C) to   transform y into a nonnegative vector without changing P ∈P (1 − πP )yP .   
   
  7  
   
  Other Set Systems  
   
  The results in this paper lead to the question whether suﬃciency of () and computability of feasible decompositions can be established for other set systems, beyond abstract networks. We give negative answers for several natural candidates of such systems and point out interesting questions for future research. Suﬃciency of () (). There are simple counterexamples for the suﬃciency of () in the following cases, even when assuming that π ≡ 1: when P is the set of bases of a matroid; when P is the set of perfect matchings in a bipartite graph; when P is the set of si -ti -paths in a digraph with multiple terminal pairs (si , ti ). An interesting question in this context is whether we can describe the systems for which () is suﬃcient by means of forbidden substructures. Approximately Feasible Decompositions (). Given the non-existence result mentioned above, one may be interested in ﬁnding decompositions that satisfy the requirements at least approximately. We say a decomposition x of marginals ρ is β-approximately feasible, for β ∈ [0, 1], if it fulﬁlls (1), (3), (4)  and S⊆E:S∩P =∅ xS ≥ β · πP for all P ∈ P. Indeed, if marginals ρ fulﬁll () for requirements π, a (1 − 1/e)-approximately feasible decomposition always exists: Simply include each element e ∈ E in the random set independently with probability ρe . An interesting question for future research is whether better guarantees may be achieved for some classes of systems. Computing Feasible Decompositions and Optimization (). For a given instance, we may also be interested in ﬁnding a decomposition of the given marginals that is β-approximately feasible for the largest possible value of β. Note that this also includes the case of ﬁnding a feasible decomposition if it exists (resulting in β = 1). Unfortunately, this latter problem is NP-complete, even in quite restricted cases, as evidenced by the theorem below. However, note that this hardness result still leaves room for approximating the best possible β. Theorem 9 (). The following decision problem is NP-complete: Given a set system (E, P) with |P | = 3 for all P ∈ P and marginals ρ ∈ [0, 1]E , is there a feasible decomposition of ρ for (E, P) and requirement vector π ≡ 1? Acknowledgements. The author thanks three anonymous reviewers for numerous helpful suggestions that improved the manuscript. This work has been supported by the special research fund of KU Leuven (project C14/22/026).  
   
  318  
   
  J. Matuschke  
   
  References 1. Bertsimas, D., Nasrabadi, E., Orlin, J.B.: On the power of randomization in network interdiction. Oper. Res. Lett. 44, 114–120 (2016) 2. Correa, J., Harks, T., Kreuzen, V.J., Matuschke, J.: Fare evasion in transit networks. Oper. Res. 65, 165–183 (2017) 3. Dahan, M., Amin, S., Jaillet, P.: Probability distributions on partially ordered sets and network interdiction games. Math. Oper. Res. 47, 458–484 (2022) 4. Dijkstra, E.W.: A note on two problems in connexion with graphs. Numer. Math. 269, 271 (1959) 5. Disser, Y., Matuschke, J.: The complexity of computing a robust ﬂow. Oper. Res. Lett. 48, 18–23 (2020) 6. Ford, L.R., Fulkerson, D.R.: Maximal ﬂow through a network. Can. J. Math. 8, 399–404 (1956) 7. Hoﬀman, A.J.: A generalization of max ﬂow–min cut. Math. Program. 6, 352–359 (1974) 8. Holzmann, T., Smith, J.C.: The shortest path interdiction problem with randomized interdiction strategies: Complexity and algorithms. Oper. Res. 69, 82–99 (2021) 9. Kappmeier, J.P.W.: Generalizations of ﬂows over time with applications in evacuation optimization, Ph. D. thesis, TU Berlin (2015) 10. Kappmeier, J.P.W., Matuschke, J., Peis, B.: Abstract ﬂows over time: a ﬁrst step towards solving dynamic packing problems. Theoret. Comput. Sci. 544, 74–83 (2014) 11. Karbstein, M.: Line planning and connectivity, Ph. D. thesis, TU Berlin (2013) 12. Martens, M., McCormick, S.T.: A polynomial algorithm for weighted abstract ﬂow. In: Lodi, A., Panconesi, A., Rinaldi, G. (eds.) IPCO 2008. LNCS, vol. 5035, pp. 97–111. Springer, Heidelberg (2008). https://doi.org/10.1007/978-3-540-68891-4 7 13. Matuschke, J.: Decomposition of probability marginals for security games in abstract networks. Tech. rep., arXiv:2211.04922 (2022) 14. McCormick, S.T.: A polynomial algorithm for abstract maximum ﬂow. In: Proceedings of the 7th annual ACM-SIAM Symposium on Discrete Algorithms, pp. 490–497 (1996) 15. Pyakurel, U., Khanal, D.P., Dhamala, T.N.: Abstract network ﬂow with intermediate storage for evacuation planning. Eur. J. Oper. Res. 305, 1178–1193 (2022) 16. Szeszl´er, D.: Security games on matroids. Math. Program. 161, 347–364 (2017) 17. Tambe, M.: Security and game theory: Algorithms, deployed systems, lessons learned. Cambridge University Press (2011)  
   
  Set Selection Under Explorable Stochastic Uncertainty via Covering Techniques Nicole Megow  
   
  and Jens Schlöter(B)  
   
  Faculty of Mathematics and Computer Science, University of Bremen, Bremen, Germany {nmegow,jschloet}@uni-bremen.de Abstract. Given subsets of uncertain values, we study the problem of identifying the subset of minimum total value (sum of the uncertain values) by querying as few values as possible. This set selection problem falls into the ﬁeld of explorable uncertainty and is of intrinsic importance therein as it implies strong adversarial lower bounds for a wide range of interesting combinatorial problems such as knapsack and matchings. We consider a stochastic problem variant and give algorithms that, in expectation, improve upon these adversarial lower bounds. The key to our results is to prove a strong structural connection to a seemingly unrelated covering problem with uncertainty in the constraints via a linear programming formulation. We exploit this connection to derive an algorithmic framework that can be used to solve both problems under uncertainty, obtaining nearly tight bounds on the competitive ratio. This is the ﬁrst non-trivial stochastic result concerning the sum of unknown values without further structure known for the set. With our novel methods, we lay the foundations for solving more general problems in the area of explorable uncertainty.  
   
  Keywords: explorable uncertainty  
   
  1  
   
  · queries · set selection · set cover  
   
  Introduction  
   
  In the setting of explorable uncertainty, we consider optimization problems with uncertainty in numeric input parameters. Instead of having access to the precise numeric values, we are given uncertainty intervals that contain the precise values. Each uncertainty interval can be queried, which reveals the corresponding precise value. The goal is to adaptively query intervals until we have suﬃcient information to optimally (or approximately) solve the underlying optimization problem, while minimizing the number of queries. We mainly consider the set selection problem (MinSet) under explorable uncertainty. In this problem, we are given a set of n uncertain values represented by uncertainty intervals I = {I1 , . . . , In } and a family of m sets S = {S1 , . . . , Sm } with S ⊆ I for all S ∈ S. A value wi lies in its uncertainty interval Ii , is initially  unknown, and can be revealed via a query. The value of an S ∈ S is w(S) = Ii ∈S wi . The goal is to determine a subset of minimum value c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 319–333, 2023. https://doi.org/10.1007/978-3-031-32726-1_23  
   
  320  
   
  N. Megow and J. Schlöter  
   
  as well as its value by using a minimal number of queries. It can be seen as an integer linear program (ILP) with uncertainty in the coeﬃcients of the objective function:  m min j=1 xj Ii ∈Sj wi m (1) s.t. j=1 xj = 1 ∈ {0, 1} ∀j ∈ {1, . . . , m}. xj Since the wi ’s are uncertain, we might have to execute queries to determine an optimal solution to (1). We refer to this problem as MinSet under uncertainty. In this paper, we consider the stochastic problem variant, where all values wi are drawn independently at random from their intervals Ii according to unknown distributions di . As there are instances that cannot be solved without querying the entire input, we analyze an algorithm ALG in terms of its competitive ratio: for the set of problem instances J , it is deﬁned as maxJ∈J E[ALG(J)]/E[OPT(J)], where ALG(J) is the number of queries needed by ALG to solve instance J, and OPT(J) is the minimum number of queries necessary to solve the instance. MinSet is a fundamental problem and of intrinsic importance within the ﬁeld of explorable uncertainty. The majority of existing works considers the adversarial setting, where query outcomes are not stochastic but returned in a worst-case manner. Selection type problems have been studied in the adversarial setting and constant (matching) upper and lower bounds are known, e.g., for selecting the minimum [19], the k-th smallest element [13,19], a minimum spanning tree [10,12,18,23], sorting [17] and geometric problems [5]. However, these problems essentially boil down to comparing single uncertainty intervals and identifying the minimum of two unknown values. Once we have to compare two (even disjoint) sets and the corresponding sums of unknown values, no deterministic algorithm can have a better adversarial competitive ratio than n, the number of uncertainty intervals. This has been shown by Erlebach et al. [11] for MinSet, and it implies strong adversarial lower bounds for classical combinatorial problems, such as, knapsack and matchings [25], as well as solving ILPs with uncertainty in the cost coeﬃcients as in (1) [25]. As a main result, we provide substantially better algorithms for MinSet under stochastic uncertainty. This is a key step for breaching adversarial lower bounds for a wide range of problems. For the stochastic setting, the only related results we are aware of concern sorting [6] and the problem of ﬁnding the minimum in each set of a given collection of sets [2]. Asking for the sum of unknown values is substantially diﬀerent. The Covering Point of View. Our key observation is that we can view MinSet as a covering problem with uncertainty in the constraints. To see this, we focus on the structure of the uncertainty intervals and how a query aﬀects it. We assume that each interval Ii ∈ I is either open (non-trivial ) or trivial, i.e., Ii = (Li , Ui ) or Ii = {wi }; a standard technical assumption in explorable uncertainty. In the latter case, Li = Ui = wi . We call Li and Ui lower  and upper limit. For a set S ∈ S,  we deﬁne the initial lower limit LS = Ii ∈S Li and initial upper limit US = Ii ∈S Ui . Clearly, w(S) ∈ (LS , US ). As the intervals (LS , US ) of the sets S ∈ S can overlap, we might have to execute queries to determine the set of minimum value. A query to an interval  
   
  Set Selection Under Explorable Stochastic Uncertainty  
   
  321  
   
  Ii reveals the precise value wi and, thus, replaces both, Li and Ui , with wi . In a sense, a query to an Ii ∈ S reduces the range (LS , US ) in which w(S) might lie by increasing LS by wi − Li and decreasing US by Ui − wi . Let LS (Q) and US (Q) denote the limits of set S after querying a set of intervals Q ⊆ I. For a MinSet instance (I, S), let w∗ = minS∈S w(S) be the initially uncertain minimum set value. To solve the problem, we have to adaptively query a set of intervals Q until US ∗ (Q) = LS ∗ (Q) = w∗ holds for some S ∗ ∈ S and LS (Q) ≥ w∗ holds for all S ∈ S. Only then, we know for sure that w∗ is indeed the minimum set value and that S ∗ achieves this value. The following ILP with ai = wi − Li for all Ii ∈ I and bS = w∗ − LS for all S ∈ S formulates this problem:  min Ii ∈I xi s.t. (MinSetIP) Ii ∈S xi · ai ≥ bS ∀S ∈ S xi ∈ {0, 1} ∀Ii ∈ I Observe that this ILP is a special case of the multiset multicover problem (see, e.g., [26]). If ai = wi − Li = 1 for all Ii ∈ I and bS = w∗ − LS = 1 for all S ∈ S, then the problem is exactly the classical SetCover problem with I corresponding to the SetCover sets and S corresponding to the SetCover elements. The optimal solution to (MinSetIP) is the optimal query set for the corresponding MinSet instance. Under uncertainty however, the coeﬃcients ai = wi − Li and right-hand sides bS = w∗ − LS are unknown. We only know that ai ∈ (Li − Li , Ui − Li ) = (0, Ui − Li ) as ai = (wi − Li ) and wi ∈ (Li , Ui ). In a sense, to solve MinSet under uncertainty, we have to solve (MinSetIP) with uncertainty in the coeﬃcients and irrevocable decisions. For the rest of the paper, we interpret MinSet under uncertainty in exactly that way: We have to solve (MinSetIP) without knowing the coeﬃcients in the constraints. Whenever we irrevocably add an interval Ii to our solution (i.e., set xi to 1), the information on the coeﬃcients (in form of wi ) is revealed. Our goal is to add elements to our solution until it becomes feasible for (MinSetIP), and to minimize the number of added elements. In this interpretation, the terms “querying an element” and “adding it to the solution” are interchangeable, and we use them as such. Our main contribution is an algorithmic framework that exploits techniques for classical covering problems and adapts them to handle uncertainty in the coeﬃcients ai and the right-hand sides bS . This framework allows us to obtain improved results for MinSet under uncertainty and other covering problems. Our Results. We design a polynomial-time algorithm for MinSet under stochastic uncertainty with competitive ratio O( τ1 · log2 m), where m is the number of sets (number of constraints in (MinSetIP)) and parameter τ characterizes how “balanced” the distributions of values within the given intervals are. More precisely, τ = minIi ∈I τi and τi is the probability that wi is larger than the center of Ii (e.g., for uniform distributions τ = 12 ). This is the ﬁrst stochastic result in explorable uncertainty concerning the sum of unknown values and it builds on new methods that shall be useful for solving more general problems in this  
   
  322  
   
  N. Megow and J. Schlöter  
   
  ﬁeld. The ratio is independent of the number of elements, n. In particular for a small number of sets, m, this is a signiﬁcant improvement upon the adversarial lower bound of n [11]. Dependencies on parameters such as τ are quite standard and necessary [3,4,15,22,29]. For example, in [22] the upper bounds depend on the probability to draw the largest value of the uncertainty interval, which is an even stricter assumption that does not translate to open intervals. Our results translate also to the maximization variant of MinSet; see full version [24]. We remark that the hidden constants in the performance bounds depend on the upper limits of the given intervals. Assuming those to be constant is also a common assumption; see, e.g., [22]. Even greedy algorithms for covering problems similar to (MinSetIP) without uncertainty have such dependencies [9,26,28]. As MinSet contains the classical SetCover, an approximation factor better than O(log m) is unlikely, unless P=NP [8]. We show that this holds also in the stochastic setting, even for uniform distributions. We also show a lower bound of τ1 for MinSet under stochastic explorable uncertainty, even for pairwise disjoint sets. Thus, the dependency on log m and τ1 in our results is necessary. In the special case that all given sets are disjoint, we provide a simpler algorithm with competitive ratio τ2 . This is a gigantic improvement compared to the adversarial setting, where the lower bound of n holds even for disjoint sets [11]. Algorithmically, we exploit the covering point of view to introduce a class of greedy algorithms that use the same basic strategy as the classical SetCover greedy algorithm [7]. However, we do not have suﬃcient information to compute and query an exact greedy choice under uncertainty as this choice depends on uncertain parameters. Instead, we show that it is suﬃcient to query a small number of elements that together achieve a similar greedy value to the exact greedy choice. If we do this repeatedly and the number of queries per iteration is small in expectation, then we achieve guarantees comparable to the approximation factor of a greedy algorithm with full information. It is worth noting that this way of comparing an algorithm to the optimal solution is a novelty in explorable uncertainty as all previous algorithms for adversarial explorable uncertainty (MinSet and other problems) exploit witness sets. A witness set is a set of queries Q such that each feasible solution has to query at least one element of Q, which allows to compare an algorithm with an optimal solution. Our results translate to other covering problems under uncertainty. In particular, for (MinSetIP) under uncertainty with deterministic right-hand sides, we give a simpliﬁed algorithm with improved competitive ratio O( τ1 · log m). For a slightly diﬀerent balancing parameter, this holds even for the more general variant, where a variable can have diﬀerent coeﬃcients for diﬀerent constraints, each with an individual uncertainty interval and distribution; see full version [24]. All missing proofs are provided in the full version [24]. Further Previous Work. For adversarial MinSet under uncertainty, Erlebach et al. [11] show a (best possible) competitive ratio of 2d, where d is the cardinality of the largest set. In the lower bound instances, d ∈ Ω(n). The algorithm repeatedly queries disjoint witness sets of size at most 2d. This result was stated for the setting, in which it is not necessary to determine the value of the minimal set; if the value has to be determined, the bounds change to d.  
   
  Set Selection Under Explorable Stochastic Uncertainty  
   
  323  
   
  Further related work on MinSet includes the result by Yamaguchi and Maehara [22], who consider packing ILPs with stochastic uncertainty in the cost coeﬃcients, which can be queried. They present a framework for solving several problems and bound the absolute number of iterations that it requires to solve them, instead of the competitive ratio. However, we show in the full version [24] that their algorithm has competitive ratio Ω(n) for MinSet, even for uniform distributions. Thus, it does not improve upon the adversarial lower bound. Wang et al. [30] also consider selection-type problems in a somewhat related model. They consider diﬀerent constraints on the set of queries that, in a way, imply a budget on the number of queries. They solve optimization problems with respect to this budget, which has a very diﬀerent ﬂavor than our setting. While we are not aware of previous work on covering problems with valuequeries and uncertainty in the constraints, there is related work on queries that reveal the existence of edges in a graph instead of numeric values [3,4,15,29]. Furthermore, there is related work on covering problems in diﬀerent stochastic settings (see, e.g., [1,14,16,27]).  
   
  2  
   
  Algorithmic Framework  
   
  In this section, we present our algorithmic framework. To illustrate the main ideas, we ﬁrst consider the oﬄine variant of MinSet and give hardness results. 2.1  
   
  Oﬄine Problems and Hardness of Approximation  
   
  We refer to the problem of solving (MinSetIP) with full knowledge of the precise values wi (and w∗ ) as oﬄine. For MinSet under uncertainty, we say a solution is optimal, if it is an optimal solution for the corresponding oﬄine problem. We use OPT to refer to an optimal solution and its objective value. Oﬄine MinSet contains SetCover and, thus, is as hard to approximate. This result transfers to the stochastic setting, even with uniform distributions. Thus, an approximation factor better than O(log m) is unlikely, unless P=NP [8]. On the positive side, we can approximate oﬄine MinSet by adapting covering results [7,9,20,21,26]. In particular, we want to use greedy algorithms that iteratively and irrevocably add elements to the solution that are selected by a certain greedy criterion. Recall that “adding an element to the solution” corresponds to both, setting the variable xi of an interval Ii ∈ I in (MinSetIP) to one and querying Ii . As the greedy criterion for adding an element depends on previously added elements, we deﬁne a version of the ILP parametrized by the set Q of elements that have already been added to the solution and adjust the right-hand sides to the remaining covering requirements after adding Q. To that  end, let bS (Q) = max{bS − Ii ∈Q∩S ai , 0} for ai = wi − Li and bS = w∗ − LS .  min Ii ∈I\Q xi  s.t. (MinSetIP-Q) Ii ∈S\Q xi · ai ≥ bS (Q) ∀S ∈ S xi ∈ {0, 1} ∀Ii ∈ I \ Q  
   
  324  
   
  N. Megow and J. Schlöter  
   
   Based on the ILP and the sum of right-hand sides b(Q) = S∈S bS (Q), we adjust an algorithm for multiset multicover by Dobson [9] to our setting. The Oﬄine Algorithm scales the coeﬃcients to a and b such that all nonzero left-hand side coeﬃcients are at least 1 (we refer to such instances as scaled ). Then it greedily adds the element to the solution that reduces the right-hand sides the most, i.e., the interval Ii ∈ I \ Q that maximizes the greedy value gc (Q, Ii ) = b (Q) − b (Q ∪ {Ii }). For a subset G ⊆ I, we deﬁne gc (Q, G) = b (Q) − b (Q ∪ G). After bS (Q) < 1 for all S ∈ S, we can exploit that all non-zero coeﬃcients ai are at least one. This means that adding an element Ii ∈ I \Q satisﬁes all remaining constraints of sets S with Ii ∈ S. Thus, the remaining problem reduces to a SetCover instance, which can be solved by using the classical greedy algorithm by Chvatal [7]. This algorithm greedily adds the element Ii that maximizes greedy value gs (Q, Ii ) = A(Q)−A(Q∪{Ii }) with A(Q) = |{S ∈ S | bS (Q) > 0}|, i.e., the element that satisﬁes the largest number of constraints that are not already satisﬁed by Q. For subsets G ⊆ I, we deﬁne gs (Q, G) = A(Q)−A(Q∪G). Theorem 1 (Follows from [9]). The Oﬄine Algorithm is a polynomial-time O(log m)-approximation for oﬄine MinSet. The precise approximation factor is ρ(γ) = ln(γ ·m·maxS (w∗ −LS ))+ln(m) with smin = minIi ∈I : (wi −Li )>0 (wi − Li ), γ = 1/smin and m = |S|. We will state the competitive ratios of our algorithms in terms of ρ. To that end, deﬁne ρ¯(γ) = ln(γ · m · maxS,S  (US − LS  ) + ln(m), which is an upper bound on ρ(γ). Under uncertainty, we compare against ρ¯ to avoid the random variable w∗ . For constant Ui ’s, ρ¯ and ρ are asymptotically the same. 2.2  
   
  Algorithmic Framework  
   
  To solve MinSet under uncertainty, we ideally would like to apply the Oﬄine Algorithm. However, since the coeﬃcients ai = wi − Li and bS = w∗ − LS are unknown, we cannot do so as we cannot compute the greedy values gc or gs . While we cannot precisely compute the greedy choice, our strategy is to approximate it and to show that approximating it is suﬃcient to obtain the desired guarantees. To make this more precise, consider an iterative algorithm for (MinSetIP) that iteratively adds  pairwise disjoint subsets G1 , . . . , Gh of I to the solution. For each j, let Qj = 1≤j  ≤j−1 Gj  , i.e., Qj contains the elements that have been added to the solution before Gj . If the combined greedy value of Gj is within a factor of α to the best greedy value for the problem instance after adding Qj , then we say that Gj α-approximates the greedy choice. The following deﬁnition makes this more precise while taking into account that there are two diﬀerent greedy values gc and gs (cf. the Oﬄine Algorithm). Deﬁnition 1. For a scaled instance of (MinSetIP), some Q ⊆ I, and an α ≥ 1, a subset G ⊆ I \ Q α-approximates the current greedy choice (as characterized by Q) if one of the following conditions holds:  
   
  Set Selection Under Explorable Stochastic Uncertainty  
   
  325  
   
  1. bS (Q) < 1 for all S ∈ S and gs (Q, G) ≥ α1 · maxIi ∈I\Q gs (Q, Ii ). 2. b (Q) ≥ 1 and gc (Q, G) ≥ α1 · maxIi ∈I\Q gc (Q, Ii ). We bound the number of iterations j in which Gj α-approximates the current greedy choice via an adjusted SetCover greedy analysis. Lemma 1. Consider an arbitrary algorithm for (MinSetIP) that scales the coeﬃcients by factor γ and iteratively adds disjoint subsets G1 , . . . , Gh of I to the solution until the instance is solved. The number of groups Gj that α-approximate the current greedy choice (after adding Qj ) is at most α · ρ(γ) · OPT. The lemma states that the number of such groups Gj is within a factor of α of the performance guarantee ρ(γ) of the oﬄine greedy algorithm. If each Gj α-approximates its greedy choice, the iterative algorithm achieves an approximation factor of maxj |Gj | · α · ρ(γ). Thus, approximating the greedy choices by a constant factor using a constant group size is suﬃcient to only lose a constant factor compared to the oﬄine greedy algorithm. This insight gives us a framework to solve MinSet under uncertainty. Recall that the wi ’s (and by extension the ai ’s and bS ’s) are uncertain and only revealed once we irrevocably add an Ii ∈ I to the solution. We refer to a revealed wi as a query result, and to a ﬁxed set of revealed wi ’s for all Ii ∈ I as a realization of query results. Consider an iterative algorithm. The sets Gj can be computed and queried adaptively and are allowed to depend on (random) query results from previous iterations. Hence, Xj = |Gj | is a random variable. Let Yj be an indicator variable denoting whether the algorithm executes iteration j (Yj = 1) or terminates beforehand (Yj = 0). We deﬁne the following class of iterative algorithms and show that algorithms from this class achieve certain guarantees. Deﬁnition 2. An iterative algorithm is (α, β, γ)-Greedy if it satisﬁes: 1. For every realization of query results; each Gj α-approximates the greedy choice as characterized by Qj on the instance with coeﬃcients scaled by γ. 2. E[Xj | Yj = 1] ≤ β holds for all iterations j. Theorem 2. Each (α, β, γ)-Greedy algorithm for MinSet under uncertainty achieves a competitive ratio of α · β · ρ¯(γ) ∈ O(α · β · log m). Proof. Consider an(α, β, γ)-Greedy algorithm ALG for MinSet. Its expected  cost is E[ALG] = j E[Xj ] = j P[Yj = 1] E[Xj | Yj = 1] + P[Yj = 0] E[Xj | Yj = 0]. As E[Xj | Yj = 0] = 0 (if the algorithm terminates before iteration j, E[ALG] = it adds no more elements and, thus, Xj = 0), the equality reduces to  P[Y = 1] E[X | Y = 1]. By Deﬁnition 2, this implies E[ALG] ≤ β j j j j j P[Yj = 1].  It remains to bound j P[Yj = 1], which is the expected number of iterations of ALG. Consider a ﬁxed realization of query results. By the ﬁrst property of Definition 2, each Gj α-approximates its greedy choice for the (MinSetIP) instance of the realization scaled by factor γ. Thus, Lemma 1 implies that the number of iterations is at most αρ(γ)OPT, which is upper bounded by α¯ ρ(γ)OPT. As  
   
  326  
   
  N. Megow and J. Schlöter  
   
  Algorithm 1: MinSet with deterministic right-hand sides. 1 2 3 4 5 6  
   
  Input: Instance of MinSet with deterministic right-hand sides. 2 Q = ∅; Scale a and b by smin to a and b for smin = minIi ∈I : Ui −Li >0 Ui − Li ; while the problem is not solved do if b (Q) ≥ 1 then g = g¯c else g = g¯s ; repeat Ii ← arg maxIj ∈I\Q g(Q, Ij ); Query Ii ; Q ← Q ∪ {Ii }; until the problem is solved or wi − Li ≥ 12 · (Ui − Li );  
   
  this upper bound on the number of iterations holds for every realization and OPT is the only random variable of that term (as we substituted ρ by ρ¯), we ρ(γ) E[OPT], which implies E[ALG] ≤ αβ ρ¯(γ) E[OPT].  
   
  get j P[Yj = 1] ≤ α¯  
   
  3  
   
  MinSet with Deterministic Right-Hand Sides  
   
  We consider a variant of MinSet under uncertainty, where the right-hand sides bS of the ILP representation (MinSetIP) are deterministic and explicit part of the input. Thus, only the coeﬃcients ai = (wi − Li ) remain uncertain within the interval (0, Ui − Li ). For this variant, the instance might have no feasible solution. In that case, we require every algorithm (incl. OPT) to reduce the covering requirements as much as possible. Recall that in the stochastic setting i ]. the balancing parameter is τ = minIi ∈I τi for τi = P[wi ≥ Ui +L 2 Theorem 3. There is a polynomial-time algorithm for MinSet under uncertainty with deterministic right-hand sides and a competitive ratio of τ2 · ρ(γ) ∈ O( τ1 · log m) with γ = 2/smin for smin = minIi ∈I : Ui −Li >0 Ui − Li . The algorithm loses only a factor τ2 compared to the greedy approximation factor ρ(γ) on the oﬄine problem. We show the theorem by proving that Algo2 with rithm 1 is an (α, β, γ)-Greedy algorithm for α = 2, β = τ1 and γ = smin smin = minIi ∈I : Ui −Li >0 Ui − Li . Using Theorem 2, this implies the theorem. The algorithm scales the instance by factor γ; a and b refer to the scaled coeﬃcients. The idea is to execute the Oﬄine Algorithm under the assumption that ai = Ui − Li (and ai = γai ) for all Ii ∈ I that were not yet added to the solution. As ai = (wi − Li ) ∈ (0, Ui − Li ), this means that we assume ai to have the largest possible value. Consequently, smin is the smallest (non-zero) coeﬃcient ai under this assumption. The algorithm computes the greedy choice based on the optimistic greedy values  g¯c (Q, Ii ) = bS (Q) − max{0, bS (Q) − γ(Ui − Li )} S∈S : Ii ∈S  
   
  (if b (Q) ≥ 1) and g¯s (Q, Ii ) = |{S ∈ S : Ii ∈ S | bS (Q) > 0 ∧ bS (Q) − γ(Ui − Li ) ≤ 0}|  
   
  Set Selection Under Explorable Stochastic Uncertainty  
   
  327  
   
  (otherwise). These are the greedy values under the assumption ai = Ui − Li . We call them optimistic as they might overestimate but never underestimate the actual greedy values. For subsets G ⊆ I, we deﬁne g¯s (Q, G) and g¯c (Q, G) analogously. In contrast to gs and gc , Algorithm 1 has suﬃcient information to compute g¯s and g¯c , and the best greedy choice based on the optimistic greedy values. The algorithm is designed to ﬁnd, in each iteration, an element Ii with wi − i Li ≥ Ui −L . We show that (i) this ensures that each iteration 2-approximates 2 the greedy choice and (ii) that ﬁnding such an element takes only τ1 tries in expectation. This suﬃces to apply Theorem 2. i) implies wi − Li ≥ 12 (Ui − Li ) To show (ii), we can observe that wi ≥ (Ui +L 2 (Ui +Li ) and that P[wi ≥ ] ≥ τ holds by assumption. Thus, we ﬁnd an interval Ii 2 satisfying wi − Li ≥ 12 (Ui − Li ) with probability at least τ . This implies that, given an iteration of the while-loop is started, it in expectation takes τ1 tries to ﬁnd such an interval Ii . This is exactly the second property of Deﬁnition 2. To prove (i), we use the next lemma, which shows that the optimistic greedy value of an Ii with wi − Li ≥ 12 (Ui − Li ) is close to the actual greedy value. 2 Lemma 2. Consider an instance of (MinSetIP) scaled by γ = smin and some Q ⊆ I. If wi − Li ≥ (Ui − Li )/2 for an Ii ∈ I \ Q, then gc (Q, Ii ) ≥ g¯c (Q, Ii )/2. If additionally b (Q) < 1, then gs (Q, Ii ) = g¯s (Q, Ii )  
   
  Proof. The statement regarding gc and g¯c holds directly by deﬁnition. To show the second statement, we use the assumption b (Q) < 1 and the choice of γ. i , we have From b (Q) < 1 follows bS (Q) < 1 for all S ∈ S. As wi − Li ≥ Ui −L 2 Ui −Li smin 2  ai = wi − Li ≥ 2 ≥ 2 and, therefore, ai = γai = smin ai ≥ 1. This means that adding Ii to the solution satisﬁes all constraints for sets S with Ii ∈ S that are not yet satisﬁed by Q. Thus, the optimistic greedy value g¯s (Q, Ii ) and the real greedy value gs (Q, Ii ) are the same, i.e., g¯s (Qj , Ii ) = gs (Q, Ii ), as adding Ii cannot satisfy more constraints even if the coeﬃcient ai was Ui − Li .  
   
  As the algorithm always queries the interval Ii with the best optimistic greedy value, Lemma 2 shows that the last query of the iteration 2-approximates the greedy choice after querying the set Q of all previous queries. This implies (i) and Property 1 of Deﬁnition 2. By Theorem 2 this suﬃces to prove Theorem 3.  
   
  4  
   
  MinSet Under Uncertainty  
   
  We consider MinSet under uncertainty and prove the following main result. Theorem 4. There is a polynomial-time algorithm for MinSet under uncertainty with a competitive ratio of O( τ1 log m · ρ¯(γ)) ⊆ O( τ1 · log2 m) with γ = 2/smin for smin = minIi ∈I : Ui −Li >0 Ui − Li . Exploiting Theorem 2, we prove the statement by providing Algorithm 2 and showing that it is an (α, β, γ)-Greedy algorithm for α = 2, γ = 2/smin and  
   
  328  
   
  N. Megow and J. Schlöter  
   
  β = τ1 (log1.5 (m · 2(maxIi ∈I (Ui − Li ))/smin ) + log2 (m)). Note that α and γ are deﬁned as in the previous section and will be used analogously. For β on the other hand, we require a larger value to adjust for the additional uncertainty in the right-hand sides bS = w∗ − LS as the minimum set value w∗ is unknown. Notice that we do not have suﬃcient information to execute Algorithm 1, since we need the right-hand side values to compute even the optimistic greedy values. To handle this additional uncertainty, we want to ensure that each iteration of our algorithm α-approximates the greedy choice for each possible value of w∗ . To do so, we compute and query the best optimistic greedy choice for several carefully selected possible values w∗ . To state our algorithm, we deﬁne a parametrized variant of (MinSetIP) that states the problem under the assumptions that w∗ = w for some w and that the set Q ⊆ I has already been queried. The coeﬃcients  are scaled to ai = (2/smin )(wi − Li ) and    b S (Q, w) = max{(2/smin )(w − LS ) − Ii ∈Q∩S ai , 0}. As before, let b (Q, w) =  S∈S bS (Q, w).  min Ii ∈I\Q xi    s.t. (MinSetIP-Qw) Ii ∈S\Q xi · ai ≥ bS (Q, w) ∀S ∈ S xi ∈ {0, 1} ∀Ii ∈ I As the right-hand sides are unknown, we deﬁne the greedy values for every possible value w for w∗ . To that end, let gc (Q, Ii , w) = b (Q, w) − b (Q ∪ {Ii }, w) and gs (Q, Ii , w) = A(Q, w) − A(Q ∪ {Ii }, w), where A(Q, w) = |{S ∈ S | bS (Q, w) > 0}|. As before, gc (Q, Ii , w) and gs (Q, Ii , w) describe how much adding Ii to the solution reduces the sum of right-hand sides and the number of nonsatisﬁed constraints, respectively; now under the assumption that w∗ = w. The optimistic greedy values g¯c (Q, Ii , w) and g¯s (Q, Ii , w) for an Ii ∈ I are deﬁned analogously but again assume that ai = Ui − Li . Similar to Algorithm 1, we would like to repeatedly compute and query the i (cf. best optimistic greedy choice until the queried Ii satisﬁes wi − Li ≥ Ui −L 2 the repeat-statement). However, we cannot decide which greedy value, g¯c or g¯s , to use as deciding whether bS (Q, w∗ ) < 1 depends on the unknown w∗ . Instead, we compute and query the best optimistic greedy choice for both greedy values (cf. the for-loop). Even then, the best greedy choice still depends on the unknown right-hand sides. Thus, we compute and query the best optimistic greedy choice for several carefully selected values w (cf. the inner while-loop) to make sure that the queries of the iteration approximate the greedy choice for every possible w∗ . Additionally, we want to ensure that we use at most β queries in expectation. Consider an iteration of the outer while-loop with g = g¯c , and let Q denote the set of queries that were executed before the start of the iteration. Since we only care about the greedy value gc if there exists some S ∈ S with bS (Q) > 1 (otherwise we use g¯s and gs instead), we assume that this is the case. If not, we use a separate analysis for the for-loop iteration with g = g¯s . ¯ that 2-approximates Our goal for the iteration is to query a set of intervals Q the best greedy choice I ∗ after querying Q, i.e., it has a greedy value ¯ Q, w∗ ) ≥ 1 gc (I ∗ , Q, w∗ ). To achieve this for the unknown w∗ , the algogc (Q, 2 rithm uses the parameter d, which is initialized with 1 (cf. Line 5), the minimum  
   
  Set Selection Under Explorable Stochastic Uncertainty  
   
  329  
   
  Algorithm 2: Algorithm for MinSet under uncertainty. 1 2 3 4 5 6 7 8 9 10 11 12 13 14  
   
  Input: Instance of MinSet under uncertainty. Scale all coeﬃcients with γ = 2/smin for smin = minIi ∈I : (Ui −Li )>0 (Ui − Li ); Q ← ∅, wmin ← minimum possible value w∗ (keep up-to-date); while the problem is not solved do foreach g from the ordered list g¯c , g¯s do d ← 1; Q ← Q; if g = g¯c then wmax ← max possible value w∗ ; else wmax ← max w s.t. bS (Q, w) < 1 for all S ∈ S; while ∃wmin ≤ w ≤ wmax such that maxIh ∈I\Q g(Q, Ih , w) ≥ d do repeat w ← min wmin ≤ w ≤ wmax s.t. maxIh ∈I\Q g(Q, w, Ih ) ≥ d ; Ii ← arg maxIh ∈I\Q g(Q, Ih , w); Query Ii ; Q ← Q ∪ {Ii }; U −L Q1/2 ← {Ij ∈ Q \ Q | wj − Lj ≥ j 2 j };  if g = g¯c then d ← gc (Q , Q1/2 , w) else d ← gs (Q , Q1/2 , w); i until wi − Li ≥ Ui −L or w ≤ wmax : maxIh ∈I\Q g(Q, w, Ih ) ≥ d ; 2  
   
  possible value for g¯c (I ∗ , Q, w∗ ) under the assumption that there exists some S ∈ S with bS (Q) > 1. In an iteration of the inner while-loop, the algorithm repeatedly picks the minimal value w such that the best current optimistic greedy choice has an optimistic greedy value of at least d (cf. Line 10). If no such value exists, then the loop terminates (cf. Lines 8, 14). Afterwards, it queries the corresponding best optimistic greedy choice Ii for the selected value w (cf. Line 11). Similar to the algorithms of the previous section, this is done repeatedly until wi − Li ≥ (Ui − Li )/2. The key idea to achieve the 2-approximation with an expected number of queries that does not exceed β, is to always reset the value d to gc (Q , Q1/2 , w), where Q1/2 is the subset of all intervals Ij that have already been queried in the current iteration of the outer while-loop and satisfy wj − Lj ≥ (Uj − Lj )/2 (cf. Lines 12, 13). This can be seen as an implicit doubling strategy to search for an unknown value. It leads to an exponential increase of d over the iterations of the inner while-loop, which will allow us to bound their number. With the following lemma, we prove that this choice of d also ensures that the queries of the iteration indeed 2-approximate the best greedy choice for w∗ if there exists a S ∈ S with bS (Q , w∗ ) ≥ 1. If there is no such set, we can use a similar proof. For an iteration j of theouter while-loop, let Gj be the set of queries during the iteration and let Qj = j  0 m for all β ∈ D \{β 0 }. The point (x0 , y0 ) is called an exposing point of Γ (β 0 ) x− β  y ≥ 0. In terms of Theorem 5, an exposing point is equivalent to an exposing ∞ sequence for Γ (β 0 ) x−β  0 y ≥ 0 deﬁned by the constant sequence ((x0 , y0 ))t=1 . m Let β 0 ∈ D and set (x0 , y0 ) := (Γ (β 0 ), β 0 ). It is easy to verify that m (x0 , y0 ) ∈ Q and Γ (β 0 ) x0 − β  0 y0 = 0. Furthermore, for each β ∈ D \ {β 0 },   we have Γ (β) x0 − β y0 > 0 because Γ is strictly non-expansive. Thus, Theorem 3.1 in [24] implies that CΓ is a maximal Q-free set. The existence of an exposing point immediately implies that CΓ is full-dimensional. For example, any strict convex combination of two exposing points is in the interior of CΓ .  
   
  6  
   
  Preliminary Results on Non-expansive Functions  
   
  In this section we collect a variety of lemmata to prove the main theorems. Throughout this section, assume Γ : Dm → Dn is non-expansive. Lemma 2. Let I ⊆ Dm be a finite set of pairwise isometric points. The following properties hold true:   β ≥ 0 for each β ∈ I, then β∈I β Γ (β) ∈ Dn 1. If β∈I β β ∈ Dm , where  and Γ ( β∈I β β) = β∈I β Γ (β).  2. If β∈I β Γ (β) ∈ Dn , where β ≥ 0 for each β ∈ I, then β∈I β β ∈ Dm and Γ ( β∈I β β) = β∈I β Γ (β).  :=  Proof. Set β β∈I β β. Using the isometry of points in I, we have   
   
    
   
  2 β∈I β Γ (β)  
   
  =  
   
    
   
     β,β  ∈I β β Γ (β) Γ (β )  
   
  =  
   
    
   
   β,β  ∈I β β β  
   
    
   
   2. β  = β  
   
   ∈ Dm , so the previous equation In the case ofProperty 1, we assume β proves that  β∈I β Γ (β) = 1. In the case of Property 2, we assume   ∈ Dm . There β∈I β Γ (β)2 = 1, so the previous equation proves that β   = fore, it remains to show that Γ (β) β∈I β Γ (β) in both cases; we prove these simultaneously.  
   
  Towards a Characterization of Maximal Quadratic-Free Sets  
   
  343  
   
  Using the non-expansive property of Γ and the nonnegativity of β , we have =  β 1=β  
   
    
   
          β ≤  β∈I β Γ (β) Γ (β) = Γ (β) β∈I β Γ (β) .  
   
  β∈I β β  
   
    ( The Cauchy-Schwarz inequality implies that 1 = Γ (β) β∈I β Γ (β)). Since  = both vectors have unit norm, we conclude that Γ (β)   β∈I β Γ (β). The following lemma is helpful when analyzing full-dimensional Q-free sets. Lemma 3. Define CΓ  as in (2). Assume CΓ is full-dimensional and let I ⊆ m be a finite set. If D β∈I λβ β = 0, where λβ > 0 for each β ∈ I, then  λ Γ (β) =  0. β β∈I  Proof. Assume to the contrary that β∈I λβ Γ (β) = 0. Fix β  ∈ I. We have   β  = − β∈I\{β } (λβ/λβ )β and Γ (β  ) = − β∈I\{β } (λβ/λβ )Γ (β). The following inequalities are both valid for CΓ :   
   
    
   
   ( β∈I\{β }  Γ (β  ) x − β   y = −( β∈I\{β }  
   
  λβ λβ λβ λβ  
   
   Γ (β)) x − ( β∈I\{β }  Γ (β)) x + ( β∈I\{β }  
   
  λβ λβ λβ λβ  
   
  β) y ≥ 0 β) y ≥ 0.  
   
  Thus, CΓ satisﬁes an equation contradicting that it is full-dimensional.  
   
     
   
  The next lemma, which is known from convexity theory, will allow us to simplify the description of CΓ in the proofs of Theorems 3 and 4. The proof follows from Theorem 17.3 [26]. Lemma 4. Define CΓ as in (2). If CΓ is full-dimensional and γ  x − β  y ≥ 0 is valid for CΓ , then (γ, β) ∈ cone({(Γ (β), β) : β ∈ Dn }). Our ﬁnal lemma states that if an inequality Γ (β) x − β  y ≥ 0 is implied by other inequalities of the same form indexed by I ⊆ Dm , then β must be isometric with β ∈ I. This will be used in the proof of Theorem 4 to help establish that we have a covering of Dm by isometric points. m Lemma 5. Let β ∈ D , I ⊆ Dm be a finite set, and λβ > 0 for each β ∈ I be such that (Γ (β), β) = β∈I λβ (Γ (β), β). Then β and β are isometric for each β ∈ I.  
   
  Proof. Notice that    λβ Γ (β)  Γ (β) − β β∈I λβ β      = β∈I λβ Γ (β) Γ (β) − β β ,  
   
  0 = Γ (β) Γ (β) − β  β =  
   
    
   
  β∈I  
   
  where the ﬁrst equality follow from β ∈ Dm and Γ (β) ∈ Dn . Due to the nonexpansiveness of Γ , every summand is non-negative. Since the sum is 0, every   summand must be 0. As λβ > 0, we conclude that Γ (β) Γ (β) = β  β.  
   
  344  
   
  7  
   
  G. Mu˜ noz et al.  
   
  A Proof of Theorem 3  
   
  From our discussion in Section 1.1, we know the set CΓ is always Q-free. Since we assume CΓ is a polyhedron, it admits a ﬁnite description using facet inequalities. By applying Lemma 4 to each facet inequality, we can assume that there is a ﬁnite set I ⊆ Dm such that CΓ = {(x, y) ∈ Rn × Rm : Γ (β) x − β  y ≥ 0 ∀ β ∈ I}. We assume that Γ (β) x − β  y ≥ 0 deﬁnes a facet of CΓ for each β ∈ I. We will prove that this representation of CΓ suﬃces to prove maximality in Theorem 3 using Theorem 5. To this end, let β ∈ I. According to Theorem 5, it suﬃces to show that Γ (β) x − β  y ≥ 0 has an exposing sequence. For t ∈ N, deﬁne xt := Γ (β) +  
   
  √ 2t+1 t  
   
  Γ  
   
  and  
   
  yt := (1 + 1t ) β,  
   
  (6)  
   
  where Γ ∈ Dn will be chosen in Claim 1 so that Γ (β) Γ = 0. Using this property, the inclusion β ∈ Dm and Γ , Γ (β) ∈ Dn , we see that (xt , yt ) ∈ Q. Consider a bounded sequence of inequalities γ t x − αt y ≥ 0, where t ∈ N, that are satisﬁed by points in CΓ and such that 0 ≥ γ t xt − αt yt . By the Farkas Lemma, there exist numbers λβ,t ≥ 0 for each β ∈ I such that  (γ t , αt ) = β∈I λβ,t (Γ (β), β). (7) After normalizing (γ t , αt ), we may assume (γ t , αt ) = (Γ (β), β) for all t. Furthermore, according to Carath´eodory’s theorem we may assume that for each t the set {(Γ (β), β) : λβ,t > 0} is linearly independent. Consequently, there exists τ > 0 such that λβ,t ≤ τ for each β ∈ I and t ∈ N. In order to demonstrate that ((xt , yt ))∞ t=1 is an exposing sequence, we prove  limt→∞ β∈I λβ,t (Γ (β), β) = (Γ (β), β). To this end, it suﬃces to prove limt→∞ λβ,t = 0 for each β ∈ I \ {β}. We will choose Γ so that this condition is met. Note that √    0 ≥ γ t xt −αt yt = β∈I λβ,t (Γ (β) Γ (β)−β  β)+ 2t+1 Γ  Γ (β)− 1t β  β . t Multiplying through by t, we have   √  0 ≥ β∈I λβ,t t(Γ (β) Γ (β) − β  β) + 2t + 1 Γ  Γ (β) − β  β .  
   
  (8)  
   
  Claim 1. Γ can be chosen such that Γ  Γ (β) = 0 and for each β ∈ I \ {β} √ limt→∞ t(Γ (β) Γ (β) − β  β) + 2t + 1 Γ  Γ (β) − β  β = ∞. Proof of Claim. Regardless of Γ , if β is such that Γ√(β) Γ (β) − β  β > 0, then the limit goes to ∞ because the term t dominates 2t + 1.  
   
  Towards a Characterization of Maximal Quadratic-Free Sets  
   
  345  
   
  In what remains, we need to choose Γ so that Γ (β) Γ > 0 for all β ∈ I \{β} satisfying Γ (β) Γ (β) − β  β √ = 0. If we establish this, then the limit tends to inﬁnity because of the term 2t + 1. Deﬁne J := {β ∈ I \ {β} : Γ (β) Γ (β) − β  β = 0}. We consider two cases: whether Γ (β) ∈ cone(Γ (J)) or not. Case 1. Assume Γ (β) ∈ cone{Γ (β) : β ∈ J}. Deﬁne K := cone(Γ (J ∪ {β})). If K is not pointed, then 0 ∈ Rn is a non-trivial conic combination of the generators of K. By Lemma 2, 0 ∈ Rm can be obtained using the same conic multipliers applied to vectors in J ∪ {β}. However, Lemma 3 implies that CΓ is not full-dimensional, which is a contradiction. Hence, K is pointed. The fact that J is ﬁnite together with Γ (β) ∈ cone{Γ (β) : β ∈ J} implies that Γ (β) generates an extreme ray of K and there is no β ∈ J that generates the same extreme ray. Thus, by the separating hyperplane theorem there exists some Γ ∈ Dn such that Γ  Γ (β) = 0 < Γ  Γ (β) for all β ∈ J, as desired. Case 2. Assume Γ (β) ∈ cone{Γ (β) : β ∈ J}. Thereexists a set H ⊆ J and numbers β > 0 for each β ∈ H such that Γ (β) = β∈H β Γ (β). Deﬁne  :=  β β. Using the non-expansive property of Γ , we have β β∈H  
   
   2= β  
   
    
   
   β,β  ∈H β β β  
   
    
   
  β ≤  
   
    
   
     β,β  ∈H β β Γ (β) Γ (β )  
   
  = Γ (β)2 = 1.  
   
  Using the isometry with β and each β ∈ H, we then have      β =  β β∈H β β β = β∈H β Γ (β) Γ (β) = Γ (β) Γ (β) = 1.   β| ≤ ββ  Thus, we have equality in the Cauchy-Schwarz inequality |β ≤ 1,  1   so β = β . Thus, (Γ (β), β) = β∈H β (Γ (β), β) contradicting that Γ (β) x − β  y ≥ 0 deﬁnes a facet of CΓ . Choose Γ ∈ Dn according to Claim 1. For each t ∈ N, we have   √ λβ,t t(Γ (β) Γ (β) − β  β) + 2t + 1 Γ  Γ (β) − β  β = −λβ,t ≥ −τ. Together with (8), this implies   √  0 ≥ −τ + β∈I\{β} λβ,t t(Γ (β) Γ (β) − β  β) + 2t + 1 Γ  Γ (β) − β  β . (9) For β ∈ I \ {β}, if λβ,t does not go to 0 as t tends to ∞, then Claim 1 implies that the righthand side of (9) will go to ∞, which is a contradiction. Hence, (7) tends to (Γ (β), β) as t tends to ∞.   Remark 2. As we mentioned in Section 1.1, we conjecture that Theorem 3 is generalizable to a set CΓ that is not necessarily a polyhedron. With this in mind, a natural question is how reliant on polyhedrality the proof of this section is. Various points of the proof can be adapted to handle a non-polyhedral case: for example, a similar expression to (7) can be obtained for an inﬁnite I. However, one the key steps that heavily uses ﬁniteness is the construction of Γ using a strict separating hyperplane in Case 1 of Claim 1. It is not clear if such Γ exists in a general case, and the proof may need a diﬀerent approach.  
   
  346  
   
  8  
   
  G. Mu˜ noz et al.  
   
  A Proof of Theorem 4  
   
  (⇐) We show that if β ∈ Dm \ I, then Γ (β) x − β  y ≥ 0 is implied by the inequalities indexed by I. Let β ∈ Dm \I. By assumption, there exists a set J ⊆ I of pairwise isometric points satisfying  β ∈ cone(J). Hence, thereexist λβ ≥ 0 for each β ∈ J such that β = β∈J λβ β. We have Γ (β) = β∈J λβ Γ (β) by Lemma 2. This shows that (Γ (β), β) ∈ cone({(Γ (β), β) : β ∈ J}). Hence, Γ (β) x − β  y ≥ 0 is implied by the inequalities indexed by I. (⇒) CΓ is a polyhedron, so by Lemma 4 there is a ﬁnite representation   CΓ = (x, y) ∈ Rn × Rn : Γ (β) x − β  y ≥ 0 ∀ β ∈ I . Let β ∈ Dm \ I. The inequality Γ (β) x − β  y ≥ 0 is valid for CΓ , so there exists a set J ⊆ I and positive coeﬃcients λβ for each β ∈ J such that  (Γ (β), β) = β∈J λβ (Γ (β), β). Lemma 5 states that β  β = Γ (β) Γ (β) for all β ∈ J. For each β  ∈ J, we have  Γ (β  ) Γ (β) − β   β = β∈J λβ (Γ (β  ) Γ (β) − β   β). The left-hand side is 0 because β and β  are isometric, and every summand on the right-hand side is nonnegative because λβ > 0 and Γ (β  ) Γ (β) − β   β ≥ 0 by the non-expansive property of Γ . Hence, Γ (β  ) Γ (β) = β   β for all β ∈ J. As β  was arbitrarily chosen in J, we see that all elements of J are pairwise isometric and β ∈ cone(J). Acknowledgements. The second author was supported by a Natural Sciences and Engineering Research Council of Canada (NSERC) Discovery Grant [RGPIN-202102475]. The authors would like to thank the three anonymous reviewers for their valuable feedback.  
   
  References 1. Andersen, K., Jensen, A.N.: Intersection cuts for mixed integer conic quadratic sets. In: Goemans, M., Correa, J. (eds.) IPCO 2013. LNCS, vol. 7801, pp. 37–48. Springer, Heidelberg (2013). https://doi.org/10.1007/978-3-642-36694-9 4 2. Andersen, K., Louveaux, Q., Weismantel, R., Wolsey, L.: Cutting planes from two rows of the simplex tableau. In: Proceedings of Integer Programming and Combinatorial Optimization (IPCO), pp. 1–15 (2007) 3. Averkov, G.: A proof of Lov´ asz’s theorem on maximal lattice-free sets. Contrib. Algebra Geom. (2013) 4. Averkov, G., Basu, A., Paat, J.: Approximation of corner polyhedra with families of intersection cuts. SIAM J. Optim. 28(1), 904–929 (2018) 5. Averkov, G.: On maximal s-free sets and the Helly number for the family of s-convex sets. SIAM J. Discret. Math. 27(3), 1610–1624 (2013)  
   
  Towards a Characterization of Maximal Quadratic-Free Sets  
   
  347  
   
  6. Baes, M., Oertel, T., Weismantel, R.: Duality for mixed-integer convex minimization. Math. Program. 158, 547–564 (2016) 7. Balas, E.: Intersection cuts - a new type of cutting planes for integer programming. Oper. Res. (1971) 8. Barvinok, A.: A course in convexity. Am. Math. Soc. (2002) 9. Basu, A., Conforti, M., Cornu´ejols, G., Weismantel, R., Weltge, S.: Optimality certificates for convex minimization and Helly numbers. Oper. Res. Lett. 45(6), 671–674 (2017) 10. Basu, A., Dey, S., Paat, J.: Nonunique lifting of integer variables in minimal inequalities. SIAM J. Discret. Math. (2019) 11. Basu, A., Conforti, M., Cornu´ejols, G., Zambelli, G.: Maximal lattice-free convex sets in linear subspaces. Math. Oper. Res. 35(3), 704–720 (2010) 12. Basu, A., Conforti, M., Cornu´ejols, G., Zambelli, G.: Minimal inequalities for an infinite relaxation of integer programs. SIAM J. Discret. Math. 24(1), 158–168 (2010) 13. Bienstock, D., Chen, C., Mu˜ noz, G.: Intersection cuts for polynomial optimization. In: Lodi, A., Nagarajan, V. (eds.) IPCO 2019. LNCS, vol. 11480, pp. 72–87. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-17953-3 6 14. Bienstock, D., Chen, C., Mu˜ noz, G.: Outer-product-free sets for polynomial optimization and oracle-based cuts. Math. Program. 183, 105–148 (2020) 15. Chmiela, A., Mu˜ noz, G., Serrano, F.: On the implementation and strengthening of intersection cuts for QCQPs. Math. Program. 1–38 (2022) 16. Conforti, M., Cornu´ejols, G., Daniilidis, A., Lemar´echal, C., Malick, J.: Cutgenerating functions and S-free sets. Math. Oper. Res. (2014) 17. Conforti, M., Cornu´ejols, G., Zambelli, G.: A geometric perspective on lifting. Oper. Res. 59(3), 569–577 (2011) 18. Conforti, M., Cornu´ejols, G., Zambelli, G.: Integer Programming. Springer, Cham (2014). https://doi.org/10.1007/978-3-319-11008-0 19. Conforti, M., Summa, M.D.: Maximal s-free convex sets and the Helly number. SIAM J. Discret. Math. 30(4), 2206–2216 (2016) 20. Dey, S., Wolsey, L.: Two row mixed-integer cuts via lifting. Math. Program. 124, 143–174 (2010) 21. Lov´ asz, L.: Geometry of numbers and integer programming. In: Iri, M., Tanabe, K. (eds.) Mathematical Programming: Recent Developments and Applications, pp. 177–201. Kluwer Academic Publishers, Amsterdam (1989) 22. Modaresi, S., Kılın¸c, M., Vielma, J.: Intersection cuts for nonlinear integer programming convexification techniques for structured sets. Math. Program. (2016) 23. Mu˜ noz, G., Serrano, F.: Maximal quadratic-free sets. In: Proceedings of the International Conference on Integer Programming and Combinatorial Optimization, pp. 307–321 (2020) 24. Mu˜ noz, G., Serrano, F.: Maximal quadratic-free sets. Math. Program. 192, 229– 270 (2022) 25. Paat, J., Schl¨ oter, M., Speakman, E.: Constructing lattice-free gradient polyhedra in dimension two. Math. Program. 192(1), 293–317 (2022) 26. Rockafellar, R.T.: Convex Analysis. Princeton University Press, Princeton (1970) 27. Tuy, H.: Concave minimization under linear constraints with special structure. Dokl. Akad. Nauk SSSR 159, 32–35 (1964)  
   
  Compressing Branch-and-Bound Trees ´ Gonzalo Mu˜ noz1 , Joseph Paat2(B) , and Alinson S. Xavier3 1  
   
  2  
   
  Institute of Engineering Sciences, Universidad de O’Higgins, Rancagua, Chile [email protected]  Sauder School of Business, University of British Columbia, Vancouver, BC, Canada [email protected]  3 Energy Systems and Infrastructure Analysis Division, Argonne National Laboratory, Lemont, IL, USA [email protected]   
   
  Abstract. A branch-and-bound (BB) tree certiﬁes a dual bound on the value of an integer program. In this work, we introduce the tree compression problem (TCP): Given a BB tree T that certiﬁes a dual bound, can we obtain a smaller tree with the same (or stronger) bound by either (1) applying a diﬀerent disjunction at some node in T or (2) removing leaves from T ? We believe such post-hoc analysis of BB trees may assist in identifying helpful general disjunctions in BB algorithms. We initiate our study by considering computational complexity and limitations of TCP. We then conduct experiments to evaluate the compressibility of realistic branch-and-bound trees generated by commonly-used branching strategies, using both an exact and a heuristic compression algorithm.  
   
  1  
   
  Introduction  
   
  Consider an integer linear programming (IP) problem min{c x : x ∈ P ∩ Zn },  
   
  (1)  
   
  where c ∈ Qn and P := {x ∈ Rn : Ax ≤ b} for A ∈ Qm×n and b ∈ Qm . Primal bounds on (1) can be certiﬁed by integer feasible solutions z ∈ P ∩ Zn . Dual bounds on (1), on the other hand, are typically certiﬁed using branch-andbound (BB) trees. A BB tree is a graph-theoretical tree T where each node v corresponds to a polyhedron Q(v), with the root corresponding to P. Moreover, v is either a leaf, or it has exactly two children corresponding to the polyhedra deﬁned by applying a disjunction (π  x ≤ π0 )∨(π  x ≥ π0 +1) to Q(v), where we call π ∈ Zn the branching direction and π0 ∈ Z. If we solve the corresponding linear programs over all leaves of T , then the smallest value obtained over all leaves yields a dual bound for (1). See Sect. 2 for a formal deﬁnition of BB trees and the dual bound. In order to generate a BB tree, one must identify a strategy for selecting a leaf of the tree and a strategy for selecting a disjunction to apply. See [22] for a survey on diﬀerent strategies. In practical implementations of the BB method, c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 348–362, 2023. https://doi.org/10.1007/978-3-031-32726-1_25  
   
  Compressing Branch-and-Bound Trees  
   
  349  
   
  the only allowed directions are typically {e1 , . . . , en }, in which case we say the algorithm uses variable disjunctions. However, many results explore the beneﬁt of additional directions: various subsets of {−1, 0, 1}n are explored in [25,27,30]; directions derived from mixed integer Gomory cuts are explored in [9,19]; directions derived using basis reduction techniques are explored in [1,26]; Mahajan and Ralphs [23] solve a subproblem to ﬁnd a disjunction that closes the duality gap by a certain amount. The largest set of directions is the set Zn , in which case the algorithm uses general disjunctions. Although a larger set of allowable directions provides more ﬂexibility, it has been repeatedly veriﬁed that searching through this set during the execution of the algorithm can be computationally expensive [15,23]. The work in this paper is motivated by a diﬀerent approach to identify meaningful directions. Given a tree T produced using some set of allowable directions D ⊆ Zn , we ask if T can be “compressed” into a smaller tree with the same (or stronger) dual bound by using a potentially larger set of directions D ⊇ D, and a limited set of transformations. This post-hoc compression analysis is more restricted and allows one to use a global view of the tree to identify potentially meaningful branching directions, as opposed to the dynamic approach. We believe this compression question may help produce small trees to be used as better certiﬁcates [7] or as training data for learn-to-branch strategies. Related Work. To the best of our knowledge, this is the ﬁrst piece of work to study the tree compression problem. A related question is the minimum size of a BB tree certifying optimality or infeasibility of (1); we use some of these results in our own work. Chv´ atal [8] and Jeroslow [18] gives examples of IPs that require a BB tree whose size is exponential in the number of variables n when only variable directions D = {e1 , . . . , en } are used to generate disjunctions. There are examples where an exponential lower bound in n cannot be avoided even with general disjunctions [10,11]. Basu et al. [3] consider the set Ds of directions whose support is at most s; they prove that if s ∈ O(1), then a BB tree proving infeasibility of Jeroslow’s instance has exponential in n many nodes [3]. For an interesting perspective on provable upper bounds, Dey et al. [12] relate the size of BB trees generated using full strong branching and variable disjunctions to the additive integrality gap for certain classes of instances like vertex cover. For complexity results, Pfetsch et al. [16] show that is it NP-hard to ﬁnd the smallest BB tree generated using only variable disjunctions. Mahajan and Ralphs [24] show that it is NP-complete to decide whether there is a general disjunction proving infeasibility at the root node. They also provide a MIP that can be solved at a node in a BB tree to yield a disjunction maximizing the dual bound improvement. The tree compression problem is a post-hoc analysis of a BB tree. A similar kind of analysis is done in backdoor branching, where one explores a tree T to ﬁnd small paths from the root to the optimal solution with the ultimate aim to identify good branching decisions to make next time the algorithm is run on a similar IP [14,20]. The major diﬀerence between backdoor branching and the compression question is that the former only considers ﬁnding a path  
   
  350  
   
  G. Mu˜ noz et al.  
   
  existing in the tree while the latter considers how to modify a tree to create short paths. Another form of post-hoc analysis is tree balancing, where the goal is to transform a tree T proving integer infeasibility into a new tree with the same dual bound whose size is polynomial in |T | and whose depth is polylogarithmic in |T |; see, e.g., [4] for a discussion on balancing and stabbing planes. A major diﬀerence between the balancing question and the compression question is that the former is allowed to grow the tree along branches while the latter is not. Our Contributions. We introduce the tree compression problem in Sect. 2. In Theorem 1, we show that the problem is NP-Complete when D = Zn and c = 0. We then demonstrate in Theorem 2 that tree compression does not always give the smallest BB tree meeting a certain dual bound. In fact, we give an example of a BB tree T of size |T | ≥ 2n+1 − 1 that cannot be compressed to a BB tree n with fewer than (2 − 1)/n nodes, but there is a diﬀerent BB tree with the same root and dual bound with only 7 nodes. These results appear in Sect. 3. We next provide extensive computational results on the compression problem. We look at BB trees from MIPLIB 3.0 [6] instances generated using full strong branching, the state-of-the-art variable branching strategy with respect to tree size, and reliability branching with plunging, often considered the state-of-the-art branching strategy with respect to running time. We ﬁrst compress these trees using a computationally-expensive exact algorithm based on a MIP formulation by Mahajan and Ralphs [23,24]. We then evaluate how much of this compression is achievable in a short amount of time, by applying a heuristic algorithm based on the iterative procedure introduced by Owen and Mehrota [27]. Overall, we see that many MIPLIB 3.0 trees can be signiﬁcantly compressed. Moreover, we ﬁnd that the heuristic procedure achieves good compression. These algorithms and results are described in Sects. 4 and 5, respectively.  
   
  2  
   
  The Tree Compression Problem (TCP)  
   
  We deﬁne a branch-and-bound (BB) tree as a graph-theoretical rooted tree where each node v corresponds to a polyhedron Q(v), and the root node r corresponds to Q(r) = P. Furthermore, each node v is either a leaf, or it has exactly two children corresponding to the polyhedra Q(v) ∩ {x ∈ Rn : π  x ≤ π0 }  
   
  and Q(v) ∩ {x ∈ Rn : π  x ≥ π0 + 1},  
   
  (2)  
   
  where π ∈ Zn is called the branching direction and π0 ∈ Z. The dual bound relative to c ∈ Qn provided by a BB tree T is d(T, c) := minv∈L(T ) min{c x : x ∈ Q(v)}, where L(T ) is the set of leaves of T . Deﬁne d(T, c) = ∞ if Q(v) = ∅ for each v ∈ L(T ), and d(T, c) = −∞ if x → c x is unbounded from below over Q(v) for some v ∈ L(T ). For simplicity, our deﬁnition allows BB trees that have multiple nodes corresponding to the same polyhedron, although such trees would typically not be generated by well-designed BB algorithms. We also do not require the tree  
   
  Compressing Branch-and-Bound Trees  
   
  351  
   
  to certify infeasibility or optimality of (1), to allow trees generated by partial (e.g. time- or node-limited) runs of the BB method. Let T be a BB tree and v ∈ T be a non-leaf node. Our notion of compression is based on two operations on T . For (π, π0 ) ∈ Zn × Z, let replace(T, v, π, π0 ) denote the BB tree obtained from T by replacing all descendants of v with the two new children deﬁned by applying the disjunction (π  x ≤ π0 ) ∨ (π  x ≥ π0 + 1) to Q(v), i.e., the two new children are the polyhedra in (2). We use drop(T, v) to denote the BB tree obtained from T by removing all descendants of v. We refer to the number of nodes in T as the size of T and denote it by |T |. We say that a BB tree T  is a compression of T if there exists a sequence of BB trees T1 = T, T2 , . . . , Tk = T  such that for each i ∈ {2, . . . , k} we have that 1. Either Ti = drop(Ti−1 , v) for some v ∈ Ti−1 , or Ti = replace(Ti−1 , v, π, π0 ) for some v ∈ Ti−1 and (π, π0 ) ∈ Zn × Z. 2. |Ti | < |Ti−1 | and d(Ti , c) ≥ d(Ti−1 , c). Note that the deﬁnition of compression depends on the dual bound of T . Also, observe that the replacement operation only acts on non-leaf nodes and thus only produces children of non-leaf nodes. Consequently, leaf nodes of a BB tree will either remain leaf nodes or disappear from the tree during the compression process. Given that the replacement operation creates two new nodes that are leaves themselves, the previous discussion implies that any new (potentially dense) disjunctions introduced in the compression process appear near the bottom of the tree. See [5,15,28] for comments on potential drawbacks of dense inequalities. As an example of these deﬁnitions, consider P := [0, 1/5]2 and the following BB tree T (disjunctions are indicated on edges and polyhedra in the nodes): x1 ≤ 0  
   
  {0}  
   
  x2 ≤  
   
  0  
   
  P  
   
  x1 ≥ 1  
   
  {0} × [0, 1/5] x 2 ≥1 ∅  
   
  ∅  
   
  x1  
   
  ≤0  
   
  ∅  
   
  x1  
   
  ≥1  
   
  ∅  
   
  Let c = (−1, −1); we have d(T, c) = 0. We can compress T with the drop operation at the right child v2 of the root r; see ﬁgure (a). We can compress T with the replace operation at the root with π = −c and π0 = 0; see ﬁgure (b). It can be checked that d(drop(T, v2 ), c) = d(replace(T, r, π, 0), c) = 0.  
   
  352  
   
  G. Mu˜ noz et al.  
   
  x1  
   
  {0}  
   
  x2 ≤  
   
  0  
   
  ≤0 P  
   
  x1  
   
  ≥1  
   
  {0} × [0, 1/5] x 2 ≥ 1  
   
  ∅  
   
  {0}  
   
  x2 x1 +  
   
  ≤ 0 P x1 + x 2 ≥ 1 ∅  
   
  ∅  
   
  (a) The BB tree drop(T, v2 )  
   
  (b) The BB tree replace(T, r, π, 0)  
   
  The example illustrates that strict dual improvement is not necessary in the compression process. It is possible for the dual bound to improve during the compression process; e.g., use the same example except replace P by the triangle with vertices (−1/2, −1/2), (−1/2, 1), (1, −1/2). For an example of an invalid compression operation, one can replace 1/5 in the original example by 1/2; here replace(T, r, π, 0) would no longer be a compression because we deteriorate the lower bound. The tree compression problem (TCP) with respect to a set of allowable directions D is deﬁned as follows: Given a BB tree T and an objective vector c ∈ Qn , is there a compression of T where the replacement operation only uses branching directions in D? There is also an optimization version of this question in which we try to compress T as much as possible. Section 3 considers this decision problem (showing this is NP-Complete) and the optimization problem (showing limitations of compression). Our computational results in Sects. 4 and 5 consider the optimization problem. As seen in the previous example, the choice of D inﬂuences the compression question; the BB tree in ﬁgure (a) is the best compression if D only contains unit vectors while the BB tree in ﬁgure (b) is the best compression if D contains the all-ones vector.  
   
  3  
   
  Complexity Results and Lower Bounds  
   
  We show (TCP) is NP-Complete when D = Zn and c = 0. Our proof uses a reduction from the NP-Complete problem of disjunctive infeasibility (DI) [24, Proposition 3.2]: Given A ∈ Qm×n and b ∈ Qn defining a polyhedron S = {x ∈ Rn : Ax ≤ b}, decide if there exists π ∈ Zn \ {0} and π0 ∈ Z such that S ⊆ {x ∈ Rn : π0 < π  x < π0 + 1}. Keep in mind that the input to (DI) is a single polyhedron whereas the input to (TCP) is an entire BB tree. For this reason, if D is a smaller set in the (TCP) deﬁnition, e.g., vectors of bounded support, then (TCP) can be solved in polynomial time by solving a series of ﬁxed dimension MIPs, one at each node of T ; see [24, §2.1]. Theorem 1. (TCP) is NP-Complete when D = Zn and c = 0. Proof. We brieﬂy argue (TCP) is in NP when D = Zn and c = 0. Let T be a BB tree that can be compressed. Either d(T, 0) = 0, which happens if Q(v) = ∅ for some v ∈ L(T ), or d(T, 0) = ∞, which happens if Q(v) = ∅ for all v ∈ L(T ). If a non-leaf node v of T satisﬁes Q(v) = ∅, then T  = drop(T, v) is a compression of T whose size is polynomial in the size of T . Suppose d(T, 0) = ∞. Since T  
   
  Compressing Branch-and-Bound Trees  
   
  353  
   
  can be compressed, there exists v ∈ T and (π, π0 ) ∈ Zn × Z such that applying the disjunction (π  x ≤ π0 ) ∨ (π  x ≥ π0 + 1) to Q(v) will yield two empty polyhedra. Mahajan and Ralphs demonstrate that ﬁnding such a disjunction is in NP [24, §3]. In particular, there is a compression T  = replace(T, v, π, π0 ) of T whose size is polynomial in the size of T . This shows that (TCP) is in NP. Consider an instance (A, b) of (DI). Let x∗ ∈ S \ Zn ; this can be found in polynomial time unless S is empty (in which case the answer to (DI) is ‘yes’) or a single integer vector (in which case the answer is ‘no’). Without loss of generality, x∗1 ∈ Z. We lift S into Rn+1 to create an instance of (TCP). We write a point in Rn+1 as (x, y) ∈ Rn × R. Deﬁne P := conv ({(x∗ , 0), (x∗ , 1)} ∪ {(x, 1/2) : x ∈ S}) We build a BB tree T with root node r and Q(r) = P. Branch on the disjunction (y ≤ 0) ∨ (y ≥ 1) at r to obtain v1 and v2 : Q(v1 ) := {(x, y) ∈ P : y ≤ 0} = {(x∗ , 0)} Q(v2 ) := {(x, y) ∈ P : y ≥ 1} = {(x∗ , 1)}. Branch on v1 and v2 using (x1 ≤ x∗1 ) ∨ (x1 ≥ x∗1 ) to obtain v3 , v4 , v5 , v6 : Q(v3 ) := {(x, y) ∈ P Q(v4 ) := {(x, y) ∈ P Q(v5 ) := {(x, y) ∈ P Q(v6 ) := {(x, y) ∈ P  
   
  : : : :  
   
  y y y y  
   
  ≤0 ≤0 ≥1 ≥1  
   
  and and and and  
   
  x1 x1 x1 x1  
   
  ≤ x∗1 } = ∅ ≥ x∗1 } = ∅ ≤ x∗1 } = ∅ ≥ x∗1 } = ∅.  
   
  T has 7 nodes, and the four leaves v3 , v4 , v5 , v6 have corresponding polyhedra that are empty. The encoding size of T is polynomial in the encoding size of S. If (DI) has a ‘yes’ answer with certiﬁcate π ∈ Zn \ {0} and π0 ∈ Z, then P ⊆ S × R ⊆ {(x, y) ∈ Rn × R : π0 < π  x < π0 + 1}. Hence, the answer to (TCP) is ‘yes’ because replace(T, r, (π, 0), π0 ) is a compression of T . Assume (TCP) has a ‘yes’ answer. The drop operation can only be applied to r, v1 or v2 , and doing so to any of these does not compress the tree because the dual bound decreases. So, the ‘yes’ answer must come from the replace operation. In order to decrease the size of the tree, which is required for compression, the replace operation must be applied at r. Therefore, there is (π, πn+1 ) ∈ Zn × Z and π0 ∈ Z such that π0 < π  x + πn+1 y < π0 + 1 for all (x, y) ∈ P. Note that π = 0 and πn+1 = 0 as otherwise (x∗ , 0) or (x∗ , 1) violates  one of these inequalities. The tuple (π, π0 ) provides a ‘yes’ answer to (DI).  Note that (TCP) can be answered in polynomial time if the set D of directions allowed in the replacement operation is polynomial in the size of T , e.g., D = {e1 , . . . , en }. Indeed, one can try the drop operation at each node and the replace operation for each node-direction pair (v, d); this requires polynomial time because the size of D is polynomial in the size of T . The next theorem shows that tree compression does not always yield the smallest tree for a given dual bound.  
   
  354  
   
  G. Mu˜ noz et al.  
   
  Theorem 2. For n ≥ 2, there exists a polytope P ⊆ Rn+1 and a BB tree T with root polyhedron P such that 1. |T | ≥ 2n+1 − 1 and d(T, 0) = ∞. n 2. T cannot be compressed to a tree with fewer than (2 − 1)/n nodes.   3. There exists a tree T with root P, |T | = 7 and d(T, 0) = d(T  , 0). Proof. Let P ⊆ [0, 1]n be a polytope satisfying P ∩ Zn = ∅ and if a tree T with root P satisﬁes d(T , 0) = ∞, then |T | ≥ 2n+1 − 1. One such P comes from [11, Proposition 3]. Let T be a BB tree of minimal size with root P and d(T , 0) = ∞. Minimality implies that only the leaves correspond to empty polyhedra. There exist (|T | − 1)/2 ≥ 2n − 1 non-empty non-leaf nodes in T . For each non-empty node v ∈ T , we have Q(v) \ Zn = Q(v) = ∅. So, there exists i∗ ∈ {1, . . . , n} such n that at least (2 − 1)/n nodes in T whose corresponding polyhedron contains a point with i∗ th component in (0, 1). We denote the set of these nodes as N := {v ∈ T : ∃ x ∈ Q(v) with xi∗ ∈ (0, 1)}. For each v ∈ N , arbitrarily choose a point in Q(v) whose i∗ th component is in (0, 1) and call this point x(v). Deﬁne P := conv({(x(v), t) : v ∈ N and t ∈ {0, 1}} ∪ (P × {1/2})). Note that P ∩ Zn+1 = ∅. Create a BB tree T  with root polyhedron P and d(T  , 0) = ∞ by ﬁrst branching on (xn+1 ≤ 0) ∨ (xn+1 ≥ 1); the polyhedra of the resulting children are conv{(x(v), j) : v ∈ N } for j ∈ {0, 1}. Given that x(v)i∗ ∈ (0, 1) for each v ∈ N , we can branch on each conv{(x(v), j) : v ∈ N } using (xi∗ ≤ 0) ∨ (xi∗ ≥ 1) to obtain all empty children nodes. This proves 3. We deﬁne T in the theorem by lifting T . More precisely, extend every disjunction (π  x ≤ π0 ) ∨ (π  x ≥ π0 + 1) in T to a disjunction (π  x ≤ π0 ) ∨ (π  x ≥ π0 + 1), where π := (π, 0). Thus, |T | = |T | ≥ 2n+1 − 1. Furthermore, P ⊆ P × R, so d(T, 0) = ∞ because d(T , 0) = ∞. Thus, T satisﬁes 1. It remains to prove 2. Every point in P is of the form (x , α), where x in P and α ∈ [0, 1]. Assume to the contrary that T can be compressed via the drop operation. The corresponding node in T can also be dropped. However, this contradicts the minimality of T . We claim that if v ∈ T corresponds to a node in v ∈ N , then T cannot be compressed at v using the replace operation. Suppose there exists v ∈ T corresponding to a node v ∈ N and a disjunction (π  x + πn+1 xn+1 ≤ π0 ) ∨ (π  x + πn+1 xn+1 ≥ π0 + 1) that we can use to compress T at v via the replace operation, i.e., Q(v) ⊆ {(x, α) ∈ Rn × R : π0 < π  x + πn+1 α < π0 + 1}. If πn+1 = 0, then this disjunction can be projected to T to compress it, contradicting the minimality of T . So, πn+1 = 0. For each α ∈ [0, 1] the point (x(v), α) satisﬁes π0 − π  x(v) < πn+1 α < π0 − π  x(v) + 1. But this cannot be satisﬁed if we plug in α = 0 and α = 1 because πn+1 ∈ Z. Thus, the replace operation can only be applied to nodes in T that do not n correspond to nodes in N . We have |N | ≥ (2 − 1)/n, so T cannot be compressed n   to fewer than (2 − 1)/n nodes, which proves 2.  
   
  Compressing Branch-and-Bound Trees  
   
  4  
   
  355  
   
  Compression Algorithms  
   
  In this section we introduce two compression algorithms and later evaluate their performance. Let T be a BB tree and c ∈ Qn . For both algorithms, the general approach we follow is: (1) Traverse T starting from the root. We may skip leaves, since these are not compressible; (2) If the minimum of x → c x over Q(v) is greater than or equal to d(T, c) then we apply drop(T, v); (3) Otherwise, we search for (π, π0 ) ∈ Zn × Z such that T  = replace(T, v, π, π0 ) satisﬁes d(T, c) ≥ d(T  , c). In the following, we provide two methods for Step (3), which is the bottleneck of the procedure. 4.1  
   
  An Exact Method  
   
  A BB tree replace(T, v, π, π0 ) is a compression of T if and only if min{c x : x ∈ Q(v), π  x ≤ π0 } ≥ d(T, c) and min{c x : x ∈ Q(v), π  x ≥ π0 + 1} ≥ d(T, c). Mahajan and Ralphs [23] proposed MIP formulation that can be used to ﬁnd such (π, π0 ); the only diﬀerence is that they used it for ﬁnding a general disjunction that could provide the best possible dual improvement when branching, but we can easily adapt it to our compression task. The resulting model we use is ⎫ ⎧ A p − sL c − π = 0, p b − d(T, c)sL − π0 ≥ δ ⎬ ⎨ (3) δ : A q − sR c + π = 0, q b − d(T, c)sR − π0 ≥ δ − 1 max ⎭ δ,p,q,π, ⎩ π0 ,sL ,sR p, q ≥ 0, sL , sR ≥ 0, π ∈ Zn , π0 ∈ Z Any feasible solution with δ > 0 produces a tuple (π, π0 ) that we can use in the replace operation. Conversely, if no such δ exists, neither does a suitable disjunction; see [23]. Model (3) can be costly to solve in practice. However, if given enough time, one can be certain that it will yield an algorithm capable of compressing T as much as possible. 4.2  
   
  A Heuristic Method  
   
  Many heuristic methods for ﬁnding good branching directions have been proposed in the literature (e.g. [9,16,19,27]) and can be readily used for tree compression. Here, we adapt a procedure in Owen and Mehrota [27] that iteratively improves variable directions by changing one coeﬃcient at a time. To outline the method, assume we have solved the LP relaxation at a node v. The ﬁrst step is to ﬁnd the best variable direction π ∈ {e1 , . . . , en }. Suppose π  x ≤ π0 is the side of the disjunction with the smallest optimal value. We add this constraint to the node LP and re-solve it to obtain a fractional solution x. For each fractional component xi , we then evaluate the branching directions π + ei and π − ei . If one of these directions yields a better dual bound than π, then we replace π by it and repeat the procedure until π can no longer be improved. At the end, if the bound provided by π is better than the tree bound, we apply replace(T, v, π, π0 ). Unlike the previous exact method, this iterative method provides no guarantees that a suitable disjunction will be found, even if it exists, and therefore may not achieve the best compression. However, it is typically much faster.  
   
  356  
   
  5  
   
  G. Mu˜ noz et al.  
   
  Computational Experiments  
   
  In this section, we attempt to compress MIPLIB 3.0 trees using the methods described in the previous section. Our main goal is to evaluate, without taking running time into consideration, how compressible are realistic BB trees generated by two commonly-used branching strategies — full strong branching (FSB) and reliability branching with plunging (RB). Our secondary goal is to estimate how much of this compression can be achieved in shorter and more practical running times. 5.1  
   
  Methodology  
   
  For each branching strategy and for each MIPLIB 3.0 instance, we started by generating a BB tree using a custom textbook implementation of the BB method. We chose MIPLIB 3.0, instead of larger benchmark sets, so that we could compute large FSB trees for all instances and could obtain accurate results for the exact compression method. We used a custom implementation of the BB method, instead of exporting the tree generated by a commercial MIP solver, so that we could easily understand how exactly the tree is generated and control every aspect of the algorithm. The implementation is written in Julia 1.8 and has been made publicly available as part of the open-source MIPLearn software package [29]. It relies on an external LP solver, accessed through JuMP [13] and MathOptInterface [21], to solve the LP relaxation of each BB node and to evaluate strong branching decisions. In our experiments, we used Gurobi 9.5 [17] with default settings as the LP solver. When generating the trees, we provided the optimal value to the BB method and imposed a 10,000-node limit. No time limit was imposed, and no presolve or cutting planes were applied. After the trees were generated, they were then compressed by the exact and the heuristic methods described in Sect. 4. Both methods were implemented in Python 3.10 and gurobipy. The nodes were traversed using depth-ﬁrst search. For the exact method, we imposed a 24-h limit on the entire procedure and a 20min limit on each individual MIP. For the heuristic method, we imposed a 15-min limit on the entire procedure and no time limits on individual nodes. All MIPs and LPs were solved with Gurobi 9.5 with default settings. The experiments were run on a dedicated desktop computer (AMD Ryzen 9 7950X, 4.5/5.7 GHz, 16 cores, 32 threads, 128 GB DDR5), and 32 trees were compressed in parallel at a time; each compression was single-threaded. 5.2  
   
  Full Strong Branching Results  
   
  Full strong branching (FSB) is a strategy which solves, at each node of the BB tree, two LPs for each fractional variable, then picks as the branching variable the one that presents the best overall improvement to dual bound [2]. FSB is often paired, as we do in our experiments, with best-bound node selection rule, which always picks, as the BB node to process next, an unexplored leaf node that has minimal optimal value. Although computationally expensive, FSB is typically  
   
  Compressing Branch-and-Bound Trees  
   
  357  
   
  Fig. 1. Compressibility of FSB trees (exact method, 24-h limit).  
   
  considered the state-of-the-art branching strategy in terms of node count, so one would naturally expect such trees to be hard to compress. Figure 1 shows the exact compressibility of FSB trees under diﬀerent restrictions on the support size of the disjunction. Speciﬁcally, supp:inf corresponds to the exact method based on Model (3), whereas supp:1 and supp:2 use the same model, but impose the additional constraint that at most 1 or 2 coeﬃcients of π, respectively, can be non-zero. Method drop is the method in which we are only allowed to drop nodes, not replace them. In the chart, the compressibility of diﬀerent methods is superimposed, with the weaker methods in the foreground and the stronger methods in the background. The y-axis indicates how small is the resulting tree, with larger values indicating higher compression. For example, on instance vmp1, methods drop, supp:2 and supp:inf were able to reduce the tree by 22.2%, 67.1% and 80.9%, respectively. Method supp:1 does not appear in the chart because it was not able to improve upon drop. The line shows the average compression obtained by the strongest method across all instances. Our ﬁrst insight from Fig. 1 is that many FSB trees can be signiﬁcantly compressed, despite the notorious tree-size eﬃciency of this branching rule. On average, supp:inf was able to reduce tree size by 35.2%, with the ratio exceeding 50% for 20 (out of 59) instances. We also note, from the ﬁgure, that a large support size is required for obtaining the best results, although a restricted support size still provides signiﬁcant compression. On average, supp:2 compressed the trees by 24.0%, which is still considerable, although being well below supp:inf. Method supp:1, on the other hand, never outperformed drop. This was expected, as it can be easily shown that trees generated by FSB (with best-bound) on a particular set of candidate branching directions can never be compressed (beyond dropping nodes) based on the same set of directions. Also as a direct consequence of using the best-bound node selection rule, we observed that, for the vast majority of instances, few nodes could be dropped. On average, drop was only able  
   
  358  
   
  G. Mu˜ noz et al.  
   
  Fig. 2. Compressibility of FSB trees (heuristic method, 15-min limit).  
   
  to compress the trees by 12.1% on average, with the compression being near zero for 50 instances. Finally, despite the positive average compression results for supp:inf, we do note that a large number of trees could not be meaningfully compressed. Speciﬁcally, supp:inf presented a compression ratio below 5% for 19 instances, which may indicate that trees for certain classes of problems are hard to compress. Furthermore, supp:inf took an exceedingly long average time of 47,153 s, with 25 instances hitting the 24-h limit. We now focus on more practical tree compression algorithms. Figure 2 shows the performance of the heuristic method, outlined in Subsect. 4.2, on the same BB trees, with a 15-min limit. We see that the heuristic method is able to obtain compression ratios comparable to supp:inf in a reasonable amount of time. On average, heuristic took 493 s to run (95x faster than the exact method), and reduced tree size by 27.7% (7.5% points lower). We conclude that FSB trees are compressible not only in a theoretical sense, but also in practice. We also note that heuristic outperformed supp:inf for 12 instances, sometimes by a signiﬁcant margin. Notable examples include instances bell5, bell3a, vpm2, p0282 and mas74, where the margin exceeded 15% points. This is possible due to the time limits imposed on supp:inf. 5.3  
   
  Reliability Branching with Plunging  
   
  Reliability branching (RB) is a strategy that attempts to accelerate FSB by skipping strong branching computations for variables that already have reliable pseudocosts [2]. In our experiments, the pseudocost of a variable is considered reliable if it is based on 10 or more strong branching evaluations. RB has been shown to perform well on a variety of real-world instances and it is often considered the state-of-the-art branching rule in terms of running time. Plunging is a modiﬁcation to node selection which attempts to exploit the fact that sequentially solving two LPs that are similar can done much faster than solving two LPs  
   
  Compressing Branch-and-Bound Trees  
   
  359  
   
  Fig. 3. Compressibility of RB trees (exact method, 24-h limit).  
   
  that are signiﬁcantly diﬀerent. When plunging is enabled, the BB method picks, as the node to explore next, one of the children of the most-recently explored node, falling back to best-bound node selection when both children are pruned. Our motivation for analyzing RB trees with plunging is that we expect such trees to resemble the ones generated by typical state-of-the-art MIP solvers. Figure 3 shows the exact compressibility of RB trees, under diﬀerent support size restrictions. The ﬁrst notable fact is that RB trees are, as expected, much more compressible than FSB trees. On average, drop, supp:1, supp:2 and supp:inf were able to reduce tree size by 51.9%, 57.3%, 61.5% and 66.3%, respectively. Method supp:inf presented compression ratio above 50% for 42 (out of 59) instances, and above 80% for 34 instances. The strong performance of drop can be directly attributed to plunging. While the technique may be helpful when solving MIPs, we observed that it leads to the exploration of areas in the tree that do not contribute to its overall dual bound, and which can be dropped in a post-hoc analysis. As with previous experiments, the best compression results were obtained with larger support sizes, although, in this case, the beneﬁts of unbounded support were not as large as before, in relative terms. Method supp:1, unlike in previous experiments, provided signiﬁcant compression in a number of instances (e.g. gen, l152lav, qnet1 o), and a modest average improvement over drop. We attribute this to suboptimal variable branching decisions made by RB, which is also expected. As in the previous case, we do note that supp:inf failed to meaningfully compress a few instances, and it was overall prohibitively slow, requiring 45,256 s on average. Finally, Fig. 4 shows the performance of the heuristic method on RB trees. Similarly to the results in the previous section, the heuristic method presented very strong performance, obtaining compression ratios that approached or even exceed those of the exact method, in much smaller running times. Method heuristic took an average of 335 s (134x faster) and obtained an average com-  
   
  360  
   
  G. Mu˜ noz et al.  
   
  Fig. 4. Compressibility of RB trees (heuristic method, 15-min limit).  
   
  pression ratio of 63.7% (2.5% points lower). We conclude that BB trees generated by node and variable selection rules that focus on MIP solution time tend to be highly compressible, in both a theoretical and a practical sense.  
   
  6  
   
  Future Work  
   
  We have formally introduced the tree compression problem, and we demonstrated through experiments how much trees can be compressed. There are many open questions that we believe warrant future research. First, is there a family of problems for which BB trees generated, say using strong branching, can be provably compressed? Second, for a tree generated using branching directions in a set D, how compressible is the tree using directions in the Minkowski Sum D + D? In particular when D is the set of variable disjunctions, a positive result may indicate sparse disjunctions that are useful in a BB tree. This would complement our current computational results on disjunctions of support size 2. Third, given that the compression algorithm is based (partially) on general disjunctions which can be seen as splits, is there a relationship between the strength of split cuts at the root and the compressibility of a BB tree? Finally, could the general disjunctions found by the compression algorithm be useful in solving similar MIP instances? Acknowledgements. J. Paat was supported by a Natural Sciences and Engineering ´ Research Council of Canada Discovery Grant [RGPIN-2021-02475]. A.S. Xavier was partially supported by the U.S. Department of Energy Oﬃce of Electricity. The authors want to thank the referees, whose comments improved the overall presentation of the paper, led to better bounds in Theorem 2, and identiﬁed directions of future work.  
   
  Compressing Branch-and-Bound Trees  
   
  361  
   
  References 1. Aardal, K., Lenstra, A.: Hard equality constrained integer knapsacks. Math. Oper. Res. 29, 724–738 (2004) 2. Achterberg, T., Koch, T., Martin, A.: Branching rules revisited. Oper. Res. Lett. 33(1), 42–54 (2005) 3. Basu, A., Conforti, M., Di Summa, M., Jiang, H.: Complexity of branch-and-bound and cutting planes in mixed-integer optimization - II. In: Singh, M., Williamson, D.P. (eds.) IPCO 2021. LNCS, vol. 12707, pp. 383–398. Springer, Cham (2021). https://doi.org/10.1007/978-3-030-73879-2 27 4. Beame, P., et al.: Stabbing planes. In: Karlin, A.R. (ed.) 9th Innovations in Theoretical Computer Science Conference (ITCS 2018). Leibniz International Proceedings in Informatics (LIPIcs), vol. 94, pp. 10:1–10:20. Schloss Dagstuhl-LeibnizZentrum fuer Informatik, Dagstuhl (2018). https://doi.org/10.4230/LIPIcs.ITCS. 2018.10, http://drops.dagstuhl.de/opus/volltexte/2018/8341 5. Bixby, R.: Solving real-world linear programs: a decade and more of progress. Oper. Res. 50(1), 3–15 (2002) 6. Bixby, R., Boyd, E., Indovina, R.: MIPLIB: a test set of mixed integer programming problems. SIAM News (1992) 7. Cheung, K.K.H., Gleixner, A., Steﬀy, D.E.: Verifying integer programming results. In: Eisenbrand, F., Koenemann, J. (eds.) IPCO 2017. LNCS, vol. 10328, pp. 148– 160. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-59250-3 13 8. Chv´ atal, V.: Hard knapsack problems. Oper. Res. 28, 1402–1411 (1980) 9. Cornu´ejols, G., Liberti, L., Nannicini, G.: Improved strategies for branching on general disjunctions. Math. Program. 130, 225–247 (2011) 10. Dadush, D., Tiwari, S.: On the complexity of branching proofs. In: Saraf, S. (ed.) 35th Computational Complexity Conference (CCC 2020). Leibniz International Proceedings in Informatics (LIPIcs), vol. 169, pp. 34:1–34:35. Schloss DagstuhlLeibniz-Zentrum f¨ ur Informatik, Dagstuhl (2020) 11. Dey, S., Dubey, Y., Molinaro, M.: Lower bounds on the size of general branch-andbound trees. Math. Program. (2022) 12. Dey, S., Dubey, Y., Molinaro, M., Shah, P.: A theoretical and computational analysis of full strong-branching. arXiv:2110.10754 (2021) 13. Dunning, I., Huchette, J., Lubin, M.: Jump: a modeling language for mathematical optimization. SIAM Rev. 59(2), 295–320 (2017). https://doi.org/10.1137/ 15M1020575 14. Fischetti, M., Monaci, M.: Backdoor branching. INFORMS J. Comput. 25(4), 693–700 (2018) 15. Gamrath, G., Melchiori, A., Berthold, T., Gleixner, A.M., Salvagnin, D.: Branching on multi-aggregated variables. In: Michel, L. (ed.) CPAIOR 2015. LNCS, vol. 9075, pp. 141–156. Springer, Cham (2015). https://doi.org/10.1007/978-3-319-180083 10 16. Gl¨ aser, M., Pfetsch, M.: On the complexity of ﬁnding shortest variable disjunction branch-and-bound proofs. In: Aardal, K., Sanit` a, L. (eds.) IPCO 2022. LNCS, vol. 13265, pp. 291–304. Springer, Cham (2022). https://doi.org/10.1007/978-3-03106901-7 22 17. Gurobi Optimization: Gurobi Optimizer (Version 9.5). https://www.gurobi.com/ products/gurobi-optimizer/. Accessed 4 Nov 2022 18. Jeroslow, R.: Trivial integer programs unsolvble by branch-and-bound. Math. Program. 6, 105–109 (1974)  
   
  362  
   
  G. Mu˜ noz et al.  
   
  19. Karamanov, M., Cornu´ejols, G.: Branching on general disjunctions. Math. Program. 128, 403–436 (2011) 20. Khalil, E., Vaezipoor, P., Dilkina, B.: Finding backdoors to integer programs: a Monte Carlo tree search framework. In: Proceedings of AAAI (2022) 21. Legat, B., Dowson, O., Dias Garcia, J., Lubin, M.: MathOptInterface: a data structure for mathematical optimization problems. INFORMS J. Comput. 34(2), 672– 689 (2021). https://doi.org/10.1287/ijoc.2021.1067 22. Linderoth, J., Savelsbergh, M.: A computational study of search strategies for mixed integer programming. INFORMS J. Comput. 11(2), 173–187 (1999) 23. Mahajan, A., Ralphs, T.: Experiments with branching using general disjunctions. In: Proceedings of Operations Research and Cyber-Infrastructure, pp. 101–118 (2009) 24. Mahajan, A., Ralphs, T.: On the complexity of selecting disjunctions in integer programming. SIAM J. Optim. 20(5), 2181–2198 (2010) 25. Mahmoud, H., Chinneck, J.: Achieving MILP feasibility quickly using general disjunctions. Comput. Oper. Res. 40, 2094–2102 (2013) 26. Mehrotra, S., Li, Z.: Branching on hyperplane methods for mixed integer linear and convex programming using adjoint lattices. J. Glob. Optim. (2010) 27. Owen, J., Mehrotra, S.: Experimental results on using general disjunctions in branch-and-bound for general-integer linear programs. Comput. Optim. Appl. 20, 159–170 (2001) 28. Walter, M.: Sparsity of lift-and-project cutting planes. In: Helber, S., et al. (eds.) Operations Research Proceedings 2012, pp. 9–14. Springer, Cham (2014). https:// doi.org/10.1007/978-3-319-00795-3 2 29. Xavier, A.S., Qiu, F.: MIPLearn: a framework for learning-enhanced mixedinteger optimization (Julia interface) (2022). https://github.com/ANL-CEEESA/ MIPLearn.jl 30. Yang, Y., Boland, N., Savelsbergh, M.: Multivariable branching: a 0–1 knapsack problem case study. INFORMS J. Comput. 33(4), 1354–1367 (2021)  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear Bilevel Programming Gonzalo Mu˜ noz(B) , David Salas, and Anton Svensson Instituto de Ciencias de la Ingenier´ıa, Universidad de O’Higgins, Rancagua, Chile {gonzalo.munoz,david.salas,anton.svensson}@uoh.cl Abstract. We study linear bilevel programming problems whose lowerlevel objective is given by a random cost vector with known distribution. We consider the case where this distribution is nonatomic, allowing to pose the problem of the leader using vertex-supported beliefs in the sense of [29]. We prove that, under suitable assumptions, this formulation turns out to be piecewise aﬃne over the so-called chamber complex of the feasible set of the high point relaxation. We propose two algorithmic approaches to solve general problems enjoying this last property. The ﬁrst one is based on enumerating the vertices of the chamber complex. The second one is a Monte-Carlo approximation scheme based on the fact that randomly drawn points of the domain lie, with probability 1, in the interior of full-dimensional chambers, where the problem (restricted to this chamber) can be reduced to a linear program. Keywords: Bilevel Programming · Bayesian Approach · Chamber complex · Enumeration algorithm · Monte-Carlo algorithm  
   
  1  
   
  Introduction  
   
  Stackelberg games, also referred to as bilevel programming problems, were ﬁrst introduced by H. von Stackelberg in [31]. In this seminal work, an economic equilibrium problem between two ﬁrms was studied, under the particularity that one of them, the leader, is able to anticipate the decisions of the other one, the follower. Bilevel programming is an active ﬁeld of research, and we refer the reader to the monographs [10,11] for comprehensive introductions, and to [12] for recent developments. In the last decade, researchers have started to consider uncertainty in Stackelberg games. A recent survey by Beck, Ljubi´c and Schmidt [3] provides an overview of new questions and recent contributions on this topic. One model that considers uncertainty in Stackelberg games is the Bayesian approach [26,29]. The starting point is that for any given leader’s decision x, the leader only knows that the reaction y of the follower is selected from a set Y (x), The ﬁrst author was supported by FONDECYT Iniciaci´ on 11190515 (ANID-Chile). The second author was supported by the Center of Mathematical Modeling (CMM) FB210005 BASAL funds for centers of excellence (ANID-Chile), and the grant FONDECYT Iniciaci´ on 11220586 (ANID-Chile). The third author was supported by the grant FONDECYT postdoctorado 3210735 (ANID-Chile). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 363–377, 2023. https://doi.org/10.1007/978-3-031-32726-1_26  
   
  364  
   
  G. Mu˜ noz et al.  
   
  hence being y a decision-dependent uncertainty parameter. The leader endows the set Y (x) with a probability distribution βx which models how the leader believes that the possible responses of the follower are distributed. Note that the classical optimistic and pessimistic approaches of bilevel programming are included in this setting, under quite mild assumptions (see [29]). Uncertainty in the data of the lower-level has been considered by Claus for linear bilevel programming from a variational perspective considering risk measures (see the survey [6] by Burtscheidt, and the references therein, and the recent works [7,8]). In [19], Ivanov considered the cost function of the follower as a bilinear form Ax + ξ(ω), y. Recently, in [5], Buchheim, Henke and Irmai considered a bilevel version of the continuous knapsack problem with uncertainty on the follower’s objective. In this work, we consider a linear bilevel programming problem where the lower-level objective is uncertain for the leader but follows a prior known distribution (as the particular case studied in [5]). We study the problem from a Bayesian approach perspective [29], and by means of the so-called chamber complex of a polytope (see Sect. 4), which subdivides the space of the leader’s decisions in a meaningful way. The idea of using the chamber complex to understand geometrical properties of optimization problems under uncertainty is not new, but it is recent. To the best of our knowledge, the ﬁrst work that does this is [14] (see also [13]), on which multistage stochastic linear optimization is studied. However, the techniques there cannot be extended to Stackelberg games. Due to space constraints, we do not provide all details in this extended abstract. We refer the reader to our full-length preprint [27]. 1.1  
   
  Problem Formulation and Contributions  
   
  Our study focuses on the setting of linear bilevel programming, i.e., the objective functions and constraints of the problem are all linear. More precisely, we aim to study the problem where the leader decides a vector x ∈ Rnx that solves ⎧ min d1 , x + E[d2 , y(x, ω)] ⎪ ⎪ x ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ s.t. x ∈ X ⎧ (P) := (1) ⎪ c(ω), y ⎪ ⎨ min ⎪ y ⎪ ⎪ ny ⎪ y(x, ω) solves ω ∈ Ω a.s. ⎪ ⎪ ⎪ s.t. y ∈ R , ⎩ ⎩ Ax + By ≤ b, where A ∈ Rm×nx , B ∈ Rm×ny , b ∈ Rm , d1 ∈ Rnx , d2 ∈ Rny , c : Ω → Sny is a random vector over a probability space (Ω, Σ, P) with values in the unit sphere of Rny , and X ⊂ Rnx is a nonempty polytope. The notation carries the usual ambiguity of bilevel problems, which appears whenever the lower-level optimal response y(x, ω) is not uniquely determined for some x ∈ X. However, we focus our attention here on costs whose distributions are nonatomic (in a sense we will specify later on) which implies that, with probability 1, y(x, ω) is unique for all x ∈ X.  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  365  
   
  Our main contributions regarding this problem are: (a) To rewrite (1) using a Bayesian approach formulation and a sample average approximation for it; (b) to show the structure of the leader’s objective function and its relation to the chamber complex of the feasible set of the high-point relaxation; and (c) to exploit these structures in a mixed-integer-programming-based algorithm and in a Monte-Carlo algorithm that can tackle (1).  
   
  2  
   
  Preliminaries  
   
  For an integer n ∈ N, we write [n] := {1, . . . , n}. Throughout this work, we will consider Euclidean spaces Rn endowed with their usual norm · and their inner product ·, ·. We denote by Sn the unit sphere of Rn . For a set O ⊂ Rn , we denote the aﬃne dimension of O as dim(O), which corresponds to the dimension of the aﬃne envelope of O, denoted by aﬀ(O). The relative interior of O is denoted by ri(O). We write 1O to denote the indicator function of a set O ⊂ Rn , having value 1 on O and 0 elsewhere. In general, we follow the standard notation of mathematical programming. For a polyhedron P , we denote by F (P ) the collection of all faces of P , and by ext(P ) the vertices (extreme points) of P . For any k ∈ {0, . . . , n} we will write (2) F≤k (P ) := {F ∈ F (P ) : dim(F ) ≤ k}. If there is no ambiguity, we might simply write F and F≤k . For a convex set C ⊂ Rn and a point x ∈ C, we write NC (x) to denote the normal cone of C at x, i.e., (3) NC (x) = {d ∈ Rn : d, y − x ≤ 0 ∀y ∈ C}. Motivated by the structure of problem (1), we deﬁne the polyhedron D as the feasible region of the high-point relaxation of the problem (see, e.g., [21]), i.e., D = {(x, y) ∈ Rnx × Rny : Ax + By ≤ b} .  
   
  (4)  
   
  It will be assumed throughout the paper that D is full dimensional. We do not lose generality since it is always possible to embed D into Rdim(D) . We will also assume that D is compact, i.e. it is a polytope. Finally, by moving the leader’s constraints to the follower’s problem, we assume without losing any generality that   (5) X = x ∈ Rnx : ∃y ∈ Rny such that Ax + By ≤ b . In the latter assumption about X we are simply stating that the lower-level problem is feasible for any feasible choice of x and restricting ‘unilaterally’ the x coordinate in D which does not change the lower-level problem. We deﬁne the ambient space Y for the follower’s decision vector as   Y = y ∈ Rny : ∃x ∈ Rnx such that Ax + By ≤ b . (6) Note that, since D is full-dimensional and compact in Rnx × Rny , both X and Y are full-dimensional (in Rnx and Rny , respectively) and compact as well. We  
   
  366  
   
  G. Mu˜ noz et al.  
   
  write π : Rnx ×Rny → Rnx to denote the parallel projection given by π(x, y) = x. In particular, equation (5) can be written as X = π(D). Given nonempty sets U ⊂ Rnx and V ⊂ Rny we write M : U ⇒ V to denote a set-valued map, i.e., a function assigning to each x ∈ U a (possibly empty) set M (x) in V . In this work, we consider the set-valued map S : X ⇒ Rny deﬁned as (7) S(x) = {y ∈ Rny : (x, y) ∈ D}. We call S the ﬁber map of D (through the projection π). Clearly, S has nonempty convex and compact values, and S(X) = Y , as given by equation (6).  
   
  3  
   
  Vertex-Supported Beliefs and Bayesian Formulation  
   
  In what follows, we write B(Y ) to denote the Borel σ-algebra of Y and P(Y ) to denote the family of all (Borel) probability measures on Y . We endow P(Y ) with the topology of weak convergence (see, e.g., [22, Chapter 13]). Accordingly, we will say that a measure-valued map h : X → P(Y ) is weak continuous if it is so for this topology (which coincides with the weak* topology when looking the space of measures as the dual space of the space of continuous functions, see [22, Remark 13.14]). Recall from [29] that for a set-valued map M : X ⇒ Y with closed and nonempty values, a map β : X → P(Y ) is said to be a belief over M if for every x ∈ X, the measure β(x) = βx concentrates on M (x), i.e., βx (M (x)) = 1. By identifying P(M (x)) with its natural injection into P(Y ), a belief over M can be understood as a selection of {P(M (x)) : x ∈ X}. Let (Ω, Σ, P) be a probability space. To model the cost function of the lowerlevel problem in (1), we will consider only random vectors c : Ω → Sny with nonatomic distributions, in the sense that ∀O ∈ B(Sny ) :  
   
  Hny −1 (O) = 0 =⇒ P[c(ω) ∈ O] = 0,  
   
  (8)  
   
  where B(Sny ) stands for the Borel σ-algebra of Sny , and Hny −1 denotes the (ny − 1)-Hausdorﬀ measure over (Sny , B(Sny )). In other words, the probability measure P ◦ c−1 is absolutely continuous with respect to Hny −1 . Note that with this deﬁnition, any random vector c : Ω → Rny , which has an absolutely continuous distribution with respect to the Lebesgue measure Lny , induces an equivalent c(ω) . This new random vector is random vector c¯ : Ω → Sny given by c¯(ω) = c(ω) well-deﬁned almost surely in Ω, except for the negligible set N = c−1 (0), and using c(·) or c¯(·) in problem (1) is equivalent. Now, to understand the distribution of the optimal response y(x, ω) induced by the random vector c : Ω → Sny , we consider a belief β : X → P(Y ) over the ﬁber map S : X ⇒ Y given by dβx (y) = pc (x, y) := P[−c(ω) ∈ NS(x) (y)].  
   
  (9)  
   
  Note that P[−c(ω) ∈ NS(x) (y)] = P[−c(ω) ∈ int(NS(x) (y)) ∩ Sny ] for any point (x, y) ∈ D, and that int(NS(x) (y)) is nonempty only if y is an extreme point  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  367  
   
  of S(x). By putting together both observations, one can easily deduce that for each x ∈ X, p(x, ·) is a discrete density function whose support is contained in ext(S(x)). Therefore, the belief β is given by  pc (x, y)1O (y), ∀O ∈ B(Y ). (10) βx (O) = y∈ext(S(x))  
   
  We call β the vertex-supported belief induced by c. With this construction, we can rewrite problem (1) as (P) := min d1 , x + Eβx [d2 , y] x∈X  
   
  (11)  
   
  where Eβx [d2 , y] = y∈ext(S(x)) d2 , ypc (x, y). Our goal in this work is to study problem (1) by proﬁting from the Bayesian formulation (11), in the sense of [29]. 3.1  
   
  Sample Average Formulation  
   
  Problem (11) has an intrinsic diﬃculty which consists in how to evaluate the objective function θ(x) = d1 , x + Eβx [d2 , y]. To make an exact evaluation of θ at a point x ∈ X one would require to compute the set of all vertices y1 , . . . , yk of S(x) (having a positive probability of being optimal for c(ω)) and to compute the corresponding probabilities pc (x, y1 ), . . . , pc (x, yk ), deﬁned as the “sizes” of the respective normal cones at each vertex yi . This is not always possible. To deal with this issue, we consider the well-known sample average approximation (SAA) method for stochastic optimization (see, e.g., [18,30]). That is, we take an i.i.d sample {ˆ c1 , . . . , cˆN0 } of the random lower-level cost c(·), where each sample unit is drawn following the (known) distribution of c(·), and try to solve the (now deterministic) problem ⎧ N0 minx d1 , x + N10 i=1 d2 , yi (x) ⎪ ⎪ ⎪ ⎪ ⎨ ˆ := (P) (12) s.t. x ∈ X  
   
  ⎪ ⎪ ⎪ min ˆ c , y y i ⎪ ⎩ ∀i ∈ [N0 ], yi (x) solves s.t. Ax + By ≤ b. Proposition 1 ([27]). Assume that c(·) has a nonatomic distribution over Sny , in the sense of (8). Then, with probability 1, we have that for each i ∈ [N0 ] and ci , y : Ax + By ≤ b} is a singleton. each x ∈ X the set argminy {ˆ Based on the above proposition, for the sample {ˆ c1 , . . . , cˆN0 } we can, for each i ∈ [N0 ], deﬁne the mapping x → yi (x) where yi (x) is the unique ci , y : Ax + By ≤ b}. Thus, almost surely, problem (12) is element argminy {ˆ well-deﬁned. We close this section by stating that problem (12) is a consistent approximation of the original problem (11).  
   
  368  
   
  G. Mu˜ noz et al.  
   
  Proposition 2 ([27]). Let x∗N0 be an optimal solution of (12) for a sample of ∗ be the associated optimal value. Let S be the set of solutions size N0 , and let νN 0 N →∞  
   
  0 of (1) and let ν¯ be its optimal value. Then, d(x∗N0 , S) := inf x∈S x∗N0 −x −−− −−→  
   
  N →∞  
   
  0 ∗ 0, and νN −−− −−→ ν¯, both with probability 1. 0  
   
  4  
   
  Geometrical Structure of Vertex-Supported Beliefs  
   
  Here, we recall the deﬁnition of a chamber complex, frequently used in some ﬁelds of mathematics, like computational geometry (see, e.g., [9]). Definition 1 (Chamber complex). Let D ⊂ Rnx × Rny be a polyhedron as described in (4). For each x ∈ X = π(D), we deﬁne the chamber of x as   π(F ) : F ∈ F (D), x ∈ π(F ) . (13) σ(x) = The chamber complex, is then given by the (ﬁnite) collection of chambers, i.e., C (D) = {σ(x) : x ∈ X}. For a more comprehensive exposition of the chamber complex C (D) and their many interesting properties, we refer the reader to [9,13,14,27] and references therein. The next proposition shows that to compute a chamber it is enough to consider faces of D with dimensions up to nx instead of the collection of all faces. Proposition 3 ([27]). For any x ∈ X, one has that σ(x) = {π(F ) : F ∈ F , x ∈ π(F ), dim(F ) ≤ nx }. While the previous result narrows the class of faces that are needed to compute a chamber, we may still need faces of drastically diﬀerent dimensions. The next example illustrates this phenomenon. Example 1. Consider the polytope D := {(x, y) ∈ R2 × R : |x1 | ≤ y ≤ 1 − |x2 |}, whose vertices are (0, ±1, 0) and (±1, 0, 1). Clearly, (0, 0) and (1, 0) are minimal chambers, however, (0, 0) is not a projection of a vertex of D, while (1, 0) cannot be obtained using only projections of facets. It is well-known (see, e.g., [14]) that the family {ri(K) : K ∈ C(D)} is a partition of X. With this in mind, we introduce the following deﬁnition. Definition 2. A function f : X → R is said to be piecewise linear over the chamber complex C (D) if there exists a sequence of pairs {(dK , aK ) : K ∈ C (D)} ⊂ Rnx × R such that  f (x) = (dK , x + aK )1ri(K) (x), ∀x ∈ X. (14) K∈C (D)  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  369  
   
  Fig. 1. The polytope D of Example 1 and its chamber complex whose vertex (0, 0) is not a projection of a vertex of D.  
   
  In what follows, it will be useful to distinguish minimal chambers and maximal chambers, with respect to the inclusion ordering. The former are characterized by having nonempty interior, while the latter are the vertices in the chamber complex. Definition 3. Let D ⊂ Rnx ×Rny be a polyhedron as described in (4). We deﬁne K (D) := {K ∈ C (D) : int(K) = ∅} , V (D) := {v ∈ X : {v} ∈ C (D)} .  
   
  (15) (16)  
   
  We call K (D) the family of full-dimensional chambers of D, and V (D), the vertices of the chamber complex C (D) (which correspond to the family of zerodimensional chambers of D). It is worth mentioning that K (D) is a covering of X, i.e., X ⊂ K (D). This follows from the fact that each chamber is contained in a full-dimensional chamber. A very straightforward proposition (see [27]) is that  
   
  ext(K). (17) V (D) = K∈K (D)  
   
  A direct implication of this observation is the following corollary, which is one of the keystones of the enumeration algorithm that we propose. Corollary 1. If a function f : X → R is continuous and piecewise linear over the chamber complex C (D), then it has at least one minimizer in V (D). We ﬁnish this section with our main theorem. Theorem 1 (See [27]). Consider a random cost c with nonatomic distribution and β : X → P(Y ) the vertex-supported belief induced by c over S as deﬁned in (10). Then, 1. β is weakly continuous, and thus for any lower semicontinuous function f : X × Y → R, the problem min Eβx [f (x, ·)] has a solution. x∈X  
   
  2. The function x ∈ X → d1 , x+Eβx [d2 , y] is continuous and piecewise linear over C (D). 3. For almost every sample {ˆ c1 , . . . , cˆN0 }, the function x ∈ X → d1 , x + N0 1 i=1 d2 , yi (x) is well-deﬁned, continuous and piecewise linear over C (D). N0 In particular, problem (1) has at least one solution over V (D).  
   
  370  
   
  5  
   
  G. Mu˜ noz et al.  
   
  Algorithms  
   
  The rest of the work is focused on algorithms to solve problem (11) in the cases when we can evaluate the objective function x → d1 , x + Eβx [d2 , y], or solve problem (12), otherwise. Theorem 1 shows that both problems have the form min θ(x),  
   
  (18)  
   
  x∈X  
   
  where θ : X → R is a continuous function and it is piecewise linear over the chamber complex C (D) (with probability 1, in the case of problem (12)). Thus, we provide algorithms to solve this generic problem. 5.1  
   
  Enumeration Algorithm  
   
  Corollary 1 gives us a natural strategy to solve problem (18): It is enough to compute the chamber vertices V (D) and evaluate the corresponding objective function θ at each one of them. In this section we provide an enumeration algorithm to compute V (D) by sequentially solving mixed-integer programming problems which are formulated using F≤nx := {F ∈ F : dim(F ) ≤ nx }, as shown in Proposition 3. We remind the reader that, due to the discussion in Example 1, we may need faces of diﬀerent dimensions to compute V (D). This is why we rely on the full set F≤nx . Remark 1. Computing V (D) is at least as hard as computing all vertices of a polytope. Indeed, given an arbitrary (full-dimensional) polytope P ⊆ Rn , one may consider D = P × [0, 1]. The vertices of P correspond exactly to V (D). To the best of our knowledge, the complexity of ﬁnding all vertices of a polytope P is currently unknown; however, for a polyhedron P (not necessarily bounded), it is known that it is NP-complete to decide, given a subset of vertices of P , if there is a new vertex of P to add to the collection [20]. Therefore, we can expect that computing V (D) will be computationally expensive. For x ∈ X, let us deﬁne the label of x as the set (x) := {F ∈ F≤nx : x ∈ π(F )}. Endowing the set of all (ﬁnitely many) labels with the order of the inclusion, one can show (see [27]) that x ∈ V (D) ⇐⇒ (x) is a maximal label.  
   
  (19)  
   
  Intuitively, this states that a vertex of a chamber is obtained by intersecting as many projections of faces as possible (of dimension ranging from 0 to nx ). Using this result, we can generate an element of V (D) through a MILP formulation that ﬁnds an x such that (x) is a maximal label. The following formulation achieves this.  zF (20a) max z,x,y  
   
  s.t.  
   
  F ∈F ≤nx  
   
  Ax + ByF ≤ b AF x + BF yF ≥ bF − M (1 − zF )  
   
  ∀F ∈ F≤nx ∀F ∈ F≤nx  
   
  (20b) (20c)  
   
  zF ∈ {0, 1}  
   
  ∀F ∈ F≤nx  
   
  (20d)  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  371  
   
  Here, y and z stand for the vectors (yF : F ∈ F≤nx ) and (zF : F ∈ F≤nx ), respectively. For each F ∈ F≤nx , AF , BF and bF are submatrices of A, B and b such that F = {(x, y) ∈ D : AF x + BF y = b}. Finally, M is a vector of m positive values such that Ai x+Bi y −bi ≥ −Mi , for all (x, y) ∈ D. This vector M is well deﬁned when D is a polytope and can be easily computed using m linear programs. Formulation (20) is straightforward. It tries to “activate” as many faces as possible such that the intersection of their projection is non-empty. Remark 2. We note that, while conceptually simple, (20) depends on the enumeration of all faces F≤nx which can be a highly challenging task. Other approaches below also rely on this. We have not yet devised a mechanism around this potentially expensive enumeration; moreover, in many of our computational experiments (Sect. 6), our approaches are actively making use of a signiﬁcant portion of F≤nx . For this reason, we can only handle small-size problems in this work. We discuss potential future avenues for solving these limitations in Sect. 6. Note that these diﬃculties are in line with the discussion of Remark 1. Let (z ∗ , x∗ , y ∗ ) be an optimal solution of (20). It is not hard to see that x∗ is an element of V (D), thus, we can collect it and focus on generating a new element of V (D). Noting that (x∗ ) = {F ∈ F≤nx : zF∗ = 1}, we see that such new element can be obtained by adding the following inequality to (20)  zF ≥ 1. (21) ∗ =0 F ∈F ≤nx : zF  
   
  Since (x∗ ) is a maximal label, we can easily see that constraint (21) is removing only the single element x∗ of V (D) from (20). This is a so-called “no-good cut”. This procedure can be iterated until the optimization problem becomes infeasible. In our computational experiments, however, we noted that detecting infeasibility was particularly challenging for the optimization solver, and thus devised an alternative strategy: we add a new binary variable s that can relax (21) when needed, and whose value will deﬁne the stopping criterion. Under these considerations, we next present the precise model we use. Suppose we have partially generated a set V ⊆ V (D), we generate an element of V (D) \ V or determine V = V (D) using the following optimization problem  zF (22a) max z,s,x,y  
   
  s.t.  
   
  F ∈F ≤nx  
   
  Ax + ByF ≤ b  
   
  ∀F ∈ F≤nx  
   
  (22b)  
   
  AF x + BF yF ≥ bF − M (1 − zF )  zF + s ≥ 1  
   
  ∀F ∈ F≤nx  
   
  (22c)  
   
  ∀v ∈ V  
   
  (22d)  
   
  F ∈(v)  
   
    
   
  zF ≤ |F≤nx |(1 − s)  
   
  (22e)  
   
  F ∈F ≤nx  
   
  zF ∈ {0, 1} s ∈ {0, 1}  
   
  ∀F ∈ F≤nx  
   
  (22f) (22g)  
   
  372  
   
  G. Mu˜ noz et al.  
   
  Algorithm 1: Chamber vertex enumeration algorithm 1 2 3 4 5 6 7 8 9 10 11  
   
  Input: A, B, b deﬁning a polytope D = {(x, y) ∈ Rnx × Rny : Ax + By ≤ b}; Set V = ∅, s∗ = 0; Compute F≤nx (D); while true do Solve problem (22) and obtain an optimal solution (z ∗ , s∗ , x∗ , y ∗ ); if s∗ = 0 then break ; end V ← V ∪ {x∗ }; Store (x∗ ) = {F ∈ F≤nx (D) : zF∗ = 1}; end Result: The set V = V (D)  
   
  Lemma 1 (see [27]). Problem (22) is always feasible provided that D = ∅. Moreover, in an optimal solution (z ∗ , s∗ , x∗ , y ∗ ), then one (and only one) of the following situations hold (a) s∗ = 0 and x∗ ∈ V (D) \ V , or (b) s∗ = 1 and V (D) = V . In Algorithm 1 we formalize our enumeration procedure. To solve problem (18), it is enough to run Algorithm 1, and evaluate θ over the set V = V (D). 5.2  
   
  Monte-Carlo Approximation Scheme  
   
  The previous enumeration algorithm of Sect. 5.1 has several drawbacks. First, it requires (in practice) computing the whole collection of faces of D, which might depend exponentially on the whole dimension nx + ny . And even with the collection of faces at hand, computing all chamber vertices in V (D) can be hard. Moreover, V (D) might be exponentially large. Another approach, that we explore in this section, is to try to compute the collection of full-dimensional chambers K (D). Despite the fact that K (D) might still be exponentially large, in some cases it is considerably smaller than C (D). Moreover drawing points x uniformly over X yield that σ(x) ∈ K (D) almost surely. Indeed, this follows from Proposition 2.6 in [27] and the facts that there are ﬁnitely many chambers in K (D), and only those in K (D) are not negligible. To simplify the exposition, we will assume that X ⊂ [0, 1]nx and we will write c X = [0, 1]nx \ X. To be able to consider samples in [0, 1]nx , we identify (x) = ∅ for all x ∈ X c . We base our algorithm in the following lemma. Lemma 2 (see [27]). Let = (¯ x) for some x ¯ ∈ X and assume that K := σ(¯ x) is a full-dimensional chamber. Then, (x) ⊂ Fnx := {F ∈ F : dim(F ) = nx }. Moreover, for each j ∈ [nx ], the following linear problem  max t t, (yF )F ∈ (23) (¯ x + tej , yF ) ∈ F, ∀F ∈ , s.t.  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  373  
   
  Algorithm 2: Monte-Carlo algorithm 1 2 3 4 5 6 7 8 9 10 11  
   
  Input: A, B, b deﬁning a polytope D = {(x, y) ∈ Rnx × Rny : Ax + By ≤ b}, θ : X → R continuous and piecewise linear over C (D); Generate a (uniformly iid) training sample S of size N over [0, 1]nx ; Set List = ∅, x ˆ = N aN , θˆ = ∞; Compute Fnx ; foreach ξ ∈ S do Compute  = {F ∈ Fnx : ξ ∈ π(F )}; if  ∈ List or  = ∅ then continue; end List ← List ∪ {}; Compute d as in Lemma 2; Solve the linear problem   
   
  min  
   
  d , x  
   
  s.t.  
   
  (x, yF ) ∈ F, ∀F ∈   
   
  x,(yF )F ∈  
   
  12 13 14 15  
   
  ﬁnding a solution x ˆ and set the value θˆ = θ(ˆ x ); if θˆ < θˆ then x ˆ←x ˆ , θˆ ← θˆ ; end end ˆ for problem (18). Result: The pair solution-value (ˆ x, θ)  
   
  has a solution t∗j > 0. Finally, for every function θ : X → R continuous and piecewise linear over the chamber complex C (D), the vector d := dK ∈ Rnx   such that θ K = d , · + aK (for some aK ∈ R) can be computed as   
   
  d =  
   
    
   
  θ(¯ x + t∗nx enx ) − θ(¯ x) θ(¯ x + t∗1 e1 ) − θ(¯ x) ,··· , ∗ t1 t∗nx  
   
    
   
  .  
   
  With this result, we can establish a Monte-Carlo algorithm (see Algorithm 2) to approximate the solution of problem (18): we randomly draw points x ¯ x), and use Lemma 2 to optimize θ over σ(¯ x) via an from [0, 1]nx , compute (¯ LP formulation. Note that, to compute labels, we only need (with probability 1) access to Fnx , which might depend exponentially only on the lower-level dimension ny and not nx + ny (see [27]). The main drawback of Algorithm 2 is ˆ is an optimal solution of that we cannot ensure in general that the result (ˆ x, θ) problem (18) or not. A measurement in terms of unseen chambers is proposed ˆ might be. in [27] to quantify how good the solution (ˆ x, θ)  
   
  6  
   
  Numerical Experiments  
   
  We implemented both Algorithms 1 and 2 in Julia 1.8.2 [4], using Polymake [15] to compute the faces of a polytope and Gurobi 9.5.2 [16] to solve (22)  
   
  374  
   
  G. Mu˜ noz et al.  
   
  and any auxiliary LP. Our code is publicly available in https://github.com/gmunoz/bilevelbayesian. All experiments were run single-threaded on a Linux machine with an Intel Xeon Silver 4210 2.2G CPU and 128 GB RAM. The main objectives behind these experiments are (1) to determine how Algorithm 1 scales and (2) how well the Monte-Carlo algorithm performs in comparison to the exact method. A global time limit of 15 min was set for Algorithm 1; in case this time limit is met, only the chamber vertices that were found are used. We focus our attention in sample average formulations, as in (12), where the lower-level cost is assumed to have a uniform distribution over the unit sphere. We use instances from two publicly available libraries: BOLib [32] and the bilevel instances in [1], which we call CoralLib. Since our approach relies on computing a (possibly exponentially) large number of faces, we can only consider low-dimensional instances at the moment: we restrict to nx + ny ≤ 10. Additionally, we consider randomly generated instances of the stochastic bilevel continuous knapsack problem [5]. These instances have the form: max −δx + d y x  
   
  s.t. x ∈ [L, U ]  
   
  ⎧ c(ω), y ⎪ ⎨ min y y(x, ω) solves a y ≤ x, ⎪ ⎩ s.t. y ∈ [0, 1]ny  
   
  (24) ω ∈ Ω a.s.  
   
  In our experiments, we consider a to be a random non-negative vector, δ = 1/4 and d the vector of ones. We call Knapsack i an instance generated for ny = i. While these instances have a more eﬃcient algorithm for them than the one presented here (see [5]), they are helpful in showing how well our generalpurpose Monte-Carlo algorithm performs. In all experiments, we used a sample of size 100 for the follower’s cost vector. The same sample is used in both algorithms to better compare their performance. Additionally, in Algorithm 2 we used samples of size 200 for the domain X. In Table 1, we compare the performance of both methods. The gap measures how far the value of the Monte-Carlo algorithm is from the exact method, i.e., if vali is the value obtained by Algorithm i, then the gap is Gap = |val1 |−1 (val2 − val1 ). Since we ran Algorithm 1 with a time limit, it may be that Gap < 0, which indicates the Monte-Carlo algorithm performing better than the exact method. The results in Table 1 clearly shows an advantage of the Monte-Carlo approach over the exact method. The Monte-Carlo approach was able to meet or surpass the value of the exact method in almost all cases. In the largest examples, the Monte-Carlo had a much better performance, in some cases providing much better solutions than the exact method in shorter running times. The main (and clear) challenge for this work is scalability: while these results show short running times, these are all instances of small dimensions. The main bottleneck currently is the enumeration of the faces of a polytope. In the case of Algorithm 1, there does not seem to be much hope in improving this substan-  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  375  
   
  Table 1. Summary of results for Algorithms 1 and 2 for selected BOLib instances [32], CoralLib instances [1] and Knapsack instances [5]. The “Size” of the instance is (nx + ny , m). The “Obj gap” column shows the gap between the values found for both algorithms; a negative gap indicates the stochastic method performed better. The “Error” column shows the upper estimation of the volume of unseen chambers during the sampling process (see [27] for the details). The columns labeled “Computation Times” contain the running times (in seconds) for the computation of all the faces, the execution of Algorithm 1 and of Algorithm 2. The columns labeled “Used faces” contain the number of faces that were explicitly used during the execution of each algorithm. Computation Times Used Faces Instance  
   
  Size  
   
  |F≤nx | |Fnx | Obj gap Error Faces Alg. 1 Alg. 2 Alg. 1 Alg 2.  
   
  BOLib/AnandalinghamWhite1990 (2,7)  
   
  12  
   
  6  
   
  0%  
   
  0%  
   
  1.4  
   
  3.8  
   
  7.2  
   
  12  
   
  5  
   
  BOLib/Bard1984a  
   
  (2,6)  
   
  10  
   
  5  
   
  0%  
   
  0%  
   
  3.1  
   
  6.8  
   
  7.9  
   
  10  
   
  5  
   
  BOLib/Bard1984b  
   
  (2,6)  
   
  10  
   
  5  
   
  0%  
   
  0%  
   
  1.4  
   
  4.1  
   
  7.5  
   
  10  
   
  5  
   
  BOLib/Bard1991Ex2  
   
  (3,6)  
   
  14  
   
  9  
   
  0%  
   
  0%  
   
  1.4  
   
  4.2  
   
  8.2  
   
  14  
   
  6  
   
  BOLib/BardFalk1982Ex2  
   
  (4,7)  
   
  45  
   
  17  
   
  0%  
   
  45%  
   
  1.7  
   
  4.3  
   
  7.6  
   
  45  
   
  5  
   
  BOLib/BenAyedBlair1990a  
   
  (3,6)  
   
  20  
   
  12  
   
  0%  
   
  0%  
   
  1.4  
   
  4.2  
   
  8.5  
   
  20  
   
  4  
   
  BOLib/BenAyedBlair1990b  
   
  (2,5)  
   
  6  
   
  3  
   
  0%  
   
  0%  
   
  1.5  
   
  4.3  
   
  8.0  
   
  6  
   
  3  
   
  BOLib/BialasKarwan1984a  
   
  (3,8)  
   
  20  
   
  12  
   
  0%  
   
  0%  
   
  1.6  
   
  4.4  
   
  8.4  
   
  20  
   
  10  
   
  BOLib/BialasKarwan1984b  
   
  (2,7)  
   
  12  
   
  6  
   
  0%  
   
  0%  
   
  1.5  
   
  4.3  
   
  8.0  
   
  12  
   
  5  
   
  BOLib/CandlerTownsley1982  
   
  (5,8)  
   
  111  
   
  48  
   
  1%  
   
  37%  
   
  1.8  
   
  7.9  
   
  18.5  
   
  111  
   
  16  
   
  BOLib/ClarkWesterberg1988  
   
  (2,3)  
   
  6  
   
  3  
   
  0%  
   
  0%  
   
  1.5  
   
  4.3  
   
  8.0  
   
  6  
   
  3  
   
  BOLib/ClarkWesterberg1990b  
   
  (3,7)  
   
  15  
   
  9  
   
  0%  
   
  0%  
   
  1.5  
   
  4.4  
   
  8.3  
   
  15  
   
  9  
   
  BOLib/GlackinEtal2009  
   
  (3,6)  
   
  20  
   
  5  
   
  0%  
   
  48%  
   
  1.6  
   
  4.8  
   
  8.0  
   
  20  
   
  3  
   
  BOLib/HaurieSavardWhite1990  
   
  (2,4)  
   
  8  
   
  4  
   
  0%  
   
  0%  
   
  1.6  
   
  4.5  
   
  8.3  
   
  8  
   
  4  
   
  BOLib/HuHuangZhang2009  
   
  (3,6)  
   
  20  
   
  12  
   
  0%  
   
  0%  
   
  1.6  
   
  4.4  
   
  8.6  
   
  20  
   
  7  
   
  BOLib/LanWenShihLee2007  
   
  (2,8)  
   
  14  
   
  7  
   
  0%  
   
  1%  
   
  1.6  
   
  4.5  
   
  8.2  
   
  14  
   
  6  
   
  BOLib/LiuHart1994  
   
  (2,5)  
   
  10  
   
  5  
   
  0%  
   
  0%  
   
  1.6  
   
  4.4  
   
  8.6  
   
  10  
   
  4  
   
  BOLib/MershaDempe2006Ex1  
   
  (2,6)  
   
  8  
   
  4  
   
  0%  
   
  0%  
   
  1.7  
   
  4.8  
   
  8.6  
   
  8  
   
  4  
   
  BOLib/MershaDempe2006Ex2  
   
  (2,7)  
   
  10  
   
  5  
   
  0%  
   
  64%  
   
  1.5  
   
  4.3  
   
  6.4  
   
  10  
   
  3  
   
  BOLib/TuyEtal1993  
   
  (4,7)  
   
  45  
   
  17  
   
  0%  
   
  54%  
   
  1.7  
   
  4.5  
   
  7.6  
   
  45  
   
  5  
   
  BOLib/TuyEtal1994  
   
  (4,8)  
   
  72  
   
  24  
   
  0%  
   
  46%  
   
  1.6  
   
  4.5  
   
  7.5  
   
  72  
   
  6  
   
  BOLib/VisweswaranEtal1996  
   
  (2,6)  
   
  8  
   
  4  
   
  0%  
   
  0%  
   
  1.4  
   
  4.3  
   
  7.9  
   
  8  
   
  4  
   
  BOLib/WangJiaoLi2005  
   
  (3,7)  
   
  23  
   
  14  
   
  0%  
   
  0%  
   
  1.5  
   
  4.4  
   
  8.6  
   
  23  
   
  5  
   
  CoralLib/linderoth  
   
  (6,15)  
   
  545  
   
  51  
   
  0%  
   
  74%  
   
  1.4  
   
  148.0  
   
  7.4  
   
  545  
   
  7  
   
  CoralLib/moore90 2  
   
  (2,7)  
   
  12  
   
  6  
   
  0%  
   
  0%  
   
  1.4  
   
  4.0  
   
  7.6  
   
  12  
   
  5  
   
  CoralLib/moore90  
   
  (2,8)  
   
  8  
   
  4  
   
  0%  
   
  0%  
   
  1.6  
   
  4.4  
   
  8.1  
   
  8  
   
  4  
   
  Knapsack 6  
   
  (7,15)  
   
  574  
   
  447  
   
  0%  
   
  0%  
   
  3.2  
   
  117.1  
   
  19.2  
   
  574  
   
  255  
   
  Knapsack 7  
   
  (8,17)  
   
  1278  
   
  1023  
   
  0%  
   
  0%  
   
  2.5  
   
  626.9  
   
  38.5  
   
  1278  
   
  575  
   
  Knapsack 8  
   
  (9,19)  
   
  2814  
   
  2303  
   
  -14%  
   
  0%  
   
  4.9  
   
  914.7  
   
  82.4  
   
  1990  
   
  1279  
   
  Knapsack 9  
   
  (10,21) 6142  
   
  5119  
   
  -380%  
   
  0%  
   
  15.4  
   
  984.2  
   
  181.4  
   
  3346  
   
  2815  
   
  tially: note in Table 1 that in all but the bottom two entries1 , Algorithm 1 used all available faces. This is because the algorithm heavily relies on maximal labels, which is important in our procedure to not repeat chambers when enumerating. 1  
   
  The last two entries of Table 1 correspond to cases where F≤nx was not fully computed due to the time limit.  
   
  376  
   
  G. Mu˜ noz et al.  
   
  Nonetheless, we still believe Algorithm 1 can be useful as a baseline that has optimality guarantees. Algorithm 2, however, could potentially be improved signiﬁcantly. First of all, recall that this approach only uses the faces of dimension nx (i.e. Fnx ), which can be considerably smaller than F≤nx (see columns 3 and 4 of Table 1). Therefore, a more intricate enumeration that exploits this could be devised. Additionally, and perhaps more importantly, note that in the instances where |Fnx | is not too small (say, more than 40) Algorithm 2 only uses a fraction of Fnx in its execution. This indicates that one could heavily restrict the faces to consider initially and generate more on-the-ﬂy, much like in a column generation approach. Another potential improvement path is exploiting more structure of a particular family of instances, which may indicate which are the faces that one would truly need.  
   
  References 1. Coral bilevel optimization problem library. https://coral.ise.lehigh.edu/data-sets/ bilevel-instances/ Accessed 3 Nov 2022 2. Bazaraa, M.S., Sherali, H.D., Shetty, C. M.: Nonlinear programming: theory and algorithms. John Wiley Sons (2013) 3. Beck, Y., Ljubi´c, I., Schmidt, M.: A survey on bilevel optimization under uncertainty. European J. Oper. Res., (2023) (In Press) 4. Bezanson, J., Edelman, A., Karpinski, S., Shah, V.B.: Julia: A fresh approach to numerical computing. SIAM review 59(1), 65–98 (2017) 5. Buchheim, C., Henke, D., Irmai, J.: The stochastic bilevel continuous knapsack problem with uncertain follower’s objective. J. Optim. Theory. Appl. 194, 521– 542 (2022) 6. Burtscheidt, J., Claus, M.: Bilevel Linear Optimization Under Uncertainty. In: Dempe, S., Zemkoho, A. (eds.) Bilevel Optimization. SOIA, vol. 161, pp. 485–511. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-52119-6 17 7. Claus, M.: On continuity in risk-averse bilevel stochastic linear programming with random lower level objective function. Oper. Res. Lett. 49(3), 412–417 (2021) 8. Claus, M.: Existence of solutions for a class of bilevel stochastic linear programs. European J. Oper. Res. 299(2), 542–549 (2022) 9. De Loera, J., Rambau, J., Santos, F.: Triangulations: structures for algorithms and applications, volume 25. Springer Science Business Media (2010) https://doi.org/ 10.1007/978-3-642-12971-1 10. Dempe, S.: Foundations of bilevel programming. Springer Science Business Media (2002) https://doi.org/10.1007/b101970 11. Dempe, S., Kalashnikov, V., P´erez-Vald´es, G.A., Kalashnykova, N.: Bilevel programming problems. Energy Systems. Springer, Heidelberg, 2015. Theory, algorithms and applications to energy networks https://doi.org/10.1007/978-3-66245827-3 12. Dempe, S., Zemkoho, A. (eds.): SOIA, vol. 161. Springer, Cham (2020). https:// doi.org/10.1007/978-3-030-52119-6 13. Forcier, M.: Multistage stochastic optimization and polyhedral geometry. PhD. ´ Thesis, Ecole de Ponts - ParisTech (2022)  
   
  Exploiting the Polyhedral Geometry of Stochastic Linear  
   
  377  
   
  14. Forcier, M., Gaubert, S., Lecl`ere, V.: Exact quantization of multistage stochastic linear problems (2021) (preprint - arXiv:2107.09566) 15. Gawrilow, E., Joswig, M., polymake: a framework for analyzing convex polytopes. In Polytopes–combinatorics and computation of DMV Sem (Oberwolfach, 1997), 29, pp. 43–73. Birkh¨ auser, Basel, (2000) 16. Gurobi Optimization, LLC. Gurobi Optimizer Reference Manual (2022) 17. Hiriart-Urruty, J.-B., Lemar´echal, J.-B.: Convex analysis and minimization algorithms I: Fundamentals, volume 305. Springer science business media (2013) https://doi.org/10.1007/978-3-662-02796-7 18. Homem-de Mello, T., Bayraksan, G.: Monte Carlo sampling-based methods for stochastic optimization. Surv. Oper. Res. Manag. Sci., 19(1), 56–85 (2014) 19. Ivanov, S.V.: A bilevel programming problem with random parameters in the follower’s objective function. Diskretn. Anal. Issled. Oper. 25(4), 27–45 (2018) 20. Khachiyan, L., Boros, E., Borys, K., Gurvich, V., Elbassioni, K.:Generating all vertices of a polyhedron is hard. In 20th Anniversary Volume, 1–17. Springer (2009) https://doi.org/10.1007/s00454-008-9050-5 21. Kleinert, T., Labb´e, M., Ljubi´c, I., Schmidt, M.: A survey on mixed-integer programming techniques in bilevel optimization. EURO J. Comput. Optim. 9, 100007 (2021) 22. Klenke, A: Probability Theory: a Comprehensive Course. Springer (2014) https:// doi.org/10.1007/978-1-4471-5361-0 23. Leobacher, G., Pillichshammer, F.: Introduction to quasi-Monte Carlo integration and applications. Compact Textbooks in Mathematics. Birkh¨ auser/Springer, Cham (2014) 24. Lu, S., Robinson, S.M.: Normal fans of polyhedral convex sets: structures and connections. Set-Valued Anal. 16(2–3), 281–305 (2008) 25. Mak, W.-K., Morton, D.P., Wood, R.K.: Monte Carlo bounding techniques for determining solution quality in stochastic programs. Oper. Res. Lett. 24(1–2), 47–56 (1999) 26. Mallozzi, L., Morgan, J.: Hierarchical Systems with Weighted Reaction Set, pp. 271–282. Springer, US, Boston, MA, (1996) https://doi.org/10.1007/978-1-48990289-4 19 27. Mu˜ noz, G., Salas, D., Svensson, A.: Exploiting the polyhedral geometry of stochastic linear bilevel programming (2023). (preprint - arXiv:2211.02268. Former title: Linear bilevel programming with uncertain lower-level costs) 28. Rambau, J., Ziegler, G.M.: Projections of polytopes and the generalized baues conjecture. Discrete Comput. Geom. 16(3), 215–237 (1996) 29. Salas, D., Svensson, A.: Existence of solutions for deterministic bilevel games under a general bayesian approach (2020) (preprint - arXiv:2010.05368) 30. Shapiro, A., Dentcheva, D., Ruszczy´ nski, A.: Lectures on stochastic programming– modeling and theory, volume 28 of MOS-SIAM Series on Optimization. 3rd eds Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA; Mathematical Optimization Society, Philadelphia, PA, (2021) 31. Stackelberg, V.H.: Marktform und Gleichgewitch. Springer (1934) https://doi.org/ 10.1007/978-3-642-12586-7 32. Zhou, S., Zemkoho, A.B., Tin, A.: BOLIB: Bilevel Optimization LIBrary of Test Problems. In: Dempe, S., Zemkoho, A. (eds.) Bilevel Optimization. SOIA, vol. 161, pp. 563–580. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-521196 19  
   
  Towards an Optimal Contention Resolution Scheme for Matchings Pranav Nuti(B) and Jan Vondr´ ak Stanford University, Stanford, CA 94305, USA {pranavn,jvondrak}@stanford.edu  
   
  Abstract. In this paper, we study contention resolution schemes for matchings. Given a fractional matching x and a random set R(x) where each edge e appears independently with probability xe , we want to select a matching M ⊆ R(x) such that Pr[e ∈ M | e ∈ R(x)] ≥ c, for c as large as possible. We call such a selection method a c-balanced contention resolution scheme. Our main results are (i) an asymptotically (in the limit as x∞ goes to 0) optimal  0.544-balanced contention resolution scheme for general matchings, and (ii) a 0.509-balanced contention resolution scheme for bipartite matchings. To the best of our knowledge, this result establishes for the ﬁrst time, in any natural relaxation of a combinatorial optimization problem, a separation between (i) oﬄine and random order online contention resolution schemes, and (ii) monotone and non-monotone contention resolution schemes.  
   
  Keywords: Contention resolution  
   
  1  
   
  · Matching · Random graphs  
   
  Introduction  
   
  Suppose that there are n employees looking for jobs. Each employee likes a random set of jobs which, on average, has cardinality one. n jobs are available in total, and no job is especially popular amongst the employees, though some employees might have a strong preference for some particular jobs. We would like to match the employees to jobs. We are immediately faced with many natural questions: On average, what fraction of employees can we match to a job they like? Can we match employees to jobs in a fair way, without partially favoring any particular employee? What if no employee has a strong preference for any particular job? Is it easier to match employees if we learn about their preferences all at once, rather than if we learn The full version of this paper can be found at https://arxiv.org/abs/2211.03599. It contains omitted proofs, discussion of the relationship of this paper with van der Waerden’s conjecture, and an application of our contention resolution scheme to a combinatorial allocation problem. J. Vondr´ ak—Supported by NSF Award 2127781. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 378–392, 2023. https://doi.org/10.1007/978-3-031-32726-1_27  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  379  
   
  about them in an online fashion? Our paper provides answers to these questions, through the lens of contention resolution schemes. Contention resolution schemes aim to solve the following problem: Given a family of feasible sets F ⊂ 2E and a random set R sampled from a distribution on 2E , how can we choose a feasible subset I ⊆ R, I ∈ F, so that each element from R is picked with some guaranteed conditional probability: Pr[e ∈ I | e ∈ R] ≥ c for some ﬁxed c > 0 and all e ∈ E? We call such a scheme c-balanced. This condition is a kind of fairness constraint, ensuring every element e has a reasonable chance of making it into I. In this paper, we think about E as the set of edges in a graph, and F as the set of matchings of the graph. The constant c is the conditional probability with which we can ensure an edge ends up in the matching I we pick, given it appears in R. A natural assumption on the random set R is that it comes from a product distribution with marginal probabilities xe such that x is in a polytope corresponding to the family F (either the exact convex hull, or a suitable relaxation, depending on the application), i.e., roughly speaking, R on average, is in F. For matchings on graphs, this corresponds to an assumption that each edge e appears in R independently with probability xe , and the vector (xe )e∈E belongs to the matching polytope, i.e, is a fractional matching. The formal notion of contention resolution was ﬁrst investigated as a tool for randomized rounding. In this setting, we have an optimization problem subject to a constraint, and x represents a fractional solution to a relaxation of the problem. Contention resolution is one of the phases of a randomized rounding approach to converting this fractional solution into an integral solution: First we generate a random set R, by sampling each element e independently with probability xe , and then we select a subset of R which satisﬁes the desired constraint. The ﬂexibility of the approach enables its wide applicability in combinatorial optimization. This approach was introduced by Feige [2], who developed a contention resolution scheme (CRS) for matchings on the restricted class of star graphs, in the context of an application to combinatorial auctions. CRSs were then investigated more systematically in [4] in the context of submodular optimization. In particular, an optimal (1 − 1/e)-balanced CRS was identiﬁed in [4] for the case where F forms a matroid. The 1 − 1/e factor is optimal even for F = {I : |I| ≤ 1}. For applications in submodular optimization, it turns out that an additional property of monotonicity is often useful: A CRS is called monotone, if for every element e, the probability that e is selected from a set R is non-increasing as a function on the sets R containing e. This property is generally needed for the analysis of randomized rounding with a submodular objective function [4]. However, for some applications it is not necessary that a CRS is monotone; in particular it was not needed in Feige’s original application in [2], and it is also unnecessary for a related application that we present in the full version of this paper.  
   
  380  
   
  P. Nuti and J. Vondr´ ak  
   
  Contention resolution has also been studied in online settings (where it has seen applications to prophet inequalities and sequential pricing problems, for example) with either adversarial or random ordering of elements [6,8–10,13]. For example, for matroids there is a 1/2-balanced adversarial order online CRS [9]. We do not investigate online contention resolution here, but we should mention that in prior results, random order online contention resolution schemes (RCRS) are able to match the best known oﬄine results: For matroids, there is a (1 − 1/e)-balanced RCRS, due to an elegant LP duality connection with prophet inequalities [9]. The situation is much more complicated when F encodes constraints such as matchings and the optimal factors are generally unknown. The cases of bipartite and general matchings have attracted attention due to their fundamental nature and their frequent appearance in applications. We can think of matching constraints as an intersection of two matroid constraints, and for an intersection of 1 -balanced RCRS [8]; in particular, this gives k matroid constraints, there is a k+1 a 1/3-balanced RCRS (and hence also an oﬄine CRS with the same factor) for bipartite matchings. Recent work in both oﬄine and online settings has signiﬁcantly improved the factor of 1/3. In the oﬄine setting, [7] gives a (1 − e−2 )/2  0.432-balanced scheme for general matchings, which can be improved slightly further [11]. Very interestingly, [11] identiﬁes the optimal monotone scheme for bipartite matchings, which achieves a balancedness of  0.476. Nevertheless, the optimal CRSs for bipartite and general matchings are still unknown. The primary reason that it seems to be harder to obtain the optimal non-monotone scheme is that decisions on whether an edge should be included in the matching need not be local (i.e., a function of the edge’s immediate neighborhood), and it is harder to analyze the behavior of an algorithm that makes non-local decisions. In terms of impossibility results, an upper bound of  0.544 follows from a classical paper of Karp and Sipser [1], as discussed in [7]. In the online setting, the best known CRSs are due to recent results in [12]: In the random order case, they provide a 0.474-balanced scheme for general matchings and a 0.476-balanced scheme for bipartite matchings, and in the bipartite case, they also establish an upper bound of 0.5. Notably, the 0.474-balanced scheme is in fact the best known CRS for general matchings, whether oﬄine or online. In the adversarial order case, they provide a 0.344-balanced scheme for general matchings and a 0.349-balanced scheme for bipartite matchings. 1.1  
   
  Our Results  
   
  To explain our results, we start by formally setting up some notation. Given a graph G = (V, E), a fractional matching is a point x ∈ [0, 1]E in the matching polytope, i.e., a point in the convex hull of vectors 1M for all matchings M in G. For a fractional matching x, let xuv be the component of x corresponding to the edge (u, v).  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  381  
   
  The problem we are interested in studying is: Contention Resolution for Matchings. We are given a fractional matching x, and a random set R(x) where edges appear independently with probabilities xuv . Our goal is to choose a matching M ⊆ R(x) such that for every edge (u, v), Pr[(u, v) ∈ M | (u, v) ∈ R(x)] ≥ c. Such a scheme is called c-balanced, and we want to ﬁnd a scheme with c as large as possible. The main questions we ask are: (i) Is there a contention resolution scheme for matchings achieving the upper bound  0.544 of Karp and Sipser? (ii) Is there a separation between the optimal c for online and oﬄine contention resolution schemes? (iii) Is there a separation between the optimal c for monotone and non-monotone contention resolution schemes? In this paper, we prove the following results. The ﬁrst result, which applies to both bipartite and non-bipartite matchings, is an attempt to answer (i). Theorem 1. Assuming that x is a fractional matching such that x∞ ≤ , there is (γ − f ())-balanced contention resolution scheme, where γ  0.544 is the impossibility bound of Karp and Sipser and lim→0 f () = 0. For fractional matchings without any assumption on their ∞ norm1 , we present an improved CRS in the bipartite case. Theorem 2. There is 0.509-balanced contention resolution scheme for bipartite matchings. This theorem answers questions (ii) and (iii), since the optimal RCRS for bipartite matchings is at most 0.5-balanced, and the optimal monotone CRS for bipartite matchings is  0.476-balanced. Our theorem thus establishes separations that, to our knowledge, have not been demonstrated in any other natural relaxations of combinatorial optimization problems before. (Note that for matroids, the known optimal (1 − 1/e)-balanced schemes are monotone.) Returning to the context we started this paper with, our results establish that we can match more than half of all the employees to jobs they like without partially favoring any particular employee, and in case no employee has a strong preference for any particular job, we can do better, and match 54% of employees to jobs. This is a signiﬁcant improvement over what we can do if we learn the employees preferences in an online fashion. We should also mention here the important concept of a correlation gap. Informally, the correlation gap measures how much we might lose while optimizing a function, in the worst case, by assuming that the distributions that deﬁne 1  
   
  It might appear from the work of Bruggmann and Zenklusen (see lemma 7 in [11]) that the assumption of x∞ ≤  should be easy to drop from Theorem 1. This would be the case if our theorem applied to graphs with parallel edges, which unfortunately, it does not.  
   
  382  
   
  P. Nuti and J. Vondr´ ak  
   
  the function are independent rather than correlated. In the context of bipartite matchings,  the correlation gap is deﬁned as the minimumpossible ratio between E[max{ e∈M we : M ⊆ R(x), M is a matching}] and e∈E we xe , where x is a fractional bipartite matching and w is any vector of weights. By LP duality (see [4]), Theorem 2 also provides (the best known) lower bound of 0.509 on the correlation gap for bipartite matchings. In light of Theorem 1, we believe that the correlation gap for bipartite (and perhaps even non-bipartite) matchings is indeed the Karp-Sipser bound of γ  0.544, and the optimal CRS is γ-balanced. 1.2  
   
  Our Techniques  
   
  Our Theorem 1 follows from an improved and simpliﬁed analysis of Karp and Sipser’s algorithm [1] for constructing matchings by adding random edges adjacent to leaves. While we utilize many of the ideas from Karp and Sipser’s paper, our analysis of the algorithm is an improvement in several ways: – We obtain a contention resolution scheme, while Karp and Sipser only compute the expected size of the maximum matching. This yields the somewhat surprising conclusion that Karp and Sipser’s algorithm works just as well for weighted matchings as it does for unweighted matchings. – We avoid Karp and Sipser’s (technically complicated) use of the so-called diﬀerential equation method. We also avoid the use of generating functions, another method used recently to calculate the expected size of the maximum matching in random graphs [5]. – We obtain results for any random graph R(x) constructed from a fractional matching satisfying x∞ ≤ , unlike Karp and Sipser who only consider the Erdos-Renyi random graph Gn,c/n . Many previous results require that there be some kind of symmetry in the random graph to obtain bounds on the size of the matching. We stress that we do not need to make any such assumption on R(x). We do need to assume that x∞ ≤ . This assumption is useful because it ensures that the neighbourhood of any particular edge looks like a random tree. A closely related assumption (“local weak convergence”) has been considered previously in the literature. This assumption, together with recursive distributional equations, is used to formalize various statistical mechanical heuristics regarding matchings in random graphs. Most related to our work is the work of Bordenave, Lelarge, and Salez [3]. Once again, the advantage of our method is that we obtain a CRS (as opposed to computing the expected size of the maximum matching) and we avoid the use of technically complicated tools. These improvements come at a cost–we assume that the average degree of each vertex is less than or equal to 1. The theoretical and practical signiﬁcance of this case, and the importance of contention resolution schemes, make this trade-oﬀ a good choice. Our Theorem 2 requires several new techniques, although the basic idea can be traced back to Karp and Sipser as well: When deciding which edge incident  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  383  
   
  to a vertex we should add to a matching, it is beneﬁcial to pick an edge which is adjacent to a leaf, since it doesn’t block us from adding other edges into the matching. It turns out that in general, it is actually better not to follow this rule absolutely (at least in our analysis) but we still pick degree-1 edges with signiﬁcant priority over other edges. We present two diﬀerent schemes using these ideas; the ﬁrst one is simpler and achieves a factor  0.480 (already establishing the separation between monotone and non-monotone schemes). An interesting feature of this scheme is that it can be implemented as a parallel algorithm with each vertex independently making decisions about whether to include an edge adjacent to it in the matching by looking only at its immediate neighborhood. The best schemes known previously did not have this useful property. Our more complicated scheme achieves a factor  0.509 (thus demonstrating a separation between oﬄine CRSs and RCRSs). Both schemes rely on an extended version of contention resolution for choosing 1 element from a possibly correlated distribution, which we present in Sect. 3, and the 0.509-balanced scheme uses the FKG inequality to handle correlations between edges in the ﬁnal stage. Throughout this paper, even though we state our theorems for fractional matchings x,we will actually only need to assume that x satisﬁes the vertex constraints v xuv ≤ 1. Furthermore, we can always assume that x satisﬁes  x = 1 for every u. We can achieve this by adding vertices and edges with v uv probabilities such that the edge probabilities at each vertex add up to 1; this only makes the task of designing a CRS more diﬃcult.  
   
  2 2.1  
   
  An Optimal CRS When x∞ → 0 The Karp-Sipser Algorithm  
   
  The Karp-Sipser algorithm is a method to select a matching in a graph. Given a graph G, the algorithm deletes all the degree 0 vertices, selects a random degree 1 vertex (if one exists), and adds the edge adjacent to it to the matching. Then, it deletes all the edges adjacent to the edge just added to the matching, and recurses on the newly obtained graph G . Note that unlike in the paper of Karp and Sipser, we do not use a two stage process to generate the matching. An attractive feature of the Karp-Sipser algorithm is that it doesn’t “make any mistakes”. This is because for any vertex v of degree 1 in a graph G, G has a maximum matching in which v is matched. If an edge is deleted by the algorithm at some stage, we will say that it disappears. We also say that a vertex is added to the matching if an edge adjacent to it is added to the matching. Before we discuss the analysis of the algorithm, we take a brief detour. 2.2  
   
  Random Trees  
   
  Consider the following method to generate a random tree in steps. Fix two special vertices, u and v, and draw an edge between them. In step i, for each vertex at  
   
  384  
   
  P. Nuti and J. Vondr´ ak  
   
  the depth i − 1, independently sample a Poisson random variable with mean 1, and add as many children to the vertex as the obtained sample. Stop at step j if there are no vertices at depth j − 1. Let us call the random tree generated by this process T . Since the two subtrees of u and v are independent copies of a Galton-Watson process with 1 expected child at each node, it is straightforward to prove that this process terminates with probability 1. So it is almost always true that this process produces a ﬁnite tree. The following lemma explains why we care about the process T : Up to small errors, it describes the distribution of the connected component containing a given edge (u, v) in R(x). We omit the proof which involves a coupling argument and an application of Le Cam’s theorem.  Lemma 1. Let x be a fractional matching with w xvw = 1 for every vertex v, and x∞ ≤ . Let R(x) be the corresponding random graph. Let us condition on (u, v) ∈ R(x) and define N ((u, v)) to be the connected component in R(x) containing (u, v). Let T be a random tree produced by the process described above and T0 be any finite realization of the process. Then | Pr[N ((u, v)) = T0 | (u, v) ∈ R(x)] − Pr[T = T0 ]| = O(|T0 |2 ). We stress that the lemma is only true for graphs without parallel edges. For graphs with parallel edges, the lemma fails, even for the simple case of a graph with only two vertices. The use of this lemma makes it impossible to apply the work of Bruggmann and Zenklusen (lemma 7 in [11]). 2.3  
   
  The Karp-Sipser Algorithm on Trees  
   
  It is easy to prove by induction (using the fact that trees always have degree 1 vertices) that in an execution of the Karp-Sipser algorithm on a forest, an edge must eventually either disappear, or else, is added to the matching. Together with the fact that the Karp-Sipser algorithm does not make mistakes, this shows that the Karp-Sipser algorithm ﬁnds a maximum matching in a tree. Given a tree, we would like to be able to analyze which vertices and edges end up in the matching the algorithm selects, independent of the random choices the algorithm makes. To that end, consider the following algorithm to label the vertices of a tree (this is similar to, but not exactly same as the scheme in [1]): Root the tree at an arbitrary vertex. Starting at the maximum possible depth, look at all the vertices at a ﬁxed depth. If a vertex has no L children (this can perhaps be true vacuously), label it L. Else, label it W. Iteratively label vertices higher in the tree, until the root of the tree receives a label. The following claims are true (regardless of the chosen root, and regardless of the random choices the algorithm makes): 1. If an edge between a W parent and an L child disappears, it must be because the W vertex was added to the matching. 2. Every W vertex is added to the matching.  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  385  
   
  3. Every edge between two W vertices disappears. Proof of claim 1. Suppose by way of contradiction that an edge between a W parent and L child disappears because the L vertex was added to the matching. Certainly, this does not happen in the ﬁrst step of the execution of the algorithm. Consider the very ﬁrst time it happens. The L vertex must have been added to the matching through a W labelled child it has. This W vertex must have degree 1, and so the edge connecting it to an L child must have disappeared. This contradicts our assumption of the original edge being the ﬁrst edge between a W parent and an L child that has disappeared because the L vertex was added to the matching.  
   
  Proof of claim 2. Every W vertex has an edge connecting it to an L child; either that edge disappears, and the claim follows by claim 1, or that edge is added to the matching and the claim still follows.  
   
  Proof of claim 3. Suppose by way of contradiction that an edge between two W vertices is added to the matching. Consider the state of the graph just before this edge is added. One of the vertices must have degree 1, so an edge connecting to its L child must have disappeared. But the only way such an edge can disappear is by the W vertex being added to the matching, contradiction!  
   
  2.4  
   
  Putting It Together  
   
  We can now calculate the probability with which the Karp-Sipser algorithm, when executed on the random tree T , adds the special edge between u and v to the matching. To this end, ﬁrst label the trees rooted at u and v using the procedure described in the previous section (imagining the special edge connecting u and v does not exist, and we are just labelling two diﬀerent rooted trees). Let us ﬁrst calculate the probability λ that u is labelled L: λ = Pr[u is labelled L] = Pr[u has no children labelled L] ∞  Pr[u has k children and none of them are labelled L] = =  
   
  k=0 ∞  k=0  
   
  e−1 (1 − λ)k = e−1 · e1−λ = e−λ k!  
   
  λ is thus the unique real number which solves the equation x = e−x . Second, let us calculate the probability that the edge between u and v is added to the matching, and v is labelled L. Imagine now rooting the random tree T at u. This does not change the label of any of the vertices except possibly u which is now labelled W. This means that u must end up in the matching. None of the edges connecting u with any of its W children end up in the matching. All the edges connecting u  
   
  386  
   
  P. Nuti and J. Vondr´ ak  
   
  with any of its L children, and the special edge between u and v are completely symmetric from the standpoint of the execution of the Karp-Sipser algorithm. Therefore, Pr[(u, v) is added to the matching, v is labelled L] ∞  Pr[(u, v) is added to the matching, v is labelled L, u has k L children] = =  
   
  k=0 ∞  k=0  
   
  ∞   ∞  λ  r k e−1 λk+1 e−λ = = (eλ − 1)e−λ = 1 − λ λ (1 − λ)r−k k k+1 r! (k + 1)! r=k  
   
  k=0  
   
  Third, note that if we initially labelled both u and v L, then (u, v) must end up in the matching. This is because if we imagine rooting the tree at u, u is labelled W, so ends up in the matching, but the only way this can happen is if (u, v) ends up in the matching since all of its other children are labelled W. Fourth, note that if we initially labelled both u and v W, then (u, v) must disappear. This is because if we imagine rooting the tree at u, the labelling remains the same, and every edge between W vertices disappears. Finally, we can compute the probability that the special edge (u, v) ends up in the matching selected by Karp-Sipser as the sum of the probabilities of the edge ending up in the matching when u and v are labelled (respectively) L and L, L and W, W and L, and W and W. This is equal to 2(1 − λ) − λ2 . Theorem 1 now follows from a careful application of Lemma 1. Lemma 1 involves establishing a close correspondence between the neighborhood of an edge in the Galton-Watson process and the neighborhood of an edge in R(x). This correspondence can be exploited to obtain a correspondence in the behavior of the Karp-Sipser algorithm in the two settings. We omit the details, but we show here how Lemma 1 can be applied to prove the weaker statement that for fractional matchings x such that x∞ → 0, the neighborhood of any edge (u, v) does not contain a cycle with high probability. This weaker statement contains the main idea of the proof of Theorem 1. Lemma 1 implies that for any set of ﬁnite trees F = {T1 , T2 , . . . , Tm } that are realizations of the random process T ,    | Pr[N ((u, v)) ∈ F | (u, v) ∈ R(x)] − Pr[T ∈ F ]| = O  |Ti |2 and hence it follows that  
   
     | Pr[N ((u, v)) ∈ / F | (u, v) ∈ R(x)] − (1 − Pr[T ∈ F ])| = O  |Ti |2  
   
  and so, for any F we have lim Pr[N ((u, v)) contains a cycle | (u, v) ∈ R(x)]  
   
  →0  
   
  ≤ lim Pr[N ((u, v)) ∈ / F | (u, v) ∈ R(x)] →0  
   
  = 1 − Pr[T ∈ F ]  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  387  
   
  Since we know that T produces a ﬁnite tree with probability 1, we can take F larger and larger to prove that lim Pr[N ((u, v)) contains a cycle | (u, v) ∈ R(x)] = 0  
   
  →0  
   
  3  
   
  Improved CRSs for Bipartite Matchings  
   
  Now we turn to contention resolution for bipartite matchings, without any assumption on the ∞ norm of the fractional matching. A basic building block of our CRSs is the following theorem which establishes the existence of a scheme for choosing 1 out of n elements (historically the ﬁrst CRS [2]). Theorem 3. Suppose that D is a distribution on 2E such that for every set S ⊆ E,  Pr [S ∩ R = ∅] ≥ βi . R∼D  
   
  i∈S  
   
  Then there is a monotone contention resolution scheme for choosing one element e(R) from R ∼ D such that Pr[e(R) = i] ≥ βi for every i ∈ E. This theorem can be proved using a max-ﬂow/min-cut argument, as brieﬂy discussed in [2]. We omit the proof. 3.1  
   
  A 0.480-Balanced Scheme for Bipartite Matchings  
   
  Before going to the proof of Theorem 2, we will show the existence of a simple 2(1 − e−1/e ) − e−2 -balanced contention resolution scheme for bipartite matchings2 . We remark that 2(1 − e−1/e ) − e−2 ≥ 0.480 and hence this already beats the optimal monotone scheme for bipartite matchings. By necessity, our scheme is non-monotone and this result establishes a strict separation between monotone and non-monotone schemes for bipartite matchings. The Simple Scheme: 1. For each edge (u, v) (with probability xuv of appearing), independently −xuv declare it active with probability 1−exuv given it appears. 2. For each vertex u, call an active edge (u, v) “available at vertex u” if v has no other edges adjacent to it which are active. 3. Using a contention resolution scheme for 1 element, select one of the available edges at each vertex. Ensure that an edge (u, v) gets selected at vertex u with  2xuv xuv . probability at least xuv (1 − e−1/e ) − 2e12 + e 2e−e 2 4. The set of edges selected at all the vertices form the matching M . 2  
   
  Note the similarity in the expression to 2(1 − λ) − λ2 = 2(1 − e−λ ) − λ2 , the constant from our previous analysis. This similarity is not a coincidence, and we can think of the scheme we describe as ﬁrst-order approximation to Karp-Sipser.  
   
  388  
   
  P. Nuti and J. Vondr´ ak  
   
  The ﬁrst step of the scheme is a kind of pre-processing which ensures that edges with high probabilities of appearing don’t destroy the chances of neighbouring edges getting picked by the scheme. This strategy has also been used in the literature previously [11]. The second step is a ﬁrst attempt at using the idea that it is always useful to add vertices with degree 1 into the matching. This does not seem to have been explicitly exploited by previous CRSs. To analyze the algorithm, note ﬁrstly that it is easy to see that the selected edges really do form a matching. Secondly, let us note that the probability that an edge (u, v) is available at a vertex u is  
   
    exuv − 1 e−xu v = 1 − e−xuv e−(1−xuv ) = F (xuv ) = 1 − e−xuv e   u ∈δ(v),u =u  
   
  and similarly, the probability that an edge (u, v) is isolated amongst active edges is 2   e2xuv − exuv 1 − e−xuv e−(1−xuv ) = e2 Hence, if a CRS of the sort used in step 3 exists, the desired result follows since Pr[(u, v) ∈ M ] = 2 Pr[(u, v) is selected at u] − Pr[(u, v) is selected at both u, v] = 2 Pr[(u, v) is selected at u] − Pr[(u, v) is isolated amongst active edges]   1 e2xuv − exuv e2xuv − exuv = 2xuv (1 − e−1/e ) − 2 + − 2e e2 e2   1 = 2xuv (1 − e−1/e ) − 2 2e Furthermore whether (u, vi ) is available at u is independent of whether (u, vj ) is available at u (this is where we use the fact that the graph is bipartite; note that we actually only need to assume that the graph is triangle-free; it is unclear how to drop this assumption). Therefore, it follows from Theorem 3 that if the probability of (u, vi ) appearing is xi (short for xuvi ), the existence of the required CRS depends only on whether Pr[at least one of (u, vi ) is available] = 1 − ≥  
   
  n  
   
  (1 − F (xi ))  
   
  i=1  
   
    1 e2xi − exi xi (1 − e−1/e ) − 2 + 2e 2e2 i=1  
   
  n   
   
  Therefore, the desired result follows from the following lemma, whose proof we omit.  x Lemma 2. If xi ≤ 1, xi ≥ 0, and F (x) = e e−1 , then   n n  
   
   1 e2xi − exi −1/e (1 − F (xi )) ≥ xi (1 − e )− 2 + 1− 2e 2e2 i=1 i=1  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  3.2  
   
  389  
   
  A 0.509-Balanced Scheme for Bipartite Matchings  
   
  In this section we present our best CRS for bipartite matchings which beats the best possible RCRS. We call the set of vertices on the left V1 , and on the right, V2 . There are two main ideas. One idea is to select edges in two stages, with the ﬁrst stage devoted to running contention resolution on the edges at each vertex in V1 , and the second stage is devoted to running contention resolution on the edges picked in stage 1 at each vertex in V2 . The other main idea involves noticing that edges (u, v) such that v has degree 1 in R have no competition in the second stage and hence should be preferentially selected in the ﬁrst stage, since if selected they will certainly survive in our matching. The Red/Blue/Gray Scheme: 1. Recall that Pr[(u, v) ∈ R] = xuv . Decide for each edge (u, v) ∈ R independently at random whether to mark it gray, so that Pr[(u, v) is gray] = xuv − (1 − e−xuv ). We call the edges (u, v) ∈ R which are not gray active. 2. For each (u, v) such that (u, v) is the only active edge incident to v, decide independently at random whether to mark (u, v) red, so that Pr[(u, v) is red] = 1 − e−xuv /e . Mark all other active edges blue. We have Pr[(u, v) is blue] = e−xuv /e − e−xuv . 3. For each u ∈ V1 , if there are any red edges incident to u, perform contention resolution to include one of them in R1 , so that Pr[(u, v) ∈ R1 ] = (1 − e−1/e )xuv . 4. For each u ∈ V1 , if there are no red edges incident to u, and there are some blue edges incident to u, perform contention resolution to include one of them in R2 , so that Pr[(u, v) ∈ R2 ] = (e−1/e − e−1 )xuv . 5. For each u ∈ V1 , if there are no active (red or blue) edges incident to u, and there are some gray edges incident to u, perform contention resolution 1 2 xuv . to include one of them in R3 , so that Pr[(u, v) ∈ R3 ] ≥ 2e 6. Finally, for each v ∈ V2 , perform contention resolution among all edges in R1 ∪ R2 ∪ R3 incident to v, to include one of them in M , so that Pr[(u, v) ∈ M ] ≥ 0.509 xuv . Implicit in step 2 is the claim that the deﬁnition of red edges is valid. Implicit in each of steps 3, 4, 5, and 6 above is a claim that there exists a certain contention resolution scheme for choosing 1 out of n elements. The existence of such schemes can be proved by applying Theorem 3, if we can calculate the probability that at least one of a subset of edges “is available for consideration at that stage” (i.e., is red, is blue, etc.). For steps 3, 4, and 5, this quantity is fairly simple to calculate, because all the choices (to designate edges red or blue or gray) are made independently. The following lemma, whose proof we omit, summarizes the claimed existences in these cases.  
   
  390  
   
  P. Nuti and J. Vondr´ ak  
   
  Lemma 3. The definition of red edges is valid. There are CRSs among red, blue, and gray edges such that Pr[(u, v) ∈ R1 ] = (1 − e−1/e )xuv , Pr[(u, v) ∈ 1 2 xuv for every edge (u, v). R2 ] = (e−1/e − e−1 )xuv , and Pr[(u, v) ∈ R3 ] ≥ 2e To ﬁnish, we need to analyze Step 6 of the algorithm, which is contention resolution among all the surviving edges on the right-hand side. Here, there can be at most one red edge incident to a vertex v ∈ V2 , possibly multiple gray edges which appear independently, and possibly multiple blue edges whose survival up to this stage of the scheme is correlated. This correlation causes the main trouble in our analysis of this ﬁnal step, because it makes it harder to calculate the probability that at least one of a subset of edges incident at a vertex v is in R1 ∪ R2 ∪ R3 . Ideally, we would like to prove that the appearance of blue edges satisﬁes some form of negative correlation. At the moment, we are able to prove only pairwise negative correlation which is suﬃcient to achieve the factor of 0.509. A stronger correlation result (for example negative cylinder dependence) would lead to an improved factor. We include a full proof of the following lemma due to its conceptual importance in the overall proof. Lemma 4. For any two incident edges (u, v) and (u , v), Pr[(u, v) ∈ R2 & (u , v) ∈ R2 | (u, v), (u , v) are blue] ≤ Pr[(u, v) ∈ R2 | (u, v), (u , v) are blue]·Pr[(u , v) ∈ R2 | (u, v), (u , v) are blue]. Proof. Deﬁne Γ (u) = {v  : (u, v  ) active} and Γ (u ) = {v  : (u , v  ) active}. Note that conditioning on (u, v), (u , v) being blue edges is the same as conditioning on v ∈ Γ (u) ∩ Γ (u ), because edges (u, v), (u , v) being active also means that they must be blue. We claim that conditioned on Γ (u), Γ (u ) such that v ∈ Γ (u) ∩ Γ (u ), the probability that (u, v) ∈ R2 is decreasing in Γ (u) and increasing in Γ (u ), while conversely the probability that (u , v) ∈ R2 is increasing in Γ (u) and decreasing in Γ (u ). We prove this by considering a ﬁxed choice of the active edges incident to V1 \ {u, u }, and at the end averaging over these choices. Consider Γ (u), Γ (u ) where v ∈ Γ (u) ∩ Γ (u ). For (u, v) to be selected in R2 , there cannot be any red edge incident to u. The only candidates for such red edges are (u, v˜) where v˜ ∈ Γ (u) \ Γ (u ), because edges incident to Γ (u) ∩ Γ (u ) are blue by deﬁnition. For each v˜ ∈ Γ (u) \ Γ (u ), (u, v˜) is red if v˜ does not have any other incident active edges (and an additional independent coin ﬂip succeeds, as deﬁned in Step 2). Clearly, the event of no red edge incident to u is monotonically decreasing in Γ (u) \ Γ (u ). In case there is no red edge incident to u, we perform contention resolution among the blue edges incident to u, which are all the edges (u, v  ), v  ∈ Γ (u). Since this scheme is monotone, the probability of survival is monotonically decreasing in Γ (u). This monotonicity property also remains preserved when we average over the choices of active edges incident to V1 \ {u, u }. Overall, the probability of (u, v) surviving in R2 is monotonically decreasing in Γ (u) and  
   
  Towards an Optimal Contention Resolution Scheme for Matchings  
   
  391  
   
  increasing in Γ (u ). Symmetrically, the probability of (u , v) surviving in R2 is monotonically decreasing in Γ (u ) and increasing in Γ (u). Given this monotonicity property, we use the FKG inequality to prove our result. The appearances of vertices in Γ (u) and Γ (u ) are independent (since these are determined by the edges incident to u and u respectively). Let us deﬁne γ ∈ {0, 1}2n where γi = 0 if i ∈ Γ (u) and γn+i = 1 if i ∈ Γ (u ). As we argued, Pr[(u, v) ∈ R2 | γ] is increasing in γ and Pr[(u , v) ∈ R2 | γ] is decreasing in γ, for all γ consistent with v ∈ Γ (u)∩Γ (u ). Therefore, by the FKG inequality applied to this subspace (conditioned on v ∈ Γ (u) ∩ Γ (u )), Pr[(u, v) ∈ R2 & (u , v) ∈ R2 | v ∈ Γ (u) ∩ Γ (u )] ≤ Pr[(u, v) ∈ R2 | v ∈ Γ (u) ∩ Γ (u )] · Pr[(u , v) ∈ R2 | v ∈ Γ (u) ∩ Γ (u )].  

  as desired.  
   
  The main takeaway from this lemma is that if we let β be a lower bound on the probability that an edge survives in R2 given that it is blue, then, conditioned on having at least two active (and hence blue) edges at a vertex v in V2 in step 6, the probability that one of them survives in R2 is at least 2β − β 2 . In the ﬁnal analysis of step 6, if there are more than 2 blue edges at a vertex v, we only use two of them. This allows us to establish our desired conclusion. Theorem 4. There is a CRS in Step 6 which achieves a factor of 0.509. To prove the theorem, we consider a vertex v ∈ V2 and all the edges incident to v which are in R1 ∪ R2 ∪ R3 (i.e. survived contention resolution on the lefthand side). To show that the required kind of CRS exists, we consider a subset of edges S incident to v, and compute the probability that at least one of them survives as follows:  
   
  ∅] Pr[S ∩ (R1 ∪ R2 ∪ R3 ) = ∅] = Pr[S ∩ R1 = + Pr[S ∩ R1 = ∅ & S ∩ R2 = ∅] + Pr[S ∩ (R1 ∪ R2 ) = ∅ & S ∩ R3 = ∅]. We ﬁnish the proof by establishing lower bounds on each of the three terms and applying Theorem 3. Lemma 4 is useful in the analysis of the second term. We omit the proof here. We refer the reader to the full version for details. Acknowledgements. We would like to thank Chandra Chekuri for stimulating discussions.  
   
  References 1. Karp, R.M., and Sipser, M.: Maximum matchings in sparse random graphs. In: 22nd Annual Symposium on Foundations of Computer Science, Nashville, Tennessee, USA, 28–30 October 1981, pp. 364–375. IEEE Computer Society (1981)  
   
  392  
   
  P. Nuti and J. Vondr´ ak  
   
  2. Feige, U.: On maximizing welfare when utility functions are subadditive. SIAM J. Comput. 39(1), 122–142 (2009) 3. Bordenave, C., Lelarge, M., Salez, J.: Matchings on in nite graphs. Probab. Theory Relat. Fields 157(1), 183–208 (2013) 4. Chekuri, C., Vondr´ ak, J., Zenklusen, R.: Submodular function maximization via the multilinear relaxation and contention resolution schemes. SIAM J. Comput. 43(6), 1831–1879 (2014) 5. Balister, P., and Gerke, S.: Controllability and matchings in random bipartite graphs. In: Czumaj, A., Georgakopoulos, A., Kr´ al, D., Lozin, V., Pikhurko, O. (eds.) Surveys in Combinatorics 2015. London Mathematical Society Lecture Note Series. Cambridge University Press, pp. 119–146 (2015) 6. Feldman, M., Svensson, O., Zenklusen, R.: Online contention resolution schemes. In: Krauthgamer, R. (ed.) Proceedings of the Twenty-Seventh Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2016, Arlington, VA, USA, 10–12 January 2016, pp. 1014–1033. SIAM (2016) 7. Guruganesh, G., Lee, E.: Understanding the correlation gap for matchings. In: Lokam, S.V., and Ramanujam, R. (eds.) 37th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2017, 11–15 December 2017, Kanpur, India. LIPIcs, 1–15. Schloss Dagstuhl - LeibnizZentrum f¨ ur Informatik (2017) 8. Adamczyk, M., Wlodarczyk, M.: Random order contention resolution schemes. In: Thorup, M. (ed.) 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, 7–9 October 2018, pp. 790–801. IEEE Computer Society (2018) 9. Lee, E., Singla, S.: Optimal online contention resolution schemes via ex-ante prophet inequalities. In: Azar, Y., Bast, H., and Herman, G. (eds.) 26th Annual European Symposium on Algorithms, ESA 2018, 20–22 August 2018, Helsinki, Finland. LIPIcs, 1–14. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik (2018) 10. Fu, H., Tang, Z.G., Wu, H., Wu, J., Zhang, Q.: Random order vertex arrival contention resolution schemes for matching, with applications. In: Bansal, N., Merelli, E., Worrell, J. (eds.) 48th International Colloquium on Automata, Languages, and Programming, ICALP 2021, 12–16 July 2021, Glasgow, Scotland (Virtual Conference). LIPIcs, 1–20. Schloss Dagstuhl - Leibniz-Zentrum f¨ ur Informatik (2021) 11. Bruggmann, S., Zenklusen, R.: An optimal monotone contention resolution scheme for bipartite matchings via a polyhedral viewpoint. Math. Program. 191(2), 795– 845 (2022) 12. MacRury, C., Ma, W., Grammel, N.: On (random-order) online contention resolution schemes for the matching polytope of (bipartite) graphs (2022). https://arxiv. org/abs/2209.07520 13. Pollner, T., Roghani, M., Saberi, A., Wajc, D.: Improved online contention resolution for matchings and applications to the gig economy. In: Proceedings of the 23rd ACM Conference on Economics and Computation. EC 2022, pp. 321–322. Association for Computing Machinery, Boulder, CO, USA (2022)  
   
  Advances on Strictly Δ-Modular IPs Martin N¨ agele1(B) , Christian N¨ obel2 , Richard Santiago2 , and Rico Zenklusen2 1  
   
  Research Institute for Discrete Mathematics and Hausdorﬀ Center for Mathematics, University of Bonn, Bonn, Germany [email protected]  2 Department of Mathematics, ETH Zurich, Zurich, Switzerland {cnoebel,rtorres,ricoz}@ethz.ch  
   
  Abstract. There has been signiﬁcant work recently on integer programs (IPs) min{c x : Ax ≤ b, x ∈ Zn } with a constraint marix A with bounded subdeterminants. This is motivated by a well-known conjecture claiming that, for any constant Δ ∈ Z>0 , Δ-modular IPs are eﬃciently solvable, which are IPs where the constraint matrix A ∈ Zm×n has full column rank and all n × n minors of A are within {−Δ, . . . , Δ}. Previous progress on this question, in particular for Δ = 2, relies on algorithms that solve an important special case, namely strictly Δ-modular IPs, which further restrict the n×n minors of A to be within {−Δ, 0, Δ}. Even for Δ = 2, such problems include well-known combinatorial optimization problems like the minimum odd/even cut problem. The conjecture remains open even for strictly Δ-modular IPs. Prior advances were restricted to prime Δ, which allows for employing strong number-theoretic results. In this work, we make ﬁrst progress beyond the prime case by presenting techniques not relying on such strong number-theoretic prime results. In particular, our approach implies that there is a randomized algorithm to check feasibility of strictly Δ-modular IPs in strongly polynomial time if Δ ≤ 4. Keywords: Bounded subdeterminants  
   
  1  
   
  · Congruency constraints  
   
  Introduction  
   
  Integer Programs (IPs) min{c x : Ax ≤ b, x ∈ Zn } are a central NP-hard problem class in Combinatorial Optimization. There is substantial prior work Funded through the Swiss National Science Foundation grants 200021 184622 and P500PT 206742, the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 817750), and the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany’s Excellence Strategy – EXZ-2047/1 – 390685813.  
   
  c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 393–407, 2023. https://doi.org/10.1007/978-3-031-32726-1_28  
   
  394  
   
  M. N¨ agele et al.  
   
  and interest in identifying special classes of polynomial-time solvable IPs while remaining as general as possible. One of the best-known such classes are IPs with a constraint matrix that is totally unimodular (TU), i.e., the determinant of any of its square submatrices is within {−1, 0, 1}. A long-standing open conjecture in the ﬁeld is whether this result can be generalized to Δ-modular constraint matrices for constant Δ. Here, we say that a matrix A ∈ Zk×n is Δ-modular if it has full column rank and all n × n submatrices have determinants in {−Δ, . . . , Δ}.1 For brevity, we call an IP with Δ-modular constraint matrix a Δ-modular IP. We recap the above-mentioned conjecture below. Unfortunately, we do not know its precise origin; it may be considered folklore in the ﬁeld. Conjecture 1. For constant Δ ∈ Z≥0 , Δ-modular IPs can be solved in polynomial time. First progress on Conjecture 1 was made by Artmann, Weismantel, and Zenklusen [3], who showed that it holds for Δ = 2 (the bimodular case). Fiorini, Joret, Weltge, and Yuditsky [11] show that the conjecture is true for an arbitrary constant Δ under the extra condition that the constraint matrix has at most two non-zero entries per row or column. Through a non-trivial extension of the techniques in [3], it was shown by N¨ agele, Santiago, and Zenklusen [24] that there is a randomized algorithm to check feasibility of an IP with a strictly 3-modular constraint matrix in polynomial time. Here, a matrix A ∈ Zk×n is called strictly Δ-modular if it has full column rank and all its n × n submatrices have determinants in {−Δ, 0, Δ}. As a key ingredient, all these prior approaches solve certain combinatorial optimization problems with congruency constraints. This is not surprising, as even strictly Δ-modular IPs include the following class of MCCTU problems:2 Multi-Congruency-Constrained TU Problem (MCCTU): Let T ∈ Zk×n be TU, b ∈ Zk , c ∈ Rk , m ∈ Zq>0 , γi ∈ Zn for i ∈ [q], r ∈ Zq . Solve min{c x : T x ≤ b, γi x ≡ ri  
   
  (mod ∗)mi ∀i ∈ [q], x ∈ Zn } .  
   
  Unless mentioned otherwise, we assume that in the context of MCCTU problems, q and mi are constant. Even MCCTU with just a single congruency constraint, i.e., q = 1, already contains the classical and well-studied odd and even cut problems, and, more generally, the problem of ﬁnding a minimum cut whose number of vertices is r (mod m). (See [5,14,19,25,26,29] for related work.) It can also 1  
   
  2  
   
  A weaker variant of the conjecture claims eﬃcient solvability of IPs with totally Δmodular constraint matrices, where all subdeterminants are bounded by Δ in absolute value. The conjecture involving Δ-modular matrices implies the weaker variant. Indeed, an IP min{c x : Ax ≤ b, x ∈ Zn } with a totally Δ-modular constraint matrix can be reformulated as min{c (x+ − x− ) : A(x+ − x− ) ≤ b, x+ , x− ∈ Zn ≥0 }. It is not hard to see that the constraint matrix of the new LP remains totally Δ-modular; moreover, it has full column rank because of the non-negativity constraints. To capture an MCCTU problem as a strictly Δ-modular IP, replace each congruency constraint γi x ≡ ri (mod mi ) by an equality constraint γi x+mi yi = r with yi ∈ Z. The corresponding constraint matrix is strictly Δ-modular for Δ = qi=1 mi .  
   
  Advances on Strictly Δ-Modular IPs  
   
  395  
   
  capture the minimum T -join problem, congruency-constrained ﬂow problems, and many other problems linked to TU matrices. Combinatorial optimization problems with congruency constraints are highly non-trivial and many open questions remain. As they are already captured by strictly Δ-modular IPs, this motivates the following weakening of Conjecture 1. Conjecture 2. Strictly Δ-modular IPs can be solved in polynomial time for constant Δ ∈ Z≥0 . Even resolving this weaker conjecture would settle several open problems, including congruency-constrained min cuts (in both directed and undirected graphs), or the problem of eﬃciently and deterministically ﬁnding a perfect matching in a red/blue edge-colored bipartite graph such that the number of red matching edges is r (mod m). (This is a simpliﬁed version of the famous red-blue matching problem, where the task is to ﬁnd a perfect matching with a speciﬁed number of red edges; for both versions, randomized algorithms are known.) Interestingly, for the bimodular case (Δ = 2), a result by Veselov and Chirkov [33] implies that Conjecture 1 and Conjecture 2 are equivalent (see [3]). Our goal is to shed further light on Conjecture 2 and overcome some important hurdles of prior approaches. In a ﬁrst step, we note that a positive resolution of Conjecture 2 does not only imply eﬃcient solvability of MCCTU problems, but also vice versa, and this reduction works in strongly polynomial time. Lemma 1. Let Δ > 0. Every strictly Δ-modular IP can, in strongly polynomial q time, be reduced to an MCCTU problem with moduli mi such that Δ = i=1 mi . Without the strongly polynomial time condition, this also follows from very recent work of Gribanov, Shumilov, Malyshev, and Pardalos [15, Lemma 4]. Further, we are interested in making progress regarding the feasibility version of Conjecture 2, i.e., eﬃciently deciding whether a strictly Δ-modular IP is feasible. Prior approaches settle this question for Δ = 2 [3] and—using a randomized algorithm—for Δ = 3 [24]. A main hurdle to extend these is that they crucially rely on Δ being prime, for example through the use of the Cauchy-Davenport Theorem. Our main contribution here is to address this. In particular, we can check feasibility for Δ = 4 with a randomized algorithm, which is the ﬁrst result in this context for non-prime Δ. More importantly, our techniques will hopefully prove useful for future advances on this challenging question. Theorem 1. There exists a strongly polynomial-time randomized algorithm to find a feasible solution of a strictly 4-modular IP, or detect that it is infeasible. We remark that the randomization appearing in the above theorem comes from the fact that one building block of our result is a reduction to a problem class that includes the aforementioned congruency-constrained red/blue-perfect matching problem, for which only randomized approaches are known.  
   
  396  
   
  M. N¨ agele et al.  
   
  1.1  
   
  Group-Constrained Problems and Proof Strategy for Theorem 1  
   
  To show Theorem 1, we exploit its close connection to MCCTU. Capturing the congruency constraints of an MCCTU problem through an abelian group constraint, we attain the following group-constrained TU feasibility problem. Group-Constrained TU Feasibility (GCTUF): Let T ∈ Rk×n be a TU matrix, let b ∈ Zk , let (G, +) be a ﬁnite abelian group, and let γ ∈ Gn and r ∈ G. The task is to show infeasibility or ﬁnd a solution of the system T x ≤ b, γ  x = r, x ∈ Zn . Here, the scalar product γ  x denotes the linear combination of the group elements γ1 , . . . , γn with multiplicities x1 , . . . , xn in G. Group constraints generalize congruency constraints, which are obtained in the special case where G is cyclic. More generally, by the fundamental theorem of ﬁnite abelian groups, a ﬁnite abelian group G is, up to isomorphism, a direct product of cyclic groups. Hence, a group constraint can be interpreted as a set of congruency constraints and vice versa. Thus, GCTUF and MCCTU feasibility are two views on the same problem. We stick to GCTUF mostly for convenience of notation. Moreover, the GCTUF setting also allows for an elegant use of group-related results later on. One may assume that the group is given through its multiplication table (the Cayley table). In fact, the precise group representation is not of great importance to us. Concretely, for constant Δ, strictly Δ-modular IP feasibility problems reduce to GCTUF problems with a constant size group. Many of our polynomial-time algorithmic results can even be extended to settings where the group size is not part of the input, and access to group operations is provided through an oracle. By Lemma 1 and the aforementioned equivalent viewpoint of multiple congruency constraints and a group constraint, in order to prove Theorem 1, it is enough for us to show the equivalent statement below. Theorem 2. There exists a strongly polynomial time randomized algorithm for GCTUF problems with a group of cardinality at most 4. On a high level, we follow a well-known strategy for TU-related problems by employing Seymour’s decomposition [31] to decompose the problem into problems on simpler, more structured TU matrices. (See, e.g., [1,3,9,24].) Roughly speaking, a TU matrix is either very structured—in which case we call it a base block —or can be decomposed into smaller TU matrices through a small set of well-deﬁned operations. (See the discussion following Theorem 7.) The use of Seymour’s decomposition typically comes with two main challenges, namely (i) solving the base block cases, and (ii) propagating solutions of the base block cases back through the decomposition eﬃciently to solve the original problem. First, we show that this propagation can be done eﬃciently for our problem. Theorem 3. Let G be an abelian group of size at most 4. Given an oracle for solving base block GCTUF problems with group G, we can solve GCTUF problems with group G in strongly polynomial time with strongly polynomially many calls to the oracle.  
   
  Advances on Strictly Δ-Modular IPs  
   
  397  
   
  In fact, our approach underlying Theorems 2 and 3 operates in a hierarchy of GCTUF problems with increasingly relaxed group constraints of the form γ  x ∈ R for subsets R ⊆ G of increasing size, and allows for proving the above results for such relaxed GCTUF problems for arbitrary constant-size groups G as long as |G| − |R| ≤ 3. (See Sect. 3 for more details.) In principle, this is along the lines of the approach to congruency-constrained TU problems in [24], but incorporates the new viewpoint of group constraints, and additionally improves over earlier results in two ways: First, our approach applies to arbitrary ﬁnite abelian groups, while previous setups heavily relied on the group cardinality being a prime. Secondly, in the setting with relaxed group constraints, we extend the admissible range of |G| − |R| by one, thus proceeding further in the hierarchy of GCTUF problems, and newly covering GCTUF problems with groups of cardinality 4. Besides being a key part of our approach, Theorem 3 underlines that base block GCTUF problems are not merely special cases, but play a key role in progress on general GCTUF problems. There are only two non-trivial types of such base block GCTUF problems, namely when the constraint matrix is a socalled network matrix or a transpose thereof. Both cases cover combinatorial problems that are interesting on their own, and their complexity status remains open to date. If the constraint matrix is a network matrix, GCTUF can be cast as a circulation problem with a group constraint. By reducing to and exploiting results of Camerini, Galbiati, and Maﬃoli [7] on exact perfect matching problems, a randomized algorithm for the congruency-constrained case has been presented in [24]. We observe that these results extend to the group-constrained setting. The other base block case, where the constraint matrix is the transpose of a network matrix, can be cast as a group-constrained directed minimum cut problem by leveraging a result in [24]. Prior work combined this reduction with results on congruency-constrained submodular minimization [25] to solve the optimization version of the problem for congruency-constraints of prime power modulus. We show that the feasibility question on this base block can be solved eﬃciently on any ﬁnite abelian group of constant order, thus circumventing the prime power restriction that is intrinsic in prior approaches. Theorem 4. Let G be a finite abelian group. There is a strongly polynomial time algorithm for solving GCTUF problems with group G where the constraint matrix is the transpose of a network matrix. 1.2  
   
  Further Related Work  
   
  The parameter Δ has been studied from various viewpoints. While eﬃcient recognition of (totally) Δ-modular matrices is open for any Δ ≥ 2, approaches to approximate the largest subdeterminant in absolute value were studied [8,27]. Also, focusing on more restricted subdeterminant patterns proved useful [2,12,33]. Aiming at generalizing a bound of Heller [21] for Δ = 1, bounds on the maximum number of rows of a Δ-modular matrix were obtained [4,13,23]. Also, the inﬂuence of the parameter Δ on structure and properties of IPs and polyhedra is multi-faceted (see, e.g., [6,10,16–18,22,28,32] and references therein).  
   
  398  
   
  M. N¨ agele et al.  
   
  1.3  
   
  Structure of the Paper  
   
  In Sect. 2, we prove Theorem 4. Section 3 illustrates our approach and new contributions towards Theorem 3 on a more technical level, and explains the main new ingredients of our proof. Due to space constraints, some proofs are deferred to a long version of this paper, including the proof of Lemma 1.  
   
  2  
   
  GCTUF with Transposed Network Constraint Matrices  
   
  In the setting with a congruency constraint instead of a group constraint, [24] shows that every base block problem with a constraint matrix that is a transposed network matrix can be reduced to a node-weighted minimization problem over a lattice with a congruency constraint,3 i.e., a problem of the form min{w(S) : S ∈ L, γ(S) ≡ r(mod m)} ,  
   
  (1)  
   
  where L ⊆ 2N is a lattice on some ﬁnite  ground set N , γ : N → Z,r ∈ Z, m ∈ Z>0 , w : N → R, and we use γ(S) := v∈S γ(v) as well as w(S) := v∈S w(v).4 Being a special case of congruency-constrained submodular minimization, it is known that such problems, and thus the corresponding congruency-constrained TU problems with a transposed network constraint matrix, can be solved in strongly polynomial time for constant prime power moduli m, while the case of general constant composite moduli remains open [25]. The progress on GCTUF, particularly the reduction to base block feasibility problems through Theorem 3 and its generalization (Theorem 8 in Sect. 3), motivates studying these reductions and results in the feasibility setting and with a group constraint instead of a congruency constraint, giving rise to the following problem. Group-Constrained Lattice Feasibility (GCLF): Let N be a ﬁnite set, L ⊆ 2N a lattice, (G, +) a ﬁnite abelian group, γ : N → G, r ∈ G. The task is to ﬁnd X ∈ L with γ(X) = r, or decide infeasibility. We observe that the reduction in [24] from congruency-constrained TU problems with transposed network constraint matrices to problems of the form given in (1) extends to the group-constrained case. In particular, we obtain the following result in the feasibility setting. Proposition 1. Let G be a finite abelian group. Any GCTUF problem with group G and a constraint matrix that is a transposed network matrix can in strongly polynomial time be reduced to a GCLF problem with group G. 3 4  
   
  In fact, the proof in [24] claims a reduction to a submodular minimization problem, but shows the stronger one presented here. We recall that a lattice L ⊆ 2N is a set family such that for any A, B ∈ L, we have A ∩ B, A ∪ B ∈ L. We assume such a lattice to be given by a compact encoding in a directed acyclic graph H on the vertex set N such that X ⊆ N is an element of the − (X) = ∅ (cf. [20, Section 10.3]). Here, as usual, in a digraph lattice if and only if δH G = (V, A) and for X ⊆ V , we denote by δ + (X) and δ − (X) the arcs in A leaving and entering X, respectively. Moreover, we write δ ± (v) := δ ± ({v}) for v ∈ V .  
   
  Advances on Strictly Δ-Modular IPs  
   
  399  
   
  Thus, it remains to study GCLF problems. Interestingly, for the pure feasibility question, we can circumvent the barriers present in the optimization setting, and obtain the following result through a concise argument. Theorem 5. Let G be a finite abelian group. GCLF problems with group G can be solved in strongly polynomial time. Clearly, Proposition 1 and Theorem 5 together imply Theorem 4. The main observation towards a proof of Theorem 5 is the following elementary lemma. Lemma 2. Let G be a finite abelian group, and let γ1 , . . . , γ ∈ G. If  ≥ |G|, then there is a non-empty subset I ⊆ [] such that i∈I γi = 0.  Proof. Either si := j≤i γj = 0 for some i ∈ [], or there exist i < j with si = sj ; hence I = [i] or I = {i + 1, . . . , j}, respectively, has the desired properties.  
   
  To prove Theorem 5, we work with a representation of the lattice L through an acyclic digraph H (see Footnote 4). We exploit that every X ∈ L is uniquely deﬁned by the subset CX := {x ∈ X : δ + (x) ⊆ δ + (X)}. Proof of Theorem 5. We claim that if the given GCLF problem is feasible, there is a feasible X with |CX | < |G|. If so, we obtain an eﬃcient procedure for GCLF with group G through enumerating all such CX and checking if γ(X) = r. To prove the claim, assume for contradiction that it is wrong, and let X ∈ L be minimal with γ(X) = r. Then |CX | ≥ |G|, and applying Lemma 2 to CX gives a non-empty subset Y ⊆ CX with γ(Y ) = 0. Thus, X \ Y is a strictly smaller lattice element with γ(X \ Y ) = γ(X) − γ(Y ) = γ(X) = r, a contradiction.  

  3  
   
  Overview of Our Techniques Leading to Theorem 3  
   
  In order to tackle GCTUF problems, following ideas from [24], we introduce a hierarchy of slightly relaxed GCTUF problems by weakening the group constraint. R-Group-Constrained TU Feasibility (R-GCTUF): Let T ∈ {−1, 0, 1}k×n be TU, b ∈ Zk , let (G, +) be a ﬁnite abelian group, γ ∈ Gn and R ⊆ G. The task is to show infeasibility or ﬁnd a solution of T x ≤ b, γ  x ∈ R, x ∈ Zn . Here, we typically call R the set of target elements. The above setup allows us to measure progress between GCTUF (the case of |R| = 1) and an unconstrained IP with TU constraint matrix (captured by setting R = G). In particular, the diﬃculty of an R-GCTUF problem increases as the size of R, i.e., the number of target elements, decreases. The main parameter capturing this hardness is the depth d := |G| − |R| of the problem. We show the following generalization of Theorem 2. Theorem 6. Let G be a finite abelian group. There is a strongly polynomial randomized algorithm solving R-GCTUF problems with group G and |G| − |R| ≤ 3.  
   
  400  
   
  M. N¨ agele et al.  
   
  Our argument uses Seymour’s decomposition theorem. To this end, for matrices A ∈ ZkA ×nA and B ∈ ZkB ×nB as well as vectors e, f , g,and h of appropriate       size, we recall that the 3-sum of hA 0e 1e and g0 g1 fB is ghA efB .5 Theorem 7 (Seymour’s Decomposition). Let T ∈ Zk×n be TU. Then either (i) T is a base block matrix, or (ii) T can, possibly after row and column permutations and pivoting once, be decomposed into a 3-sum of TU matrices with nA , nB ≥ 2. Additionally, we can in time poly(n) decide which of the cases holds and determine the involved matrices. Item (i) covers three types of matrices: network matrices, transposes thereof, and matrices obtainable through basic operations from one of two speciﬁc 5 × 5 TU matrices. (For more details on Seymour’s decomposition, see, e.g., [30], and for a version tailored to our setting, see [24, Theorem 2.2].) By combining results for base blocks from [24] with our results from Sect. 2, it follows that GCTUF problems can be solved in strongly polynomial time if the constraint matrix is a base block matrix; hence dealing with Item (i) above. In Item (ii), the potential pivoting step can be handled by extending a result from [24] to the group setting. Hence, it remains to discuss how to deal with constraint matrices that are 3-sums. We devote the rest of this section to discuss the main ingredients needed to cover this case. Altogether, we proof the following generalization of Theorem 3. Theorem 8. Let G be a finite abelian group and  ∈ Z≥1 with  ≥ |G| − 3. Given an oracle for solving base block R-GCTUF problems with group G and any R ⊆ G with |R| ≥ , we can solve R-GCTUF problems with group G and R ⊆ G with |R| ≥  in strongly polynomial time with strongly polynomially many calls to the oracle. 3.1  
   
  Reducing to a Simpler Problem When the Target Elements Form a Union of Cosets  
   
  If R, the set of target elements, is a union ofcosets of the same non-trivial proper k subgroup H of G (i.e., it is of the form R = i=1 (gi +H) for some g1 , . . . , gk ∈ G, or equivalently, R = R + H), we can directly reduce to a simpler problem. Indeed, assume R = R + H for a non-trivial proper subgroup H of G. Then, we can equivalently rewrite the R-GCTUF problem with a group constraint in the quotient group G/H and new target set R = R/H. The depth of the < new problem in the corresponding hierarchy is d = |G/H| − |R/H| = |G|−|R| |H| |G|−|R|, so we end up with an easier problem. Since existence of such a subgroup H can be checked eﬃciently (given that G has constant size), we can always determine upfront whether the R-GCTUF problem at hand is reducible, and if so, reduce it to a simpler R-GCTUF problem. Thus, for the rest of this section we assume R is not a union of cosets. This assumption allows us to apply a special case of the Cauchy-Davenport theorem that holds despite the fact that the group order is not assumed to be prime. We refer to Lemma 3 for details. 5  
   
  For simplicity, we use a notion of a 3-sum that allows one or both of ef  and gh to be zero matrices. Typically, those cases would be called 2- and 1-sums, respectively.  
   
  Advances on Strictly Δ-Modular IPs  
   
  3.2  
   
  401  
   
  Decomposing the Problem  
   
  We now focus on an R-GCTUF problem with a constraint  matrix T that can A ef  be decomposed into a 3-sum of the form T = gh B . The decomposition allows for splitting x, b, and γ into two parts accordingly, giving the equivalent formulation  

  xA ∈ ZnA A ef  b xA   xA + γB xB ∈ R , . (2) ≤ A , γA ·  xB bB gh B xB ∈ ZnB In the inequality system, the variables xA and xB interact only through the rankone blocks ef  and gh . Fixing values of α := f  xB and β := h xA allows for rephrasing (2) through the following two almost independent problems AxA ≤ bA − αe xA ∈ ZnA  
   
  h xA = β  
   
  ,  
   
  and  
   
  BxB ≤ bB − βg xB ∈ ZnB  
   
  f  xB = α  
   
  ,  
   
  (3)  
   
  where we seek to ﬁnd solutions xA and xB such that their corresponding group   xA and rB := γB xB , respectively, satisfy rA + rB ∈ R. Hence, elements rA := γA this desired relation between the target elements rA and rB is the only dependence between the two problems once α and β are ﬁxed. We assume without loss of generality that A has no fewer columns than B, and refer to the problem on the left as the A-problem, and the problem on the right as the B-problem. We denote by Π the set of all (α, β) ∈ Z2 such that both the A- and B-problem are feasible. (Note that both problems are described through a TU constraint matrix; hence, feasibility can be checked eﬃciently.) Also, for (α, β) ∈ Π, let πA (α, β) ⊆ G be all group elements rA ∈ G for which there is a solution xA to the A-problem with γ  xA = rA , and deﬁne πB analogously. We refer to πA and πB as patterns. Hence, (2) is feasible if and only if there is a pair (α, β) ∈ Π such that, for some rA ∈ πA (α, β) and rB ∈ πB (α, β), we have rA + rB ∈ R. Thus, patterns contain all information needed to decide feasibility. Using techniques from [24], we can restrict our search for feasible solutions ⊆ Π. More precisely, for i ∈ {0, 1, 2}, we can in to a constant-size subset Π strongly polynomial time ﬁnd i , ui ∈ Z with ui − i ≤ d such that if (2) is feasible, then there is a pair (α, β) in  
   
  := (α, β) ∈ Z2 : 0 ≤ α + β ≤ u0 , 1 ≤ α ≤ u1 , 2 ≤ β ≤ u2 (4) Π for which there is a solution xA to the A-problem and a solution xB to the Bproblem with γ  xA + γ  xB ∈ R. Therefore, the challenges lie less in the size of Π, but rather in how to obtain information on the sets πA (α, β) and πB (α, β) for pairs (α, β) ∈ Π. Opposed to previous techniques, which almost solely focused on πB , we investigate both πA and πB and their interplay—see Sect. 3.3. As B has at most half the columns of the constraint matrix T of the original R-GCTUF problem (2), we can aﬀord (runtime-wise) to recursively call our algorithm multiple times on the B-problem for diﬀerent targets RB of the same depth d = |G| − |R| as the original problem, i.e., with |RB | = |R|. (We refrain  
   
  402  
   
  M. N¨ agele et al.  
   
  from using larger depths, as GCTUF become harder with increasing depth.) This πB (α, β))| = min{d + allows us to compute a set π ¯B (α, β) ⊆ πB (α, β) of size |¯ ¯B (α, β) = ∅ and, as long as |¯ πB (α, β)| < 1, πB (α, β)}. Indeed, we can start with π min{d + 1, πB (α, β)}, we solve an RB -GCTUF B-problem (i.e., we look for a BπB (α, β) being a set of size problem solution xB with γ  xB ∈ RB ) with RB = G\¯ at least |G| − d. If RB ∩ πB (α, β) = ∅, then we ﬁnd an element in RB ∩ πB (α, β) that can be added to π ¯B (α, β) and we repeat; otherwise, RB ∩ πB (α, β) = ∅ and we know that we computed π ¯B (α, β) = πB (α, β). To the contrary, note that the A-problem may be almost as big as the original GCTUF problem (possibly with just two fewer columns). Hence, here we cannot aﬀord (runtime-wise) a similar computation as for the B-problem. However, we can aﬀord to solve multiple RA -GCTUF A-problems of smaller depth, i.e., |RA | > |R|, because the runtime decreases signiﬁcantly with decreasing depth. By using the same approach as in the B-problem, but with sets RA of size |RA | ≥ πA (α, β)| = min{d, πA (α, β)}. |R|+1, we obtain a set π ¯A (α, β) ⊆ πA (α, β) of size |¯ Let us next take a closer look at patterns. Fix some (α, β) ∈ Π and let A 1 i , . . . , rA } for some A ≥ 1 and pairwise diﬀerent rA ∈ G, and πA (α, β) = {rA  1  i i A let xA , . . . , xA be corresponding solutions of the A-problem with γA xA = rA . i i Deﬁne B , rB , and xB analogously. Observe that if A ≤ d and B ≤ d + 1, we have π ¯X (α, β) = πX (α, β) for both X ∈ {A, B}. Hence, we can compute j i + rB ∈ R for some all feasible group elements and check explicitly whether rA i ∈ [A ] and j ∈ [B ], i.e., whether a solution exists. If B ≥ d + 1, we can (independently of A ) even show that there always exists a feasible solution, and we can also ﬁnd one: Indeed, we can compute d + 1 solutions xi := (x1A , xiB ) 1 i + rB ∈ G, at least one of which must satisfy with pairwise diﬀerent sums rA 1 i + rB ∈ R. If A ≥ d and B ≥ 2, we can argue similarly: We show that among rA ¯B (α, β) (which we can any d elements of π ¯A (α, β), and any two elements of π j j i i , rB with rA + rB ∈ R. Note that while for groups compute), there is a pair rA of prime order this can be shown via the Cauchy-Davenport theorem, the above result does not hold in general. We show, however, that as long as R is not a union of cosets in G, we can recover the implication (cf. Section 3.1 for why this assumption is legit). Lemma 3. Let G be a finite abelian group, and let R ⊆ G be such that R = R + H for any non-trivial subgroup H of G. Then, for any subsets X, Y ⊆ G with |X| = |G| − |R| and |Y | ≥ 2, we have (X + Y ) ∩ R = ∅. Proof. Let b1 , b2 ∈ Y with b1 = b2 , and set h = b1 −b2 . Assume (X + Y )∩R = ∅. Then |X| = |G| − |R| implies |X + Y | = |X|. Thus, X + b1 = X + b2 and hence X = X + h. Iterating gives X = X + h, where h denotes the subgroup generated by h. As R = G \ (X + b1 ), we get R = R + h, a contradiction.  
   
  The following observation summarizes the above discussion. If |¯ Observation 1 Let (α, β) ∈ Π. πA (α, β)| ≤ d − 1 or |¯ πB (α, β)| ≥ 2, we can immediately determine whether a feasible solution to the original R-GCTUF problem exists for such (α, β), and if so, obtain one by combining solutions com¯B . puted for the A- and B-subproblem when determining π ¯A and π  
   
  Advances on Strictly Δ-Modular IPs  
   
  403  
   
  Thus, the only case in which we cannot immediately check whether a feasible solution exists for some (α, β), is when B = 1 and A ≥ d + 1 (which imply πB (α, β)| = 1). This is the only case where we may have |¯ πA (α, β)| = d and |¯ πA (α, β) + π ¯B (α, β)) ∩ R = ∅, in which case (πA (α, β) + πB (α, β)) ∩ R = ∅ but (¯ we say that (α, β) contains a hidden solution. 3.3  
   
  Handling Patterns  
   
  In the rest of this section, we describe how our new techniques allow for overcoming barriers restricting previous approaches to depth d = 2. Recall that we as deﬁned in (4). We call sets of this form, for focus on a constant size subset Π any choice of i and ui , pattern shapes, and denote by  1  D := ±( 10 ), ±( 01 ), ± −1 (5) Focusing on Π allows for eﬃciently the possible edge directions of conv(Π). to the extent discussed computing π ¯X (α, β) for X ∈ {A, B} and all (α, β) ∈ Π earlier. In order to proceed, we use a structural result from [24], called averaging, that allows us to relate solutions—and thus elements of πX —across diﬀerent (α, β). Despite being true in more generality, the exposition here requires the following special case only. Proposition 2 ([24, special case of Lemma 5.3]). Consider an R-GCTUF with problem as described in (2). Let X ∈ {A, B}, v ∈ D, and (α, β) ∈ Π (α, β) + 2v ∈ Π. Given a solution x1 of the X-problem for (α, β) and, similarly, x2 for (α, β) + 2v, there are solutions x3 , x4 for the X-problem for (α, β) + v such that x1 + x2 = x3 + x4 . We remark that the proof of the above result for congruency-constrained problems given in [24] only exploits that congruency-constraints are linear constraints; therefore, the result carries over to group-constraints seamlessly. In previous approaches for depth d = 2, it was enough to only compute a single element from πA (e.g., by solving the A-problem after dropping the group constraint). Concretely, consider patterns of the shape as given in Fig. 1. For d = 2, Proposition 2 can be used to show that, if there is a hidden feasible solution for (α, β) = (0, 0) or (α, β) = (2, 0), then there must also be a feasible solution for (α, β) = (1, 0). The example in Fig. 1 shows that this is no longer true if the depth d exceeds 2, as only (α, β) = (0, 0) admits a feasible solution. This problem can be circumvented by analyzing the A-pattern π ¯A . As argued in Sect. 3.2, if a pair (α, β) has a hidden solution, then |πA (α, β)| ≥ d + 1 (and hence |¯ πA (α, β)| = d), hence we assume that there exists at least one such pair. The following result uses averaging (i.e., Proposition 2) to show that pairs (α , β  ) adjacent to such a pair (α, β) containing a hidden solution also have large π ¯A (α , β  ). such that |πA (α, β)| ≥ d + 1 Lemma 4. Let d ∈ {1, 2, 3}, v ∈ D, and (α, β) ∈ Π and (α, β) + 2v ∈ Π. Then |¯ πA ((α, β) + v)| = d.  
   
  404  
   
  M. N¨ agele et al.  
   
  πA  
   
  β 0  
   
  πB  
   
  β  
   
  0,1,2  
   
  0, 1  
   
  0  
   
  0  
   
  1  
   
  2  
   
  0  
   
  α  
   
  1  
   
  0, 1  
   
  0  
   
  0  
   
  1  
   
  2  
   
  α  
   
  Fig. 1. Possible patterns πA and πB for a problem with group G = Z/4Z. Every square  and the numbers in the box indicate elements of corresponds to a pair (α, β) ∈ Π, πA (α, β) and πB (α, β), respectively. For R = {3}, there is a feasible solution with (α, β) = (0, 0), but this cannot be detected without studying πA .  
   
  Proof. It is enough to show that |πA ((α, β) + v)| ≥ d. To this end, for each of the at least d + 1 elements r ∈ πA (α, β), let xr1 be a corresponding solution of the A-problem, and let x2 denote any ﬁxed solution for the A-problem on the pair (α, β) + 2v. Proposition 2 applied to xr1 and x2 gives solutions xr3 and xr4  r  r  r  r corresponding to elements γA x3 , γA x4 ∈ πA ((α, β)+v) with γA x3 +γA x4 taking at least d + 1 diﬀerent values. Assume for the sake of deriving a contradiction of diﬀerent sums of pairs that |πA ((α, β) + v)| ≤ d − 1. Then, since the   number + d − 1 = (d − 1)d/2 < d + 1 for of elements in πA ((α, β) + v) is bounded by d−1 2 d ∈ {1, 2, 3}, this contradicts the above construction.  
   
  Remark 1. For depth d = 4, one can ﬁnd GCTUF problems with G = Z/5Z and patterns that fail to satisfy Lemma 4; we present one such example in Fig. 2. Moreover, we remark that Lemma 4 is the only place in our proofs where we use the assumption that d = |G| − |R| ≤ 3.  
   
  πA  
   
  β 0  
   
  0, 1, 0, 1, 2,3,4 2 0  
   
  1  
   
  πB  
   
  β 0 2  
   
  0  
   
  α  
   
  1  
   
  0, 1  
   
  0  
   
  0  
   
  1  
   
  2  
   
  α  
   
  Fig. 2. Possible patterns πA and πB for a problem with group G = Z/5Z. Every square  and the numbers in the box indicate the elements of corresponds to a pair (α, β) ∈ Π, πA (α, β) and πB (α, β), respectively. For d = 4, Lemma 4 fails to hold for (α, β) = (0, 0) and v = (1, 0).  
   
  The main application of Lemma 4 is the following: If, on top of the assumption πA ((α, β) + in Lemma 4, |πB ((α, β) + v)| ≥ 2 holds, then Lemma 3 guarantees (¯ v)+¯ πB ((α, β)+v))∩R = ∅. From now on, we analyze both the A- and B-patterns in detail, in particular through averaging, to guarantee the aforementioned nonempty intersection and thus ﬁnd a solution, or identify additional properties that lead to progress. To distinguish cases of diﬀerent pattern structure, we need the following deﬁnition (see Fig. 3 for an illustration).  
   
  Advances on Strictly Δ-Modular IPs  
   
  405  
   
  an interior pair if (α, β)+ Definition 1. Let D be as in (5). We call (α, β) ∈ Π v ∈ Π for all v ∈ D, a border pair if (α, β) ± v ∈ Π for exactly two v ∈ D, and a vertex pair if it is not an interior or border pair. Note that for a border pair (α, β), due to symmeβ try, the two directions v ∈ D with (α, β) ± v ∈ Π will always be antiparallel, i.e., v and −v for some x x v ∈ D. To continue, the four types of patterns we b i x distinguish are the following: (I) |πB (α, β)| = 1 for or this is not the case, and (II) Π has x b x all (α, β) ∈ Π, α an interior pair, or (III) Π has no interior but border pairs, or (IV) Π has only vertex pairs. We sketch how to proceed for each of the types and present the Fig. 3. A pattern shape detailed discussion in the long version. with an interior, border, and vertex pairs (marked i,  
   
  Patterns of type I . In a type I pattern, techniques b, and w, respectively). of [24] enable reducing the problem to a new GCTUF problem with same G and |R|, and at least one variable less, thus allowing to make progress.  
   
  contains an interior pair and a hidden solution for some Patterns of type II . If Π pair (α, β), we can use techniques from [24] to ﬁnd v ∈ D such that (α, β) + 2v ∈ and |πB ((α, β) + v)| ≥ 2. Using Lemma 4 gives |πA ((α, β) + v)| ≥ d. So by Π ¯B (α, β) + v) ∩ R = ∅, hence we can ﬁnd a solution. Lemma 3, (¯ πA ((α, β) + v) + π Patterns of type III . In this case, we show that if we fail to ﬁnd a solution in π ¯A + π ¯B , then we can reduce to a smaller pattern shape Π  , allowing to induct. We ﬁrst deal with the case where there is no border pair (α, β) satisfying |πB (α, β)| ≥ 2. One can show that this implies that all pairs with |πB (α, β)| = 1 Recall that these are the only pairs that lie on a single tight constraint of Π. might contain a hidden solution, so we can use as Π  all pairs on this tight constraint. In the other case, there is a border pair (α, β) with |πB (α, β)| ≥ 2. Assume additionally that there is a hidden solution for a pair sharing a tight constraint with (α, β) (note that the latter is unique). Using Lemma 4 and Propoof Π sition 2, we get that there must exist a pair (α , β  ) with |πA (α , β  )| ≥ d and ¯A + π ¯B , |πB (α , β  )| ≥ 2. By Lemma 3, this implies existence of a solution in π contradicting the assumption. Thus, there cannot be a hidden solution anywhere on the tight constraint at (α, β), so taking Π and strengthening that constraint by one unit leads to the desired Π  . Patterns of type IV . For type IV pattern structure, we ﬁrst observe that, by with |πB (α, β)| ≥ 2, Observation 1, if there are any solutions for pairs (α, β) ∈ Π we can also ﬁnd one eﬃciently by combining solutions computed for the A- and ¯B . In the other case, i.e., when no B-subproblem when determining π ¯A and π solutions exist for such (α, β), it turns out that a type IV pattern is structured enough to allow a reduction to a type I pattern, analogous to an argument of [24].  
   
  406  
   
  M. N¨ agele et al.  
   
  References 1. Aprile, M., Fiorini, S.: Regular matroids have polynomial extension complexity. Math. Oper. Res. 47(1), 540–559 (2021). https://doi.org/10.1287/moor.2021.1137 2. Artmann, S., Eisenbrand, F., Glanzer, C., Oertel, T., Vempala, S., Weismantel, R.: A note on non-degenerate integer programs with small sub-determinants. Oper. Res. Lett. 44(5), 635–639 (2016). https://doi.org/10.1016/j.orl.2016.07.004 3. Artmann, S., Weismantel, R., and Zenklusen, R.: A Strongly Polynomial Algorithm for Bimodular Integer Linear Programming. In: Proceedings of the 49th Annual ACM Symposium on Theory of Computing (STOC ’17), pp. 1206–1219, Montreal (2017). https://doi.org/10.1145/3055399.3055473 4. Averkov, G., Schymura, M.: On the Maximal Number of Columns of a Δ - modular Matrix. In: Proceedings of the 23rd International Conference on Integer Programming and Combinatorial Optimization (IPCO ’22), pp. 29–42, Eidhoven (2022). https://doi.org/10.1007/978-3-031-06901-7 3 5. Barahona, F., Conforti, M.: A construction for binary matroids. Discret. Math. 66(3), 213–218 (1987). https://doi.org/10.1016/0012-365X(87)90097-5 6. Bonifas, N., Di Summa, M., Eisenbrand, F., H¨ ahnle, N., Niemeier, M.: On Subdeterminants and the Diameter of Polyhedra. Discrete Comput. Geometry 52(1), 102–115 (2014). https://doi.org/10.1007/s00454-014-9601-x 7. Camerini, P.M., Galbiati, G., Maﬃoli, F.: Random pseudo-polynomial algorithms for exact matroid problems. J. Algorithms 13, 258–273 (1992). https://doi.org/10. 1016/0196-6774(92)90018-8 8. Di Summa, M., Eisenbrand, F., Faenza, Y., Moldenhauer, C.: On Largest Volume Simplices and Sub-determinants. In: Proceedings of the 26th Annual ACMSIAM Symposium on Discrete Algorithms (SODA ’15), pp. 315–323, San Diego (2015). https://doi.org/10.1137/1.9781611973730.23 9. Dinitz, M., Kortsarz, G.: Matroid secretary for regular and decomposable matroids. SIAM J. Comput. 43(5), 1807–1830 (2014). https://doi.org/10.1137/13094030X 10. Eisenbrand, F., Vempala, S.: Geometric random edge. Math. Program. 1, 325–339 (2016). https://doi.org/10.1007/s10107-016-1089-0 11. Fiorini, S., Joret, G., Weltge, S., and Yuditsky, Y.: Integer programs with bounded subdeterminants and two nonzeros per row. In: Proceedings of the 62nd Annual Symposium on Foundations of Computer Science (FOCS ’22), pp. 13–24 (2022). https://doi.org/10.1109/FOCS52979.2021.00011 12. Glanzer, C., Stallknecht, I., and Weismantel, R.: On the recognition of a, b, cmodular matrices. In: Proceedings of the 22nd International Conference on Integer Programming and Combinatorial Optimization (IPCO ’21), pp. 238–251, Atlanta (2021). https://doi.org/10.1007/978-3-030-73879-2 17 13. Glanzer, C., Weismantel, R., Zenklusen, R.: On the number of distinct rows of a matrix with bounded subdeterminants. SIAM J. Discret. Math. 32(3), 1706–1720 (2018). https://doi.org/10.1137/17M1125728 14. Goemans, M.X., Ramakrishnan, V.S.: Minimizing submodular functions over families of sets. Combinatorica 15(4), 499–513 (1995). https://doi.org/10.1007/ BF01192523 15. Gribanov, D., Shumilov, I., Malyshev, D., Pardalos, P.: On Δ-modular integer linear problems in the canonical form and equivalent problems. J. Global Optim. (2022). https://doi.org/10.1007/s10898-022-01165-9  
   
  Advances on Strictly Δ-Modular IPs  
   
  407  
   
  16. Gribanov, D.V.: An FPTAS for the Δ-modular multidimensional knapsack problem. In: Proceedings of the International Conference on Mathematical Optimization Theory and Operations Research (MOTOR), pp. 79–95 (2021). https://doi. org/10.1007/978-3-030-77876-7 6 17. Gribanov, D.V., Zolotykh, N.Y.: On lattice point counting in Δ-modular polyhedra. Optim. Lett. (1), 1–28 (2021). https://doi.org/10.1007/s11590-021-01744x 18. Gribanov, D.V., Veselov, S.I.: On integer programming with bounded determinants. Optim. Lett. 10(6), 1169–1177 (2015). https://doi.org/10.1007/s11590-0150943-y 19. Gr¨ otschel, M., Lov´ asz, L., Schrijver, A.: Corrigendum to our paper ‘The ellipsoid method and its consequences in combinatorial optimization’. Combinatorica 4(4), 291–295 (1984). https://doi.org/10.1007/BF02579139 20. Gr¨ otschel, M., Lov´ asz, L., Schrijver, A.: Geometric Algorithms and Combinatorial Optimization. Springer, Cham (1993). https://doi.org/10.1007/978-3-642-78240-4 21. Heller, I.: On linear systems with integral valued solutions. Pac. J. Math. 7(3), 1351–1364 (1957). https://doi.org/10.2140/pjm.1957.7.1351 22. Lee, J., Paat, J., Stallknecht, I., Xu, L.: Improving proximity bounds using sparsity. In: Ba¨ıou, M., Gendron, B., G¨ unl¨ uk, O., Mahjoub, A.R. (eds.) ISCO 2020. LNCS, vol. 12176, pp. 115–127. Springer, Cham (2020). https://doi.org/10.1007/978-3030-53262-8 10 23. Lee, J., Paat, J., Stallknecht, I., Xu, L.: Polynomial upper bounds on the number of diﬀering columns of Δ-modular integer programs. Math. Oper. Res. (2022). https://doi.org/10.1287/moor.2022.1339 24. N¨ agele, M., Santiago, R., Zenklusen, R.: Congruency-constrained TU problems beyond the bimodular case. In: Proceedings of the 33rd Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2022), pp. 2743–2790 (2022). https://doi. org/10.1137/1.9781611977073.108 25. N¨ agele, M., Sudakov, B., Zenklusen, R.: Submodular minimization under congruency constraints. Combinatorica 39(6), 1351–1386 (2019). https://doi.org/10. 1007/s00493-019-3900-1 26. N¨ agele, M., Zenklusen, R.: A new contraction technique with applications to congruency-constrained cuts. Math. Program. (6), 455–481 (2020). https://doi. org/10.1007/s10107-020-01498-x 27. Nikolov, A.: Randomized rounding for the largest simplex problem. In: Proceedings of the 47th Annual ACM Symposium on Theory of Computing (STOC 2015), pp. 861–870, Portland (2015). https://doi.org/10.1145/2746539.2746628 28. Paat, J., Schl¨ oter, M., Weismantel, R.: The integrality number of an integer program. Math. Program. (6), 1–21 (2021). https://doi.org/10.1007/s10107-02101651-0 29. Padberg, M.W., Rao, M.R.: Odd minimum cut-sets and b-matchings. Math. Oper. Res. 7(1), 67–80 (1982). https://doi.org/10.1287/moor.7.1.67 30. Schrijver, A.: Theory of Linear and Integer Programming. Wiley, New York (1998) 31. Seymour, P.D.: Decomposition of regular matroids. J. Comb. Theory, Ser. B 28(3), 305–359 (1980). https://doi.org/10.1016/0095-8956(80)90075-1 ´ A strongly polynomial algorithm to solve combinatorial linear pro32. Tardos, E.: grams. Oper. Res. 34(2), 250–256 (1986). https://doi.org/10.1287/opre.34.2.25 33. Veselov, S.I., Chirkov, A.J.: Integer program with bimodular matrix. Discret. Optim. 6(2), 220–222 (2009). https://doi.org/10.1016/j.disopt.2008.12.002  
   
  Cut-Suﬃcient Directed 2-Commodity Multiﬂow Topologies Joseph Poremba(B) and F. Bruce Shepherd Computer Science, University of British Columbia, Vancouver, BC, Canada {jporemba,fbrucesh}@cs.ubc.ca  
   
  Abstract. In multicommodity network ﬂows, a supply-demand graph pair (G, H) (called a multiﬂow topology) is cut-suﬃcient if, for all capacity weights u and demand weights d, the cut condition is enough to guarantee the existence of a feasible multiﬂow. We characterize the cut-suﬃcient topologies for two classes of directed 2-commodity ﬂows: roundtrip demands, where H is a 2-cycle, and 2-path demands, where H is a directed path of length two. To do so, we introduce a theory of relevant minors. Unlike the undirected setting, for directed graphs the cutsuﬃcient topologies are not closed under taking minors. They are however closed under taking relevant minors. Respectively, the cut-suﬃcient topologies for roundtrip and two-path demands are characterized by one and two forbidden relevant minors. As an application of our results, we show that recognizing cut-suﬃciency for directed multiﬂow topologies is NP-hard, even for roundtrip demands. This is in contrast to undirected 2-commodity ﬂows, for which topologies are always cut-suﬃcient. Keywords: Network Flows  
   
  1  
   
  · Multiﬂows · Cuts · Flow-cut Gap  
   
  Introduction  
   
  Network ﬂows are one of the fundamental areas of combinatorial optimization and we study its feasibility question. Given an edge-capacitated supply network (directed or undirected) G = (V, E, u) and an edge-weighted demand network H = (V, F, d), can we route (fractionally) in G the demands from H without violating G’s edge capacities? Perhaps the most natural requirement for this ﬂow to exist is the cut condition: for each non-empty S  V , the total demand on edges in H in the cut induced by S, is at most the total capacity on G’s edges in this cut. For undirected graphs this is: d(δH (S)) ≤ u(δG (S))  
   
  for all S  V, S = ∅.  
   
  (1)  
   
  For directed graphs, we replace δ with δ + . The classical Max-Flow Min-Cut (aka Menger’s) Theorem asserts that this condition is suﬃcient in the case where |E(H)| = 1. This is not always the case. The authors are grateful for an NSERC Discovery Grant which supported this work. c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 408–422, 2023. https://doi.org/10.1007/978-3-031-32726-1_29  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  409  
   
  For instance, in Fig. 1 the cut condition holds for unit capacities and demands. However, the shortest path between s, t for any demand edge st ∈ E(H) is 2. Hence any ﬂow that satisﬁes this demand would require 8 units of capacity, whereas G only has 6. This is a proof that we must scale up some capacity to 43 in order to route H. It is easy to check in fact that we may route H as long as every edge has capacity 43 . This idea of ﬁnding the minimum scaling up of capacities so that H is routable is the basis for the notion of ﬂow-cut gap. A multiﬂow topology consists of a pair of graphs (G, H) on the same node set V . We say the topology has ﬂow-cut gap α ≥ 1 if the following holds for every multiﬂow instance on (G, H), i.e. for every endowment of capacities u and demands d: if (G, H, u, d) satisﬁes the cut condition, 4 Fig. 1. Flow-cut gap 3 . The edges of G are then a multiﬂow exists if we scale the capacities up to αu. We emphasize solid and the edges of H are dashed. that the ﬂow-cut gap is a property of a topology (G, H), while the cut condition and feasibility are properties of a weighted instance (G, H, u, d). The foundational works of Leighton-Rao [21], Auman-Rabani [3], and Linial-London-Rabinovich [22] show that for arbitrary undirected topologies the ﬂow-cut gap is O(log n); moreover this is tight due to an expander example in [21]. There is also a conjecture which asserts that the socalled integral ﬂow-cut gap is quantitatively linked to this standard ﬂow-cut gap [7]. There have also been investigations on establishing constant-factor ﬂow-cut gaps for restricted families [5–7,10,19,20]. Our focus is on topologies that are cut-suﬃcient, that is, multiﬂow topologies with ﬂow-cut gap 1. Several important classes of undirected topologies have been shown to have this property. The most renowned results are the Max-Flow MinCut Theorem (|E(H)| = 1), Hu’s 2-commodity Theorem (|E(H)| = 2) [12], and the Okamura-Seymour Theorem (planar G where all demand edges have their endpoints on a single face) [26]. There is no over-arching theorem, however, that captures all cut-suﬃcient undirected topologies. On a related note, the problem of recognizing cut-suﬃciency has not been studied as far as we know. The lack of a recognition algorithm for cut-suﬃciency is curious since it is a minor-closed property. Namely, if an undirected pair (G, H) has a ﬂow-cut gap ≤ α, then so does any pair which arises by contracting or deleting edges in G. This is veriﬁed by noting that deleting an edge corresponds to setting its capacity to 0 and contracting corresponds to setting its capacity to +∞. Hence it is tempting to claim that there is an algorithm to detect ≤ α ﬂowcut gap topologies, since this minor-closed property should conﬁrm a ﬁnite list of “forbidden multiﬂow topologies”. This is not the case however, due to the subtlety that the demand graph is also part of the topology. Speciﬁcally, [4]  
   
  410  
   
  J. Poremba and F. B. Shepherd  
   
  gives a characterization of when the ﬂow-cut gap is 1 for pairs (G, H) where G is series-parallel. They prove there are inﬁnitely many minimal “bad” topologies called the odd spindles. These generalize the graph of Fig. 1 by replacing the “demand triangle” by a “demand odd cycle”. We are not aware of an algorithm for recognizing this property for series-parallel topologies. Of course, when |E(H)| = 2, Hu’s Theorem gives us a very simple polynomial time recognition algorithm for undirected cut-suﬃciency. Given such a topology (G, H), it always outputs YES! We consider the directed analogue of this question and prove the following contrasting result. Theorem 1. It is NP-hard to determine whether a directed multiﬂow topology (G, H) is cut-suﬃcient, even if H is a 2-cycle. In general, there is much less work for directed cut-suﬃciency. One beautiful result is a theorem of Nagamochi and Ibaraki [24] which shows that any cutsuﬃcient directed topology (G, H) is also “integrally cut-suﬃcient”. In other words, if all the capacities and demands are integral, then the cut condition is suﬃcient to guarantee an integral routing. Theorem 1 relies on an understanding of the forbidden minors in directed 2-commodity topologies, much along the lines of the undirected series-parallel characterization of Chakrabarti et al. [4]. There are a number of diﬃculties we face with this approach. Most signiﬁcantly, directed cut-suﬃciency does not enjoy the same minor-closed property as the undirected setting. The key issue is that contracting an edge e in the directed setting may not correspond to deﬁning its capacity to +∞. This is because it may create entirely new paths for ﬂows to use. This requires us to develop a theory of “relevant minors”. Namely, a minor (G , H  ) is relevant if the cut condition in the minor is directly connected to the cut condition in (G, H) with an appropriate setting of edge weights in (G, H). The technical results we need are developed in Sect. 3. We partition the class of 2-commodity topologies into one of three types. H is said to have roundtrip demands if E(H) = {(s, t), (t, s)} for distinct nodes s, t ∈ V , it has 2-path demands if E(H) = {(s, t), (t, r)} where s, t, r are distinct nodes, and it has 2-matching demands if E(H) = {(s1 , t1 ), (s2 , t2 )} for distinct nodes s1 , s2 , t1 , t2 . There is also the case where H has a single common head or common tail, but these are always cut-suﬃcient by a simple reduction from the Max-Flow Min-Cut Theorem. Using the notion of relevant minors, we ﬁnd that the two topologies from Fig. 2a-2b, are the only minimal forbidden relevant minors for roundtrip and 2-path topologies. More precisely we have the following. Theorem 2. A directed multiﬂow topology with roundtrip demands is cutsuﬃcient if and only if it does not contain the bad dual triangles (Fig. 2a) as a relevant minor. Theorem 3. A directed multiﬂow topology with 2-path demands is cut-suﬃcient if and only if it does not contain the bad triangle (Fig. 2b) or the bad dual triangles (Fig. 2a) as a relevant minor.  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  (a) The bad dual triangles.  
   
  411  
   
  (b) The bad triangle.  
   
  Fig. 2. The minimal bad roundtrip and 2-path demand topologies. With unit capacities and demands, each satisﬁes the cut condition but is not feasible.  
   
  These results imply that, in the case of roundtrip and 2-path demands, the minimal non-cut-suﬃcient directed topologies are certiﬁed as such by multiﬂow instances with 0,1 data (i.e., demands and capacities are 0, 1-valued). Ultimately, this implies that any non-cut-suﬃcient topology in these classes is certiﬁed by 0,1 demand values and 0,1,+∞ capacity values. This 2 property need not always hold; Fig. 3 is an undirected example where the cut condition is suﬃcient for unit demand weights but not when one of the demand edges has weight 2. We conjecture - see Sect. 6 - that this 0,1 property is true for all directed Fig. 3. An undirected topology where 2-commodity topologies. If true, this the cut condition is suﬃcient for unit would give a complete characterization demands, but not in general. of 2-commodity cut-suﬃciency using a result in [27], which establishes that the non-cut-suﬃcient topologies certiﬁed by 0, 1 demands are characterized via the minors in Fig. 2b and 2a. We achieve Theorems 2 and 3 by showing that, for roundtrip and 2-path demands, if G contains two paths for its diﬀerent commodities that share an edge, then we ﬁnd either the bad dual triangles or the bad triangle as a relevant minor. This argument also yields the following characterization of cut-suﬃciency, which is in a convenient form to prove Theorem 1. Theorem 4. Suppose (G, H) is a directed multiﬂow topology with roundtrip or 2-path demands, say (s, t) and (t, r) where r may equal s. The topology is cutsuﬃcient if and only if every st-path is arc-disjoint from every tr-path in G. 1.1  
   
  Other Related Work  
   
  There are several other known cut-suﬃcient undirected classes. Lomonosov and Seymour ( [23,30], cf. Corollary 72.2a [29]) yield a characterization of the demand  
   
  412  
   
  J. Poremba and F. B. Shepherd  
   
  graphs H such that every supply graph G “works” for H, i.e., (G, H) is cutsuﬃcient for any graph G with V (H) ⊆ V (G). They prove that any such H is (a subgraph of) either K4 , C5 or the union of two stars. Another question asks for which (supply) graphs G is it the case that (G, H) is cut-suﬃcient for every H which is a subgraph of G; Seymour [31] shows that this is precisely the class of K5 minor-free graphs. A related result is to characterize which pairs (G, Z) with Z ⊆ V (G) are cut-suﬃcient for every demand graph H with V (H) = Z. In [25] it is shown that this occurs if and only if G is (reducible to) planar and Z is a subset of one face, i.e., essentially Okamura-Seymour instances [26]. We refer the reader to [7] for additional discussion. Similar to our relevant minors, other works have deﬁned restricted types of directed graph minors to achieve interesting characterizations in other applications. Some examples include butterﬂy minors (introduced in [13], used in [1,14,17]), strongly-connected contractions [16], d-minors [8], and shallow minors [18]. There is no uniﬁed theory of directed minors that is useful in every context. Our context is diﬀerent than the aforementioned in that we need to consider both G and H to achieve the desired properties (though in Corollary 1, connections to butterﬂy and strongly-connected contractions can be seen). A related but diﬀerent gap result for directed multicommodity ﬂows has been studied that is deﬁned in terms of the directed non-bipartite sparsest cut problem. Here, a “cut” is any set F ⊆ E(G), and the sparsity of F is the ratio between u(F ) and the total demand of all commodities separated by F . The gap is the smallest ratio, over all u and d, of the maximum ﬂow to the smallest sparsity of a cut. This is the “non-bipartite” ﬂow-cut gap. For undirected graphs, the two gaps coincide, but not so in √ the directed setting. For this non-bipartite ﬂowacke [11], cut gap, a general bound of O( n) was proven by Hajiaghayi and R¨ ˜ 11/23 ) by Agarwal et al. [2]. Recently, several results have later improved to O(n given improved bounds for certain classes of supply graphs, such as directed series-parallel and graphs of bounded pathwidth [28], and planar [15].  
   
  2  
   
  Preliminaries  
   
  By paths we always mean simple paths, and for directed graphs we mean these to be simple directed paths. We use tail(e) and head(e) to represent the tail and head of an edge e, respectively. For an edge set F , we deﬁne tail(F ) = {tail(e) : e ∈ F } and head(F ) = {head(e) : e ∈ F }. For multicommodity ﬂows, we always assume integer capacities u and demand weights d. This assumption does not aﬀect the value of the ﬂow-cut gap, or whether a topology is cut-suﬃcient. We let Gu be the multigraph obtained by splitting each e ∈ E(G) into u(e) parallel copies (and deﬁne Hd similarly). 2.1  
   
  Cut-Deceptive Weights and Minors of Multiflow Topologies  
   
  For discussion of contraction, we allow parallel edges and loops. We write deletion and contraction of an edge set F as G−F and G/F respectively. Edges have their  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  413  
   
  own identity beyond their incident nodes. Contractions may change the ends of non-contracted edges, but those edges themselves still exist. For notational convenience we still write edges in terms of incident nodes, such as e = (w, v). A minor of an undirected or directed multiﬂow topology (G, H) is obtained by a sequence of edge deletions from G and H, and contractions of edges in G. Contracting e ∈ E(G) identiﬁes its ends in both G and H, and we denote this topology (G, H)/e. For a multiﬂow topology (G, H), we say weights (u, d) are cut-deceptive if (G, H, u, d) satisﬁes the cut condition but is not feasible. Hence, a topology is cut-suﬃcient if and only if it does not have any cut-deceptive weights. For undirected multiﬂow topologies, the family of cut-suﬃcient topologies is closed under taking minors. In particular, if a minor (G , H  ) has cut-deceptive weights (u, d), then those weights can be extended to cut-deceptive weights (uext , dext ) for (G, H) as follows. Definition 1 (Extension of Weights). Let (G , H  ) be a minor of an undirected or directed multiﬂow topology (G, H). Let (u, d) be weights for (G , H  ). We deﬁne the extension1 of (u, d) to be the weights (uext , dext ) of (G, H) where: – – – – –  
   
  3  
   
  uext (e) = 0 if e ∈ E(G) was deleted, uext (e) = +∞ if e ∈ E(G) was contracted, uext (e) = u(e) for all other edges e ∈ E(G ), dext (e) = 0 if e ∈ E(H) was deleted, dext (e) = d(e) for all other edges e ∈ E(H  ).  
   
  Relevant Minors and Entry-Exit Connected Edge Sets  
   
  In contrast to the undirected setting, the cut-suﬃcient directed multiﬂow topologies are not closed under taking minors. For example, consider the topology in Fig. 4. It is trivially cut-suﬃcient, since it is impossible to satisfy the cut condition with nonzero demands. However, contracting Fig. 4. A cut-suﬃcient topology, with a the highlighted edge yields the bad non-cut-suﬃcient minor. triangle (Fig. 2b), which is not cutsuﬃcient. Without restricting the kinds of minors allowed, it does not make sense to speak of forbidden minors. 1  
   
  Recall that deletions and contractions commute. The extension is invariant to the speciﬁc ordering of these operations. However, there may be operation sequences that are diﬀerent beyond simple re-ordering but still produce the same minor. For example, a single vertex is a minor of a triangle, but any two edges can be contracted and the third deleted to obtain it. The speciﬁc choice aﬀects the extension. It is tedious to instrument this nuance throughout the text, but we associate a minor with a set of deletions and contractions that produce it.  
   
  414  
   
  3.1  
   
  J. Poremba and F. B. Shepherd  
   
  Relevant Minors  
   
  We introduce a theory of relevant minors for directed multiﬂow topologies that gives closure for cut-suﬃciency. In particular, if (G , H  ) is a relevant minor of (G, H), and (G , H  ) has cut-deceptive weights (u, d), then (uext , dext ) are cutdeceptive weights of (G, H). There are two potential reasons for (uext , dext ) to not be cut-deceptive: either (G, H, uext , dext ) is feasible, or the cut condition is not satisﬁed. The feasibility aspect is not a problem: it is easy to observe that if (G, H, uext , dext ) is feasible, then (G , H  , u, d) is also feasible using the same ﬂow paths (after contracting). Thus the following deﬁnition gives us the desired properties. Definition 2 (Relevant Minor). A minor (G , H  ) of directed multiﬂow topology (G, H) is relevant if, for all weights (u, d) of (G , H  ) that satisfy the cut condition, (G, H, uext , dext ) also satisﬁes the cut condition. Proposition 1. Let (G , H  ) be a relevant minor of directed multiﬂow topology (G, H). If (u, d) are cut-deceptive weights for (G , H  ), then (uext , dext ) are cutdeceptive weights for (G, H). Hence, a directed multiﬂow topology (G, H) is cutsuﬃcient if and only if every relevant minor of (G, H) is cut-suﬃcient. As a consequence, we conclude one direction of Theorems 2 and 3: if a directed multiﬂow topology contains either the bad triangle or the bad dual triangles as a relevant minor, then it is not cut-suﬃcient. 3.2  
   
  Contractions of Entry-Exit Connected Sets  
   
  The deﬁnition of a relevant minor is abstract and does not immediately suggest how to show that a minor is relevant. We develop some useful tools for this purpose. First, it is easily shown that deletions always produce relevant minors. Proposition 2. Let (G, H) be a directed multiﬂow topology. – For any e ∈ E(G), (G − e, H) is a relevant minor of (G, H). – For any e ∈ E(H), (G, H − e) is a relevant minor of (G, H). Proof. In either case, let (G , H  ) be the minor in question. Consider weighted instances (G , H  , u, d) and (G, H, uext , dext ). Cuts in the two instances that are induced by the same node subset have the same weights. Hence, the cut condition is satisﬁed in both or neither. So the only potential issues are contractions. We say an edge or edge set is safe if its contraction produces a relevant minor. What might make an edge unsafe? Consider Fig. 4. Contracting the highlighted edge produces a minor that is not relevant. The issue is that new connectivity is created by the contraction, so it is easier to satisfy the cut condition than in the original topology. This notion of safety seems to be intricate and does not satisfy simple properties such as: safe edge sets being closed under unions. While we are progressing towards  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  415  
   
  a full characterization of safety, in this paper, we rely on a suﬃcient condition for a set of edges to be safe. Speciﬁcally, we show that if contracting an edge set does not create new terminal connectivity, then it is safe. We formalize this notion as follows. Definition 3 (Entry/Exit Points, Entry-Exit Connected). Let (G, H) be a directed multiﬂow topology. Let F ⊆ E(G) be weakly connected. – We denote by Entry(F ) the set of nodes x ∈ V (F ) such that there exists an sx-path in G − F for some s ∈ tails(H). We call these entry points of F . – We denote by Exit(F ) the set of nodes y ∈ V (F ) such that there exists a yt-path in G − F for some t ∈ heads(H). We call these exit points of F . We say F is entry-exit connected if G[F ] contains an xy-path for every x ∈ Entry(F ) and y ∈ Exit(F ). To prove such sets are safe, we recast the cut condition from discussing density of cuts to discussing paths connecting terminals. We call this new form the path cut condition. In essence, the cut condition in (G, H, u, d) is equivalent to the existence of, for every F ⊆ E(H), d(F ) many arc-disjoint tails(F )−heads(F ) paths (i.e., paths between tails(F ) and heads(F )) in Gu . Definition 4 (Weakly Feasible Routing). Let F ⊆ E(H) be a demand subset of directed multiﬂow instance (G, H, u, d). A weakly feasible routing of F is a set PF of d(F ) arc-disjoint tails(F ) − heads(F ) paths in Gu . Furthermore, the weakly feasible routing is fair or marginal-satisfying if both:   – exactly d δF+ (s) paths in PF start at s for every s ∈ tails(F ), and  −  – exactly d δF (t) paths in PF end at t for every t ∈ heads(F ). On a technical note, this deﬁnition is problematic if tails(F ) ∩ heads(F ) = ∅. Fortunately, in such a case no cut contains the entirety of F . It is a degenerate case that ultimately can be excluded from the path cut condition2 . Now, we deﬁne the path cut condition. In fact, we deﬁne two versions. Each is useful in diﬀerent circumstances, and both are equivalent to the cut condition. Definition 5 (Path Cut Condition). Let (G, H, u, d) be a directed multiﬂow instance. The (fair) path cut condition is the property that, for every F ⊆ E(H) where tails(F ) ∩ heads(F ) = ∅, there exists a (fair) weakly feasible routing of F . Theorem 5. Let (G, H, u, d) be a directed multiﬂow instance. The cut condition, the path cut condition, and the fair path cut condition are equivalent. The path cut condition gives a convenient way to prove that it is safe to contract entry-exit connected edge sets. 2  
   
  An equally valid alternative would be to allow a weakly feasible routing of F to pack inﬁnitely many copies of the length-zero path on a node in tails(F ) ∩ heads(F ).  
   
  416  
   
  J. Poremba and F. B. Shepherd  
   
  Theorem 6. Let (G, H) be a directed multiﬂow topology. If a weakly connected edge set F ⊆ E(G) is entry-exit connected, then F is safe. Proof. Let (G , H  ) = (G, H)/F . Let vF be the identiﬁed node for F in (G , H  ). Let (u, d) be weights for (G , H  ) that satisfy the path cut condition. We prove that (G, H, uext , dext ) satisﬁes the path cut condition by showing that for each J ⊆ E(H) with tailsH (J) ∩ headsH (J) = ∅, there is a weakly feasible routing of J in (G, H, uext , dext ). Let k = d(J) = dext (J). For each x ∈ Entry(F ) and y ∈ Exit(F ), let Fx,y be an xy path in G[F ] (which exist, since F is entry-exit connected). Note that in Guext , there are inﬁnitely many copies of each Fx,y , since uext (e) = +∞ for all e ∈ F . For each x and y, select k of them, say Fx,y,1 , . . . , Fx,y,k . Recall that, per our convention on minors, the edges of J still exist in H  . However, the ends of edges may change. We split into two cases. In the ﬁrst case, suppose there exists v ∈ tailsH  (J) ∩ headsH  (J). Since tailsH (J) ∩ headsH (J) = ∅, but the intersection is non-empty after contracting F into vF , it must be that v = vF . Then there exist s ∈ tailsH (J) and t ∈ headsH (J) such that s, t ∈ V (G[F ]). Note that s ∈ Entry(F ) and t ∈ Exit(F ). Then taking Fs,t,i for i = 1, . . . , k gives a weakly feasible routing of F . In the second case, suppose that tailsH  (J) ∩ headsH  (J) = ∅. Then, the path cut condition of (G , H  , u, d) implies that there is a set P  of k arc-disjoint tailsH  (J) − headsH  (J) paths in Gu . We map each of the paths P1 , . . . , Pk in P  to a tailsH (J)−headsH (J) path in Guext . Each Pi ∈ P  is a path from some s ∈ tailsH  (J) to some t ∈ headsH  (J). If Pi avoids vF , then s ∈ tailsH (J) and t ∈ headsH (J), and we map Pi to itself. If Pi uses vF , then in Guext its edges form two paths: a path Xi from some sˆ ∈ tailsH (J) to some x ∈ Entry(F ), and a path Yi from some y ∈ Exit(F ) to some tˆ ∈ headsH (J) (either path may have length zero). Joining Xi and Yi with Fx,y,i yields a tailsH (J) − headsH (J) path. We map Pi to this path. In this way, each Pi ∈ P  maps to a tailsH (J) − headsH (J) path in Guext that uses only the edges of Pi and edges in some Fx,y,i . Then the image of P  under this mapping is a set of k arc-disjoint tailsH (J) − headsH (J) paths in Guext , as desired. There are several special cases of entry-exit connected sets that lead to quick ways to justify safety. Definition 6. A subdivision of directed multiﬂow topology (G, H) is obtained by a sequence of the following operation: select an edge e ∈ E(G), and replace it with a path of length at least one. Corollary 1. Let (G, H) be a directed multiﬂow topology. 1. 2. 3. 4.  
   
  If F ⊆ E(G) is strongly connected, then F is safe. − If e = (a, b) ∈ E(G) with deg+ G (a) = 1 and degH (a) = 0, then e is safe. − + If e = (a, b) ∈ E(G) with degG (b) = 1 and degH (b) = 0, then e is safe. If (G, H) is a subdivision of (G , H  ), then (G , H  ) is a relevant minor of (G, H).  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  417  
   
  Items 1 and 4 are used to prove Theorem 2, and Item 3 is additionally used to prove Theorem 3, though the proof for the latter is omitted in this paper since it is very similar to the former. We note that these theorems do not require the full generality of this entry-exit connected machinery, and Corollary 1 can be proven in an ad-hoc fashion without appealing to Theorem 6. However it shows that the cases of Corollary 1 are diﬀerent expressions of the same general connectivity property. More importantly, the entry-exit machinery is general in the sense of not being restricted to a two demand setting. Moreover, the general form of entry-exit connected sets is used in [27] for studying safe contractions when there are 2-matching demands. We expect it to be useful in investigating characterizations of cut-suﬃciency for more general H.  
   
  4  
   
  Characterizations of Cut-Suﬃciency  
   
  We now apply our theory of relevant minors to prove Theorems 2, 3, and 4, which characterize the cut-suﬃcient directed multiﬂow topologies for roundtrip and 2-path demands. What remains to prove is that if there are cut-deceptive weights for a topology, then one of the desired relevant minors exists. 4.1  
   
  Opposingly Ordered Paths  
   
  The cut condition implies the existence of certain paths in Gu . From there, infeasibility implies particular interactions of these paths, which we use to prove the existence of the desired relevant minor. To that end, we use the following terminology to describe interactions between paths. Definition 7 (Overlap Segments, Bridges). Let P and Q be paths in a directed graph that share at least one node. – An overlap segment is a maximal common subpath of P and Q. It is trivial if it is one node. It is terminal if it contains the start or end of either path. – A P -bridge of Q is a maximal subpath B of P that has at least one edge and shares no edges or internal nodes of B with Q. In the above, note that P can be written as an alternating sequence of P bridges of Q and the overlap segments of P and Q. When we say that we are listing objects, such as overlap segments, nodes, or edges, in P -order, we mean we list them by their order of occurrence when following the (directed) path P . Paths can intersect numerous times in varied conﬁgurations, so it may not be obvious how to proceed looking for a particular minor. To manage this complexity, we reduce to the case where the overlap segments follow a special pattern. Definition 8 (Opposingly Ordered). Let P and Q be paths in a directed graph that share at least one node. We say that P and Q are opposingly ordered if the P -order of their overlap segments is the reverse of the Q-order.  
   
  418  
   
  J. Poremba and F. B. Shepherd  
   
  Lemma 1. Let P be an s1 t1 -path and let Q be an s2 t2 -path in a directed graph, where s1 = s2 and t1 = t2 , such that P and Q share an edge. In P ∪ Q, there exists an s2 t2 -path Q∗ such that: – P and Q∗ are opposingly ordered, and – P and Q∗ share an edge. 4.2  
   
  Characterization for Roundtrip and Two-Path Demands  
   
  We now have the tools to prove our characterizations. We begin with roundtrip demands. Lemma 2. Let (G, H) be a directed multiﬂow topology with roundtrip demands between s and t. Suppose G contains an st-path P and a ts-path Q that are not arc-disjoint. Then (G, H) contains the bad dual triangles (Fig. 2a) as a relevant minor. Proof. Consider a counterexample that minimizes |E(P )|+|E(Q)|. By Lemma 1, we may assume P and Q are opposingly ordered, otherwise we replace Q with Q∗ . Note that s and t themselves are trivial terminal overlap segments. Since P and Q share an edge, there is a non-trivial overlap segment J ∗ . Note that J ∗ is not terminal. We claim J ∗ is the only non-terminal overlap segment. Suppose there are at least two, for the sake of contradiction. Let JP be the ﬁrst non-terminal overlap segment in P -order (last in Q-order), and let JQ be the ﬁrst in Q-order (last in P -order). At least one of these two is not J ∗ . Without loss of generality, suppose JP = J ∗ . Say JP starts at w and ends at v. Let C be the cycle obtained by starting at s, following the ﬁrst (in P -order) P -bridge of Q to w, following JP from w to v, then following the last (in Q-order) Q-bridge of P from v to s. Consider the topology (G , H  ) = (G, H)/C, which has roundtrip demands. Since directed cycles are strongly connected, this contraction is safe by Corollary 1. Additionally, P  = P/(P ∩ C) and Q = Q/(Q ∩ C) are paths for the two commodities. Moreover, they have a non-trivial overlap segment, namely J ∗ . By minimality, we obtain the desired relevant minor in (G , H  ), and hence in (G, H), a contradiction. So, there is exactly one non-terminal overlap segment J ∗ , and it is nontrivial. Let w∗ and v ∗ be the ﬁrst and last nodes of J ∗ , respectively (in either P -order or Q-order, both are the same for nodes of an overlap segment). The only other overlap segments are the terminal ones, s and t themselves. There are thus exactly two P -bridges of Q, connecting s to w∗ and v ∗ to t, respectively. Similarly there are exactly two Q-bridges of P , connecting t to w∗ and v ∗ to s, respectively. Then, the topology (P ∪ Q, H) is exactly a subdivision of the bad dual triangles. By Corollary 1, the bad dual triangles is a relevant minor of (P ∪ Q, H) and hence also of (G, H). Lemma 2 implies that if (G, H) has roundtrip demands and does not contain the bad dual triangles as a relevant minor, then every st-path in G is arc-disjoint  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  419  
   
  from every ts-path. Such topologies are easily veriﬁed to be cut-suﬃcient, since for any weights, any pair of weakly feasible routings for the two commodities together form a feasible routing for the whole instance. Hence Theorem 2 follows, as well as the part of Theorem 4 pertaining to roundtrip demands. For 2-path demands, we proceed along similar lines as for roundtrip demands. Theorem 3, and the remainder of Theorem 4, is straightforwardly implied by the following lemma whose proof we defer to the full version. Lemma 3. Let (G, H) be a directed multiﬂow topology with 2-path demands (s, t) and (t, r). If G has an st-path and a tr-path that are not arc-disjoint, then (G, H) contains either the bad dual triangles or the bad triangle as a relevant minor.  
   
  5  
   
  NP-Hardness of Recognizing Cut-Suﬃciency  
   
  The proofs of Theorems 2 and 3 can be adapted to give a polynomial time algorithm. Given (G, H) with roundtrip or 2-path demands, and weights (u, d) that satisfy the cut condition, the algorithm outputs either a feasible integer routing for (G, H, u, d) or one of the two forbidden relevant minors. The algorithm does not however determine whether (G, H) is cut-suﬃcient, since particular (u, d) may be feasible despite (G, H) not being cut-suﬃcient in general. We show that determining if a directed multiﬂow topology (G, H) is cut-suﬃcient (the CutSufficient decision problem) is NP-hard, even if we restrict to roundtrip demands (the CutSufficientRT decision problem). We reduce from an NP-hard decision problem we call UsefulEdge. Given a directed graph G, distinct nodes s, t ∈ V (G), and an edge e ∈ E(G), it asks whether there exists a (simple directed) st-path in G that uses the edge e. The directed 2-node-disjoint path problem, proved by Fortune et al. [9] to be NPhard, can be reduced to UsefulEdge. Theorem 1 is implied by the following. Theorem 7. There is a polynomial time reduction from the UsefulEdge problem to the CutSufficientRT problem. Proof. Given an input (G, s, t, e = (w, v)) for UsefulEdge, we construct a multiﬂow topology (G , H  ) with roundtrip demands. We obtain G from G as follows: 1. Subdivide e into e1 = (w, w ), e2 = (w , v  ), e3 = (v  , v), where w , v  are new nodes and w, v maintain their other incident edges. 2. Add two new nodes s , t , and edges (s , s), (t, t ), (t , w ), and (v  , s ). Finally, deﬁne H  = (V (G ), {(s , t ), (t , s )}). We claim that (G , H  ) is not cutsuﬃcient if and only if there is an st-path in G that uses e, which proves the result. Deﬁne Q to be the path (t , w ), (w , v  ), (v  , s ). For the “only if” direction, suppose that (G , H  ) is not cut-suﬃcient. Then by Theorem 4, G has some s t -path P  that shares an edge with some t s -path. The only t s -path is Q , and the only possible shared edge is e2 = (w , v  ),  
   
  420  
   
  J. Poremba and F. B. Shepherd  
   
  so P  uses e1 , e2 , e3 . It also uses (s , s) and (t, t ). Swapping e1 , e2 , e3 for e and removing (s , s) and (t, t ) from P  , we ﬁnd an st-path of G that uses e. For the “if” direction, suppose there is an st-path P in G that uses e. By swapping e for e1 , e2 , e3 and adding (s , s) and (t, t ), we obtain an s t -path P  in G that uses e2 . Now, P  shares e2 = (w , v  ) with Q . By Theorem 4, the topology is not cut-suﬃcient.  
   
  6  
   
  Towards a Complete 2-Commodity Characterization  
   
  For two commodities, the only remaining case is 2-matching demands. We conjecture that the bad dual triangles and the bad triangle are the only forbidden relevant minors for this case. Conjecture 1. A directed multiﬂow topology with 2-matching demands (and hence, two demands in general) is cut-suﬃcient if and only if it does not contain the bad triangle or the bad dual triangles as a relevant minor. In [27], the following is proved. Proposition 3. If directed multiﬂow topology (G, H) has 2-matching demands and (integer) cut-deceptive weights (u, d) where d(e) = 1 for all e ∈ E(H), then it contains either the bad triangle or the bad dual triangles as a relevant minor. The argument considers more intricate interactions of paths arising from the fair path cut condition. It also requires general entry-exit connected contractions, rather than the specialized cases of Corollary 1. For roundtrip and 2-path demands, there is a clear reduction to the case of unit weight demands: if there is a cut-deceptive weighting (u, d), then by taking any paths P and Q for the two commodities that share an edge, Lemmas 2 and 3 show there is a cut-deceptive weighting for (P ∪ Q, H) where the demands are unit. This observation is encapsulated in Theorem 4. However, we do not have so strong a result for 2-matching demands. It is not enough to just take paths for the two commodities that share an edge, as this may not even satisfy the cut condition.  
   
  References 1. Adler, I.: Directed tree-width examples. J. Comb. Theory Ser. B 97(5), 718–725 (2007). https://doi.org/10.1016/j.jctb.2006.12.006, https://linkinghub. elsevier.com/retrieve/pii/S0095895606001444 2. Agarwal, A., Alon, N., Charikar, M.S.: Improved approximation for directed cut problems. In: Proceedings of the Thirty-Ninth Annual ACM Symposium on Theory of Computing - STOC ’07, p. 671. ACM Press, San Diego, California, USA (2007). https://doi.org/10.1145/1250790.1250888, http://portal.acm.org/citation. cfm?doid=1250790.1250888 3. Aumann, Y., Rabani, Y.: An o (log k) approximate min-cut max-ﬂow theorem and approximation algorithm. SIAM J. Comput. 27(1), 291–301 (1998)  
   
  Cut-Suﬃcient Directed 2-Commodity Multiow Topologies  
   
  421  
   
  4. Chakrabarti, A., Fleischer, L., Weibel, C.: When the cut condition is enough: a complete characterization for multiﬂow problems in series-parallel networks. In: Proceedings of the Forty-Fourth Annual ACM Symposium on Theory of Computing, pp. 19–26. ACM (2012) 5. Chakrabarti, A., Jaﬀe, A., Lee, J.R., Vincent, J.: Embeddings of topological graphs: lossy invariants, linearization, and 2-sums. In: 2008 49th Annual IEEE Symposium on Foundations of Computer Science, pp. 761–770. IEEE, Philadelphia, PA, USA, October 2008. https://doi.org/10.1109/FOCS.2008.79, http://ieeexplore.ieee.org/ document/4691008/ 6. Chekuri, C., Gupta, A., Newman, I., Rabinovich, Y., Sinclair, A.: Embedding k-outerplanar graphs into l1. SIAM J. Discret. Math. 20(1), 119–136 (2006). https://doi.org/10.1137/S0895480102417379, http://epubs.siam.org/doi/10.1137/ S0895480102417379 7. Chekuri, C., Shepherd, F.B., Weibel, C.: Flow-cut gaps for integer and fractional multiﬂows. J. Comb. Theory Ser. B 103(2), 248–273 (2013) 8. Deligkas, A., Meir, R.: Directed graph minors and serial-parallel width. In: 43rd International Symposium on Mathematical Foundations of Computer Science, vol. 21, p. 38 (2018) 9. Fortune, S., Hopcroft, J., Wyllie, J.: The directed subgraph homeomorphism problem. Theor. Comput. Sci. 10(2), 111–121 (1980). https://doi.org/10.1016/03043975(80)90009-2, http://www.sciencedirect.com/science/article/pii/030439758090 0092 10. Gupta, A., Newman, I., Rabinovich, Y., Sinclair, A.: Cuts, trees and 1 -embeddings of graphs. Combinatorica 24(2), 233–269 (2004) √ 11. Hajiaghayi, M.T., R¨ acke, H.: An O( n)-approximation algorithm for directed sparsest cut. Inf. Process. Lett. 97(4), 156–160 (2006). https://doi.org/10.1016/j. ipl.2005.10.005, https://linkinghub.elsevier.com/retrieve/pii/S0020019005002929 12. Hu, T.C.: Multi-commodity network ﬂows. Oper. Res. 11(3), 344–360 (1963). https://doi.org/10.1287/opre.11.3.344, http://pubsonline.informs.org/doi/ 10.1287/opre.11.3.344 13. Johnson, T., Robertson, N., Seymour, P., Thomas, R.: Directed tree-width. J. Comb. Theory Ser. B 82(1), 138–154 (2001). https://doi.org/10.1006/jctb.2000. 2031, https://linkinghub.elsevier.com/retrieve/pii/S0095895600920318 14. Kawarabayashi, K.i., Kreutzer, S.: The directed grid theorem. In: Proceedings of the Forty-Seventh Annual ACM Symposium on Theory of Computing, pp. 655– 664. ACM, Portland Oregon USA, June 2015. https://doi.org/10.1145/2746539. 2746586, https://dl.acm.org/doi/10.1145/2746539.2746586 15. Kawarabayashi, K.I., Sidiropoulos, A.: Embeddings of planar quasimetrics into directed  1 and polylogarithmic approximation for directed sparsest-cut. In: 2021 IEEE 62nd Annual Symposium on Foundations of Computer Science (FOCS), pp. 480–491. IEEE, Denver, CO, USA, February 2022. https://doi.org/10.1109/ FOCS52979.2021.00055, https://ieeexplore.ieee.org/document/9719783/ 16. Kim, I., Seymour, P.: Tournament minors. J. Comb. Theory Ser. B 112, 138–153 (2015). https://doi.org/10.1016/j.jctb.2014.12.005, https://linkinghub. elsevier.com/retrieve/pii/S0095895614001403 17. Kintali, S., Zhang, Q.: Forbidden directed minors and Kelly-width. Theor. Comput. Sci. 662, 40–47 (2017). https://doi.org/10.1016/j.tcs.2016.12.008, https:// linkinghub.elsevier.com/retrieve/pii/S0304397516307149  
   
  422  
   
  J. Poremba and F. B. Shepherd  
   
  18. Kreutzer, S., Tazari, S.: Directed nowhere dense classes of graphs. In: Proceedings of the Twenty-Third Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 1552–1562. Society for Industrial and Applied Mathematics, January 2012. https://doi.org/10.1137/1.9781611973099.123, https://epubs.siam.org/doi/ 10.1137/1.9781611973099.123 19. Lee, J.R., Raghavendra, P.: Coarse diﬀerentiation and multi-ﬂows in planar graphs. Discret. Comput. Geom. 43(2), 346–362 (2010). https://doi.org/10.1007/s00454009-9172-4, http://link.springer.com/10.1007/s00454-009-9172-4 20. Lee, J.R., Sidiropoulos, A.: On the geometry of graphs with a forbidden minor. In: Proceedings of the 41st Annual ACM Symposium on Theory of Computing - STOC ’09, p. 245. ACM Press, Bethesda, MD, USA (2009). https://doi.org/10.1145/ 1536414.1536450, http://portal.acm.org/citation.cfm?doid=1536414.1536450 21. Leighton, T., Rao, S.: Multicommodity max-ﬂow min-cut theorems and their use in designing approximation algorithms. J. ACM 46(6), 787–832 (1999) 22. Linial, N., London, E., Rabinovich, Y.: The geometry of graphs and some of its algorithmic applications. Combinatorica 15(2), 215–245 (1995) 23. Lomonosov, M.V.: Combinatorial approaches to multiﬂow problems. NorthHolland (1985) 24. Nagamochi, H., Ibaraki, T.: On max-ﬂow min-cut and integral ﬂow properties for multicommodity ﬂows in directed graphs. Inf. Process. Lett. 31, 279–285 (1989) 25. Naves, G., Shepherd, B.: When do Gomory-Hu subtrees exist? SIAM J. Discret. Math. 36(3), 1567–1585 (2022) 26. Okamura, H., Seymour, P.D.: Multicommodity ﬂows in planar graphs. J. Comb. Theory Ser. B 31(1), 75–81 (1981). http://www.sciencedirect.com/science/article/ B6WHT-4KBW025-8/2/9b4489ece0a97e9d8340d69948600501 27. Poremba, J.C.: Directed multicommodity ﬂows: cut-suﬃciency and forbidden relevant minors. Master’s thesis, University of British Columbia (2022) 28. Salmasi, A., Sidiropoulos, A., Sridhar, V.: On constant multi-commodity ﬂowcut gaps for families of directed minor-free graphs. In: Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 535–553. SIAM (2019) 29. Schrijver, A.: Combinatorial Optimization: Polyhedra and Eﬃciency, vol. 24. Springer, Heidelberg (2003) 30. Seymour, P.D.: Four-terminus ﬂows. Networks 10(1), 79–86 (1980) 31. Seymour, P.D.: Matroids and multicommodity ﬂows. Eur. J. Comb. 2(3), 257–290 (1981)  
   
  Constant-Competitiveness for Random Assignment Matroid Secretary Without Knowing the Matroid Richard Santiago(B) , Ivan Sergeev, and Rico Zenklusen Department of Mathematics, ETH Zurich, Zurich, Switzerland {rtorres,isergeev,ricoz}@ethz.ch  
   
  Abstract. The Matroid Secretary Conjecture is a notorious open problem in online optimization. It claims the existence of an O(1)-competitive algorithm for the Matroid Secretary Problem (MSP). Here, the elements of a weighted matroid appear one-by-one, revealing their weight at appearance, and the task is to select elements online with the goal to get an independent set of largest possible weight. O(1)-competitive MSP algorithms have so far only been obtained for restricted matroid classes and for MSP variations, including Random-Assignment MSP (RA-MSP), where an adversary ﬁxes a number of weights equal to the ground set size of the matroid, which then get assigned randomly to the elements of the ground set. Unfortunately, these approaches heavily rely on knowing the full matroid upfront. This is an arguably undesirable requirement, and there are good reasons to believe that an approach towards resolving the MSP Conjecture should not rely on it. Thus, both Soto [SIAM Journal on Computing 2013] and Oveis Gharan & Vondrak [Algorithmica 2013] raised as an open question whether RA-MSP admits an O(1)-competitive algorithm even without knowing the matroid upfront. In this work, we answer this question aﬃrmatively. Our result makes RA-MSP the ﬁrst well-known MSP variant with an O(1)-competitive algorithm that does not need to know the underlying matroid upfront and without any restriction on the underlying matroid. Our approach is based on ﬁrst approximately learning the rank-density curve of the matroid, which we then exploit algorithmically.  
   
  1  
   
  Introduction  
   
  The Matroid Secretary Problem (MSP), introduced by Babaioﬀ, Immorlica, and Kleinberg [1], is a natural and well-known generalization of the classical Secretary Problem [6], motivated by strong connections and applications in mechanism design. Formally, MSP is an online selection problem where we are given This project received funding from Swiss National Science Foundation grant 200021 184622 and the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 817750).  
   
  c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 423–437, 2023. https://doi.org/10.1007/978-3-031-32726-1_30  
   
  424  
   
  R. Santiago et al.  
   
  a matroid M = (N, I),1 with elements of unknown weights w : N → R≥0 that appear one-by-one in uniformly random order. Whenever an element appears, one has to immediately and irrevocably decide whether to select it, and the goal is to select a set of elements I ⊆ N that (i) is independent, i.e., I ∈ I, and (ii) has weight w(I) = e∈I w(e) as large as possible. The key challenge in the area is to settle the notorious Matroid Secretary Problem (MSP) Conjecture: Conjecture 1 ( [1]). There is an O(1)-competitive algorithm for MSP. The best-known procedures for MSP are O(log log(rank(M)))-competitive [7,13], where rank(M) is the rank of the matroid M, i.e., the cardinality of a largest independent set. Whereas the MSP Conjecture remains open, extensive work in the ﬁeld has led to constant-competitive algorithms for variants of the problem and restricted settings. This includes constant-competitive algorithms for speciﬁc classes of matroids [2,4,5,8,9,11,12,14,16]. Moreover, in terms of natural variations of the problem, Soto [16] showed that constant-competitiveness is achievable in the so-called Random-Assignment MSP, RA-MSP for short. Here, an adversary chooses |N | weights, which are then assigned uniformly at random to ground set elements N of the matroid. (Soto’s result was later extended by Oveis Gharan and Vondr´ ak [15] to the setting where the arrival order of the elements is adversarial instead of uniformly random.) Constant-competitive algorithms also exist for the Free Order Model, where the algorithm can choose the order in which elements appear [9]. Intriguingly, a key aspect of prior advances on constant-competitive algorithms for special cases and variants of MSP is that they heavily rely on knowing the full matroid M upfront. This is also crucially exploited in Soto’s work on RA-MSP. In fact, if the matroid is not known upfront in full, there is no natural variant of MSP for which a constant-competitive algorithm is known. A high reliance on knowing the matroid M = (N, I) upfront (except for its size |N |) is undesirable when trying to approach the MSP Conjecture, because it is easy to obstruct an MSP instance by adding zero-weight elements. Not surprisingly, all prior advances on the general MSP conjecture, like the abovementioned O(log log(rank(M)))-competitive algorithms [7,13] and also earlier procedures [1,3], only need to know |N | upfront and make calls to an independence oracle on elements revealed so far. Thus, for RA-MSP, it was raised as an open question both in [16] and [15], whether a constant-competitive algorithm exists without knowing the matroid upfront. The key contribution of this work is to aﬃrmatively answer this question, making the random assignment setting the ﬁrst MSP variant for which a constant-competitive algorithm is known without knowing the matroid and without any restriction on the underlying matroid.  
   
  1  
   
  A matroid M is a pair M = (N, I) where N is a ﬁnite set and I ⊆ 2N is a nonempty family satisfying: 1) if A ⊆ B and B ∈ I then A ∈ I, and 2) if A, B ∈ I and |B| > |A| then ∃e ∈ B \ A such that A ∪ {e} ∈ I.  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  425  
   
  Theorem 1. There is a constant-competitive algorithm for RA-MSP with only the cardinality of the matroid known upfront. Moreover, our result holds in the more general adversarial order with a sample setting, where we are allowed to sample a random constant fraction of the elements and all remaining (non-sampled) elements arrive in adversarial order. As mentioned, when the matroid is fully known upfront, an O(1)-competitive algorithm was known for RA-MSP even when the arrival order of all elements is adversarial [15]. Interestingly, for this setting it is known that, without knowing the matroid upfront, no constant-competitive algorithm exists. More precisely, a lower bound on the competitiveness of Ω(|N |/log log|N |) was shown in [15]. Organization of the Paper. We start in Sect. 2 with a brief discussion on the role of (matroid) densities in the context of random assignment models, as our algorithm heavily relies on densities. Decomposing the matroid into parts of diﬀerent densities has been central in prior advances on RA-MSP. However, this crucially relies on knowing the matroid upfront. We work with a rank-density curve, introduced in Sect. 3.1, which is also unknown upfront; however, we show that it can be learned approximately (in a well-deﬁned sense) by observing a random constant fraction of the elements. Section 3 provides an outline of our approach based on rank-density curves and presents the main ingredients which allow us to derive Theorem 1. Sect. 4 showcases the main technical tool that allows us to approximate the rank-density curve from a sample set. Finally, Sect. 5 discusses our main algorithmic contribution and a sketch of its analysis. We emphasize that we predominantly focus on providing a simple algorithm and analysis, refraining from optimizing the competitive ratio of our procedure at the cost of complicating the presentation. Moreover, due to space constraints, some proofs are deferred to the long version of this paper. We assume that all matroids are loopless, i.e., every element is independent by itself. This is without loss of generality, as loops can simply be ignored in matroid secretary problems.  
   
  2  
   
  Random-Assignment MSP and Densities  
   
  A main challenge in the design and analysis of MSP algorithms is how to protect heavier elements (or elements of an oﬄine optimum) from being spanned by lighter ones that are selected earlier during the execution of the algorithm. In the random assignment setting, however, weights are assigned to elements uniformly at random, which allows for shifting the focus from protecting elements based on their weights to protecting elements based on their role in the matroid structure. Intuitively speaking, an element arriving in the future is at a higher risk of being spanned by the algorithm’s prior selection if it belongs to an area of the matroid with larger cardinality and smaller rank (“denser” area) than an area with smaller cardinality and larger rank (“sparser” area).  
   
  426  
   
  R. Santiago et al.  
   
  This is formally captured by the notion of density: the density of a set U ⊆ N in a matroid M = (N, I) is |U |/r(U ), where r : 2N → Z≥0 is the rank function of M.2 Densities play a crucial role in RA-MSP [15,16]. Indeed, prior approaches decomposed M into its principal sequence, which is the chain ∅  S1  . . .  Sk = N of sets of decreasing densities obtained as follows. S1 ⊆ N is the densest set of M (in case of ties it is the unique maximal densest set), S2 is the union of S1 and the densest set in the matroid obtained from M after contracting S1 , and so on until a set Sk is obtained with Sk = N . Figure 1a shows an example of the principal sequence of a graphic matroid.  
   
  Fig. 1. Figure 1a shows a graph representing a graphic matroid together with its principal sequence ∅  S1  · · ·  S7 = N , where N are all edges of the graph. Figure 1b shows its rank-density curve. Each step in the rank-density curve (highlighted by a circle) corresponds to one Si and has y-coordinate equal to the density of Mi = (M/Si−1 )|Si \Si−1 and x-coordinate equal to r(Si ).  
   
  Previous approaches then considered, independently for each i ∈ [k] := {1, . . . , k}, the matroid Mi := (M/Si−1 )|Si \Si−1 , i.e., the matroid obtained from M by contracting Si−1 and then restricting to Si \ Si−1 . (By convention, we set S0 := ∅.) These matroids are also known as the principal minors of M. Given an independent set in each principal minor, their union is guaranteed to be independent in the original matroid M. Prior approaches (see, in particular, [16] for details) then exploited the following two key properties of the principal minors Mi :  
   
  2  
   
  The rank function r : 2N → Z≥0 assigns to any set U ⊆ N the cardinality of a maximum cardinality independent set in U , i.e., r(U ) := max{|I| : I ⊆ U, I ∈ I}.  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  427  
   
  k  
   
  i=1 E[w(OPT(Mi ))] = Ω(E[w(OPT(M))]), where OPT(M) (and analogously OPT(Mi )) is an (oﬄine) maximum weight independent set in M and the expectation is over all random weight assignments. (ii) Each matroid Mi is uniformly dense, which means that the (unique maximal) densest set in Mi is the whole ground set of Mi .  
   
  (i)  
   
  Property (i) guarantees that, to obtain an O(1)-competitive procedure, it suﬃces to compare against the (oﬄine) optima of the matroids Mi . Combining this with property (ii) implies that it suﬃces to design a constant-competitive algorithm for uniformly dense matroids. Since uniformly dense matroids behave in many ways very similarly to uniform matroids, which are a special case of uniformly dense matroids, it turns out that the latter admit a simple yet elegant O(1)-competitive algorithm. (See [16] for details.)  
   
  3  
   
  Outline of Our Approach  
   
  As discussed, prior approaches [15,16] for RA-MSP heavily rely on knowing the matroid upfront, as they need to construct its principal sequence upfront. A natural approach would be to observe a sample set S ⊆ N containing a constant fraction of all elements and then try to mimic the existing approaches using the principal sequence of M|S , the matroid M restricted to the elements in S. A main hurdle lies in how to analyze such a procedure as the principal sequence of M|S can diﬀer signiﬁcantly from the one of M. In particular, one can construct matroids where the density of some parts is likely to be underestimated by a super-constant factor. Moreover, generally M|S may have many diﬀerent densities not present in M (e.g., when M is uniformly dense). We overcome these issues by not dealing with principal sequences directly, but rather using what we call the rank-density curve of a matroid, which captures certain key parameters of the principal sequence. As we show, rank-density curves have three useful properties: (i) They provide a natural way to derive a quantity that both relates to the oﬄine optimum and can be easily compared against to bound the competitiveness of our procedure. (ii) They can be learned approximately by observing an O(1)-fraction of N . (iii) Approximate rank-density curves can be used algorithmically to protect denser areas from sparser ones without having to know the matroid upfront. Section 3.1 introduces rank-density curves and shows how they conveniently allow for deriving a quantity that compares against the oﬄine optimum. Section 3.2 then discusses our results on approximately learning rank-density curves and how this can be exploited algorithmically. 3.1  
   
  Rank-Density Curves  
   
  Given a matroid M = (N, I), one natural way to deﬁne its rank-density curve ρM : R>0 → R≥0 , is through its principal minors M1 , . . . , Mk , which are deﬁned  
   
  428  
   
  R. Santiago et al.  
   
  through the principal sequence ∅  S1  · · ·  Sk = N as explained in Sect. 2. For a value t ∈ (0, rank(M)], let it ∈ [k] be the smallest index such that r(Sit ) > t. The value ρM (t) is then given by the density of Mit . (See Fig. 1b for an example.) In addition, we set ρM (t) = 0 for any t > rank(M). A formally equivalent way to deﬁne ρM , which is more convenient for what we do later, is as follows. For any S ⊆ N and λ ∈ R≥0 , we deﬁne DM (S, λ) ∈ argmax {|U | − λr(U )} U ⊆S  
   
  (1)  
   
  to be the unique maximal maximizer of maxU ⊆S {|U | − λr(U )}. It is well-known that each set in the principal sequence S1 , . . . , Sk is nonempty and of the form DM (N, λ) for λ ∈ R≥0 . This leads to the following way to deﬁne the rank-density curve, which is the one we use in what follows. Definition 1 (rank-density curve). Let M = (N, I) be a matroid. Its rankdensity curve ρM : R>0 → R≥0 is deﬁned by  max {λ ∈ R≥0 : r(DM (N, λ)) ≥ t} ∀t ∈ (0, rank(M)] ρM (t) := 0 ∀t > rank(M). When the matroid M is clear from context, we usually simply write ρ instead of ρM for its rank-density curve and D(N, λ) instead of DM (N, λ). Note that ρ is piecewise constant, left-continuous, and non-increasing. (See Fig. 1b for an example.) If M is a uniformly dense matroid with density λ, we have ρ(t) = λ for t ∈ (0, rank(M)]. We now expand on how ρM is related to the expected oﬄine optimum value E[OPT(M)] of an RA-MSP instance. To this end, we use the function η : [0, |N |] → R≥0 deﬁned by   η(a) := ER∼Unif(N,a) max w(e) , (2) e∈R  
   
  where Unif(N, a ) is a uniformly random set of a many elements out of N ; and we set η(a) = 0 for a ∈ [0, 1) (i.e., when the set R above is empty) by convention. In words, η(a) is the expected maximum weight out of a weights chosen uniformly at random from all the weights {we }e∈N . Based on this notion, we assign the following value F (ρ) to a rank-density curve ρ:  ∞ F (ρ) := η(ρ(t))dt. (3) 0  
   
  Note that as the graph of ρ is a staircase, the above integral is just a ﬁnite sum. One can then show that the values of the oﬄine optimum and F (ρ) diﬀer by at most a constant factor — proof deferred. Lemma 1. Let (M, w) be a random-assignment MSP instance. Let M be any matroid minor of M and let F be as deﬁned above. Then E[w(OPT(M ))] ≤ 3e  e−1 · F (ρM ). Thus, to be constant-competitive, it suﬃces to provide an algorithm returning an independent set of expected weight Ω(F (ρ)).  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  429  
   
  RA-MSP Subinstances. We will often work with minors of the matroid that is originally given in our RA-MSP instance, and apply certain results to such minors instead of the original matroid. To avoid confusion, we ﬁx throughout the paper one RA-MSP instance with matroid Morig = (Norig , Iorig ) and unknown but (adversarially) ﬁxed weights w : Norig → R≥0 , and our goal is to design an O(1)-competitive algorithm for this instance. The weights w of the original instance are the only weights we consider, even when working with RA-MSP subinstances on minors of Morig , as their elements also obtain their weights uniformly at random from w. In particular, the function F as deﬁned in (3) is always deﬁned with respect to the original weights w. Many of our statements hold not just for minors of M but any matroid with weights uniformly drawn from w. For simplicity, we typically also state these results for minors of M. For a matroid M = (N, I) with |N | ≤ |Norig |, we denote by (M, w) the RA-MSP instance on the matroid M obtained by assigning a uniformly random subset of |N | weights among the weights w uniformly at random to the elements in N . Our subinstances will be of this type (with M being a minor of Morig ). Even though there may be more weights than elements, such instances (M, w) can indeed be interpreted as RA-MSP instances, as they correspond to the adversary ﬁrst choosing uniformly at random a subset of |N | weights among the weights in w, which then get assigned uniformly at random to the elements. 3.2  
   
  Proof Plan for Theorem 1 via Rank-Density Curves  
   
  We now expand on how one can learn an approximation ρ˜ of the rank-density curve ρMorig and how this can be exploited algorithmically to return an independent set of expected weight Ω(F (ρMorig )), which by Lemma 1 implies O(1)competitiveness of the procedure. To this end, we start by formalizing the notion of an approximate rank-density curve, which relies on the notion of downshift. Definition 2. Let ρ : R>0 → R≥0 be a non-increasing function and let α, β ∈ R≥1 . The (α, β)-downshift ρ : R>0 → R≥0 of ρ is deﬁned via an auxiliary function φ : R>0 → R≥0 as follows:  ρ(α)  ∀t ∈ (0, 1], 1 if φ(t) ∈ (0, 1), β φ(t) := ρ(α·t) ρ (t) := φ(t) otherwise . ∀t > 1; β Moreover, a function ρ˜ : R>0 → R≥0 is called an (α, β)-approximation of ρ if it is non-increasing and ρ ≤ ρ˜ ≤ ρ, where ρ is the (α, β)-downshift of ρ. The reason we round up values in (0, 1) in the above deﬁnition of downshift, is that while we deﬁne the latter for a more general type of curves, throughout the paper we mainly use it with rank-density curves, and density values are always at least one. One issue when working with an (O(1), O(1))-approximation ρ˜ of ρ is that F (˜ ρ) may be more than a constant factor smaller than F (ρ) and we thus cannot compare against F (˜ ρ) to obtain an O(1)-competitive procedure. However, as the  
   
  430  
   
  R. Santiago et al.  
   
  following lemma shows, also in this case we can obtain a simple lower bound for the value F (˜ ρ) in terms of F (ρ) and the largest weight wmax in w. Lemma 2. Let M be a matroid minor of Morig , let α, β ∈ R≥1 , and let ρ˜ be ρ) + αwmax . an (α, β)-approximation of ρM . Then F (ρM ) ≤ 2αβF (˜ Proof. By the deﬁnition of an (α, β)-approximate curve we have    ∞  ∞  α 1 1 η(˜ ρ(t))dt ≥ η(ρ(t))dt = η(ρ(t))dt F (˜ ρ) = F (ρ) − 2αβ α 2αβ 0 0  1  ≥ F (ρ) − αwmax , 2αβ where the ﬁrst inequality follows since ρ˜ is an (α, β)-approximation of ρM and from properties of η (proof deferred), and the last inequality holds by deﬁnition of η. A key implication of Lemma 2 is that it suﬃces to obtain an algorithm that returns an independent set of expected weight Ω(F (˜ ρ)) for some (O(1), O(1))ρ) = Ω(F (ρMorig ))− approximation ρ˜ of ρMorig . Indeed, Lemma 2 then implies F (˜ O(wmax ). By running this algorithm with some probability (say 0.5) and otherwise Dynkin’s [6] classical secretary algorithm, which picks the heaviest element with constant probability, an overall algorithm is obtained that returns an independent set of expected weight Ω(F (ρMorig )). Hence, Lemma 2 helps to provide bounds on the competitiveness of algorithms that are competitive with the F -value of an approximate rank-density curve. This technique is also used in the following key statement, which shows that an algorithm with strong guarantees can be obtained if we are given an (O(1), O(1))-approximation of the rank-density curve of the matroid on which we work — see Sect. 5. Theorem 2. Let M be a matroid minor of Morig , and let ρM denote the rankdensity curve of M. Assume we are given an (α, β)-approximation ρ˜ of ρM for integers α ≥ 24 and β ≥ 3. Then there is an eﬃcient procedure ALG(˜ ρ, α, β) that, when run on the RA-MSP subinstance given by M, returns an independent  
   
  1 F (ρM ) − α2 wmax . set I of M of expected weight at least 1440eα 2 β2 The last main ingredient of our approach is to show that such an accurate proxy ρ˜ can be computed with constant probability. More precisely, we show that, after observing a sample set S containing every element of Norig independently with probability 1/2, the rank-density curve of (the observed) Morig |S – is close to the rank-density curve of Morig |Norig \S , allowing us to use ρ Morig |S as desired proxy for the RA-MSP subinstance given by Morig |Norig \S , and – is close to the rank-density curve of Morig , which allows for relating the oﬄine optimum of the RA-MSP subinstance given by Morig |Norig \S to the one of Morig . We highlight that the next result is purely structural and hence independent of weights or the MSP setting. See Sect. 4 for details.  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  431  
   
  Theorem 3. Let M = (N, I) be a matroid and S ⊆ N be a random set containing every element of N independently with probability 1/2. Then, with probability at least 1/100, ρ M|S and ρ M|N \S are both (288, 9)-approximations of ρM . Combining the above results, we get the desired O(1)-competitive algorithm. Proof of Theorem 1. For brevity, let M := Morig and N := Norig throughout this proof. Recall that by Lemma 1, it suﬃces to provide an algorithm returning an independent set of expected weight Ω(F (ρM )). Consider the following procedure: First observe (without picking any element) a set S ⊆ N containing every element of N independently with probability 1/2 and let ρ˜ denote the (288, 9)downshift of ρ M|S . Then run the algorithm described in Theorem 2 on M|N \S with ρ˜ as the approximate rank-density curve. Let I denote the output of the above procedure and let A be the event deﬁned in Theorem 3, that is, A = {S ⊆ N : ρ M|S and ρ M|N \S are (288, 9)-approximations of ρM }. Then, observe that for any ﬁxed S ∈ A, we have  

  1 F ρ M|N \S − 2884 wmax E[w(I) | S] ≥ 1440e·288 4 ·94 wmax 1 ≥ 2880e·288 F (ρM ) − 720e·9 5 ·95 3, where the ﬁrst inequality follows from Theorem 2 and that, for every S ∈ A, the curve ρ˜ is a (2882 , 92 )-approximation of ρ M|N \S ,3 while the second inequality follows from Lemma 2 and the fact that for every S ∈ A the curve ρ M|N \S is a (288, 9)-approximation of ρM . Moreover, the ﬁrst inequality uses that conditioning on any ﬁxed S ∈ A does not have any impact on the uniform assignment of the weights w to the elements. This holds because the event A only depends on the sampled elements S but not the weights of its elements. Hence, the RA-MSP subinstance given by M|N \S on which we use the algorithm described in Theorem 2, indeed assigns weights of w uniformly at random to elements, as required. It then follows that the output of the above procedure satisﬁes  
   
  wmax 1 1 E[w(I) | S] Pr[S] ≥ 100 E[w(I)] ≥ 2880e·2885 ·95 F (ρM ) − 720e·93 , S∈A  
   
  where the last inequality uses that Pr[A] ≥ 1/100 by Theorem 3. Since running the classical secretary algorithm on Morig returns an independent set of expected weight at least wmax/e, the desired result now follows by running the procedure described above with probability 1/2, and running the classical secretary algorithm otherwise. 3  
   
  ρ˜ is a (2882 , 92 )-approximation of ρ M|N \S because ρ˜ is the (288, 9)-downshift of ρ M|S , and, both ρ M|N \S and ρ M|S are (288, 9)-approximations of ρM . First, this implies that ρ M|N \S lies above ρ˜. Second, the approximation parameter (2882 , 92 ) can be derived by observing that the (α2 , β2 )-downshift of the (α1 , β1 )-downshift of some rank-density function is an (α1 α2 , β1 β2 )-approximation of that rank-density function — proof deferred.  
   
  432  
   
  4  
   
  R. Santiago et al.  
   
  Learning Rank-Density Curves from a Sample  
   
  One of the main challenges when designing and analyzing algorithms for MSP is understanding what kind of (and how much) information can be learned about the underlying instance after observing a random sample of it. In this section, we discuss the main ingredient to show that, with constant probability, after observing a sample set S one can learn a good approximation of the rank-density curve of both M and M|N \S — see Theorem 3. However, even if one knew the exact (instead of an approximate) rank-density curve of M|N \S , given that the matroid is not known upfront (and hence neither which elements are associated to each of the diﬀerent density areas of the curve), it is a priori not clear how to proceed. A second main contribution of this section is to show that the set of elements in N \ S that are spanned by a subset of S of a given density is well-structured. In particular, this will allow us to build k a (chain) decomposition M of M| i i=1 N \S where all the Mi ’s satisfy some desired properties with constant probability — see Sect. 5.1 for details. The main technical contribution in this section is the following result. Theorem 4. Let M = (N, I) be a matroid containing 3h disjoint bases for some h ∈ Z≥1 . Let S ∼ B(N, 1/2). Then   
   
   | |N | ≤ exp − 144 , (4) Pr |span(D(S, h)) \ S| ≤ |N 12  Pr r(D(S, h)) ≤  
   
  r(N ) 8  
   
    

  ) ≤ exp − r(N . 48  
   
  (5)  
   
  Proof. We prove (4) and defer the proof of (5) to the full version. Let Mh = (N, Ih ) denote the h-fold union of M and let rh denote its rank function. Consider the procedure described in Algorithm 1, which is loosely inspired by [10]. Algorithm 1: Algorithm for lower bounding ES [|span(D(S, h)) \ S|] Set W ← ∅, G ← ∅, and C ← ∅ for every e ∈ N considered in an arbitrary order do if W ∪ {e} ∈ Ih then if e ∈ S then Update W ← W ∪ {e} else if e ∈ S then Update C ← C ∪ {e} else Update G ← G ∪ {e}  
   
  Note that the following three properties hold at all times: W , G, and C are pairwise disjoint; W ⊆ S and C ⊆ S, while G ∩ S = ∅; and W ∈ Ih . In addition, by construction, at the end of the procedure we have: (i) S = C W . Moreover, the random sets G and C have identical distributions, because each element belongs to S with probability 1/2 independently.  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  433  
   
  (ii) G ⊆ span(D(S, h)) \ S. Because G ∩ S = ∅, it is enough to show G ⊆ span(D(S, h)). Given an arbitrary e ∈ G, by construction we have W ∪{e} ∈ / Ih , i.e., rh (W ∪ {e}) = rh (W ). As W ⊆ S, this yields rh (S ∪ {e}) = rh (S), which then implies (proof deferred) e ∈ span(D(S, h)). As G ⊆ span(D(S, h)) \ S, and G and C have the same distribution, we get       | | | ≤ Pr |G| ≤ |N = Pr |C| ≤ |N (6) Pr |span(D(S, h) \ S)| ≤ |N 12 12 12 . Moreover, |C| = |S| − |W | ≥ |S| − hr(N ) ≥ |S| − |N |/3,  
   
  (7)  
   
  where the equality follows from S = C  W , the ﬁrst inequality from W ∈ Ih (which implies |W | = rh (W ) ≤ hr(N )), and the last one from the fact that M contains 3h many disjoint bases (and hence |N | ≥ 3hr(N )). Combining (6) and (7) we obtain       | | ≤ Pr |S| − |N3 | ≤ |N ≤ Pr |S| ≤ 56 E[|S|] , Pr |span(D(S, h) \ S)| ≤ |N 12 12 (8) where the second inequality follows from E[|S|] = |N |/2. Relation (4) now follows by applying a Chernoﬀ bound Pr[X < (1 − δ)E[X]] < exp[ − δ2 E[X]/2] for X = |S| to the right-hand side expression in (8) and using E[|S|] = |N |/2. The proof of Theorem 3 is based on the concentration result (5). In summary, rather than directly showing that ρ M|S approximates ρM well everywhere, we consider a discrete set of points on ρM associated to minors of M of geometrically increasing ranks. We then apply (5) to these minors and employ a union bound to show that we get a good approximation for these grid points. The union bound works out because the ranks are geometrically increasing and appear in the exponent of the right-hand side of (5). (Complete proof is deferred.)  
   
  5  
   
  The Main Algorithm and Its Analysis  
   
  In this section we describe the procedure from Theorem 2 and discuss the two main ingredients of its analysis. The ﬁrst one is to show that if the approximate curve ρ˜ is well-structured (in some well-deﬁned sense), then there is an algorithm retrieving a constant factor of F (˜ ρ) on expectation — see Theorem 5. The second one is then to show that given any initial approximate curve ρ˜, one can ﬁnd wellstructured curves whose F function value is close to F (˜ ρ) — see Theorem 6. The next result, whose proof is sketched in Sect. 5.1, formalizes the ﬁrst step above. Theorem 5. Let M = (N, I) be a matroid minor of Morig , and let r and ρM denote the rank function and rank-density curve of M, respectively. Let ρ ≤ ρM be a rank-density curve with densities {λi }i∈[m] such that the λi are powers of some integer β ≥ 3 and λ1 > · · · > λm ≥ 1. Assume r(D(N, λi+1 )) ≥ ρ, β) 24r(D(N, λi/β )) for i ∈ [m − 1]. Then there is an eﬃcient procedure ALG(˜ that, when run on the RA-MSP subinstance given by M, returns an independent set I of M of expected weight at least (1/180e)F (ρ).  
   
  434  
   
  R. Santiago et al.  
   
  The second main ingredient in the proof of Theorem 2 is the following result. Due to space constraints, we defer its proof to the long version. Theorem 6. Let M = (N, I) be a matroid minor of Morig , and let r and ρM denote the rank function and rank-density curve of M, respectively. Given an (α, β)-approximate curve ρ˜ of ρM with α ∈ R≥24 and β ∈ Z≥3 , there is a procedure ALG(˜ ρ, α, β) returning rank-density curves ρ, ρ1 , ρ2 , ρ3 , ρ4 such that: 2 2 (i) ρ is an (α , β )-approximation of ρM . (ii) i∈[4] F (ρi ) ≥ F (ρ). (iii) For each i ∈ [4], ρi satisﬁes the following properties: Let {μj }j∈[] be the densities of ρi , then all the μj are powers of β ≥ 3, and r(D(N, μj+1 )) ≥ αr(D(N, μj/β )) ≥ 24r(D(N, μj/β )) for j ∈ [ − 1]. Moreover, ρi ≤ ρM .  
   
  We now show how Theorem 5 and Theorem 6 combined imply Theorem 2. Proof of Theorem 2. Given an (α, β)-approximation ρ˜ of ρM , ﬁrst run the procedure from Theorem 6 to get curves ρ, ρ1 , ρ2 , ρ3 , ρ4 . Then choose an index i ∈ [4] uniformly at random and run the procedure from Theorem 5 on ρi to get an independent set with expected weight at least  4    1 1 1 1 F (ρ) ≥ F (ρM ) − α2 wmax , F (ρi ) ≥ 2 2 180e 4 i=1 720e 1440eα β where the last inequality uses Lemma 2 and the fact that ρ is an (α2 , β 2 ) approximation of ρM . Thus, to show Theorem 2, it remains to prove Theorem 5. 5.1  
   
  Proof (Sketch) of Theorem 5  
   
  Throughout this section we use the notation and assumptions from Theorem 5. We prove the theorem in two steps.First, we argue that after observing k a sample set S, we can build a chain i=1 Mi of M|N \S satisfying certain properties with at least constant probability. Then we argue that, given such a chain, there is a procedure returning an independent set I of M with E[w(I)] = Ω(F (ρ)), leading to the desired result. We start by discussing the former claim. Given a sample set S ⊆ N , we build a chain of matroids as follows. For i ∈ [m] let Ni := span(D(S, λi/β )) \ (S ∪ span(D(S, λi−1/β ))), and Mi := (M/span(D(S, λi−1/β )))|Ni ,  
   
  (9)  
   
  where D(S, λ0/β ) = ∅ by convention. In addition, for every i ∈ [m] let N i := D(N, λi ), and deﬁne Λ := {i ∈ [m] : r(N i ) ≥ 24, λi ≥ β}. Note that Λ and the N i ’s do not depend on the  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  435  
   
  sample set S. Moreover, from the assumptions of Theorem 5 it follows that Λ ⊇ [m] \ {1, m}. The next result shows that with constant probability, the sample set S is such that for each i ∈ Λ, the set Ni contains a subset Ui of large rank and density; more precisely, r(Ui ) ≥ Ω(r(N i )) and |Ui |/r(Ui ) ≥ Ω(λi ). Lemma 3. Let S ∼ B(N, 1/2), and let Ni , N i , and Λ be as deﬁned above. Then, , every Ni with i ∈ Λ contains λi disjoint independent with probability at least 1/3 sets I1 , . . . , Iλi such that j∈[λi ] |Ij | ≥ (1/24)λi r(N i ). The second main ingredient in the proof is to show that the above result can be exploited algorithmically. More precisely, we prove the following. Lemma 4. Let M = (N, I) be a matroid minor of Morig containing h disjoint h independent sets I1 , . . . , Ih such that s := (1/h) j=1 |Ij | ≥ 1. Then there is a procedure that, when run on the RA-MSP subinstance given by M, and with only h given upfront, returns an independent set of M with expected weight at least (s/2e)η(h). This is still the case even if the elements of M are revealed in adversarial (rather than uniformly random) order. We can now combine Lemmas 3 and 4 to prove Theorem 5 as follows. Proof of Theorem 5. Let OSP(M, h) denote the online selection procedure described in Lemma 4. Additionally, m for i ∈ [m], let ri denote the coeﬃcient of η(λi ) in F (ρ). Hence, F (ρ) = i=1 ri η(λi ). Consider the following algorithm: choose and execute one of the three branches presented below with probability 12/15, 2/15, and 1/15, respectively. k (i) Observe S ∼ B(N, 1/2), construct the chain i=1 Mi as deﬁned in (9), and run OSP(Mi , λi ) for every i ∈ [m] (independently in parallel), returning all the picked elements. (ii) Run the classical secretary algorithm on M without observing anything and return the picked element (if any). (iii) Run OSP(M, 1) without observing anything and return all picked elements. Suppose we execute branch (i). By Lemma 3, with probability at least 1/3, every Mi with i ∈ Λ satisﬁes the conditions of Lemma 4 with parameters h = λi and s = (1/24)r(N i ). Note that s ≥ 1 holds given that r(N i ) ≥ 24 for all i ∈ Λ. As additionally all matroids in the chain form a direct sum, executing the ﬁrst branch of the algorithm returns an independent set with expected weight at least 1 1 r(N i ) 1 1 · η(λi ) = r(N i )η(λi ) ≥ ri η(λi ), 3 2e 24 144e 144e i∈Λ  
   
  i∈Λ  
   
  i∈Λ  
   
  where the inequality follows from ρ ≤ ρM and N i = D(N, λi ) for every i ∈ [m]. Therefore, if i ∈ Λ, then the corresponding term ri η(λi ) in F (ρ) is accounted for by branch (i). Thus it only remains to consider i ∈ [m] \ Λ ⊆ {1, m}. Assume ﬁrst that 1 ∈ / Λ. In this case, we must have r(N 1 ) < 24. Since the expected weight yielded by running the classical secretary algorithm is at least  
   
  436  
   
  R. Santiago et al.  
   
  and η(|N |) ≥ η(λ1 ), then by running branch (ii) the expected weight of the output set is at least  
   
  η(|N |)/e,  
   
  1 r(N 1 )η(λ1 ) 1 η(|N |) ≥ · r1 η(λ1 ), ≥ e e 23e r(N 1 ) where the last inequality follows from r1 ≤ r(N 1 ) ≤ 23. Finally, assume that m ∈ / Λ. Then λm = 1, in which case running branch (iii) yields E[w(OSP(M, 1))] ≥  
   
  1 1 r(N )η(1) ≥ r(N m )η(λm ), 2e 2e  
   
  where the ﬁrst inequality holds by Lemma 4 with h = 1 and s = r(N ) ≥ 1, as any basis of M is an independent set of rank r(N ), and the second inequality holds because r(N ) ≥ r(N m ) and λm = 1. The desired lower bound on the expected weight of the set returned by the algorithm now follows by combining the above results with the respective probabilities that each branch is executed. To sum up, we discuss that our main result (i.e., Theorem 1) still holds in the more general adversarial order with a sample setting, where we are allowed to sample a set S ⊆ N containing every element of N independently with probability 1/2, and the remaining (non-sampled) elements arrive in adversarial order. In order to see this, ﬁrst note that the only place in the proof of Theorem 5 where we use that the non-sampled elements (i.e., N \ S) arrive in random order, is to argue that when running the classical secretary algorithm in branch (ii) we obtain an expected weight of at least wmax/e. Indeed, branches (i) and (iii) rely on running the procedure from Lemma 4, whose guarantees hold in the case where the elements arrive in adversarial order. However, note that running the classical secretary procedure in the above adversarial order with a sample setting outputs an element with expected weight of at least wmax/4. Indeed, the probability of selecting wmax in the latter setting is at least the probability of the event that wmax is not sampled and the second largest weight is; which occurs with probability 1/4. Thus, Theorem 5 holds (up to possibly a slightly worse constant) in the adversarial order with a sample setting. Next, observe that this implies that Theorem 2 also holds in the above setting (again, up to possibly a slightly worse constant). This follows because its proof relies on combining the procedures from Theorems 5 and 6, and the latter is completely oblivious to the arrival order of the elements. Finally, note that the proof of Theorem 1 uses the procedure from Theorem 5 and the classical secretary algorithm. Because (as discussed above) both of these algorithms have very similar guarantees in the adversarial order with a sample setting to the ones shown in this paper for random order, the claim follows.  
   
  O(1)-Competitive Random Assignment MSP Without Knowing the Matroid  
   
  437  
   
  References 1. Babaioﬀ, M., Immorlica, N., Kleinberg, R.: Matroids, secretary problems, and online mechanisms. In: Symposium on Discrete Algorithms (SODA 2007), pp. 434– 443 (2007) 2. Babaioﬀ, M., et al.: Matroid secretary problems. J. ACM 65(6), 1–26 (2018) 3. Chakraborty, S., Lachish, O.: Improved competitive ratio for the matroid secretary problem. In: Proceedings of the 23rd Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 1702–1712 (2012) 4. Dimitrov, N.B., Plaxton, C.G.: Competitive weighted matching in transversal matroids. Algorithmica 62(1), 333–348 (2012) 5. Dinitz, M., Kortsarz, G.: Matroid secretary for regular and decomposable matroids. In: Proceedings of the 24th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 108–117 (2013) 6. Evgenii Borisovich Dynkin: The optimum choice of the instant for stopping a Markov process. Soviet Math. 4, 627–629 (1963) 7. Feldman, M., Svensson, O., Zenklusen, R.: A simple O(log log(rank))-competitive algorithm for the matroid secretary problem. Math. Oper. Res. 43(2), 638–650 (2018) 8. Im, S., Wang, Y.: Secretary problems: laminar matroid and interval scheduling. In: Proceedings of the 22nd Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 1265–1274 (2011) 9. Jaillet, P., Soto, J.A., Zenklusen, R.: Advances on matroid secretary problems: free order model and laminar case. In: Goemans, M., Correa, J. (eds.) IPCO 2013. LNCS, vol. 7801, pp. 254–265. Springer, Heidelberg (2013). https://doi.org/10. 1007/978-3-642-36694-9 22 10. Karger, D.: Random sampling and greedy sparsiﬁcation for matroid optimization problems. Math. Program. 82 (1998). https://doi.org/10.1007/BF01585865 11. Kesselheim, T., et al.: An optimal online algorithm forweighted bipartite matching and extensions to combinatorial auctions. In: Proceedings of the 21st Annual European Symposium on Algorithms (ESA), pp. 589–600 (2013) 12. Korula, N., P´ al, M.: Algorithms for secretary problems on graphs and hypergraphs. In: Proceedings of the 36th International Colloquium on Automata, Languages and Programming (ICALP), pp. 508–520 (2009) 13. Lachish, O.: O(log log(rank)) competitive ratio for the matroid secretary problem. In: IEEE 55th Annual Symposium on Foundations of Computer Science. IEEE 2014, pp. 326–335 (2014) 14. Ma, T., Tang, B., Wang, Y.: The simulated greedy algorithm for several submodular matroid secretary problems. In: Proceedings of the 30th International Symposium on Theoretical Aspects of Computer Science (STACS), pp. 478–489 (2013) 15. Gharan, S.O., Vondr´ ak, J.: On variants of the matroid secretary problem. Algorithmica 67(4), 472–497 (2013) 16. Soto, J.A.: Matroid secretary problem in the random-assignment model. SIAM J. Comput. 42(1), 178–211 (2013)  
   
  A Fast Combinatorial Algorithm for the Bilevel Knapsack Problem with Interdiction Constraints Noah Weninger(B)  
   
  and Ricardo Fukasawa  
   
  University of Waterloo, Waterloo, ON, Canada {nweninger,rfukasawa}@uwaterloo.ca Abstract. We consider the bilevel knapsack problem with interdiction constraints, a fundamental bilevel integer programming problem which generalizes the 0-1 knapsack problem. In this problem, there are two knapsacks and n items. The objective is to select some items to pack into the first knapsack such that the maximum profit attainable from packing some of the remaining items into the second knapsack is minimized. We present a combinatorial branch-and-bound algorithm which outperforms the current state-of-the-art solution method in computational experiments by 4.5 times on average for all instances reported in the literature. On many of the harder instances, our algorithm is hundreds of times faster, and we solved 53 of the 72 previously unsolved instances. Our result relies fundamentally on a new dynamic programming algorithm which computes very strong lower bounds. This dynamic program solves a relaxation of the problem from bilevel to 2n-level where the items are processed in an online fashion. The relaxation is easier to solve but approximates the original problem surprisingly well in practice. We believe that this same technique may be useful for other interdiction problems. Keywords: Bilevel programming · Interdiction · Knapsack problem · Combinatorial algorithm · Dynamic programming · Branch and bound  
   
  1  
   
  Introduction  
   
  Bilevel integer programming (BIP), a generalization of integer programming (IP) to two-round two-player games, has been increasingly studied due to its wide real-world applicability [5,12,17]. In the BIP model, there are two IPs, called the upper level (or leader ) and lower level (or follower ), which share some variables between them. The objective is to optimize the upper level IP but with the constraint that the shared variables must be optimal for the lower level IP. The term interdiction is used to describe bilevel problems in which the upper level IP has the capability to block access to some resources used by the lower level IP. The upper level is typically interested in blocking resources in a way that produces the worst possible outcome for the lower level IP. For instance, the resources may be nodes or edges in a graph, or items to be packed into a knapsack. These problems often arise in military defense settings (e.g., see [17]). c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 438–452, 2023. https://doi.org/10.1007/978-3-031-32726-1_31  
   
  A Fast Combinatorial Algorithm for BKP  
   
  439  
   
  In this paper we study the bilevel knapsack problem with interdiction constraints (BKP), which was introduced by DeNegre in 2011 [6]. This problem is a natural extension of the 0-1 knapsack problem (KP) to the bilevel setting. Formally, we are given n items. Each item i ∈ {1, . . . , n} has an associated proﬁt pi ∈ Z>0 , upper-level weight wiU ∈ Z>0 and lower-level weight wiL ∈ Z≥0 . The upper-level knapsack has capacity C U ∈ Z≥0 and the lower-level knapsack has capacity C L∈ Z≥0 . We use the standard notation: for a vector x and set S we let x(S) := i∈S xi . The problem BKP can then be stated as follows: min  
   
  max p(Y )  
   
  X∈U Y ∈L(X)  
   
    where U = X ⊆ {1, . . . , n} : wU (X) ≤ C U ,   and L(X) = Y ⊆ {1, . . . , n} \ X : wL (Y ) ≤ C L .  
   
  (objective) (upper level) (lower level)  
   
  We call a solution (X, Y ) feasible if X ∈ U and Y ∈ argmax{p(Yˆ ) : Yˆ ∈ L(X)}. A solution (X, Y ) is optimal if it minimizes p(Y ) over all feasible solutions. Note that determining whether (X, Y ) is feasible is weakly NP-Hard. Given that “the knapsack problem is believed to be one of the ‘easier’ NPhard problems,” [16] one may propose that BKP may also be one of the ‘easier’ Σp2 -hard problems. While this may indeed be the case, unlike KP, which admits a pseudopolynomial time algorithm, BKP remains NP-complete when the input is described in unary and thus has no pseudopolynomial time algorithm unless P = NP [1]. In addition, BKP is a Σp2 -complete problem, which means it cannot even be modelled as an IP with polynomially many variables and constraints, unless the polynomial hierarchy collapses. A recent positive theoretical result for BKP is a polynomial-time approximation scheme [3]. This theoretical hardness seemed to have been conﬁrmed by the struggle of computational approaches to solve small instances. Until recently, proposed algorithms – either generic BIP algorithms [6,8,19] or more speciﬁc algorithms for BKP (or slight generalizations of it) [2,9,13] – were only able to solve instances with at most 55 items. A breakthrough result came in a paper by Della Croce and Scatamacchia [4], that proposed a BKP-speciﬁc algorithm (henceforth referred to as DCS ) which was able to solve instances containing up to 500 items. It is worth noting that all papers prior to DCS only consider instances which were generated in an uncorrelated fashion, meaning that weights and proﬁts were chosen uniformly at random with no correlation between the values. The DCS algorithm is able to solve uncorrelated instances with 500 items in less than a minute, but its performance drops signiﬁcantly even for weakly correlated instances, and most strongly correlated instances remain unsolved after an hour of computing time. These results seem to mimic what is known for KP: uncorrelated KP instances are some of the easiest types of instances to solve [16] and early KP algorithms such as expknap [15] could quickly solve uncorrelated instances but struggled with strongly correlated ones. A common aspect among all methods in the literature is that they rely fundamentally on MIP solvers. In this paper, we present a simple combinatorial branch-and-bound algorithm for solving BKP. Our algorithm improves on the  
   
  440  
   
  N. Weninger and R. Fukasawa  
   
  performance of the DCS algorithm for 94% of instances, even achieving a speedup of orders of magnitude in many cases. Furthermore, our algorithm appears to be largely impervious to correlation: it solves strongly correlated instances with ease, only signiﬁcantly slowing down when the lower-level weights equal the profits (i.e., the subset sum case). In Sect. 2, we describe our algorithm. Our algorithm relies fundamentally on a new strong lower bound computed by dynamic programming which we present in Sect. 3. Section 4 details our computational experiments. We conclude in Sect. 5 with some directions for future research. We note that some proofs were omitted for brevity.  
   
  2  
   
  A Combinatorial Algorithm for BKP  
   
  In this section we describe our exact solution method for BKP. At a high level, the algorithm is essentially just standard depth-ﬁrst branch-and-bound. Our strong lower bound, deﬁned later in Sect. 3, is essential for reducing the search space. To begin formalizing this, we ﬁrst deﬁne the notion of a subproblem. Definition 1. A subproblem (X, i) consists of some i ∈ {1, . . . , n + 1} and set of items X ⊆ {1, . . . i − 1} such that X ∈ U. Note that this deﬁnition depends on the ordering of the items, which throughout the paper we assume to be such that wp1L ≥ wp2L ≥ · · · ≥ wpnL with ties broken by n 1 2 placing items with larger pi ﬁrst. These subproblems will form the nodes of the branch-and-bound tree; (∅, 1) is the root node, and for every X ∈ U, (X, n+1) is a leaf. Every non-leaf subproblem (X, i) has the child (X, i+1), which represents omitting item i from the upper-level solution. Non-leaf subproblems (X, i) with X ∪ {i} ∈ U have an additional child (X ∪ {i}, i + 1) which represents including item i in the upper-level solution. The algorithm simply starts at the root and traverses the subproblems in a depth-ﬁrst manner, preferring the child (X ∪ {i}, i + 1) if it exists because it is more likely to lead to a good solution. Every time the search reaches a leaf (X, n + 1), we solve the knapsack problem max{p(Y ) : Y ∈ L(X)} to get a feasible solution, and updating the incumbent if appropriate. 2.1  
   
  The Bound Test  
   
  At each node (X, i) of the branch-and-bound, we ﬁnd a lower bound on the optimal value of that subproblem by the use of a bound test algorithm, which tests lower bounds against a known incumbent solution value z ∗ . The lower bound used to prune a subproblem is computed in three steps: (1) we solve a knapsack problem on items {1, . . . , i − 1} \ X, (2) we compute a lower bound for BKP restricted to items {i, . . . , n}, and (3) we combine (1) and (2) into a lower bound for the descendants of (X, i). ¯ c), which, for a given X ¯ ⊆ {1, . . . , n} For step (1), we deﬁne a function K(X, and c ≥ 0, returns the optimal value of the knapsack problem with weights wL , ¯ cannot be used: proﬁts p, and capacity c, under the restriction that items in X  
   
  A Fast Combinatorial Algorithm for BKP  
   
  441  
   
    ¯ c) = max p(Y ) : Y ⊆ {1, . . . , n} \ X ¯ and wL (Y ) ≤ c . K(X, For step (2), we need a function ω(i, cU , cL ) which is a lower bound on BKP but with upper-level capacity cU , lower-level capacity cL , and restricted to items {i, . . . , n}. So, formally, ω must satisfy ω(i, cU , cL ) ≤ min{K(X  ∪ {1, . . . , i − 1}, cL ) : X  ⊆ {i, . . . , n}, wU (X  ) ≤ cU }. We will deﬁne precisely what ω is in Sect. 3; for now, we only need to know that it has this property. We now prove the following lemma, which describes how to achieve step (3). Lemma 1. Let (X, i) be a subproblem. For all c ∈ {0, . . . , C L },   K (X ∪ {i, . . . , n}, c) + ω i, C U − wU (X), C L − c   ¯ Y¯ ) is feasible for BKP and X ¯ ∩ {1, . . . , i − 1} = X . ≤ min p(Y¯ ) : (X, Proof. First, note that for any X  ⊆ {i, . . . , n}, K(X ∪ {i, . . . , n}, c) + K(X  ∪ {1, . . . , i − 1}, C L − c) ≤ K(X ∪ X  , C L ). Thus, if we let χ := {X  ⊆ {i, . . . , n} : wU (X  ) ≤ C U − wU (X)} and take the minimum with respect to χ we get K(X ∪{i, . . . , n}, c)+ω(i, C U −wU (X), C L −c) ≤ min{K(X ∪X  , C L ) : X  ∈ χ }. and now just note that this last term is equal to   ¯ Y¯ ) is feasible for BKP and X ¯ ∩ {1, . . . , i − 1} = X . min p(Y¯ ) : (X,  
   
  From this, it follows that for any c ∈ {0, . . . , C L }, if we have   K (X ∪ {i, . . . , n}, c) + ω i, C U − wU (X), C L − c ≥ z ∗ then we can prune subproblem (X, i). We also note that the lower bound still remains valid if we replace K (X ∪ {i, . . . , n}, c) by a feasible solution to that problem. This is what is done in the function BoundTest in Algorithm 1 whose correctness is established by the following lemma. Lemma 2. If BoundTest(X, i) returns true, then subproblem (X, i) can be pruned. We end with an important consideration regarding the eﬃcient implementation of Algorithm 1. The greedy part of the bound test (Lines 2 to 4) appears to require time O(n). However, considering how we choose to branch, the values wg and pg can be computed in time O(1) given their values for the parent subproblem. To determine K(X ∪ {i, . . . , n}, c), we use the standard dynamic program (DP) for knapsack. However, for each bound test, it is only necessary to compute a single row of a DP table (i.e., ﬁll in all C L capacity values for the row associated with item i) from the row computed in the parent subproblem. By doing this, the entire BoundTest function will run in time O(C L ). Furthermore, when the branch-and-bound reaches a leaf, the knapsack solution needed to update the upper bound will already have been found by the bound test.  
   
  442  
   
  N. Weninger and R. Fukasawa  
   
  Algorithm 1: Returns true if the subproblem (X, i) can be pruned. 1 2 3 4 5 6 7  
   
  8  
   
  2.2  
   
  Precondition: z ∗ is the value of the best incumbent solution function BoundTest(X, i) wg , pg ← 0; for j = 1, . . . , i − 1 do if j ∈ / X and wg + wjL ≤ C L then wg ← wg + wjL , pg ← pg + pj ; if pg + ω(i, C U − wU (X), C L − wg ) ≥ z ∗ then return true; for c = 0, . . . , C L do if K(X ∪ {i, . . . , n}, c) + ω(i, C U − wU (X), C L − c) ≥ z ∗ then return true; return false;  
   
  Computing Initial Bounds  
   
  In our algorithm, a strong initial upper bound z ∗ can help decrease the size of the search tree. For this we use a simple heuristic we call GreedyHeuristic. ¯ is picked by GreedyHeuristic works in two steps. First, an upper level set X ¯ solving  max {p(X) : X ∈ U}. Then the lower level solution Y is picked by solving ¯ . We say GreedyHeuristic returns (X, ¯ Y¯ , z¯), where z¯ max p(Y ) : Y ∈ L(X) ¯ ¯ is the objective value of the solution (X, Y ). We now establish a case in which GreedyHeuristic actually returns an optimal solution. Lemma 3. GreedyHeuristic() returns an optimal solution if there exists an optimal solution (X, Y ) for BKP where Y = {1, . . . , n} \ X. The proof is skipped for brevity, but we remark that previous work has noted that BKP is very easily solved for such instances [2,4]. Following [4], we use an LP to detect some cases where the GreedyHeuristic is optimal. The below formulation LB(i) is a simpliﬁed version of the LP in [4]. LB(i) = min such that  
   
  i−1  
   
  j=1  
   
  pj (1 − xj )  
   
  i−1  
   
  wjU xj ≤ C U i−1 C − wiL + 1 ≤ j=1 wjL (1 − xj ) ≤ C L j=1 L  
   
  0 ≤ x ≤ 1, x ∈ Ri−1 We deﬁne LB(i) = ∞ if the LP is infeasible. This LP is used by the following lemma. We skip the proof for brevity. ¯ Y¯ , z¯). If z¯ ≤ min{LB(c) : Lemma 4. Suppose GreedyHeuristic() returns (X, ¯ ¯ 1 ≤ c ≤ n} then (X, Y ) is optimal for BKP. Before starting our branch-and-bound algorithm, we run GreedyHeuristic and check if it is optimal using Lemma 4. This enables us to quickly solve trivial instances without needing to run our main algorithm.  
   
  A Fast Combinatorial Algorithm for BKP  
   
  3  
   
  443  
   
  Lower Bound  
   
  In this section we deﬁne the lower bound ω(i, cU , cL ) that we use in our algorithm. Recall that ω(i, cU , cL ) must lower bound the restriction of BKP where we can only use items {i, . . . , n}, have upper-level capacity cU , and lower-level capacity cL . Our lower bound is based on dynamic programming (DP), which computes ω(i, cU , cL ) for all parameter values with time and space complexity O(nC U C L ). The main idea for the lower bound is to obtain good feasible solutions for the lower-level problem. Perhaps the most obvious way is to assume that the lower-level problem ﬁnds a greedy solution. It is not hard to see why this is a lower bound: a greedy lower-level solution will always achieve proﬁt at most that of an optimal lower-level solution. We can compute this lower bound with the following recursively-deﬁned DP algorithm: ωg (i, cU , cL ) = ⎧ ∞ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪−∞ ⎪ ⎪ ⎪ ⎨0  
   
  if cU < 0, if cL < 0, if cU ≥ 0, cL ≥ 0 and i > n,  
   
  ⎪ if cU ≥ 0, wiL > cL and i ≤ n. ωg (i + 1, cU , cL ) ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ωg (i + 1, cU − wiU , cL ), ⎪ ⎪ if cU ≥ 0, wiL ≤ cL and i ≤ n. ⎪ ⎩min ω (i + 1, cU , cL − wL ) + p g i i The ﬁrst three expressions are to take care of trivial cases. The fourth case skips any item which cannot ﬁt in the lower-level knapsack, as it would be pointless for the upper level to take such an item. The ﬁfth case picks the worse (i.e., better for the upper level) out of the two possible greedy solutions from the two children nodes of subproblem (X, i). This lower bound already has very good performance in practice. However, we can do better by making a deceptively simple modiﬁcation: giving the lower level the option to ignore an item. This modiﬁcation produces our strong DP lower bound, ω, which is equal to ωg in the ﬁrst three cases, but instead of the last two cases we get: ⎧ ⎫ ω(i + 1, cU − wiU , cL ), ⎪ ⎪ ⎨ ⎬ if cU ≥ 0, cL ≥ 0 ω(i, cU , cL ) = min ω(i + 1, cU , cL − wiL ) + pi , ⎪ ⎪ ⎩ max ⎭ and i ≤ n. ω(i + 1, cU , cL ) It is not a hard exercise to show that ωg (i, cU , cL ) ≤ ω(i, cU , cL ) for all 1 ≤ i ≤ n, 0 ≤ cU ≤ C U and 0 ≤ cL ≤ C L . Extrapolating our intuition about ωg , formulation ω appears to actually ﬁnd optimal lower-level solutions, so one might guess that ω(1, C U , C L ) is actually optimal for BKP, if it weren’t that this is impossible unless P = NP [1]. The subtlety is that by giving the lower level a choice of whether to take an item, we have also given the upper level the  
   
  444  
   
  N. Weninger and R. Fukasawa  
   
  power to react to that choice. Speciﬁcally, the upper level choice of whether to take item i can depend on how much capacity the lower level has used on items {1, . . . , i − 1}. Evidently, this is not permitted by the deﬁnition of BKP, which dictates that the upper level solution is completely decided prior to choosing the lower level solution. However, our experiments show that this actually gives the upper level an extremely small amount of additional power in practice. The lower bound ω may also be interpreted as a relaxation from a 2-round game to a 2n-round game. This may seem to be making the problem more diﬃcult, but each round is greatly simpliﬁed, so the problem becomes easier to solve. This 2n-round game is as follows. In round 2i − 1, the leader (the upper level player) decides whether to include the item i. In round 2i, the follower (the lower level player) responds to the leader’s decision: if item i is still available, then the follower decides whether to include item i. The score of the game is simply the total proﬁt of all items chosen by the follower. It is straightforward to see that the minimax value of this game (i.e., the score given that both players follow an optimal strategy) is equal to ω(1, C U , C L ). We now show formally that ω(1, C U , C L ) lower bounds the optimal objective value of BKP. To this end we deﬁne ωX , a modiﬁed version of ω where instead of the minimization in the case where cU ≥ 0, cL ≥ 0 and i ≤ n, the choice is made depending on whether i ∈ X for some given set X. ωX (i, cU , cL ) is equal to ωg in the ﬁrst three cases, but replaces the last two cases with: ωX (i, cU , cL ) = ⎧ if cU ≥ 0, cL ≥ 0, i ≤ n and i ∈ X, ω (i + 1, cU − wiU , cL ) ⎪ ⎨ X ωX (i + 1, cU , cL − wiL ) + pi , ⎪ / X. if cU ≥ 0, cL ≥ 0, i ≤ n and i ∈ ⎩max ωX (i + 1, cU , cL ) With this simple modiﬁcation, we claim that ωX (1, C U , C L ) = max{p(Y ) : Y ∈ L(X)} (and similarly for other i, cU , and cL ). To formalize this, we show that ωX and K (as deﬁned in Sect. 2.1) are equivalent in the following sense. Lemma 5. For all 1 ≤ i ≤ n, X ⊆ {i, . . . , n}, cU ≥ wU (X) and cL ≥ 0, ωX (i, cU , cL ) = K(X ∪ {1, . . . , i − 1}, cL ). Proof. Given that cU ≥ wU (X), the case cU < 0 can not occur in the expansion of ωX (i, cU , cL ), so ωX (i, cU , cL ) = ωX (i, ∞, cL ). Consider the 0-1 knapsack problem with proﬁts p and weights w formed by taking p = p and w = wL except with pj = wj = 0 for items j ∈ X. We can then simplify the deﬁnition of ωX (i, ∞, cL ) by using p and w to eﬀectively skip items in X: ⎧ −∞ if cL < 0, ⎪ ⎪ ⎪ ⎪ ⎨0 if cL ≥ 0 and i > n, ωX (i, ∞, cL ) = L   ⎪ ⎪ ⎪max ωX (i + 1, ∞, c − wi ) + pi , ⎪ if cL ≥ 0 and i ≤ n. ⎩ ωX (i + 1, ∞, cL )  
   
  A Fast Combinatorial Algorithm for BKP  
   
  445  
   
  The recursive deﬁnition of ωX (i, ∞, cL ) above describes the standard DP algorithm for 0-1 knapsack with capacity cL , proﬁts p and weights w but restricted to items {i, . . . , n}; this is the same problem which is solved by  
   
  K(X ∪ {1, . . . , i − 1}, cL ). We now establish that ω(i, cU , cL ) is a lower bound as desired. Theorem 1. For all 1 ≤ i ≤ n, cU ≥ 0 and cL ≥ 0, ω(i, cU , cL ) ≤  
   
  min  
   
  X⊆{i,...,n} : wU (X)≤cU  
   
  K(X ∪ {1, . . . , i − 1}, cL ).  
   
  Proof. By deﬁnition, ωX (i, cU , cL ) = ∞ if wU (X) > cU , so min  
   
  X⊆{i,...,n}  
   
  ωX (i, cU , cL ) = =  
   
  min  
   
  ωX (i, cU , cL )  
   
  min  
   
  K(X ∪ {1, . . . , i − 1}, cL ).  
   
  X⊆{i,...,n} : wU (X)≤cU X⊆{i,...,n} : wU (X)≤cU  
   
  where the last equality follows from Lemma 5. Therefore, it suﬃces to show that ω(i, cU , cL ) ≤ minX⊆{i,...,n} ωX (i, cU , cL ). The proof is by induction on i from n + 1 to 1. Let cU ≥ 0 and cL ≥ 0 be arbitrary. Our inductive hypothesis is that ω(i, cU , cL ) ≤ minX⊆{i,...,n} ωX (i, cU , cL ). For the base case, where i = n + 1, by deﬁnition we have ω(i, cU , cL ) = ωX (i, cU , cL ) = 0 for any X ⊆ {i, . . . , n} = ∅. Now we prove the inductive case. Let 1 ≤ i ≤ n be arbitrary and assume that the inductive hypothesis holds for i + 1, with every cU ≥ 0 and cL ≥ 0. We present only the case where wiU ≤ cU and wiL ≤ cL . The remaining cases (where wiU > cU or wiL > cL ) are just simpler versions of this. ω(i + 1, cU − wiU , cL ), U L ω(i, c , c ) = min   max ω(i + 1, cU , cL − wiL ) + pi , ω(i + 1, cU , cL ) ⎫ ⎧ min ωX (i + 1, cU − wiU , cL ), ⎪ ⎪ ⎪ ⎪ X⊆{i+1,...,n} ⎪ ⎪ ⎪ ⎧ ⎫⎪ ⎬ ⎨ U L L ⎪ min ωX (i + 1, c , c − wi ) + pi ,⎪ ⎨ X⊆{i+1,...,n} ⎬ ≤ min ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ max ⎪ ⎪ U L ⎪ ⎪ ⎩ min ωX (i + 1, c , c ) ⎩ ⎭⎭ ⎧ ⎪ ⎪ ⎨  
   
  X⊆{i+1,...,n}  
   
  ⎫ ωX (i + 1, cU − wiU , cL ), ⎪ ⎪ ⎬ U L L ≤ min ωX (i + 1, c , c − wi ) + pi , ⎪ ⎪ ⎪ ⎪ min max ⎩ ⎭ X⊆{i+1,...,n} ωX (i + 1, cU , cL ) ⎧ ⎫ ω (i + 1, cU − wiU , cL ), ⎪ ⎪ ⎨ X ⎬ U L L = min min ωX (i + 1, c , c − wi ) + pi , ⎪ ⎪ X⊆{i+1,...,n} ⎩ max ⎭ ωX (i + 1, cU , cL ) =  
   
  min  
   
  min  
   
  X⊆{i+1,...,n}  
   
  X⊆{i,...,n}  
   
  ωX (i, cU , cL ).  

  446  
   
  N. Weninger and R. Fukasawa  
   
  Note that in particular, this implies that ω(1, C U , C L ) ≤ minX∈U K(X, C L ) = minX∈U maxY ∈L(X) p(Y ), i.e., ω(1, C U , C L ) is a lower bound for BKP. We end this section with a simple observation. The approach we derived for our problem was based on obtaining good feasible solutions to the lower problem. Now, if the lower problem is already NP-hard, one may ask how useful can an approximate solution to the lower level be. For this, we consider a very generic problem: (1) z ∗ := min max c(x, y) x∈U y∈L(x)  
   
  For each x ∈ U, assume there exists y ∈ L(x) that maximizes the inner problem. Let y ∗ (x) be such a maximizer of c(x, y) for y ∈ L(x). The following lemma then shows that if we can solve the problem with an approximate lower level, instead of an exact one, we get an approximate solution to (1). Lemma 6. Suppose we have a function f (x) such that for all x ∈ U: – f (x) ∈ L(x), and – c(x, f (x)) ≤ c(x, y ∗ (x)) ≤ αc(x, f (x)), for some α ≥ 1. x, y ∗ (˜ x)) ≤ αz ∗ . Let x ˜ ∈ arg min c(x, f (x)). Then c(˜ x∈U  
   
  Proof. Let (x∗ , y ∗ (x∗ )) be the optimal solution to (1). Then 1  
   
  c(˜ x, y ∗ (˜ x)) ≤ c(˜ x, f (˜ x)) ≤ c(x∗ , f (x∗ )) ≤ c(x∗ , y ∗ (x∗ )) = z ∗ . α While this does not immediately give an approximation algorithm for the problem, we believe it may be useful to simplify some Σp2 -hard bilevel interdiction problems and, for that reason, we include this lemma in this work. Note that an analogous result can be also derived for a max − min problem.  
   
  4  
   
  Computational Results  
   
  In this section, we perform computational experiments to compare our algorithm (Comb) with the method from [4] (DCS ). Given that the superiority of the DCS algorithm over other approaches has been well demonstrated we do not compare our algorithm directly to the prior works [2,6,8,9,18,19]. 4.1  
   
  Implementation  
   
  We were unable to obtain either source code or a binary from the authors of [4], so we reimplemented their algorithm. We use Gurobi 9.5 instead of CPLEX 12.9, and obviously run it on a diﬀerent machine, so an exact replication of their results is nearly impossible. Nonetheless, we found our reimplementation produces results very similar to what is reported in [4], and even solves three additional instances which were not solved in [4]. Therefore, we believe that any comparison with our version of the DCS algorithm is reasonably fair.  
   
  A Fast Combinatorial Algorithm for BKP  
   
  447  
   
  Both Comb and DCS were run using 16 threads. However, not all parts of the algorithms were parallelized. Speciﬁcally, in the DCS implementation, the only part which is parallelized is the MIP solver. In the implementation of Comb, we only parallelized two parts: the computation of the lower bound ω and the computation of the initial lower bound min{LB(c) : 1 ≤ c ≤ n}. Our code is implemented in C++ and relies on OpenMP 4.5 for parallelism, Gurobi 9.5 for solving MIPs, and the implementation of the combo knapsack algorithm [14] from [11]. The code was executed on a Linux machine with four 16-core Intel Xeon Gold 6142 CPUs @ 2.60 GHz and 256 GB of RAM. All code and instances are available at https://github.com/nwoeanhinnogaehr/bkpsolver. 4.2  
   
  Instances  
   
  Our test set contains all instances described in the literature [2,4,6,10,19] and 1660 new instances which we generated. The ﬁrst 1500 were generated as follows. For each n ∈ {10, 25, 50, 102 , 103 , 104 }, INS ∈ {0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5} and R ∈ {10, 25, 50, 100, 1000}, we generated ﬁve instances according to ﬁve diﬀerent methods, which we call classes 1-5. All weights and proﬁts were selected uniformly at random in the range [1, R], but for some of the ﬁve classes, we equated wL , wU or p with each other: wL , wU and p are independent (uncorrelated) wL = p but wU is independent (lower subset-sum) wU = p but wL is independent (upper subset-sum) wL = wU = p (both subset-sum) wL = wU but p is independent (equal weights)    The capacities are chosen as follows. Let C L = INS/11 · i wiL and choose C U uniformly at random in the range [C L − 10, C L + 10]. If there is any item with wiL < C L or wiU < C U , then we increase the appropriate capacity so that this is not the case. This is the same way that the capacities are selected in [2,4,10], except that we exclude instances that would almost certainly be solved by the initial bound test and we include half integral values of INS. Note that the easiest and hardest instances reported in the literature were uncorrelated and lower subset-sum, respectively [4]. Hence, we expect these new instances to capture both best-case and worst-case behavior from the solvers. The remaining 160 instances were intended to test the case where the capacity is very large but the number of items is small. These instances were generated following the same scheme as above except that we only generated uncorrelated instances, and we chose n ∈ {5, 10, 20, 30} and R ∈ {103 , 104 , 105 , 106 }. To the best of our knowledge, instances with such large capacity have not been evaluated previously. 1. 2. 3. 4. 5.  
   
  4.3  
   
  Results  
   
  Our results on instances from the literature are summarized in Table 1. To best match the test environment used for the original DCS implementation, we ran  
   
  448  
   
  N. Weninger and R. Fukasawa Table 1. Results for instances from the literature, grouped by instance type.  
   
  Group  
   
  Num DCS Opt Best Avg  
   
  uncorrelated 940 50 weak correlated 50 strong correlated 50 inverse strong corr. 50 almost strong corr. 50 subset-sum 50 even-odd subset-sum even-odd strong corr. 50 similar weight uncorr. 50  
   
  940 66 50 0 41 0 38 0 40 0 35 0 36 0 41 0 50 0  
   
  2.32 13.49 689.58 919.91 815.4 1,087.18 1,033.98 747.12 22.89  
   
  Max  
   
  Comb Opt Best Avg  
   
  15.73 940 874 72.64 50 50 3,600 50 50 3,600 50 50 3,600 50 50 3,600 42 42 3,600 42 42 3,600 50 50 79.85 50 50  
   
  0.31 0.26 0.34 1.07 0.24 586.29 581.42 0.61 0.05  
   
  Max 6.48 3.54 3.98 34.69 3.16 3,600 3,600 17.21 0.08  
   
  the tests with a time limit of 1 h, and used the same parameters for the DCS algorithm as reported by the authors [4]. For each instance group and each solver, we reported the number of instances solved to optimality (column Opt), the number of instances on which the solver took strictly less time than the other solver (column Best), the average wall-clock running time in seconds (column Avg) and the maximum wall-clock running time in seconds (column Max). Note that measuring wall-clock time as opposed to CPU time only disadvantages our algorithm, if anything, because the DCS implementation utilizes all 16 threads for a large proportion of the time due to parallelization within Gurobi, whereas the same is not true for our algorithm. Overall, our solver had better performance on 1258 of the 1340 instances (about 94%), achieving about 4.5 times better performance on average, and solving 53 of the 69 instances which our DCS implementation did not (the original DCS implementation did not solve 72 instances). These results demonstrate the remarkable advantage that Comb has on hard instances. DCS struggles with all instances involving strong or subset-sum correlation, but Comb only signiﬁcantly slows down for subset-sum instances. In Fig. 1, we plot a performance proﬁle for instances from the literature comparing the DCS algorithm to some variants of our algorithm. This type of graph plots, for each instance, the ratio of each algorithm’s performance to the performance of the best algorithm for that instance. The instances are sorted by diﬃculty. Note that instances which timed out are counted as 3600 s seconds. For a comprehensive introduction to performance proﬁles, see [7]. The two variants of Comb included are Comb-weak, which uses the lower bound ωg instead of ω, and Comb-greedy, which uses a greedy lower bound test, i.e., where Lines 6 to 7 are omitted from Algorithm 1. The graph indicates that while Comb does better with more threads and the main variant is best, the single-threaded version and the variants still outperform 16-thread DCS. Although it is not depicted in the performance proﬁle, we also tested variants with diﬀerent item orderings, and found the one described in Sect. 2 to be the best. This is somewhat expected as this is the same ordering that gives rise to the greedy algorithm for 0-1 knapsack.  
   
  A Fast Combinatorial Algorithm for BKP  
   
  449  
   
  100  
   
  Percent of instances  
   
  80  
   
  60 Comb (1 thread) Comb (4 threads) Comb (16 threads)  
   
  40  
   
  Comb-weak (16 threads) 20  
   
  0  
   
  Comb-greedy (16-threads) DCS (16 threads) 21  
   
  23  
   
  25 27 29 211 Number of times worse than best solver  
   
  213  
   
  215  
   
  Fig. 1. Performance profile for all instances from the literature.  
   
  We now turn our attention to the new instances. Due to the large number of new instances and high diﬃculty, we used a reduced time limit of 15 min (900 s) in order to complete the testing in a timely fashion. For these tests we use the same DCS parameters used by the DCS authors for testing their own instances [4]. The results for the new instances are summarized in Tables 2 and 3. Note that there are 300 instances of each group, but Table 2 only instances for which our test machine had enough memory to store the DP table used in Comb. The performance of DCS is reported on the remaining instances in Table 3. We can see that Comb oﬀers a signiﬁcant speed improvement for all classes, and although both solvers are roughly equally capable of solving instances in the uncorrelated, upper subset-sum, equal weights, and large capacity classes, Comb solved 122 more of the instances in the lower subset-sum and both subset-sum classes than DCS. Extrapolating from the results in Table 2, we suspect that given suﬃcient memory, our solver would be able to solve many more of these instances with better performance than DCS. In Tables 5 and 6, we report some statistics collected during the tests of our algorithm. In these tables, RootTime is the average number of (wall clock) seconds required to perform the initial bound test and compute the DP table, OptTime is the average number of seconds that branch-and-bound takes to ﬁnd an optimal solution (excluding RootTime), ProofTime is the average number of seconds needed to prove optimality after an optimal solution is found, Nodes is the average number of nodes searched by branch-and-bound, and RootGap% z where z¯ is the value of the solution returned by is 100 · (¯ z − ω(1, C U , C L ))/¯ GreedyHeuristic. These tables only consider instances which ﬁt in memory and did not time out, as some of the columns are undeﬁned otherwise. Considering all  
   
  450  
   
  N. Weninger and R. Fukasawa Table 2. Summary of results for new instances, grouped by class.  
   
  Group  
   
  DCS Num Opt Best Avg  
   
  Max  
   
  Comb Opt Best Avg  
   
  Max  
   
  uncorrelated lower subset-sum upper subset-sum both subset-sum equal weights large capacity  
   
  243 256 235 235 236 92  
   
  900 900 89.25 900 120.55 900  
   
  243 236 235 189 236 92  
   
  24.02 900 21.08 900 18.38 22.72  
   
  241 173 235 130 236 90  
   
  3 0 5 0 9 1  
   
  12.42 320.36 2.7 423.83 2.2 38.78  
   
  Table 3. Summary of results for DCS on new instances which our solver could not fit in memory, grouped by class. Group  
   
  Num Opt Avg  
   
  uncorrelated  
   
  57  
   
  240 236 230 189 227 91  
   
  0.96 73.62 0.79 184.9 0.7 2.31  
   
  Table 4. An instance with n items, C U = n−1 and C L = n that has optimal objective value n − 1 but ω(1, C U , C L ) = 1.  
   
  Max  
   
  41  
   
  487.85 900  
   
  item no. p  
   
  wU wL  
   
  lower subset-sum 44  
   
  1  
   
  886.75 900  
   
  upper subset-sum 65  
   
  59  
   
  283.34 900  
   
  1 . ..  
   
  1 . ..  
   
  1 . ..  
   
  1 . ..  
   
  n-1  
   
  1  
   
  1  
   
  1  
   
  n  
   
  n-1 n-1 n  
   
  both subset-sum  
   
  65  
   
  0  
   
  equal weights  
   
  64  
   
  62  
   
  175.92 900  
   
  large capacity  
   
  68  
   
  5  
   
  864.33 900  
   
  900  
   
  900  
   
  instances which ﬁt in memory, the average root gap is 3.22%, and the maximum is 57.89%. Evidently, the root gap is typically very small and in fact ω(1, C U , C L ) ≥ 0.5 OPT in all tested instances. However, the worst case approximation factor of ω is actually unbounded. Table 4 describes a family of instances with n items for which OPT = (n−1)ω(1, C U , C L ). Despite this, branch-and-bound is able to solve these instances using only O(n) nodes. On the other hand, it is interesting to note that the subset-sum instances typically have very small root gaps, but solving them to optimality is evidently very hard. Evidently, the main disadvantage of our algorithm is its high memory usage. In our solver, we use a few simple tricks to reduce memory usage slightly: when possible, we store the DP table entries as 16-bit integers, and we avoid computing table entries for capacity values which cannot be seen in any feasible solution. Other optimizations to reduce memory usage are certainly possible as well, such as a DP-with-lists type approach, but we have not implemented this.  
   
  A Fast Combinatorial Algorithm for BKP  
   
  451  
   
  Table 5. Statistics from our solver, for instances from the literature. Group  
   
  RootTime OptTime ProofTime NumNodes  
   
  RootGap%  
   
  uncorrelated  
   
  0.3  
   
  0.03  
   
  0.02  
   
  12,053.23  
   
  5.4  
   
  weak correlated  
   
  0.25  
   
  0.04  
   
  0.03  
   
  7,130.98  
   
  2.04  
   
  strong correlated  
   
  0.26  
   
  0.03  
   
  0.11  
   
  571,473.6  
   
  2.98  
   
  inverse strong corr.  
   
  0.37  
   
  0.04  
   
  0.73  
   
  4,751,888.08  
   
  0.39  
   
  almost strong corr.  
   
  0.24  
   
  0.03  
   
  0.03  
   
  735.76  
   
  2.99  
   
  subset-sum  
   
  0.08  
   
  0.05  
   
  12.22  
   
  even-odd subset-sum  
   
  0.07  
   
  0.04  
   
  6.42  
   
  61,246,957.64  
   
  0.02  
   
  even-odd strong corr.  
   
  0.26  
   
  0.03  
   
  0.37  
   
  2,551,213.42  
   
  2.95  
   
  similar weight uncorr. 0.05  
   
  0.05  
   
  0.05  
   
  0  
   
  0  
   
  104,067,718.79 0.02  
   
  Table 6. Statistics from our solver, for new instances.  
   
  5  
   
  Group  
   
  RootTime OptTime ProofTime Nodes  
   
  RootGap%  
   
  uncorrelated lower subset-sum upper subset-sum both subset-sum equal weights large capacity  
   
  0.86 0.95 0.79 0.16 0.7 2.31  
   
  9.86 1.27 5.75 3.44 1.64 10.15  
   
  0.27 0.8 0 3.02 0.02 0  
   
  0.17 3.43 0 7.68 0.02 0  
   
  73,616.37 11,293,085.12 182.99 117,664,085.82 14.65 29.82  
   
  Conclusion  
   
  We presented a new combinatorial algorithm for solving BKP that is on average 4.5 times better, and achieves up to 3 orders of magnitude improvement in runtime over the performance of the previous state-of-the-art algorithm, DCS. The only disadvantage of our algorithm that we identiﬁed in computational testing is the high memory usage. Because of this, if memory is limited and time is not a concern, it may be a better idea to use DCS. However, if there is any correlation between the lower-level weights and proﬁts, DCS is unlikely to solve the instance in any reasonable amount of time, so it is preferable to use our algorithm on a machine with a large amount of memory, and/or to use additional implementation tricks to reduce the memory usage. For future work, it would be of interest to investigate whether our lower bound can be strengthened further (say, to an O(1)-approximation). We expect that it would be straightforward to generalize this work to the multidimensional variant of BKP (i.e., where there are multiple knapsack constrains at each level), although the issues with high memory usage would likely become worse in this setting. It may also be straightforward to apply this technique to covering interdiction problems. Beyond this, we suspect that a similar lower bound and search algorithm can be used to eﬃciently solve a variety of interdiction problems.  
   
  452  
   
  N. Weninger and R. Fukasawa  
   
  References 1. Caprara, A., Carvalho, M., Lodi, A., Woeginger, G.J.: A study on the computational complexity of the bilevel knapsack problem. SIAM J. Optim. 24(2), 823–838 (2014) 2. Caprara, A., Carvalho, M., Lodi, A., Woeginger, G.J.: Bilevel knapsack with interdiction constraints. INFORMS J. Comput. 28(2), 319–333 (2016) 3. Chen, L., Wu, X., Zhang, G.: Approximation algorithms for interdiction problem with packing constraints. arXiv preprint arXiv:2204.11106 (2022) 4. Della Croce, F., Scatamacchia, R.: An exact approach for the bilevel knapsack problem with interdiction constraints and extensions. Math. Program. 183(1), 249– 281 (2020) 5. Dempe, S.: Bilevel optimization: theory, algorithms, applications and a bibliography. In: Dempe, S., Zemkoho, A. (eds.) Bilevel Optimization. SOIA, vol. 161, pp. 581–672. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-52119-6 20 6. DeNegre, S.: Interdiction and discrete bilevel linear programming, Ph. D. thesis, Lehigh University (2011) 7. Dolan, E.D., Mor´e, J.J.: Benchmarking optimization software with performance profiles. Math. Program. 91(2), 201–213 (2002) 8. Fischetti, M., Ljubi´c, I., Monaci, M., Sinnl, M.: A new general-purpose algorithm for mixed-integer bilevel linear programs. Oper. Res. 65(6), 1615–1637 (2017) 9. Fischetti, M., Ljubic, I., Monaci, M., Sinnl, M.: Interdiction games and monotonicity, with application to knapsack problems. INFORMS J. Comput. 31, 390–410 (2019) 10. Fischetti, M., Monaci, M., Sinnl, M.: A dynamic reformulation heuristic for generalized interdiction problems. Eur. J. Oper. Res. 267, 40–51 (2018) 11. Fontan, F.: Knapsack solver (Github repository). https://github.com/fontanf/ knapsacksolver (2017) 12. Kleinert, T., Labb´e, M., Ljubi´c, I., Schmidt, M.: A survey on mixed-integer programming techniques in bilevel optimization. EURO J. Comput. Optimiz. 9, 100007 (2021) 13. Lozano, L., Bergman, D., Cire, A.A.: Constrained shortest-path reformulations for discrete bilevel and robust optimization. arXiv preprint arXiv:2206.12962 (2022) 14. Martello, S., Pisinger, D., Toth, P.: Dynamic programming and strong bounds for the 0–1 knapsack problem. Manage. Sci. 45(3), 414–424 (1999) 15. Pisinger, D.: An expanding-core algorithm for the exact 0–1 knapsack problem. Eur. J. Oper. Res. 87(1), 175–187 (1995) 16. Pisinger, D.: Where are the hard knapsack problems? Comput. Oper. Res. 32, 2271–2284 (2005) 17. Smith, J.C., Song, Y.: A survey of network interdiction models and algorithms. Eur. J. Oper. Res. 283(3), 797–811 (2020) 18. Tahernejad, S., Ralphs, T.K., DeNegre, S.T.: A branch-and-cut algorithm for mixed integer bilevel linear optimization problems and its implementation. Math. Program. Comput. 12(4), 529–568 (2020) 19. Tang, Y., Richard, J.P.P., Smith, J.C.: A class of algorithms for mixed-integer bilevel min-max optimization. J. Global Optim. 66, 225–262 (2016)  
   
  Multiplicative Auction Algorithm for Approximate Maximum Weight Bipartite Matching Da Wei Zheng1(B) and Monika Henzinger2 1  
   
  University of Illinois Urbana-Champaign, Urbana, IL, USA [email protected]  2 IST Austria, Klosterneuburg, Austria [email protected]   
   
  Abstract. We present an auction algorithm using multiplicative instead of constant weight updates to compute a (1 − ε)-approximate maximum weight matching (MWM) in a bipartite graph with n vertices and m edges in time O(mε−1 log(ε−1 )), matching the running time of the linear-time approximation algorithm of Duan and Pettie [JACM ’14]. Our algorithm is very simple and it can be extended to give a dynamic data structure that maintains a (1 − ε)-approximate maximum weight matching under (1) one-sided vertex deletions (with incident edges) and (2) one-sided vertex insertions (with incident edges sorted by weight) to the other side. The total time time used is O(mε−1 log(ε−1 )), where m is the sum of the number of initially existing and inserted edges.  
   
  1  
   
  Introduction  
   
  Let G = (U ∪ V, E) be an edge-weighted bipartite graph with n = |U ∪ V | vertices and m = |E| edges where each edge uv ∈ E with u ∈ U and v ∈ V has a non-negative weight w(uv). The maximum weight matching (MWM) problem  asks for a matching M ⊆ E that attains the largest possible weight w(M ) = uv∈M w(uv). This paper will focus on approximate solutions to the MWM problem. More speciﬁcally, if we let M ∗ denote a maximum weight matching of G, our goal is to ﬁnd a matching M such that w(M ) ≥ (1 − ε)w(M ∗ ) for any small constant ε > 0. Matchings are a very well studied problem in combinatorial optimization. Kuhn [13] in 1955 published a paper that started algorithmic work in matchings, and presented what he called the “Hungarian algorithm” which he attributed the work to K˝ onig and Egerv´ ary. Munkres [15] showed that this algorithm runs in O(n4 ) time. The running time for computing the exact MWM has been improved many times since then. Recently this year, Chen et al. [6] showed that it was possible to solve the more general problem of max ﬂow in O(m1+o(1) ) time.  
   
  c The Author(s), under exclusive license to Springer Nature Switzerland AG 2023  A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 453–465, 2023. https://doi.org/10.1007/978-3-031-32726-1_32  
   
  454  
   
  D. W. Zheng and M. Henzinger  
   
  For (1 − ε)-approximation algorithms √ for MWM in bipartite graphs, Gabow and Tarjan in 1989 showed an O(m n log(n/ε)) algorithm. Since then there were a number of results for diﬀerent running times and diﬀerent approximation ratios. The current best approximate algorithm is by Duan and Pettie [8] which computes a (1−ε)-approximate maximum weight matching in O(mε−1 log(ε−1 )) time with a scaling algorithm. We defer to their work for a more thorough survey of the history on the MWM problem. We show in our work that the auction algorithm for matchings using multiplicative weights can give a (1 − ε)-approximate maximum weight matching with a running time of O(mε−1 log(ε−1 )) for bipartite graphs. This matches the best known running time of Duan and Pettie [8]. However, in comparison to their rather involved algorithm, our algorithm is simple and only uses elementary data structures. Furthermore, we are able to use properties of the algorithm to support two dynamic operations, namely one where vertices on one side are deleted and vertices on the other side are added with all incident edges given in sorted order of weight. 1.1  
   
  Dynamic Matching Algorithms  
   
  Dynamic Weighted Matching. There has been a large body of work on dynamic matching and many variants of the problem have been studied, e.g., the maximum, maximal, as well as α-approximate setting for a variety of values of α, both in the weighted as well as in the unweighted setting. See [10] for a survey of the current state of the art for the fully dynamic setting. We just mention here a few of the most relevant prior works. For any constant δ > 0 there is a conditional lower bound based on the OMv conjecture that shows that any dynamic algorithm that returns the exact value of a maximum cardinality matching in a bipartite graph with polynomial preprocessing time cannot take time O(m1−δ ) per query and O(m1/2−δ ) per edge update operation [11]. For general weighted graphs Gupta and Peng [9] gave the ﬁrst algorithm in the fully dynamic setting with edge√insertions and deletions to maintain a (1 − ε)-approximate matching in O(ε−1 m log wmax ) time, where the edges fall into the range [1, wmax ]. Vertex Updates. By vertex update we refer to updates that are vertex insertion (resp. deletion) that also inserts (resp. deletes) all edges incident to the vertex. There is no prior work on maintaining matchings in weighted graphs under vertex updates. However, vertex updates in the unweighted bipartite setting has been studied. Bosek et al. [4] gave an algorithm that maintains the (1 − ε)-approximate matching when vertices of one side are deleted in O(ε−1 ) amortized time per changed edge. The algorithm can be adjusted to the setting where vertices of one side are inserted in the same running time, but it cannot handle both vertex insertions and deletions. Le et al. [14] gave an algorithm for maintaining a maximal matching under vertex updates in constant amortized time per changed edge. They also presented an e/(e − 1) ≈ 1.58 approximate algorithm for maximum matchings in an unweighted graph when vertex updates are only allowed on one side of a bipartite graph.  
   
  Algorithm for Approximate Maximum Weight Bipartite Matching  
   
  455  
   
  We give the ﬁrst algorithm to maintain a (1 − ε)-approximate maximum weight matching where vertices can undergo vertex insertions on one side and vertex deletions on the other side in O(ε−1 log(ε−1 )) amortized time per edge inserted. 1.2  
   
  Linear Program for MWM  
   
  The MWM problem can be expressed as the following linear program (LP) where the variable xuv denotes whether the edge uv is in the matching. It is well known [17] that the below LP is integral, that is the optimal solution has all variables xuv ∈ {0, 1}.  max w(uv)xuv uv∈E  
   
  s.t.  
   
    
   
  xuv ≤ 1  
   
  ∀u ∈ U  
   
  xuv ≤ 1  
   
  ∀v ∈ V  
   
  v∈N (u)  
   
    
   
  u∈N (u)  
   
  xuv ≥ 0  
   
  ∀uv ∈ E  
   
  We can also consider the dual problem that aims to ﬁnd dual weights yu and yv for every vertex u ∈ U and v ∈ V respectively.   min yu + yv u∈U  
   
  s.t.  
   
  yu + yv ≥ w(uv) yu ≥ 0 yv ≥ 0  
   
  1.3  
   
  v∈V  
   
  ∀uv ∈ E ∀u ∈ U ∀v ∈ V  
   
  Multiplicative Weight Updates for Packing LPs  
   
  Packing LPs are LPs of the form max{cT x | Ax ≤ b} for c ∈ Rn≥0 , b ∈ Rm ≥0 and A ∈ Rn×m ≥0 . The LP for MWM is a classical example of a packing LP. The multiplicative weight update method (MWU) has been investigated extensively to provide faster algorithms for ﬁnding approximate solutions1 to packing LPs [1,5,12,16,18,19]. Typically the running times for solving these LPs have a dependence on ε of ε−2 , e.g. the algorithm of Koufogiannakis and Young [12] would obtain a running time of O(mε−2 log n) when applied to the matching LP. The fastest multiplicative weight update algorithm for solving packing LPs by Allen-Zhu and Orecchia [1] would obtain an O(mε−1 log n) running time for 1  
   
  By approximate solution we mean a possibly fractional assignments of variables that obtains an approximately good LP objective. If we ﬁnd such an approximate solution to MWM, fractional solutions need to be rounded to obtain an actual matching.  
   
  456  
   
  D. W. Zheng and M. Henzinger  
   
  MWM. Very recently, work by Battacharya, Kiss, and Saranurak [3] extended the MWU for packing LPs to the partially dynamic setting. When restricted to the MWM problem means the weight of edges either only increase or only decrease. However as packing LPs are more general than MWM, these algorithms are signiﬁcantly more complicated and are slower by log n factors (and worse dependence on ε for [3]) when compared to our static and dynamic algorithms. We remark that our algorithm, while it uses multiplicative weight updates, is unlike typical MWU algorithms as it has an additional monotonicity property. We only increase dual variables on one side of the matching, and only (implicitly) decrease dual variables on the other side. 1.4  
   
  Auction Algorithms  
   
  Auction algorithms are a class of primal dual algorithms for solving the MWM problem that view U as a set of goods to be sold, V as a set of buyers. The goal of the auction algorithm is to ﬁnd a welfare-maximizing allocation of goods to buyers. The algorithm is commonly attributed Bertsekas [2], as well as to Demange, Gale, and Sotomayor [7]. An auction algorithm initializes the prices of all the goods u ∈ U with a price yu = 0 (our choice of yu is intentional, as prices correspond directly to dual variables), and has buyers initially unallocated. For each buyer v ∈ V , the utility of that buyer upon being allocated u ∈ U is util(uv) = w(uv) − yu . The auction algorithm proceeds by asking an unallocated buyer v ∈ V for the good they desire that maximizes their utility, i.e. for uv = arg maxu∈N (v) util(uv). If util(uv v) < 0, the buyer remains unallocated. Otherwise the algorithm allocates uv to v, then increases the price yu to yu + ε. The algorithm terminates when all buyers are either allocated or for every unallocated buyer v, it holds that util(uv v) < 0. If the maximum weight among all the edges is wmax , then the auction algorithm terminates after O(nε−1 wmax ) rounds and outputs a matching that diﬀers from the optimal by an additive factor of at most nε. 1.5  
   
  Our Contribution  
   
  We present the following modiﬁcation of the auction algorithm: When v is allocated u, increase yu to yu + ε · util(uv) instead of yu + ε. Note that this decreases util(v) by a factor of (1 − ε) and, thus, we will call algorithms with this modiﬁcation multiplicative auction algorithms. Surprisingly, we were not able to ﬁnd any literature on this simple modiﬁcation. Changing the constant additive weight update to a multiplicative weight update has the eﬀect of taking much larger steps when the weights are large, and so we are able to show that the algorithm can have no dependence on the size of the weights. In fact, we are able to improve the running time to O(mε−1 log(ε−1 )), the same as the fastest known matching algorithm of Duan and Pettie [8]. While the algorithm of [8] has the advantage that it works for general graphs and ours  
   
  Algorithm for Approximate Maximum Weight Bipartite Matching  
   
  457  
   
  is limited to bipartite graphs, our algorithm is simpler as it avoids the scaling algorithm framework and is easier to implement. Theorem 1. Let G = (U ∪ V, E) be a weighted biparitite graph. There is a multiplicative auction algorithm running in time O(mε−1 log(ε−1 )) that finds a (1 − ε)-approximate maximum weight matching of G. Furthermore, it is straightforward to extend our algorithm to a setting where edges are deleted and vertices on one side are added with all incident edges given in sorted order of weight. When the inserted edges are not sorted by weight, the running time per inserted edge increases by an additive term of O(log n) to sort all incident inserted edges. Theorem 2. Let G = (U ∪ V, E) be a weighted biparitite graph. There exists a dynamic data structure that maintains a (1 − ε)-approximate maximum weight matching of G and supports the following operations: (1) Deleting a vertex in U (2) Adding a new vertex into V along with all its incident edges sorted by weight in total time O(mε−1 log(ε−1 )), where m is sum of the number of initially existing, and inserted edges.  
   
  2  
   
  The Static Algorithm  
   
  We assume that the algorithm is given as input some ﬁxed 0 < ε < 1. Notation For sake of notation let N (u) = {v ∈ V | uv ∈ E} be the set of neighbors of u ∈ U in G, and similarly for N (v) for v ∈ V . Preprocessing of the Weights. Let wmax > 0 be the maximum weight edge of E. For our static auction algorithm we may ignore any edge uv ∈ E of weight less than ε · wmax /n as w(M ∗ ) ≥ wmax as taking n of these small weight edges would not even contribute ε · w(M ∗ ) to the matching. Thus, we only consider edges of weight at least ε · wmax /n, which allows us to rescale all edge weights by dividing them by ε · wmax /n. As a result we can assume (by slight abuse of notation) in the following that the minimum edge weight is 1 and the largest edge weight wmax equals n/ε . Furthermore, since we only care about approximations, we will also round down all edge weights to the nearest power of (1 + ε) for some ε < ε /2 and, again by slight abuse of notation, we will use w to denote these edge weights. Formally to round, we deﬁne iLog(x) = log1+ε (x) and Round(x) = (1 + ε)iLog(x) . Let kmax = iLog(wmax ) = iLog(n/ε) = O(ε−1 log(n/ε)). Let kmin be the smallest integer such that (1 + ε)−kmin ≤ ε. Observe that as log(1 + ε) ≤ ε for 0 ≤ ε ≤ 1 it holds that kmin ≥  
   
  log(ε−1 ) ≥ ε−1 log(ε−1 ). log(1 + ε)  
   
  Thus we see that kmin = Θ(ε−1 log(ε−1 )).  
   
  458  
   
  D. W. Zheng and M. Henzinger  
   
  Algorithm. The algorithm ﬁrst builds for every v ∈ V a list Qv of pairs (i, uv) for each edge uv and each value i with −kmin ≤ i ≤ juv = iLog(wuv ) and then sorts Qv by decreasing value of i. After, it calls the function MatchR(v) on every v ∈ V . The function MatchR(v) matches v to the item that maximizes its utility and updates price according to our multiplicative update rule. While matching v, another vertex v  originally matched to v may become unmatched. If this happens, MatchR(v  ) is called immediately after MatchR(v). Algorithm 2.1: MultiplicativeAuction(G = (U ∪ V, E)) M ← ∅. yu ← 0 for all u ∈ U . jv ← kmax for all v ∈ V Qv ← ∅ for all v ∈ V . For v ∈ V :  
   
  # This is only used in the analysis  
   
  1. For u ∈ N (v): (a) juv ← iLog(w(uv)) (b) jv ← max{jv , juv } (c) For i from juv to −kmin : i. Insert the pair (i, uv) into Qv . 2. Sort all (i, uv) ∈ Qv so elements are in non-increasing order of i. For v ∈ V : 1. MatchR(v). Return M . MatchR(v) While Qv is not empty: 1. 2. 3. 4.  
   
  (j, uv) ← the ﬁrst element of Qv , and remove it from Qv . jv ← j # This is only used in the analysis util(uv) ← w(uv) − yu If util(uv) ≥ (1 + ε)j : # util(uv) ← (1 − ε) · util(uv) (a) yu ← yu + ε · (util(uv)) (b) If u was matched to v  in M : – Remove (u, v  ) from M – Add (u, v) to M – MatchR(v  ) (c) Else: – Add (u, v) to M – Return  
   
  Algorithm for Approximate Maximum Weight Bipartite Matching  
   
  459  
   
  Data Structure. We store for each vertex v ∈ V the list Qv as well as its currently matched edge if it exists. In the pseudocode below we keep for each vertex v a value jv corresponding to the highest weight threshold (1 + ε)jv that we will consider. This value is only needed in the analysis. Running Time. The creation and sorting of the lists Qv takes time O(|N (v)|(kmax + kmin )) if we use bucket sort as there are only kmax + kmin distinct weights. The running time of all calls to MatchR(v) is dominated by the size of Qv , as each iteration in MatchR(v)  removes an element of Qv and takes O(1) time. Thus, the total time is O v∈V |N (v)|(kmax + kmin ) = O(m(kmax + kmin )) = O(mε−1 log(n/ε)). Invariants Maintained by the Algorithm. Consider the following invariants maintained throughout by the algorithm: Invariant 1. For all v ∈ V , and all u ∈ N (v), util(uv) < (1 + ε)jv +1 . Proof. This clearly is true at the beginning, since jv is initialized to maxu∈N (v) juv , and util(uv) = w(uv) < (1 + ε)juv +1 . As the algorithm proceeds, util(uv) which equals w(uv) − yu only decreases as yu only increases. Thus, we only have to make sure that the condition holds whenever jv decreases. The value jv only decreases from some value, say j + 1, to a new value j, in MatchR(v) and when this happens Qv does not contain any pairs (j  , uv) with j  > j anymore. Thus, there does not exist a neighbor u of v with util(uv) ≥ (1 + ε)j+1 . It follows that when jv decreases to j for all u ∈ N (v) it holds that util(uv) < (1 + ε)jv +1 . Invariant 2. If uv ∈ M , then for all other u ∈ N (v), util(uv) ≥ (1 − 2ε) · util(u v). Proof. When v was matched to u, right before we updated yu , we had that (1 + ε)jv ≤ util(uv) and, by Invariant 1, util(u v) ≤ (1 + ε)jv +1 . Thus, (1 + ε)util(uv) ≥ util(u v). The update of yu decreases yu by ε · util(uv), which decreases util(uv) by a factor of (1 − ε), but does not aﬀect util(u v). Thus we have now that: util(uv) ≥ (1 − ε)(1 + ε)−1 · util(u v) ≥ (1 − 2ε) · util(u v). Invariant 3. If u ∈ U is not matched, then yu = 0. If uv ∈ M , then yu > 0. Proof. If u is never matched, we never increment yu , so it stays 0. The algorithm increments yu by ε · util(uv) > 0 when we add uv into the matching M . Invariant 4. For all v ∈ V for which MatchR(v) was called at least once, either v is matched, or Qv is empty. Proof. MatchR(v) terminates (i) after it matches v and recurses or (ii) if Qv is empty. It is possible that for some other v  ∈ V with v  = v, that v becomes temporarily unmatched during MatchR(v  ), but we would immediately call MatchR(v) to rematch v.  
   
  460  
   
  D. W. Zheng and M. Henzinger  
   
  Approximation Factor. We will show the approximation factor of the matching M found by the algorithm by primal dual analysis. We remark that it is possible to show this result purely combinatorially as well which we include in Appendix A, as it may be of independent interest. We will show that this M and a vector y satisfy the complementary slackness condition up to a 1 ± ε factor, which implies the approximation guarantee. This was proved by Duan and Pettie [8] (the original lemma was for general matchings, we have specialized it here to bipartite matchings). Lemma 1 (Lemma 2.3 of [8]). Let M be a matching and let y be an assignment of the dual variables. Suppose y is a valid solution to the LP in the following approximate sense: For all uv ∈ E, yu + yv ≥ (1 − ε0 ) · w(uv) and for all e ∈ M , yu + yv ≤  (1 + ε1 ) · w(uv). If the y-values of all unmatched vertices are zero, then M is a (1 + ε1 )−1 (1 − ε0 ) -approximate maximum weight matching. This lemma is enough for us to prove the approximation factor of our algorithm. Lemma 2. MultiplicativeAuction(G = (U ∪ V, E)) outputs a (1 − ε )approximate maximum weight matching of the bipartite graph G. Proof. Let ε > 0 be a parameter depending on ε that we will choose later. We begin by choosing an assignment of the dual variables yu for u ∈ U and yv for v ∈ V . Let all yu ’s be those obtained by the algorithm for u ∈ U . For v ∈ V , let yv = 0 if v is not matched in M and yv = util(uv) = w(uv) − yu if v is matched to u in M . By Invariant 3 all unmatched vertices u ∈ U have yu = 0. Observe that for uv ∈ M we have yu + yv = util(uv). It remains to show that for uv ∈ M we have that yu + yv ≥ (1 − ε0 )w(uv) for some ε0 > 0. First we consider if v is unmatched, so yv = 0. Since v is unmatched, by Invariant 4 then for all u ∈ N (v), we must have util(uv) < (1 + ε)−kmin ≤ ε. Since we rescaled weights so that w(uv) ≥ 1, we know that util(uv) < ε ≤ ε · w(uv). Furthermore, observe that as yu = w(uv) − util(uv) by deﬁnition of utility, it follows that: yu + yv = yu = w(uv) − util(uv) > (1 − ε)w(uv).  
   
  (1)  
   
  Now we need to consider if v was matched to some vertex u = u. To do so we use Invariant 2: yu + yv = yu + util(u v)  
   
  By deﬁnition of y  
   
  ≥ yu + (1 − 2ε) · util(uv) = yu + (1 − 2ε) · (w(uv) − yu )  
   
  By Invariant 2 By deﬁnition of util  
   
  ≥ (1 − 2ε)w(uv) + 2ε · yu ≥ (1 − 2ε)w(uv)  
   
  Since yu ≥ 0  
   
  Thus we have satisﬁed Lemma 1 with ε0 = 2ε and ε1 = 0. Setting ε = ε /2 gives us a (1 − ε )-approximate maximum weight matching.  
   
  Algorithm for Approximate Maximum Weight Bipartite Matching  
   
  461  
   
  Thus we have shown the following result that is weaker than what we have set out to prove by a factor of log(nε−1 ) that we will show how to get rid of in the next section. Theorem 3. Let G = (U ∪ V, E) be a weighted biparitite graph. There exists a multiplicative auction algorithm running in time O(mε−1 log(nε−1 )) that finds a (1 − ε)-approximate maximum weight matching of G. 2.1  
   
  Improving the Running Time  
   
  To improve the running time to O(mε−1 log(ε−1 )), we observe that all we actually need for Lemma 2 in Equation (1) is that util(uv) ≤ ε · w(uv). Recall that juv = iLog(w(uv)). Thus it suﬃces if we change line (b) in MultiplicativeAuction to range from juv to juv − kmin , since: (1 + ε)juv −kmin = (1 + ε)−kmin · (1 + ε)juv ≤ ε · w(uv). This change implies that we insert O(kmin |N (v)|) items into Qv for every v ∈ V . However, sorting Qv for every vertex individually, even with bucket sort, would be too slow. We will instead perform one bucket sort on all the edges, then go through the weight classes in decreasing order to insert the pairs into the corresponding Qv . We explicitly give the pseudocode below as MultiplicativeAuction+. Algorithm 2.2: MultiplicativeAuction+(G = (U ∪ V, E)) M ← ∅. yu ← 0 for all u ∈ U . Qv ← ∅ for all v ∈ V . Li ← ∅ for all i from −kmin to kmax . For uv ∈ E: 1. juv ← iLog(w(uv)) 2. For i from juv to juv − kmin : (a) Insert the pair (i, uv) into Li . For i from kmax to −kmin : 1. For all (i, uv) ∈ Li : (a) Insert the pair (i, uv) to the back of Qv . For v ∈ V : 1. MatchR(v). Return M .  
   
  462  
   
  D. W. Zheng and M. Henzinger  
   
  New Runtime. Bucket sorting all mkmin pairs and initializing the sorted Qv for all v ∈ V takes total time O(mkmin + (kmax + kmin )) = O(mε−1 log(ε−1 )). The total amount of work done in MatchR(v) for a vertex v ∈ V is O(|N (v)|kmin ) which also sums to O(mε−1 log(ε−1 )). Thus we get our desired running time and have proven our main theorem that we restate here. Theorem 1. Let G = (U ∪ V, E) be a weighted biparitite graph. There is a multiplicative auction algorithm running in time O(mε−1 log(ε−1 )) that finds a (1−ε)approximate maximum weight matching of G.  
   
  3  
   
  Dynamic Algorithm  
   
  There are many monotonic properties of our static algorithm. For instance, for all u ∈ U , the yu values strictly increase. As another example, for all v ∈ V , the value of jv strictly decreases. These monotonic properties allow us to extend MultiplicativeAuction+ to a dynamic setting with the following operations. Theorem 2. Let G = (U ∪ V, E) be a weighted biparitite graph. There exists a dynamic data structure that maintains a (1 − ε)-approximate maximum weight matching of G and supports the following operations: (1) Deleting a vertex in U (2) Adding a new vertex into V along with all its incident edges sorted by weight in total time O(mε−1 log(ε−1 )), where m is sum of the number of initially existing, and inserted edges. Type (1) operations: Deleting a vertex in U. To delete a vertex u ∈ U , we can mark u as deleted and skip all edges uv in Qv for any v ∈ V in all further computation. If u were matched to some vertex v ∈ V , that is if there exists an edge uv ∈ M , we need to unmatch v and remove uv from M . All our invariants hold except Invariant 4 for the unmatched v. To restore this invariant we simply call MatchR(v). Type (2) Operations: Adding a New Vertex to V Along with All Incident Edges. To add a new vertex v to V with  incident edges to u1 v, ..., u v with w(u1 v) > · · · > w(u v), we can create the queue Qv by inserting the O(ε−1 log(ε−1 )) pairs such that it is non-increasing in the ﬁrst element of the pair. Afterwards we call MatchR(v). All invariants hold after doing so. If the edges are not given in sorted order, we can sort the  edges in O( log ) time, or in O( + ε−1 log(w(u1 v)/w(u v))) time by bucket sort. Acknowledgements. The ﬁrst author thanks to Chandra Chekuri for useful discussions about this paper. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (Grant agreement No. 101019564 “The Design of Modern Fully Dynamic Data Structures (MoDynStruct)” and from the Austrian Science Fund (FWF) project “Fast Algorithms for a Reactive Network Layer (ReactNet)”, P 33775-N, with additional funding from the netidee SCIENCE Stiftung, 2020–2024.  
   
  Algorithm for Approximate Maximum Weight Bipartite Matching  
   
  A  
   
  463  
   
  Combinatorial proof of Lemma 2  
   
  We start with a simple lemma. Lemma 3. Let G = (U ∪ V, E) be a weighted bipartite graph. Let M be the matching found by MultiplicativeAuction+(G) for ε > 0, and M  be any other matching. Then for any alternating path, i.e. a set of edges of the form u1 v1 , u2 v1 , u2 v2 , ..., uk vk , uk+1 vk with all edges of ui vi ∈ M  and ui+1 vi ∈ M , we have that: (1 − 2ε) ·  
   
  k   
   
  w(ui vi ) ≤  
   
  i=1  
   
  k   
   
  w(ui+1 vi ) + (1 − 2ε) · yu1 − yuk+1  
   
  i=1  
   
  Proof. By Invariant 2, for all i from 1 to k, since M matched vi+1 to ui we have that: (1 − 2ε)util(ui vi ) ≤ util(ui vi+1 ) Adding all such equations together we get (1 − 2ε) ·  
   
  k   
   
  util(ui vi ) ≤  
   
  i=1 k   
   
  (1 − 2ε) ·  (1 − 2ε) ·  
   
  (w(ui vi ) − yui ) ≤  
   
  w(ui vi ) −  
   
  i=1  
   
  k   
   
  yui  
   
  k   
   
  ≤  
   
  w(ui+1 vi ) − yui+1  
   
  k  i=1  
   
  w(ui vi ) ≤  
   
  i=1  
   
  k    
   
    
   
  i=1  
   
    
   
  i=1  
   
  (1 − 2ε) ·  
   
  util(ui vi+1 )  
   
  i=1  
   
  i=1 k   
   
  k   
   
  k   
   
  w(ui+1 vi ) −  
   
  k   
   
  yui+1  
   
  i=1  
   
  w(ui+1 vi ) + (1 − 2ε) · yu1 − yuk+1  
   
  i=1  
   
  Theorem 3. Let G = (U ∪ V, E) be a weighted bipartite graph and ε > 0 be an input parameter. Let M be the matching found by MultiplicativeAuction+(G) with ε = ε /2. M is a (1 − ε )-approximate maximum weight matching of the bipartite graph G. Proof. Let M ∗ be a maximum weight matching of G. Consider the symmetric diﬀerence of M with M ∗ . It consists of paths and and even cycles. It suﬃces to show that the weight obtained by M on the path or even cycle is at least (1 − ε) the weight of M ∗ . We consider the following cases: 1. Consider any even cycle u1 v1 , u2 v1 , u2 v2 , ..., uk vk , u1 vk with ui vi ∈ M ∗ for all i = 1, ..., k and the other edges in M . Applying Lemma 3 with uk+1 = u1 , and by Invariant 3 yu1 > 0 as u1 is matched gives: (1 − 2ε) ·  
   
  k  i=1  
   
  w(ui vi ) ≤  
   
  k  i=1  
   
  w(ui+1 vi ) + (1 − 2ε)yu1 − yu1  
  0. Applying Lemma 3 gives: (1 − 2ε) ·  
   
  k   
   
  w(ui vi ) ≤  
   
  i=1  
   
  k   
   
  w(ui+1 vi ) + (1 − 2ε) · 0 − yuk+1  
  (1 − 2ε)w(uk+1 vk+1 ). Adding this equation to Lemma 3, and by Invariant 3 we have yu1 = 0, so: (1 − 2ε) ·  
   
  k+1   
   
  w(ui vi )  
  2. Theorem 3. Let G = (V, A) be a Pst -covered, acyclic digraph with source vertex s and sink vertex t and let d ∈ N be a constant. A basis of the subspace Ld of the linearizable instances of the SPPd can be computed in polynomial time. Proof (Sketch). The proof idea is to specify a k ∈ N and a matrix M of polyno(d) mially bounded dimensions, such that for f : RA → Rk with f (x) = M x, we have: f (x) = 0 iﬀ x is a linearizable instance of the SPPd . Thus, the linearizable instances x of the SPPd form ker(M ) which can be eﬃciently computed.  
   
  478  
   
  E. C ¸ ela et al.  
   
  The construction of M is done iteratively and exploits the relationship between SP Pd and AP ECPd−1 similarly as in the algorithm A from Sect. 4.2. In particular we use the following two facts: (i) For each strongly basic arc a = (u, v), the function which maps x ∈ RA (a) (d−1) qd−1 : Au → R is linear (see Eq. (6) and recall Deﬁnition 5 for Au ). (ii) The function c → reduced(c) (deﬁned after Lemma 1) is linear.  
   
  (d)  
   
  to  
   
  Using (i) and (ii) iteratively as in algorithm A, we show by induction that for each strongly basic arc a = (u, v) and each d ≥ 2 there exist ka ∈ N and a linear (d−1) → Rka s.t. ga (x) = 0 iﬀ if x corresponds to a YES-instance function ga : RAu of APECPd−1 . Then we construct the linear function ga on the same domain as ga , by setting ga (x) = β whenever ga (x) = 0, where β is the common path cost of the corresponding instance xproject/63605ec6eb4e243dcb2eeb7d of APECPd−1 . Next we show that for each vertex u there exists a ku ∈ N and a linear function (d−1) → Rku such that fu (x) = 0 iﬀ x is a linearizable instance of SPPd−1 fu : RAu corresponding to APECPd−1 (see Lemma 4). Then we construct the linear function fu on the same domain as fu by setting fu (x) equal to the linearizing cost function of the instance x of the SPPd−1 whenever x is linearizable (i.e. when fu (x) = 0). The construction of M is done by repeating these steps iteratively until d = 1. One can ensure that the size of the matrix representations of all involved functions stays polynomial.  
   
  Acknowledgement. This research has been supported by the Austrian Science Fund (FWF): W1230.  
   
  References 1. Bookhold, I.: A contribution to quadratic assignment problems. Optimization 21(6), 933–943 (1990) 2. C ¸ ela, E., Klinz, B., Lendl, S., Orlin, J.B., Woeginger, G.J., Wulf, L.: Linearizable special cases of the quadratic shortest path problem. In: Kowalik, L  ., Pilipczuk, M., Rz¸az˙ ewski, P. (eds.) WG 2021. LNCS, vol. 12911, pp. 245–256. Springer, Cham (2021). https://doi.org/10.1007/978-3-030-86838-3 19 3. Cela, E., Deineko, V.G., Woeginger, G.J.: Linearizable special cases of the QAP. J. Comb. Optim. 31(3), 1269–1279 (2016) ´ 4. Custi´ c, A., Punnen, A.P.: A characterization of linearizable instances of the quadratic minimum spanning tree problem. J. Comb. Optim. 35(2), 436–453 (2018) 5. De Meijer, F., Sotirov, R.: The quadratic cycle cover problem: special cases and eﬃcient bounds. J. Comb. Optim. 39(4), 1096–1128 (2020) 6. Erdo˘ gan, G.: Quadratic assignment problem: linearizations and polynomial time solvable cases, Ph. D. thesis, Bilkent University (2006) 7. Erdo˘ gan, G., Tansel, B.: A branch-and-cut algorithm for quadratic assignment problems based on linearizations. Comput. Oper. Res. 34(4), 1085–1106 (2007) 8. Erdo˘ gan, G., Tansel, B.C.: Two classes of quadratic assignment problems that are solvable as linear assignment problems. Discret. Optim. 8(3), 446–451 (2011) 9. Gamvros, I.: Satellite network design, optimization and management. University of Maryland, College Park (2006)  
   
  A linear time algorithm for the linearization of the QSPP and SPPd  
   
  479  
   
  10. Hu, H., Sotirov, R.: Special cases of the quadratic shortest path problem. J. Comb. Optim. 35(3), 754–777 (2018) 11. Hu, H., Sotirov, R.: On solving the quadratic shortest path problem. INFORMS J. Comput. 32(2), 219–233 (2020) 12. Hu, H., Sotirov, R.: The linearization problem of a binary quadratic problem and its applications. Annal. Oper. Res. 307, 229–249 (2021) 13. Kabadi, S.N., Punnen, A.P.: An O(n4 ) algorithm for the QAP linearization problem. Math. Oper. Res. 36(4), 754–761 (2011) 14. Murakami, K., Kim, H.S.: Comparative study on restoration schemes of survivable ATM networks. In: Proceedings of INFOCOM1997, vol. 1, pp. 345–352. IEEE (1997) 15. Nie, Y.M., Wu, X.: Reliable a priori shortest path problem with limited spatial and temporal dependencies. In: Lam, W., Wong, S., Lo, H. (eds.) Transportation and Traﬃc Theory 2009: Golden Jubilee, pp. 169–195. Springer, Boston (2009). https://doi.org/10.1007/978-1-4419-0820-9 9 16. Punnen, A.P., Kabadi, S.N.: A linear time algorithm for the Koopmans-Beckmann QAP linearization and related problems. Discret. Optim. 10(3), 200–209 (2013) 17. Punnen, A.P., Walter, M., Woods, B.D.: A characterization of linearizable instances of the quadratic traveling salesman problem. arXiv preprint arXiv:1708.07217 (2017) 18. Rostami, B., et al.: The quadratic shortest path problem: complexity, approximability, and solution methods. Eur. J. Oper. Res. 268(2), 473–485 (2018) 19. Rostami, B., Malucelli, F., Frey, D., Buchheim, C.: On the quadratic shortest path problem. In: Bampis, E. (ed.) SEA 2015. LNCS, vol. 9125, pp. 379–390. Springer, Cham (2015). https://doi.org/10.1007/978-3-319-20086-6 29 20. Sen, S., Pillai, R., Joshi, S., Rathi, A.K.: A mean-variance model for route guidance in advanced traveler information systems. Transp. Sci. 35(1), 37–49 (2001) 21. Sivakumar, R.A., Batta, R.: The variance-constrained shortest path problem. Transp. Sci. 28(4), 309–316 (1994) 22. Sotirov, R., Verch´ere, M.: The quadratic minimum spanning tree problem: lower bounds via extended formulations. arXiv preprint arXiv:2102.10647 (2021) 23. Waddell, L., Adams, W.: Characterizing linearizable QAPs by the level-1 reformulation-linearization technique. (2021). https://optimization-online.org/? p=17020, preprint  
   
  Author Index  
   
  A Achterberg, Tobias  
   
  14  
   
  B Balas, Egon 275 Basu, Amitabh 1 Bestuzheva, Ksenia 14 Borst, Sander 29 Bruckmeier, Sabrina 44 Büsing, Christina 58 C Cardinal, Jean 72 Çela, Eranda 466 Chmiela, Antonia 87 D Dadush, Daniel  
   
  29, 100, 115  
   
  E Eberle, Franziska 127 Eisenbrand, Friedrich 100 F Fujishige, Satoru 142 Fukasawa, Ricardo 438 G Gersing, Timo 58 Gerstbrein, Matthew 157 Gleixner, Ambros 14 Gupta, Anupam 127 H Hanguir, Oussama 172 Henzinger, Monika 453 Hertrich, Christoph 187 Huiberts, Sophie 29 Hunkenschröder, Christoph 44 Husi´c, Edin 203  
   
  J Jäger, Sven 246 Jiang, Hongyi 1 Jin, Billy 217 Joswig, Michael 231 K Karlin, Anna R. 261 Kashaev, Danish 29 Kazachkov, Aleksandr M. 275 Kerger, Phillip 1 Kitahara, Tomonari 142 Klein, Nathan 217, 261 Klimm, Max 231 Klinz, Bettina 466 Kobayashi, Yusuke 291 Koh, Zhuan Khye 203 Koster, Arie M. C. A. 58 L Lendl, Stefan 466 Léonard, Arthur 115 Loho, Georg 203 M Ma, Will 172 Matuschke, Jannik 306 Megow, Nicole 127, 319 Molinaro, Marco 1 Moseley, Benjamin 127 Muñoz, Gonzalo 87, 334, 348, 363 N Nägele, Martin 393 Nöbel, Christian 393 Nuti, Pranav 378 O Oveis Gharan, Shayan  
   
  261  
   
  © The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 A. Del Pia and V. Kaibel (Eds.): IPCO 2023, LNCS 13904, pp. 481–482, 2023. https://doi.org/10.1007/978-3-031-32726-1  
   
  482  
   
  Author Index  
   
  P Paat, Joseph 334, 348 Poremba, Joseph 408  
   
  R Rohwedder, Lars 115 Rothvoss, Thomas 100 Ryan, Christopher Thomas  
   
  Steiner, Raphael 72 Svensson, Anton 363 V Végh, László A. 142, 203 Verberk, Lucy 157 Verschae, José 115 Vondrák, Jan 378 172  
   
  S Sagnol, Guillaume 246 Salas, David 363 Sanità, Laura 157 Santiago, Richard 393, 423 Schlöter, Jens 319 Schmidt genannt Waldschmidt, Daniel Sergeev, Ivan 423 Sering, Leon 187 Serrano, Felipe 87, 334 Shepherd, F. Bruce 408 Spitz, Sylvain 231  
   
  W Warode, Philipp 246 Weismantel, Robert 44 Weninger, Noah 438 Williamson, David P. 217 Woeginger, Gerhard J. 466 Wulf, Lasse 466  
   
  246  
   
  X Xavier, Álinson S.  
   
  348  
   
  Z Zenklusen, Rico 393, 423 Zheng, Da Wei 453 Zhou, Rudy 127  

 Report "Integer Programming and Combinatorial Optimization. 24th International Conference, IPCO 2023 Madison, WI, USA, June 21–23, 2023 Proceedings 9783031327254, 9783031327261"  
 ×    

 --- Select Reason ---  Pornographic  Defamatory  Illegal/Unlawful  Spam  Other Terms Of Service Violation  File a copyright complaint     

 Close  Submit    

    Contact information  
 Michael Browner   
   [email protected]    
   
   Address:   
 1918 St.Regis, Dorval, Quebec, H9P 1H6, Canada.   
   
 Support & Legal  
  O nas 
  Skontaktuj się z nami 
  Prawo autorskie 
  Polityka prywatności 
  Warunki 
  FAQs 
  Cookie Policy 
    
 Subscribe to our newsletter  
  Be the first to receive exclusive offers and the latest news on our products and services directly in your inbox.  
   Subscribe     

 Copyright © 2024 DOKUMEN.PUB. All rights reserved.        

 Unsere Partner sammeln Daten und verwenden Cookies zur Personalisierung und Messung von Anzeigen. Erfahren Sie, wie wir und unser Anzeigenpartner Google Daten sammeln und verwenden  .   Cookies zulassen